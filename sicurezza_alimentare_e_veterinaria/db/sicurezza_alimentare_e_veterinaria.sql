--
-- PostgreSQL database dump
--

-- Dumped from database version 15.4
-- Dumped by pg_dump version 15.4

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: Analisi_dev; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA "Analisi_dev";


ALTER SCHEMA "Analisi_dev" OWNER TO postgres;

--
-- Name: ag_conf; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA ag_conf;


ALTER SCHEMA ag_conf OWNER TO postgres;

--
-- Name: ag_his; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA ag_his;


ALTER SCHEMA ag_his OWNER TO postgres;

--
-- Name: ag_log; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA ag_log;


ALTER SCHEMA ag_log OWNER TO postgres;

--
-- Name: ag_srv; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA ag_srv;


ALTER SCHEMA ag_srv OWNER TO postgres;

--
-- Name: ag_types; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA ag_types;


ALTER SCHEMA ag_types OWNER TO postgres;

--
-- Name: ag_ui; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA ag_ui;


ALTER SCHEMA ag_ui OWNER TO postgres;

--
-- Name: agenda; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA agenda;


ALTER SCHEMA agenda OWNER TO postgres;

--
-- Name: bck; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA bck;


ALTER SCHEMA bck OWNER TO postgres;

--
-- Name: conf_ext; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA conf_ext;


ALTER SCHEMA conf_ext OWNER TO postgres;

--
-- Name: config; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA config;


ALTER SCHEMA config OWNER TO postgres;

--
-- Name: cu; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cu;


ALTER SCHEMA cu OWNER TO postgres;

--
-- Name: cu_anag; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cu_anag;


ALTER SCHEMA cu_anag OWNER TO postgres;

--
-- Name: cu_anag_sicer; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cu_anag_sicer;


ALTER SCHEMA cu_anag_sicer OWNER TO postgres;

--
-- Name: cu_conf; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cu_conf;


ALTER SCHEMA cu_conf OWNER TO postgres;

--
-- Name: cu_ft; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cu_ft;


ALTER SCHEMA cu_ft OWNER TO postgres;

--
-- Name: cu_his; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cu_his;


ALTER SCHEMA cu_his OWNER TO postgres;

--
-- Name: cu_log; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cu_log;


ALTER SCHEMA cu_log OWNER TO postgres;

--
-- Name: cu_srv; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cu_srv;


ALTER SCHEMA cu_srv OWNER TO postgres;

--
-- Name: cu_types; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cu_types;


ALTER SCHEMA cu_types OWNER TO postgres;

--
-- Name: cu_ui; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cu_ui;


ALTER SCHEMA cu_ui OWNER TO postgres;

--
-- Name: documenti; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA documenti;


ALTER SCHEMA documenti OWNER TO postgres;

--
-- Name: log; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA log;


ALTER SCHEMA log OWNER TO postgres;

--
-- Name: matrix; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA matrix;


ALTER SCHEMA matrix OWNER TO postgres;

--
-- Name: prog_2024; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA prog_2024;


ALTER SCHEMA prog_2024 OWNER TO postgres;

--
-- Name: ra; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA ra;


ALTER SCHEMA ra OWNER TO postgres;

--
-- Name: rbac; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA rbac;


ALTER SCHEMA rbac OWNER TO postgres;

--
-- Name: rbac_conf; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA rbac_conf;


ALTER SCHEMA rbac_conf OWNER TO postgres;

--
-- Name: rbac_log; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA rbac_log;


ALTER SCHEMA rbac_log OWNER TO postgres;

--
-- Name: rbac_srv; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA rbac_srv;


ALTER SCHEMA rbac_srv OWNER TO postgres;

--
-- Name: rbac_types; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA rbac_types;


ALTER SCHEMA rbac_types OWNER TO postgres;

--
-- Name: rbac_ui; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA rbac_ui;


ALTER SCHEMA rbac_ui OWNER TO postgres;

--
-- Name: tmp; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA tmp;


ALTER SCHEMA tmp OWNER TO postgres;

--
-- Name: trf; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA trf;


ALTER SCHEMA trf OWNER TO postgres;

--
-- Name: trf_conf; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA trf_conf;


ALTER SCHEMA trf_conf OWNER TO postgres;

--
-- Name: trf_his; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA trf_his;


ALTER SCHEMA trf_his OWNER TO postgres;

--
-- Name: trf_types; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA trf_types;


ALTER SCHEMA trf_types OWNER TO postgres;

--
-- Name: trf_ui; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA trf_ui;


ALTER SCHEMA trf_ui OWNER TO postgres;

--
-- Name: btree_gist; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS btree_gist WITH SCHEMA public;


--
-- Name: EXTENSION btree_gist; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION btree_gist IS 'support for indexing common datatypes in GiST';


--
-- Name: dblink; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS dblink WITH SCHEMA public;


--
-- Name: EXTENSION dblink; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION dblink IS 'connect to other PostgreSQL databases from within a database';


--
-- Name: hstore; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS hstore WITH SCHEMA public;


--
-- Name: EXTENSION hstore; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION hstore IS 'data type for storing sets of (key, value) pairs';


--
-- Name: postgres_fdw; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS postgres_fdw WITH SCHEMA public;


--
-- Name: EXTENSION postgres_fdw; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION postgres_fdw IS 'foreign-data wrapper for remote PostgreSQL servers';


--
-- Name: tablefunc; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS tablefunc WITH SCHEMA public;


--
-- Name: EXTENSION tablefunc; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION tablefunc IS 'functions that manipulate whole tables, including crosstab';


--
-- Name: unaccent; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS unaccent WITH SCHEMA public;


--
-- Name: EXTENSION unaccent; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION unaccent IS 'text search dictionary that removes accents';


--
-- Name: add_column(text, text, text); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".add_column(_table text, _new_column text, _type text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	declare
	begin	
		
  set search_path to "Analisi_dev";

		execute 'alter table h_'||_tname||' add column '||_new_column||' '|| _type||';';



return 1;
end;
$$;


ALTER FUNCTION "Analisi_dev".add_column(_table text, _new_column text, _type text) OWNER TO postgres;

--
-- Name: allinea(text, text, bigint, text, integer); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".allinea(modalita text DEFAULT 'giornaliero'::text, area text DEFAULT NULL::text, id_asl bigint DEFAULT NULL::bigint, sistema text DEFAULT NULL::text, id_gisadbi integer DEFAULT NULL::integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare 
rec record;
begin
	
	perform "Analisi_dev".pg_terminate_backend_mdgm();
 
	--return -99;
	if modalita is null then 
		modalita = 'giornaliero';
	end if;

	--SET enable_seqscan = OFF;

	if modalita != 'giornaliero' and modalita != 'istantaneo' then
		raise notice 'Parametro modalita non valido';
		return -1;
	end if;

	if area != 'piani' and area != 'asl' then
		raise notice 'Parametro area non valido';
		return -1;
	end if;

	if not exists (select code from "Analisi_dev".lookup_asl where id_provincia is not null and code = id_asl) and id_asl is not null then
		raise notice 'Parametro asl non valido';
		return -1;
	end if;

	if id_gisadbi not in (select id from "Analisi_dev".gisadbi) then
		raise notice 'ID DBI NON TROVATO';
		return -1;
	end if;

	if sistema not in ('gisa', 'vam', 'bdu') then
		raise notice 'Parametro sistema non valido';
		return -1;
	end if;

	if modalita = 'giornaliero' then
		perform "Analisi_dev".check_columns();
	end if;
	perform "Analisi_dev".update_dbi(modalita, sistema, id_gisadbi);
	perform "Analisi_dev".update_dbi_values();
	
	/*if modalita != 'istantaneo' then
		perform matrix.create_stabilimenti();	

/*		perform digemon.create_view_digemon();
		perform digemon.create_view_ocse();
		*/
	end if;*/


	if sistema is null and id_gisadbi is null then
		if area = 'piani' or area is null then
			perform matrix.create_struttura_piani();
			perform "Analisi_dev".create_piano_no_rend();
			perform "Analisi_dev".update_rendic_per_campioni();
		end if;
		
		if area = 'asl' or area is null then
			perform matrix.create_struttura_asl(id_asl);
		 	perform matrix.create_nominativi();
		end if;
	end if;
 
	--perform diag_view.create_views();
	RETURN 1;
END; 

$$;


ALTER FUNCTION "Analisi_dev".allinea(modalita text, area text, id_asl bigint, sistema text, id_gisadbi integer) OWNER TO postgres;

--
-- Name: check_columns(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".check_columns() RETURNS text
    LANGUAGE plpgsql
    AS $$
	declare
	i integer;
	j integer;
	C record;
	col record;
	str character varying;
	str_vw character varying;
	str_information_schema character varying;
	tname character varying;
	parentesi character varying;
	field_list character varying;
	fields character varying;
	dbname text;
	dbaddress text;
    dbschema text;
    column_to_add text;
   	ret text;
	col_type text;
	col_name text;
	changed bool;
	fields_old character varying;
	begin	
	select value from "Analisi_dev".config where descr = 'GISA_DB' into dbname;
	select value from "Analisi_dev".config where descr = 'GISA_ADDRESS' into dbaddress;
	ret := 'No colums added';
	for C in select * from "Analisi_dev".gisadbi where (giornaliero is true or istantaneo is true) and status = 'C' and enabled loop
	
		changed = false;
		select value from "Analisi_dev".config where id = C.id_config_db into dbname;

		RAISE NOTICE '%', 'check '||C.tname||'';
		
		if C.is_function is true and C.is_userdatatype is false then
			RAISE NOTICE 'FUNZIONE';
			parentesi := '('||coalesce(C.params, '')||')';
			str_information_schema := 'SELECT parameter_name, parameters.data_type, parameters.character_maximum_length
				FROM information_schema.routines 
				LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name  
				WHERE routines.specific_catalog='''||dbname||''' and routine_name = '''|| C.tname ||''' and parameter_mode = ''OUT'' and parameters.specific_schema = '''||C.schema||''' ';
		elsif C.is_function is false then
			RAISE NOTICE 'NO FUNZIONE';
			parentesi := '';
			str_information_schema :=  'select c.column_name as parameter_name, c.data_type, c.character_maximum_length
				from information_schema.columns c 
				where table_catalog = '''||dbname||''' and table_schema = '''||C.schema||''' and table_name = '''|| C.tname ||''' ';
		elsif C.is_function is true and C.is_userdatatype is true then
			RAISE NOTICE 'DATATYPE';
			parentesi := '('||coalesce(C.params, '')||')';
			str_information_schema := 'select distinct a.attribute_name as parameter_name, a.data_type, a.character_maximum_length 
					from information_schema.attributes a
					join  information_schema.routines r on a.udt_name = r.type_udt_name --and a.udt_schema = r.routine_schema 
					where r.routine_name = '''|| C.tname ||''' and r.routine_schema = '''||C.schema||''' ';
		end if;	
	
		raise notice '%', 'INFOSCHEMA: '||str_information_schema ||'';

		str_vw = 'create or replace view  "Analisi_dev".vw_'|| C.tname || 
			' AS SELECT * from public.dblink(''dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres'',
				''select * from '||C.schema||'.'|| C.tname||parentesi||''') AS T(';
		
		field_list := '';
		fields := '';
		i:=0;
		j = 0;
		fields_old = '';
	
	  --cerco colonne in dbi per creare nuova vw_tname
	  for col in select * FROM public.dblink('dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres',
		''||str_information_schema||'')
		 AS T(parameter_name character varying, data_type character varying,character_maximum_length character varying) loop
			if (i>0) then 
				field_list := field_list ||','; 
				fields  = fields || ','; 
			end if;
			if strpos(col.parameter_name, ' ') > 0 then 
				col.parameter_name = '"'|| col.parameter_name ||'"';
			end if;
			field_list = field_list || col.parameter_name ||' '||col.data_type;
			if col.data_type = 'character' then
				field_list:=field_list||' varying';
			end if;
			fields  = fields || col.parameter_name;
			i:=i+1;
		end loop;
	
		if i != 0 then --se esiste
			str = 'DROP VIEW IF EXISTS "Analisi_dev".vw_'||C.tname;
			raise notice '%', str;
			EXECUTE str;
		
			str_vw = str_vw ||field_list||'); ';
			RAISE NOTICE '%', 'exec '||str_vw||'';
			EXECUTE str_vw;
		
			--cerco colonne da eliminare
			for col in select c3.column_name
					from information_schema.columns c3
					where c3.table_catalog = 'mdgm' 
					and c3.table_schema = 'Analisi_dev' 
					and c3.table_name = 'h_'||C.tname
					and c3.column_name != 'rng' 
					and c3.column_name not in (
						select c2.column_name
						from information_schema.columns c2 
						where table_catalog = 'mdgm' 
						and c2.table_schema = 'Analisi_dev' 
						and c2.table_name = 'vw_'||C.tname
					) loop
			
			if strpos(col.column_name, ' ') > 0 then 
				col.column_name = '"'|| col.column_name ||'"';
			end if;
		
			str = 'CREATE TABLE IF NOT EXISTS tmp.h_'||C.tname||'_'||TO_CHAR(now(),'YYYY_MM_DD_HH24_MI_SS')||' AS SELECT * FROM "Analisi_dev".h_'||C.tname;
			raise notice '%', str;
			execute str;
			
			str = 'ALTER TABLE "Analisi_dev".h_'||C.tname||' DROP '||col.column_name||' CASCADE';
			raise notice '%', str;
			execute str;
		
			RAISE NOTICE 'Da eliminare %', col.column_name;
			insert into "Analisi_dev".check_columns_log values(C.tname, 'COLONNA '|| col.column_name || ' ELIMINATA', null);
					
			end loop;
		end if;

		field_list := '';
		fields := '';
		i = 0;
		--cerco colonne da aggiungere
		for col in select * FROM public.dblink('dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres',
		''||str_information_schema||'')
		 AS T(parameter_name character varying, data_type character varying,character_maximum_length character varying) loop
			if (i>0) then 
				field_list := field_list ||','; 
				fields  = fields || ','; 
			end if;
			if strpos(col.parameter_name, ' ') > 0 then 
				col.parameter_name = '"'|| col.parameter_name ||'"';
			end if;
			field_list = field_list || col.parameter_name ||' '||col.data_type;
			if col.data_type = 'character' then
				field_list:=field_list||' varying';
			end if;
			fields  = fields || col.parameter_name;
			i:=i+1;
			
		 	tname := 'h_'||C.tname;
		 	
			/*SELECT A.ATTNAME into COLUMN_TO_ADD  FROM PG_ATTRIBUTE A, PG_CLASS B
			    WHERE A.ATTRELID = B.OID AND A.ATTNAME = col.parameter_name AND B.RELNAME = tname;*/
		 
		 	/*SELECT A.ATTNAME into COLUMN_TO_ADD  FROM PG_ATTRIBUTE A, PG_CLASS B
			    WHERE A.ATTRELID = B.OID AND A.ATTNAME = replace(col.parameter_name, '"', '') AND B.RELNAME = tname;*/
		 
		 SELECT A.ATTNAME into COLUMN_TO_ADD  FROM PG_ATTRIBUTE A, PG_CLASS B
			    WHERE A.ATTRELID = B.OID AND A.ATTNAME ilike replace(col.parameter_name, '"', '') AND B.RELNAME = tname;
			   
			   
			if col.data_type = 'charachter' then
				col.data_type = 'charachter varying';
			end if;
		
			col_type := col.data_type;
			col_name := col.parameter_name;
		
			IF COLUMN_TO_ADD IS NULL then
				ret = col.parameter_name;
				RAISE NOTICE 'Da aggiungere %', ret;
				ret = 'Columns added';
				insert into "Analisi_dev".check_columns_log values(C.tname, 'COLONNA '|| col.parameter_name || ' AGGIUNTA', null);
				changed = true;
			else
				if j > 0 then
					fields_old  = fields_old || ', '; 
				end if;
				fields_old  = fields_old || col.parameter_name; 
			 	j = j + 1;
			END IF;
    	end loop;
    
    	if changed then
    		drop table if exists "Analisi_dev".tmp_check_columns;
    		str = 'CREATE TABLE "Analisi_dev".tmp_check_columns AS SELECT * FROM "Analisi_dev".'||tname;
    		raise notice '%', str;
			EXECUTE str;
    	
    		str = 'DROP TABLE "Analisi_dev".'||tname||' CASCADE';
    		raise notice '%', str;
    		EXECUTE str;

    		str = 'CREATE TABLE "Analisi_dev".'||tname||' (rng int8range, '||field_list||')';
    		raise notice '%', str;
    		EXECUTE str;

			str = 'INSERT INTO "Analisi_dev".'||tname||' (rng, '||fields_old||') select rng, '||fields_old||' from "Analisi_dev".tmp_check_columns';
    		raise notice '%', str;
			EXECUTE str;
		
			raise notice '-------------------------------------------
				';
		end if;
		
		if i = 0 then 
			RAISE NOTICE '------> DBI % non trovata, verrà disabilitata e saltata', C.tname;
			EXECUTE 'update "Analisi_dev".gisadbi set enabled = false where id = ' ||C.id;
			insert into "Analisi_dev".check_columns_log values(C.tname, 'DBI MANCANTE/CONFIGURAZIONE ERRATA', null);
		end if;

	
   	end loop;
return ret;
end;
$$;


ALTER FUNCTION "Analisi_dev".check_columns() OWNER TO postgres;

--
-- Name: check_columns2(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".check_columns2() RETURNS text
    LANGUAGE plpgsql
    AS $$
	declare
	i integer;
	j integer;
	C record;
	col record;
	str character varying;
	str_vw character varying;
	str_information_schema character varying;
	tname character varying;
	parentesi character varying;
	field_list character varying;
	fields character varying;
	dbname text;
	dbaddress text;
    dbschema text;
    column_to_add text;
   	ret text;
	col_type text;
	col_name text;
	changed bool;
	fields_old character varying;
	begin	
	select value from "Analisi_dev".config where descr = 'GISA_DB' into dbname;
	select value from "Analisi_dev".config where descr = 'GISA_ADDRESS' into dbaddress;
	ret := 'No colums added';
	for C in select * from "Analisi_dev".gisadbi where (giornaliero is true or istantaneo is true) and status = 'C'  loop
	
		changed = false;
		select value from "Analisi_dev".config where id = C.id_config_db into dbname;

		RAISE NOTICE '%', 'check '||C.tname||'';
		
		if C.is_function is true and C.is_userdatatype is false then
			RAISE NOTICE 'FUNZIONE';
			parentesi := '('||coalesce(C.params, '')||')';
			str_information_schema := 'SELECT parameter_name, parameters.data_type, parameters.character_maximum_length
				FROM information_schema.routines 
				LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name  
				WHERE routines.specific_catalog='''||dbname||''' and routine_name = '''|| C.tname ||''' and parameter_mode = ''OUT'' and parameters.specific_schema = '''||C.schema||''' ';
		elsif C.is_function is false then
			RAISE NOTICE 'NO FUNZIONE';
			parentesi := '';
			str_information_schema :=  'select c.column_name as parameter_name, c.data_type, c.character_maximum_length
				from information_schema.columns c 
				where table_catalog = '''||dbname||''' and table_schema = '''||C.schema||''' and table_name = '''|| C.tname ||''' ';
		elsif C.is_function is true and C.is_userdatatype is true then
			RAISE NOTICE 'DATATYPE';
			parentesi := '('||coalesce(C.params, '')||')';
			str_information_schema := 'select a.attribute_name as parameter_name, a.data_type, a.character_maximum_length 
					from information_schema.attributes a
					join  information_schema.routines r on a.udt_name = r.type_udt_name and a.udt_schema = r.routine_schema 
					where r.routine_name = '''|| C.tname ||''' and r.routine_schema = '''||C.schema||''' ';
		end if;	
	
		raise notice '%', 'INFOSCHEMA: '||str_information_schema ||'';

		str_vw = 'create or replace view  "Analisi_dev".vw_'|| C.tname || 
			' AS SELECT * from public.dblink(''dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres'',
				''select * from '||C.schema||'.'|| C.tname||parentesi||''') AS T(';
		
		field_list := '';
		fields := '';
		i:=0;
		j = 0;
		fields_old = '';
	
	  --cerco colonne in dbi per creare nuova vw_tname
	  for col in select * FROM public.dblink('dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres',
		''||str_information_schema||'')
		 AS T(parameter_name character varying, data_type character varying,character_maximum_length character varying) loop
			if (i>0) then 
				field_list := field_list ||','; 
				fields  = fields || ','; 
			end if;
			field_list = field_list || col.parameter_name ||' '||col.data_type;
			if col.data_type = 'character' then
				field_list:=field_list||' varying';
			end if;
			fields  = fields || col.parameter_name;
			i:=i+1;
		end loop;
	
		if i != 0 then --se esiste
			str = 'DROP VIEW "Analisi_dev".vw_'||C.tname;
			raise notice '%', str;
			EXECUTE str;
		
			str_vw = str_vw ||field_list||'); ';
			RAISE NOTICE '%', 'exec '||str_vw||'';
			EXECUTE str_vw;
		
			--cerco colonne da eliminare
			for col in select c3.column_name
					from information_schema.columns c3
					where c3.table_catalog = 'mdgm' 
					and c3.table_schema = 'Analisi_dev' 
					and c3.table_name = 'h_'||C.tname
					and c3.column_name != 'rng' 
					and c3.column_name not in (
						select c2.column_name
						from information_schema.columns c2 
						where table_catalog = 'mdgm' 
						and c2.table_schema = 'Analisi_dev' 
						and c2.table_name = 'vw_'||C.tname
					) loop
		
			str = 'CREATE TABLE IF NOT EXISTS tmp.h_'||C.tname||'_'||TO_CHAR(now(),'YYYY_MM_DD_HH24_MI_SS')||' AS SELECT * FROM "Analisi_dev".h_'||C.tname;
			raise notice '%', str;
			execute str;
			
			str = 'ALTER TABLE "Analisi_dev".h_'||C.tname||' DROP '||col.column_name||' CASCADE';
			raise notice '%', str;
			execute str;
		
			RAISE NOTICE 'Da eliminare %', col.column_name;
			insert into "Analisi_dev".check_columns_log values(C.tname, 'COLONNA '|| col.column_name || ' ELIMINATA', null);
					
			end loop;
		end if;

		field_list := '';
		fields := '';
		i = 0;
		--cerco colonne da aggiungere
		for col in select * FROM public.dblink('dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres',
		''||str_information_schema||'')
		 AS T(parameter_name character varying, data_type character varying,character_maximum_length character varying) loop
			if (i>0) then 
				field_list := field_list ||','; 
				fields  = fields || ','; 
			end if;
			field_list = field_list || col.parameter_name ||' '||col.data_type;
			if col.data_type = 'character' then
				field_list:=field_list||' varying';
			end if;
			fields  = fields || col.parameter_name;
			i:=i+1;
			
		 	tname := 'h_'||C.tname;
		 	
			SELECT A.ATTNAME into COLUMN_TO_ADD  FROM PG_ATTRIBUTE A, PG_CLASS B
			    WHERE A.ATTRELID = B.OID AND A.ATTNAME = col.parameter_name AND B.RELNAME = tname;
			   
			if col.data_type = 'charachter' then
				col.data_type = 'charachter varying';
			end if;
		
			col_type := col.data_type;
			col_name := col.parameter_name;
		
			IF COLUMN_TO_ADD IS NULL then
				ret = col.parameter_name;
				RAISE NOTICE 'Da aggiungere %', ret;
				ret = 'Columns added';
				insert into "Analisi_dev".check_columns_log values(C.tname, 'COLONNA '|| col.parameter_name || ' MANCANTE', null);
				changed = true;
			else
				if j > 0 then
					fields_old  = fields_old || ', '; 
				end if;
				fields_old  = fields_old || col.parameter_name; 
			 	j = j + 1;
			END IF;
    	end loop;
    
    	if changed then
    		drop table if exists "Analisi_dev".tmp_check_columns;
    		str = 'CREATE TABLE "Analisi_dev".tmp_check_columns AS SELECT * FROM "Analisi_dev".'||tname;
    		raise notice '%', str;
			EXECUTE str;
    	
    		str = 'DROP TABLE "Analisi_dev".'||tname||' CASCADE';
    		raise notice '%', str;
    		EXECUTE str;

    		str = 'CREATE TABLE "Analisi_dev".'||tname||' (rng int8range, '||field_list||')';
    		raise notice '%', str;
    		EXECUTE str;

			str = 'INSERT INTO "Analisi_dev".'||tname||' (rng, '||fields_old||') select rng, '||fields_old||' from "Analisi_dev".tmp_check_columns';
    		raise notice '%', str;
			EXECUTE str;
		
			raise notice '-------------------------------------------
				';
		end if;
		
		if i = 0 then 
			RAISE NOTICE '------> DBI % non trovata, verrà disabilitata e saltata', C.tname;
			EXECUTE 'update "Analisi_dev".gisadbi set enabled = false where id = ' ||C.id;
			insert into "Analisi_dev".check_columns_log values(C.tname, 'DBI MANCANTE', null);
		end if;

	
   	end loop;
return ret;
end;
$$;


ALTER FUNCTION "Analisi_dev".check_columns2() OWNER TO postgres;

--
-- Name: check_columns_20210419(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".check_columns_20210419() RETURNS text
    LANGUAGE plpgsql
    AS $$
	declare
	i integer;
	C record;
	col record;
	str character varying;
	str_vw character varying;
	str_information_schema character varying;
	tname character varying;
	parentesi character varying;
	field_list character varying;
	fields character varying;
	dbname text;
	dbaddress text;
    dbschema text;
    column_to_add text;
   	ret text;
	col_type text;
	col_name text;
	begin	
	select value from "Analisi_dev".config where descr = 'GISA_DB' into dbname;
	select value from "Analisi_dev".config where descr = 'GISA_ADDRESS' into dbaddress;
	ret := 'No colums added';
	for C in select * from "Analisi_dev".gisadbi where (istantaneo is true or giornaliero is true) and status = 'C' and enabled  loop
		select value from "Analisi_dev".config where id = C.id_config_db into dbname;

		RAISE NOTICE '%', 'check '||C.tname||'';
		
		if C.is_function is true and C.is_userdatatype is false then
			parentesi := '('||coalesce(C.params, '')||')';
			str_information_schema := 'SELECT parameter_name, parameters.data_type, parameters.character_maximum_length
				FROM information_schema.routines 
				LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name  
				WHERE routines.specific_catalog='''||dbname||''' and routine_name = '''|| C.tname ||''' and parameter_mode = ''OUT'' and parameters.specific_schema = '''||C.schema||''' ';
		elsif C.is_function is false then
			parentesi := '';
			str_information_schema :=  'select c.column_name as parameter_name, c.data_type, c.character_maximum_length
				from information_schema.columns c 
				where table_catalog = '''||dbname||''' and table_schema = '''||C.schema||''' and table_name = '''|| C.tname ||''' ';
		elsif C.is_function is true and C.is_userdatatype is true then
			parentesi := '('||coalesce(C.params, '')||')';
			str_information_schema := 'select a.attribute_name as parameter_name, a.data_type, a.character_maximum_length 
					from information_schema.attributes a
					join  information_schema.routines r on a.udt_name = r.type_udt_name and a.udt_schema = r.routine_schema 
					where r.routine_name = '''|| C.tname ||''' ';
		end if;	
	
		raise notice '%', 'INFOSCHEMA: '||str_information_schema ||'';

		str_vw = ' create or replace view  "Analisi_dev".vw_'|| C.tname || 
			' AS SELECT * from public.dblink(''dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres'',
				''select * from '||C.schema||'.'|| C.tname||parentesi||''') AS T(';
			field_list := '';
			fields := '';
			i:=0;
		
		/*if C.is_function and i = 0 then 
				str_information_schema := 'select a.attribute_name as parameter_name, a.data_type, a.character_maximum_length 
					from information_schema.attributes a
					join  information_schema.routines r on a.udt_name = r.type_udt_name and a.udt_schema = r.routine_schema 
					where r.routine_name = '''|| C.tname ||''' ';
				
				raise notice '%', 'SETOF! '||str_information_schema ||'';

				for col in select * FROM public.dblink('dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres',
					''||str_information_schema||'')
				 AS T(parameter_name character varying, data_type character varying,character_maximum_length character varying) loop
	
					 if (i>0) then field_list := field_list ||','; fields  = fields || ','; end if;
					field_list = field_list || col.parameter_name ||' '||col.data_type;
				
					if col.data_type = 'character' then
						field_list:=field_list||' varying';
					end if;
					fields  = fields || col.parameter_name;
					i:=i+1;
				end loop;
			end if;*/
		
	
		for col in select * FROM public.dblink('dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres',
		''||str_information_schema||'')
		 AS T(parameter_name character varying, data_type character varying,character_maximum_length character varying) loop
			if (i>0) then field_list := field_list ||','; fields  = fields || ','; end if;
			field_list = field_list || col.parameter_name ||' '||col.data_type;
				if col.data_type = 'character' then
					field_list:=field_list||' varying';
				end if;
				fields  = fields || col.parameter_name;
				i:=i+1;
			
		 	tname := 'h_'||C.tname;
		 	
			SELECT A.ATTNAME into COLUMN_TO_ADD  FROM PG_ATTRIBUTE A, PG_CLASS B
			    WHERE A.ATTRELID = B.OID AND A.ATTNAME = col.parameter_name AND B.RELNAME = tname;
			   
			if col.data_type = 'charachter' then
				col.data_type = 'charachter varying';
			end if;
		
			col_type := col.data_type;
			col_name := col.parameter_name;
			str := 'ALTER TABLE "Analisi_dev".'||tname||' ADD COLUMN  '||col_name||' '||col_type||';';
			IF COLUMN_TO_ADD IS NULL then
				RAISE NOTICE '%', 'exec '||str||'';
				execute str;
				ret = 'Columns added';
			END IF;
 
    	end loop;
    
 	/* if C.is_userdatatype and i = 0 then 
				str_information_schema := 'select distinct a.attribute_name as parameter_name, a.data_type, a.character_maximum_length , ordinal_position
					from information_schema.attributes a
					join  information_schema.routines r on a.udt_name = r.type_udt_name and a.udt_schema = r.routine_schema 
					where r.routine_name = '''|| C.tname ||''' order by ordinal_position';
				
				raise notice '%', 'SETOF! '||str_information_schema ||'';

				for col in select * FROM public.dblink('dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres',
					''||str_information_schema||'')
					 AS T(parameter_name character varying, data_type character varying,character_maximum_length character varying, ordinal_position int) loop
	
					 if (i>0) then field_list := field_list ||','; fields  = fields || ','; end if;
					field_list = field_list || col.parameter_name ||' '||col.data_type;
				
					if col.data_type = 'character' then
						field_list:=field_list||' varying';
					end if;
					fields  = fields || col.parameter_name;
					i:=i+1;
				tname := 'h_'||C.tname;
		 	
				SELECT A.ATTNAME into COLUMN_TO_ADD  FROM PG_ATTRIBUTE A, PG_CLASS B
				    WHERE A.ATTRELID = B.OID AND A.ATTNAME = col.parameter_name AND B.RELNAME = tname;
				   
				if col.data_type = 'charachter' then
					col.data_type = 'charachter varying';
				end if;
			
				col_type := col.data_type;
				col_name := col.parameter_name;
				str := 'ALTER TABLE "Analisi_dev".'||tname||' ADD COLUMN  '||col_name||' '||col_type||';';
				IF COLUMN_TO_ADD IS NULL then
					RAISE NOTICE '%', 'exec '||str||'';
					execute str;
					ret = 'Columns added';
				END IF;
				
				
				end loop;
			end if;*/
    
    
		str_vw = str_vw ||field_list||'); ';
		RAISE NOTICE '%', 'exec '||str_vw||'';
		EXECUTE str_vw;
	
   	end loop;
return ret;
end;
$$;


ALTER FUNCTION "Analisi_dev".check_columns_20210419() OWNER TO postgres;

--
-- Name: check_columns_old(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".check_columns_old() RETURNS text
    LANGUAGE plpgsql
    AS $$
	declare
	i integer;
	C record;
	col record;
	str character varying;
	str_vw character varying;
	str_information_schema character varying;
	tname character varying;
	parentesi character varying;
	field_list character varying;
	fields character varying;
	dbname text;
	dbaddress text;
    dbschema text;
    column_to_add text;
   	ret text;
	col_type text;
	col_name text;
	begin	
	select value from "Analisi_dev".config where descr = 'GISA_DB' into dbname;
	select value from "Analisi_dev".config where descr = 'GISA_ADDRESS' into dbaddress;
	ret := 'No colums added';
	for C in select * from "Analisi_dev".gisadbi where enabled and status = 'C' loop
	
		RAISE NOTICE '%', C.tname;
		
		if C.is_function = true then
			parentesi := '('||coalesce(C.params, '')||')';
			str_information_schema := 'SELECT parameter_name, parameters.data_type, parameters.character_maximum_length
				FROM information_schema.routines 
				LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name  
				WHERE routines.specific_catalog='''||dbname||''' and routine_name = '''|| C.tname ||''' and parameter_mode = ''OUT'' and parameters.specific_schema = '''||C.schema||''' ';
		else
			parentesi := '';
			str_information_schema :=  'select c.column_name as parameter_name, c.data_type, c.character_maximum_length
				from information_schema.columns c 
				where table_catalog = '''||dbname||''' and table_schema = '''||C.schema||''' and table_name = '''|| C.tname ||''' ';
		end if;	
	
	
		str_vw = ' create or replace view  "Analisi_dev".vw_'|| C.tname || 
			' AS SELECT * from public.dblink(''dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres'',
				''select * from '||C.schema||'.'|| C.tname||parentesi||''') AS T(';
			field_list := '';
			fields := '';
			i:=0;
		
	
		for col in select * FROM public.dblink('dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres',
		''||str_information_schema||'')
		 AS T(parameter_name character varying, data_type character varying,character_maximum_length character varying) loop
			if (i>0) then field_list := field_list ||','; fields  = fields || ','; end if;
			field_list = field_list || col.parameter_name ||' '||col.data_type;
				if col.data_type = 'character' then
					field_list:=field_list||' varying';
				end if;
				fields  = fields || col.parameter_name;
				i:=i+1;
			
		 	tname := 'h_'||C.tname;
		 	
			SELECT A.ATTNAME into COLUMN_TO_ADD  FROM PG_ATTRIBUTE A, PG_CLASS B
			    WHERE A.ATTRELID = B.OID AND A.ATTNAME = col.parameter_name AND B.RELNAME = tname;
			   
			if col.data_type = 'charachter' then
				col.data_type = 'charachter varying';
			end if;
		
			col_type := col.data_type;
			col_name := col.parameter_name;
			str := 'ALTER TABLE "Analisi_dev".'||tname||' ADD COLUMN  '||col_name||' '||col_type||';';
			IF COLUMN_TO_ADD IS NULL then
				raise notice 'EXECUTE str: %', str;
				execute str;
				ret = 'Columns added';
			END IF;
 
    	end loop;
		str_vw = str_vw ||field_list||'); ';
		raise notice 'EXECUTE str_vw: %', str_vw;
		EXECUTE str_vw;
	
   	end loop;
return ret;
end;
$$;


ALTER FUNCTION "Analisi_dev".check_columns_old() OWNER TO postgres;

--
-- Name: crea_dizionario_aziende(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".crea_dizionario_aziende() RETURNS void
    LANGUAGE plpgsql
    AS $$  
declare 
R record;
i integer;
n text;
begin
  i:=0;
 update "Analisi_dev".dizionario_aziende set azienda_originale = null , riferimento_id = null, riferimento_nome_tab = null;
  for R in select distinct osa_controllato as ragione_sociale, riferimento_id, riferimento_nome_tab from "Analisi_dev".ocse_235 loop
  	  	n = floor(random()* (114900-1 + 1) + 1)::bigint::text;
  	  -- 114900 numero di records della "Analisi_dev".dizionario_aziende
  	  	if i % 500 = 0 then
  		 raise notice '%', i;
  		end if;
  		while (select azienda_originale from "Analisi_dev".dizionario_aziende where id::text = n) is not null loop
  			raise notice 'conflitto %', n;
  			n = floor(random()* (114900-1 + 1) + 1)::bigint::text;
  		end loop;
  	  update "Analisi_dev".dizionario_aziende a set azienda_originale = R.ragione_sociale,
  	   riferimento_id = R.riferimento_id, riferimento_nome_tab = R.riferimento_nome_tab
  	  --from "Analisi_dev".ocse_235 b 
  	 where a.id::text = n and a.riferimento_id is null;
  		i= i + 1;
  end loop;
  end;
 $$;


ALTER FUNCTION "Analisi_dev".crea_dizionario_aziende() OWNER TO postgres;

--
-- Name: create_backup(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_backup() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	declare
	str character varying;
	C record;

	begin	
		
  set search_path to "Analisi_dev";
for C in select * from "Analisi_dev".gisadbi where enabled is true and status = 'C' loop

	
	execute 'alter table h_'||C.tname||' rename to h_'||C.tname||'_backup';
	
end loop;

return 1;
end;
$$;


ALTER FUNCTION "Analisi_dev".create_backup() OWNER TO postgres;

--
-- Name: create_macroarea(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_macroarea() RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin

	set search_path to "Analisi_dev";
	
	delete from macroarea;
	insert into macroarea select NEXTVAL('"Analisi_dev".seq_schema') as id,*, null as path
	from public.dblink('host=172.16.0.6 dbname=gisa user=postgres', 'select m.id, m.codice_sezione, m.macroarea, null as parent,  null as livello from master_list_macroarea m  where 1=0 order by macroarea')
	as T(id_gisa bigint, codice text, descrizione text, parent bigint, livello int) order by descrizione;
	
	insert into macroarea select NEXTVAL('"Analisi_dev".seq_schema') as id,* , LPAD(t.id_gisa::text, 10, '0') as path
	from public.dblink('host=172.16.0.6 dbname=gisa user=postgres', 'select m.id, m.codice_sezione, m.macroarea, null as parent, 1 as livello from master_list_macroarea m order by macroarea')
	as T(id_gisa bigint, codice text, descrizione text, parent bigint, livello int ) order by descrizione;
	
	
	insert into macroarea ( select NEXTVAL('"Analisi_dev".seq_schema') as id,  t.id_gisa , t.codice , t.descrizione, m.id, 2, m.path||'/'||lpad(t.id_gisa::text, 10, '0')
	from public.dblink('host=172.16.0.6 dbname=gisa user=postgres', 'select m.id, m.codice_attivita, m.aggregazione, id_macroarea as parent from master_list_aggregazione m order by aggregazione')
	as T(id_gisa bigint, codice text, descrizione text, parent bigint)  join "Analisi_dev".macroarea m on m.id_gisa = t.parent ) order by descrizione;
	
	
	insert into macroarea ( select NEXTVAL('"Analisi_dev".seq_schema') as id,  t.id_gisa , t.codice , t.descrizione, m.id, 3,  m.path||'/'||lpad(t.id_gisa::text, 10, '0')
	from public.dblink('host=172.16.0.6 dbname=gisa user=postgres', 'select m.id, m.codice_prodotto_specie, m.linea_attivita, id_aggregazione as parent from master_list_linea_attivita m order by linea_attivita')
	as T(id_gisa bigint, codice text, descrizione text, parent bigint)  join "Analisi_dev".macroarea m on m.id_gisa = t.parent and m.parent is not null) order by descrizione;
	
	
	insert into macroarea values ( -1, null, 'tot', 'TOTALE', null, 0, 0000);
	
	update macroarea set parent = -1 where parent is null and id != -1;
	
	update macroarea set path = 0000||'/'||path;

	return 1;
end;
$$;


ALTER FUNCTION "Analisi_dev".create_macroarea() OWNER TO postgres;

--
-- Name: create_mvw(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_mvw() RETURNS integer
    LANGUAGE plpgsql
    AS $_$
begin

	set search_path to "Analisi_dev";

drop view if exists "Analisi_dev".vw_conteggio_cu_grouped cascade;
drop view if exists "Analisi_dev".vw_conteggio_cu_grouped_no_rend cascade;
drop view if exists vw_gisa_controlli_ufficiali;
drop materialized view if exists mvw_get_ispezioni_semplici;
drop materialized view if exists mvw_get_sorveglianze;
drop materialized view if exists mvw_campioni;
drop materialized view if exists mvw_get_audit_regole;

drop  materialized view  if EXISTS "Analisi_dev".mvw_lookup_norme;
CREATE materialized view "Analisi_dev".mvw_lookup_norme as
select distinct norma, id_norma from "Analisi_dev".vw_dbi_get_all_linee_validi vglacv where data_inizio_attivita is not null;

/*create materialized view mvw_get_ispezioni_semplici as
select distinct i.id_controllo, l.codice_linea, coalesce(nullif(u.id_piano_ispezione,-1),u.id_motivo_ispezione) as id_motivo, u.id_unita_operativa, i.data_inizio_controllo, i.riferimento_id,i.riferimento_nome_tab, 1 as eseguiti, 'isp semp' as fonte
from 
h_get_controlli_ispezioni_semplici i
 join  h_get_controlli_ispezioni_semplici_percontodi u  on u.id_controllo = i.id_controllo and upper_inf(u.rng) is true
 join matrix.struttura_piani p on coalesce(nullif(u.id_piano_ispezione,-1),u.id_motivo_ispezione) = p.id_gisa and p.ha_campioni is not true-- and p.id_tipo_tecnica = 1
 join h_get_linee_attivita_controllo l on l.id_controllo = i.id_controllo  and upper_inf(l.rng) is true
where i.data_inizio_controllo >= '2019-01-01' and upper_inf(i.rng) is true
with data;*/

create materialized view mvw_get_ispezioni_semplici as
select distinct i.id_controllo, l.codice_linea, p.id_gisa as id_motivo, u.id_unita_operativa, i.data_inizio_controllo, i.riferimento_id,i.riferimento_nome_tab, 1 as eseguiti, 'isp semp' as fonte, ind.id as id_motivo_originale, al.id_norma
from 
h_get_controlli_ispezioni_semplici i
 join  h_get_controlli_ispezioni_semplici_percontodi u  on u.id_controllo = i.id_controllo and upper_inf(u.rng) is true
 join vw_dpat_indicatore_new_validi ind on ind.id = coalesce(nullif(nullif(u.id_piano_ispezione,-1),0),u.id_motivo_ispezione)
 join matrix.struttura_piani p on p.cod_raggruppamento = ind.cod_raggruppamento and p.anno = ind.anno and p.ha_campioni is not true-- and p.id_tipo_tecnica = 1
 left join h_get_linee_attivita_controllo l on l.id_controllo = i.id_controllo  and upper_inf(l.rng) is true
 left join "Analisi_dev".vw_dbi_get_all_linee_validi al on l.id_linea = al.id_linea and al.riferimento_id = i.riferimento_id and al.riferimento_id_nome_tab = i.riferimento_nome_tab 
where i.data_inizio_controllo >= '2019-01-01' and upper_inf(i.rng) is true and i.riferimento_id is not null
and i.id_asl = u.id_asl_struttura 
with data;

RAISE NOTICE 'value of sorv :';

create materialized view mvw_get_sorveglianze as  
select distinct s.id_controllo, 'tot', tm.id_struttura_piani as id_motivo, u.id_unita_operativa, s.data_inizio_controllo, s.riferimento_id, s.riferimento_nome_tab, 1 as eseguiti , 'sorveglianze' as fonte, tm.id_struttura_piani as id_motivo_originale, -1 as id_norma
from h_get_controlli_sorveglianze s  
join lookup_tipologia_motivo tm on tm.id_tipologia = 4  and extract(year from s.data_inizio_controllo) = tm.anno 
--join h_get_linee_attivita_controllo l on l.id_controllo = s.id_controllo and upper_inf(l.rng) is true
join h_get_controlli_audit_sorv_percontodi u on u.id_controllo = s.id_controllo and upper_inf(u.rng) is true
--join h_get_checklist_sorveglianza ch on ch.id_controllo = s.id_controllo
--	and ch.stato='Definitiva' and ch.is_principale is true and upper_inf(ch.rng) is true
where s.data_inizio_controllo >= '2019-01-01' and upper_inf(s.rng) is true
and s.id_stato_controllo = 2 --chiuso
with data;

----------------------------------REGOLE AUDIT
RAISE NOTICE 'value of aufit :';


create materialized view mvw_get_audit_regole as
-----Audit a1
select distinct a.id_controllo, l.codice_linea, p.id_gisa as id_motivo, u.id_unita_operativa, a.data_inizio_controllo ,a.riferimento_id, a.riferimento_nome_tab,1 as eseguiti,  'a1' as fonte, p.id_gisa as id_motivo_originale, al.id_norma
from h_get_controlli_audit a 
left join h_get_linee_attivita_controllo l on  a.id_controllo = l.id_controllo and  upper_inf(l.rng) is true 
join h_get_controlli_audit_sorv_percontodi u on u.id_controllo = a.id_controllo and upper_inf(u.rng) is true
join h_dbi_get_all_stabilimenti s on a.riferimento_id = s.riferimento_id and a.riferimento_nome_tab = s.riferimento_id_nome_tab --and upper_inf(s.rng) is true
and s.codice_macroarea||'-'||s.codice_aggregazione||'-'||s.codice_attivita = l.codice_linea and upper_inf(s.rng) is true
join lookup_aggregazione_motivo_audit m on m.aggregazione = s.codice_aggregazione 
join matrix.struttura_piani p on p.alias ilike m.motivo and extract(year from a.data_inizio_controllo) = p.anno
 left join "Analisi_dev".vw_dbi_get_all_linee_validi al on l.id_linea = al.id_linea and al.riferimento_id = a.riferimento_id and al.riferimento_id_nome_tab = a.riferimento_nome_tab 
where a.data_inizio_controllo >= '2019-01-01' and a.data_inizio_controllo <= '2019-12-31' and upper_inf(a.rng) is true and s.id_norma = 43
and a.id_asl = u.id_asl_struttura


union 


select distinct a.id_controllo, l.codice_linea, p.id_gisa as id_motivo, u.id_unita_operativa, a.data_inizio_controllo ,a.riferimento_id, a.riferimento_nome_tab,1 as eseguiti,  'a1' as fonte, u.id_motivo_audit as id_motivo_originale, al.id_norma 
from h_get_controlli_audit a 
left join h_get_linee_attivita_controllo l on  a.id_controllo = l.id_controllo and  upper_inf(l.rng) is true 
join h_get_controlli_audit_percontodi_2020 u on u.id_controllo = a.id_controllo and upper_inf(u.rng) is true
join vw_dpat_indicatore_new_validi ind on ind.id = coalesce(nullif(u.id_piano_audit,-1),u.id_motivo_audit)
join matrix.struttura_piani p on p.cod_raggruppamento = ind.cod_raggruppamento and p.anno = ind.anno
left join h_dbi_get_all_stabilimenti s on a.riferimento_id = s.riferimento_id and a.riferimento_nome_tab = s.riferimento_id_nome_tab --and upper_inf(s.rng) is true
and s.codice_macroarea||'-'||s.codice_aggregazione||'-'||s.codice_attivita = l.codice_linea and upper_inf(s.rng) is true
 left join "Analisi_dev".vw_dbi_get_all_linee_validi al on l.id_linea = al.id_linea and al.riferimento_id = a.riferimento_id and al.riferimento_id_nome_tab = a.riferimento_nome_tab 
--join lookup_aggregazione_motivo_audit m on m.aggregazione = s.codice_aggregazione 
--join matrix.struttura_piani p on p.alias ilike m.motivo and extract(year from a.data_inizio_controllo) = p.anno
where a.data_inizio_controllo >= '2020-01-01' and upper_inf(a.rng) is true --and s.id_norma = 43
and a.id_asl = u.id_asl_struttura 
--da flusso 190 vengono passati da nuova dbi
/*
union 

select distinct a.id_controllo, l.codice_linea, p.id_gisa as id_motivo, u.id_unita_operativa, a.data_inizio_controllo ,a.riferimento_id, a.riferimento_nome_tab,1 as eseguiti,  'audit' as fonte
from vw_get_controlli_audit_validi a 
join vw_get_linee_attivita_controllo_validi l on  a.id_controllo = l.id_controllo
join vw_get_controlli_audit_percontodi_2020_validi u on u.id_controllo = a.id_controllo
 join vw_dpat_indicatore_new_validi ind on ind.id = id_motivo_audit
 join matrix.struttura_piani p on p.cod_raggruppamento = ind.cod_raggruppamento and p.anno = ind.anno
where a.data_inizio_controllo >= '2020-01-01' 
and a.id_asl = u.id_asl_struttura */


-------------------a3_C SUPERVISIONI
union

select distinct a.id_controllo, null as codice_linea, p.id_gisa as id_motivo, u.id_unita_operativa, a.data_inizio_controllo ,null::bigint, null, 1 as eseguiti , 'a3_c_1' as fonte, p.id_gisa as id_motivo_originale, -1 as id_norma
--from h_get_controlli_audit a
from h_get_controlli_ispezioni_semplici a
join h_get_controlli_ispezioni_semplici_percontodi u on u.id_controllo = a.id_controllo and upper_inf(u.rng) is true
join matrix.struttura_piani p on p.alias ilike 'att%a3_c%'
where upper(a.congruo_supervisione) in (select upper(descrizione) from lookup_congruo_supervisione where is_supervisionato is true) 
and a.data_inizio_controllo >= '2019-01-01' and upper_inf(a.rng) is true

union 

select distinct a.id_controllo, null as codice_linea, p.id_gisa as id_motivo, u.id_unita_operativa, a.data_inizio_controllo ,null::bigint, null, 1 as eseguiti,  'a3_c_2' as fonte, p.id_gisa as id_motivo_originale, -1 as id_norma
--from h_get_controlli_audit a
from h_get_controlli_sorveglianze a
join h_get_controlli_audit_sorv_percontodi u on u.id_controllo = a.id_controllo and upper_inf(u.rng) is true
join matrix.struttura_piani p on p.alias ilike 'att%a3_c%'
--join h_dbi_get_all_stabilimenti ss on ss.riferimento_id = a.riferimento_id and ss.riferimento_id_nome_tab = a.riferimento_nome_tab 
-- and ss.macroarea||'-'||ss.aggregazione||'-'||ss.attivita = l.codice_linea
-- and ss.latitudine_stab is not null and ss.latitudine_stab != 0
-- and ss.longitudine_stab is not null and ss.longitudine_stab != 0
 --and upper_inf(ss.rng) is true
where upper(a.congruo_supervisione) in (select upper(descrizione) from lookup_congruo_supervisione where is_supervisionato is true) 
and a.data_inizio_controllo >= '2019-01-01' and upper_inf(a.rng) is true

union 

select distinct a.id_controllo, null as codice_linea, p.id_gisa as id_motivo, u.id_unita_operativa, a.data_inizio_controllo ,null::bigint, null, 1 as eseguiti , 'a3_c_3' as fonte, p.id_gisa as id_motivo_originale, -1 as id_norma
from h_get_controlli_ispezioni_carni a
join h_get_controlli_audit_sorv_percontodi u on u.id_controllo = a.id_controllo and upper_inf(u.rng) is true
join matrix.struttura_piani p on p.alias ilike 'att%a3_c%'
where upper(a.congruo_supervisione) in (select upper(descrizione) from lookup_congruo_supervisione where is_supervisionato is true) 
and a.data_inizio_controllo >= '2019-01-01' and upper_inf(a.rng) is true
--------------------a3_d
union

select a.id_controllo, null as codice_linea, p.id_gisa as id_motivo, u.id_unita_operativa, a.data_inizio_controllo, null::bigint, null, 1 as eseguiti, 'a3_d' as fonte, p.id_gisa as id_motivo_originale, -1 as id_norma
--from h_get_controlli_audit a
from h_get_controlli_audit_autorita_competenti a
join h_get_controlli_audit_sorv_percontodi u on u.id_controllo = a.id_controllo and upper_inf(u.rng) is true
join matrix.struttura_piani p on p.cod_raggruppamento in (select id_piano from lookup_autorita_competenti_motivo where descrizione = 'supervisione')
where lower(a.tipo_controllo) in  (select tipo_controllo from lookup_autorita_competenti_motivo where descrizione = 'supervisione') 
and a.data_inizio_controllo >= '2019-01-01' and upper_inf(a.rng) is true


------------------------a4_b 
union

select a.id_controllo, null as codice_linea, p.id_gisa as id_motivo, u.id_unita_operativa, a.data_inizio_controllo, null::bigint, null, 1 as eseguiti, 'a4_b' as fonte, p.id_gisa as id_motivo_originale, -1 as id_norma
from h_get_controlli_audit_autorita_competenti a
join h_get_controlli_audit_sorv_percontodi u on u.id_controllo = a.id_controllo and upper_inf(u.rng) is true
join matrix.struttura_piani p on p.cod_raggruppamento in (select id_piano from lookup_autorita_competenti_motivo where descrizione = 'audit interno')
where lower(a.tipo_controllo) in  (select tipo_controllo from lookup_autorita_competenti_motivo where descrizione = 'audit interno') 
and a.data_inizio_controllo >= '2019-01-01' and upper_inf(a.rng) is true



-------------------d1
union

select distinct a.id_controllo, l.codice_linea, p.id_gisa as id_motivo, u.id_unita_operativa, a.data_inizio_controllo, a.riferimento_id, a.riferimento_nome_tab, 1 as eseguiti, 'd1' as fonte, p.id_gisa as id_motivo_originale, ss.id_norma
from h_get_controlli_audit a
left join h_get_linee_attivita_controllo l on  a.id_controllo = l.id_controllo and  upper_inf(l.rng) is true 
join h_get_controlli_audit_sorv_percontodi u on u.id_controllo = a.id_controllo and upper_inf(u.rng) is true
join matrix.struttura_piani p on p.alias ilike 'att%d1' 
 join h_dbi_get_all_stabilimenti ss on ss.riferimento_id = a.riferimento_id and ss.riferimento_id_nome_tab = a.riferimento_nome_tab 
 and ss.codice_macroarea||'-'||ss.codice_aggregazione||'-'||ss.codice_attivita = l.codice_linea
-- and ss.latitudine_stab is not null and ss.latitudine_stab != 0
-- and ss.longitudine_stab is not null and ss.longitudine_stab != 0
 and upper_inf(ss.rng) is true
where ((ss.id_norma in (43,50) or
		(ss.id_norma = 49 and  ss.codice_macroarea = 'MS.A')))
		and upper_inf(a.rng) is true and a.data_inizio_controllo >= '2019-01-01' and a.data_inizio_controllo <= '31-12-2019'
		
with data;

-----------------------------campioni

/*create materialized view mvw_campioni as
select id_controllo, codice_linea, id_piano, id_unita_operativa, data_inizio_controllo, riferimento_id, riferimento_nome_tab, count(*), fonte from (
select distinct i.id_controllo, c.id_campione, l.codice_linea, coalesce(c.id_piano,c.id_attivita) as id_piano, p.id_unita_operativa, i.data_inizio_controllo, i.riferimento_id, i.riferimento_nome_tab, 1 as eseguiti, 'camp' as fonte
from h_get_campioni c
join h_get_controlli_ispezioni_semplici i on c.id_controllo_ufficiale::bigint = i.id_controllo and upper_inf(i.rng) is true 
join h_get_controlli_ispezioni_semplici_percontodi p on p.id_controllo = i.id_controllo and upper_inf(p.rng) is true
join matrix.struttura_piani pp on coalesce(c.id_piano,c.id_attivita) = pp.id_gisa and pp.ha_campioni is true
join h_get_linee_attivita_controllo l on l.id_controllo = i.id_controllo and upper_inf(l.rng) is true
--left join h_dbi_get_all_stabilimenti ss on ss.riferimento_id = i.riferimento_id and ss.riferimento_id_nome_tab = i.riferimento_nome_tab 
-- and ss.latitudine_stab is not null and ss.latitudine_stab != 0
-- and ss.longitudine_stab is not null and ss.longitudine_stab != 0
-- and upper_inf(ss.rng) is true
where i.data_inizio_controllo >= '2019-01-01' and upper_inf(c.rng) is true
)a
group by 1,2,3,4,5,6,7,9
with data ;*/
RAISE NOTICE 'value of camp :';



create materialized view mvw_campioni as
select id_controllo, codice_linea, id_piano, id_unita_operativa, data_inizio_controllo, riferimento_id, riferimento_nome_tab, count(*), fonte, id_motivo_originale, id_norma from (
select distinct i.id_controllo, c.id_campione, l.codice_linea, pp.id_gisa as id_piano, p.id_unita_operativa, i.data_inizio_controllo, i.riferimento_id, i.riferimento_nome_tab, 1 as eseguiti, 'camp' as fonte, ind.id as id_motivo_originale, al.id_norma
from h_get_campioni c
join h_get_controlli_ispezioni_semplici i on c.id_controllo_ufficiale = i.id_controllo::text and upper_inf(i.rng) is true 
join h_get_controlli_ispezioni_semplici_percontodi p on p.id_controllo = i.id_controllo  and coalesce(nullif(nullif(p.id_piano_ispezione,-1),0),p.id_motivo_ispezione) = coalesce(c.id_piano, c.id_attivita)
	and upper_inf(p.rng) is true
join vw_dpat_indicatore_new_validi ind on ind.id = coalesce(c.id_piano, c.id_attivita)
join matrix.struttura_piani pp on pp.cod_raggruppamento = ind.cod_raggruppamento and pp.anno = ind.anno and pp.ha_campioni is true
left join h_get_linee_attivita_controllo l on l.id_controllo = i.id_controllo and upper_inf(l.rng) is true
--left join h_dbi_get_all_stabilimenti ss on ss.riferimento_id = i.riferimento_id and ss.riferimento_id_nome_tab = i.riferimento_nome_tab 
-- and ss.latitudine_stab is not null and ss.latitudine_stab != 0
-- and ss.longitudine_stab is not null and ss.longitudine_stab != 0
-- and upper_inf(ss.rng) is true
 left join "Analisi_dev".vw_dbi_get_all_linee_validi al on l.id_linea = al.id_linea and al.riferimento_id = i.riferimento_id and al.riferimento_id_nome_tab = i.riferimento_nome_tab 
where i.data_inizio_controllo >= '2019-01-01' and upper_inf(c.rng) is true  and c.id_asl = p.id_asl_struttura
and c.rendicontabile is true
)a
group by 1,2,3,4,5,6,7,9,10,11
with data ;




create or replace view vw_gisa_controlli_ufficiali as 
select * from mvw_get_ispezioni_semplici
union
select * from mvw_get_sorveglianze
union
select * from mvw_get_audit_regole
union
select * from mvw_campioni;


drop materialized view if exists ra.mvw_get_campioni_validi;
create materialized view ra.mvw_get_campioni_validi as 
select *, id_controllo_ufficiale::bigint as id_controllo, COALESCE(id_piano, id_attivita) as id_motivo 
from "Analisi_dev".vw_get_campioni_validi where id_controllo_ufficiale != 'null';
create index campioni_id_cu_motivo on ra.mvw_get_campioni_validi(id_controllo, id_motivo);


truncate table ra.lookup_norme;
insert into ra.lookup_norme select distinct norma, id_norma from "Analisi_dev".vw_dbi_get_all_linee_validi vglacv where data_inizio_attivita is not null;


CREATE OR REPLACE VIEW "Analisi_dev".vw_conteggio_cu_grouped
AS SELECT count(vw_gisa_controlli_ufficiali.id_controllo) AS effettuati,
    vw_gisa_controlli_ufficiali.id_motivo AS id_indicatore,
    vw_gisa_controlli_ufficiali.id_unita_operativa AS id_struttura_uo
   FROM "Analisi_dev".vw_gisa_controlli_ufficiali
  GROUP BY vw_gisa_controlli_ufficiali.id_motivo, vw_gisa_controlli_ufficiali.id_unita_operativa;
 
 
 CREATE OR REPLACE VIEW "Analisi_dev".vw_conteggio_cu_grouped_no_rend
AS SELECT count(vw_gisa_controlli_ufficiali.id_controllo) AS effettuati,
    vw_gisa_controlli_ufficiali.id_motivo AS id_indicatore,
    vw_gisa_controlli_ufficiali.id_unita_operativa AS id_struttura_uo
   FROM "Analisi_dev".vw_gisa_controlli_ufficiali
  WHERE NOT (vw_gisa_controlli_ufficiali.id_motivo IN ( SELECT pnr.id_piano
           FROM "Analisi_dev".piano_no_rend pnr))
  GROUP BY vw_gisa_controlli_ufficiali.id_motivo, vw_gisa_controlli_ufficiali.id_unita_operativa;
 
 CREATE OR REPLACE VIEW "Analisi_dev".vw_conteggio_cu
AS SELECT a_r.id_ref AS id_struttura,
        CASE
            WHEN a_r.descrizione_breve IS NULL AND p_r.descrizione_breve IS NULL THEN COALESCE(cu.id_indicatore * '-1000'::integer, '-999'::integer::bigint) + COALESCE(cu.id_struttura_uo::bigint * '-1000000'::integer, '-999000'::integer::bigint)
            WHEN p_r.descrizione_breve IS NULL THEN COALESCE(cu.id_indicatore * '-1000'::integer, '-998'::integer::bigint)
            ELSE p_r.id_ref
        END AS id_piano,
        CASE
            WHEN cu.id_indicatore IS NULL AND cu.id_struttura_uo IS NULL THEN 'FORZE ORDINE'::character varying
            WHEN a_r.descrizione_breve IS NULL AND p_r.descrizione_breve IS NULL THEN ((('FUORI PIANO '::text || COALESCE(cu.id_indicatore::character varying, ''::character varying)::text) || ' - FUORI ASL '::character varying::text) || COALESCE(cu.id_struttura_uo::character varying, ''::character varying)::text)::character varying
            WHEN p_r.descrizione_breve IS NULL THEN ('FUORI PIANO '::character varying::text || COALESCE(cu.id_indicatore::character varying, ''::character varying)::text)::character varying
            ELSE ((COALESCE(p_r.alias, ''::text) || ' '::text) || regexp_replace(p_r.descrizione_breve::text, '[\n\r]+'::text, ' '::text, 'g'::text))::character varying
        END AS descr_p,
    COALESCE(a_r.descrizione_breve, ('NON ASL'::character varying::text || cu.id_struttura_uo)::character varying) AS descr_a,
    p_r.color,
    p_r.path_ord,
    t.target,
    d.distribuiti,
    sum(cu.effettuati) AS effettuati,
    t.target - sum(cu.effettuati)::double precision AS da_fare,
        CASE
            WHEN t.target > 0::double precision THEN sum(cu.effettuati)::double precision / t.target
            ELSE 0::double precision
        END AS perc,
    COALESCE(p_r.livello, 0::bigint) AS livello,
        CASE
            WHEN a_r.descrizione_breve IS NULL AND p_r.descrizione_breve IS NULL THEN '999'::text
            WHEN p_r.descrizione_breve IS NULL THEN '998'::text
            ELSE p_r.path
        END AS path
   FROM matrix.vw_struttura_piani_ref p_r
     LEFT JOIN "Analisi_dev".vw_conteggio_cu_grouped cu ON p_r.id = cu.id_indicatore AND NOT (cu.id_indicatore IN ( SELECT piano_no_rend.id_piano
           FROM piano_no_rend))
     LEFT JOIN matrix.struttura_asl_ref a_r ON a_r.id = cu.id_struttura_uo
     LEFT JOIN matrix.vw_target t ON a_r.id_ref = t.id_struttura AND p_r.id_ref = t.id_piano
     LEFT JOIN matrix.vw_distribuiti d ON a_r.id_ref = d.id_struttura AND p_r.id_ref = d.id_piano
  GROUP BY a_r.id_ref, (
        CASE
            WHEN a_r.descrizione_breve IS NULL AND p_r.descrizione_breve IS NULL THEN COALESCE(cu.id_indicatore * '-1000'::integer, '-999'::integer::bigint) + COALESCE(cu.id_struttura_uo::bigint * '-1000000'::integer, '-999000'::integer::bigint)
            WHEN p_r.descrizione_breve IS NULL THEN COALESCE(cu.id_indicatore * '-1000'::integer, '-998'::integer::bigint)
            ELSE p_r.id_ref
        END), (
        CASE
            WHEN cu.id_indicatore IS NULL AND cu.id_struttura_uo IS NULL THEN 'FORZE ORDINE'::character varying
            WHEN a_r.descrizione_breve IS NULL AND p_r.descrizione_breve IS NULL THEN ((('FUORI PIANO '::text || COALESCE(cu.id_indicatore::character varying, ''::character varying)::text) || ' - FUORI ASL '::character varying::text) || COALESCE(cu.id_struttura_uo::character varying, ''::character varying)::text)::character varying
            WHEN p_r.descrizione_breve IS NULL THEN ('FUORI PIANO '::character varying::text || COALESCE(cu.id_indicatore::character varying, ''::character varying)::text)::character varying
            ELSE ((COALESCE(p_r.alias, ''::text) || ' '::text) || regexp_replace(p_r.descrizione_breve::text, '[\n\r]+'::text, ' '::text, 'g'::text))::character varying
        END), (COALESCE(a_r.descrizione_breve, ('NON ASL'::character varying::text || cu.id_struttura_uo)::character varying)), p_r.color, p_r.path_ord, t.target, d.distribuiti, (COALESCE(p_r.livello, 0::bigint)), (
        CASE
            WHEN a_r.descrizione_breve IS NULL AND p_r.descrizione_breve IS NULL THEN '999'::text
            WHEN p_r.descrizione_breve IS NULL THEN '998'::text
            ELSE p_r.path
        END);
       
create or replace view "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab as
	seLECT
		ct.id_controllo_ufficiale id_controllo,
		nucleo_ispettivo_uno, componentenucleoid_uno, componente_nucleo_ispettivo_uno,
		nucleo_ispettivo_due, componentenucleoid_due, componente_nucleo_ispettivo_due,
		nucleo_ispettivo_tre, componentenucleoid_tre, componente_nucleo_ispettivo_tre,
		nucleo_ispettivo_quattro, componentenucleoid_quattro, componente_nucleo_ispettivo_quattro,
		nucleo_ispettivo_cinque, componentenucleoid_cinque, componente_nucleo_ispettivo_cinque,
		nucleo_ispettivo_sei, componentenucleoid_sei, componente_nucleo_ispettivo_sei,
		nucleo_ispettivo_sette, componentenucleoid_sette, componente_nucleo_ispettivo_sette,
		nucleo_ispettivo_otto, componentenucleoid_otto, componente_nucleo_ispettivo_otto,
		nucleo_ispettivo_nove, componentenucleoid_nove, componente_nucleo_ispettivo_nove,
		nucleo_ispettivo_dieci, componente_nucleo_ispettivo_dieci, componentenucleoid_dieci
	FROM public.crosstab(	
		'select
				id_controllo,
				id_componente,
				concat(nome, $$ $$, cognome) componente_nucleo_ispettivo
		from "Analisi_dev".vw_get_controlli_nucleoispettivo_validi
		order by 1,2')
	AS ct(id_controllo_ufficiale integer,
		  componente_nucleo_ispettivo_uno text,
		  componente_nucleo_ispettivo_due text,
		  componente_nucleo_ispettivo_tre text,
		  componente_nucleo_ispettivo_quattro text,
		  componente_nucleo_ispettivo_cinque text,
		  componente_nucleo_ispettivo_sei text,
		  componente_nucleo_ispettivo_sette text,
		  componente_nucleo_ispettivo_otto text,
		  componente_nucleo_ispettivo_nove text,
		  componente_nucleo_ispettivo_dieci text)
	inner join ( 	 
	SELECT *
	FROM public.crosstab(	
		'select
				id_controllo,
				id_componente,
				ruolo
		from "Analisi_dev".vw_get_controlli_nucleoispettivo_validi
		order by 1,2')
	AS ct_r(id_controllo_ufficiale integer,
		  nucleo_ispettivo_uno text,
		  nucleo_ispettivo_due text,
		  nucleo_ispettivo_tre text,
		  nucleo_ispettivo_quattro text,
		  nucleo_ispettivo_cinque text,
		  nucleo_ispettivo_sei text,
		  nucleo_ispettivo_sette text,
		  nucleo_ispettivo_otto text,
		  nucleo_ispettivo_nove text,
		  nucleo_ispettivo_dieci text)
	) ruoli on ct.id_controllo_ufficiale = ruoli.id_controllo_ufficiale
	inner join ( 	 
	SELECT *
	FROM public.crosstab(	
		'select
				id_controllo,
				id_componente,
				id_componente
		from "Analisi_dev".vw_get_controlli_nucleoispettivo_validi
		order by 1,2')
	AS ct_id(id_controllo_ufficiale integer,
		  componentenucleoid_uno integer,
		  componentenucleoid_due integer,
		  componentenucleoid_tre integer,
		  componentenucleoid_quattro integer,
		  componentenucleoid_cinque integer,
		  componentenucleoid_sei integer,
		  componentenucleoid_sette integer,
		  componentenucleoid_otto integer,
		  componentenucleoid_nove integer,
		  componentenucleoid_dieci integer)
	  )id on id.id_controllo_ufficiale=ct.id_controllo_ufficiale;


CREATE TABLE IF NOT EXISTS h_gisa_controlli_ufficiali (id_controllo bigint, codice_linea text, id_motivo bigint, id_unita_operativa bigint, data_inizio_controllo timestamp, riferimento_id bigint, riferimento_nome_tab bigint, eseguiti bigint, fonte text, rng int8range);


return 1;
end;
$_$;


ALTER FUNCTION "Analisi_dev".create_mvw() OWNER TO postgres;

--
-- Name: create_mvw_iuv(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_mvw_iuv() RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare 
	rec record;
	i integer;
	union_ text;
	str_create text;
	str_drop text;
	str_query text;
begin
	i := 0;
	union_ := '';

    str_drop := 'DROP MATERIALIZED VIEW IF EXISTS  "Analisi_dev".mvw_iuv;';
	str_create := 'CREATE MATERIALIZED VIEW "Analisi_dev".mvw_iuv as ';

	for rec in select * from "Analisi_dev".config_iuv where enabled loop
		if i > 0 then	
			union_ := '
				union
				';
		end if;
		if rec.motivo is false then 
			str_query := rec.query;
			str_query := replace(str_query, '$cod_raggruppamento', rec.cod_raggruppamento::text);
			str_query := 'select * from (' || replace(str_query, '$id', rec.id::text) || ')a where data >= ''2019-01-01'' ';
			str_create := str_create || union_ || str_query;
		else
			str_query = 'select distinct p.id_asl_struttura as id_asl , $cod_raggruppamento as cod_raggruppamento, data_inizio_controllo as data, count(*) as eseguiti, $id as fonte from "Analisi_dev".vw_get_controlli_ispezioni_semplici_validi i join "Analisi_dev".vw_get_controlli_ispezioni_semplici_percontodi_validi p on p.id_controllo = i.id_controllo  join "Analisi_dev".vw_dpat_indicatore_new_validi pp on coalesce(nullif(p.id_piano_ispezione,-1),p.id_motivo_ispezione) = pp.id where pp.cod_raggruppamento = $cod_raggruppamento and data_inizio_controllo > ''2019-01-01'' group by 1,2,3,5';
			str_query := replace(str_query, '$cod_raggruppamento', rec.cod_raggruppamento::text);
			str_query := replace(str_query, '$id', rec.id::text);
			str_create := str_create || union_ || str_query;
		end if;
		i = i +1;	
	end loop;

	SET enable_seqscan = OFF;

	str_create := str_create || '
		with data;';
	raise notice '%', str_create;
	execute str_drop;
	execute str_create;
	return 1;
end;
$_$;


ALTER FUNCTION "Analisi_dev".create_mvw_iuv() OWNER TO postgres;

--
-- Name: create_piano_no_rend(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_piano_no_rend() RETURNS integer
    LANGUAGE plpgsql
    AS $$
 begin
	 delete from "Analisi_dev".piani_no_rend;
	-- oscuro i tipo_item_dpat != 3 a esclusione delle supervisioni, e oscuro gli audit a1 (riabilitati 13/01/2021)
	 insert into "Analisi_dev".piani_no_rend select id, anno from "Analisi_dev".vw_dpat_indicatore_new_validi vdina where ( tipo_item_dpat != 3 and 
	 cod_raggruppamento not in (4038, 4037)); /*or (cod_raggruppamento in (5184,
						5183,
						3257,
						5185,
						5194,
						5190,
						5188,
						5193,
						5187,
						5189,
						5192,
						5186,
						5191,
						5182,
						5196,
						5195) )*/
	 --or (cod_raggruppamento in (3185, 3188)); --oscuramento a5_a, a5_b 19/11/2021, vedere whatsapp Viviana.
	return 1;
 end;
 $$;


ALTER FUNCTION "Analisi_dev".create_piano_no_rend() OWNER TO postgres;

--
-- Name: create_struttura_asl(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_struttura_asl() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare
anno_corrente text;
begin
  
	set search_path to "Analisi_dev";

 	select value from config where descr = 'ANNO CORRENTE' into anno_corrente;


	drop table if exists   struttura_asl;
	create table struttura_asl as select nextval('"Analisi_dev".seq_schema') as id, id as id_gisa, id_padre, id_asl, descrizione_lunga as descrizione, n_livello, somma_ui_area as ups, somma_uba_area as uba
	from h_oia_nodo where (anno = anno_corrente::int and stato != 1 and data_scadenza is null and not disabilitata) or (n_livello < 2 and data_Scadenza is null);

	alter table struttura_asl add column descrizione_breve text;
	update struttura_asl set descrizione_breve = upper(descrizione);
	update struttura_asl set descrizione_breve = replace(upper(descrizione),'UNITA'' OPERATIVA SEMPLICE DIPARTIMENTALE', 'UOSD') where upper(descrizione) like 'UNITA'' OPERATIVA SEMPLICE DIPARTIMENTALE%';
	update struttura_asl set descrizione_breve = replace(upper(descrizione),'UNITA'' OPERATIVA COMPLESSA', 'UOC') where upper(descrizione) like 'UNITA'' OPERATIVA COMPLESSA%';
	update struttura_asl set descrizione_breve = replace(upper(descrizione),'DIPARTIMENTO DI PREVENZIONE', 'D.D.P.') where upper(descrizione) like 'DIPARTIMENTO DI PREVENZIONE%';


	return 1;
end;
$$;


ALTER FUNCTION "Analisi_dev".create_struttura_asl() OWNER TO postgres;

--
-- Name: create_struttura_piani(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_struttura_piani() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare
	    anno_corrente text;
begin
	
	set search_path to "Analisi_dev";

 	select value from config where descr = 'ANNO CORRENTE' into anno_corrente;

	drop table if exists struttura_piani;
	CREATE TABLE struttura_piani (
		id int8 NOT null default nextval('"Analisi_dev".seq_schema'),
		id_gisa int8,
		cod_raggruppamento int8 NULL,
		anno int4 NULL,
		descrizione text NULL,
		ordinamento int4 NULL,
		data_scadenza timestamp NULL,
		stato int4 NULL,
		codice_interno int4 NULL,
		color varchar(100) NULL,
		"path" text NULL,
		livello int8 NULL,
		parent int8 NULL,
		alias text NULL,
		path_ord text null
	);

	insert into struttura_piani (id_gisa, descrizione, path, livello, parent, anno, stato, ordinamento, path_ord )values(-1, 'TOTALE', 'TOTALE', 0, null, anno_corrente::int, 2, 0, '000');
--	insert into struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-2, 'PIANO', 'TOTALE-PIANO', 1, -1, 2019, 2, 0, '000-000');
--	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-3, 'ATTIVITA', 'TOTALE-ATTIVITA', 1, -1, 2019, 2, 1, '000-001');
	
	insert into struttura_piani (id_gisa, cod_raggruppamento, anno, descrizione, ordinamento, data_scadenza, stato, codice_interno, color, path, livello, parent, alias, path_ord ) 
	select distinct  s.id as id_gisa, s.cod_raggruppamento, anno_corrente::int, s.descrizione, s.ordinamento, s.data_scadenza, s.stato, s.codice_interno, s.color, sp.path||'-'||s.descrizione, 1,  sp.id_gisa, null, sp.path_ord||'-'||lpad(s.ordinamento::text,'3','0') 
	from h_dpat_sez_new s join h_dpat_piano_attivita_new p on s.id = p.id_sezione join h_dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join struttura_piani sp on sp.descrizione::text = 'TOTALE'
	where i.anno = anno_corrente::int and p.anno = anno_corrente::int and s.anno = anno_corrente::int 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null;
	

	update struttura_piani set ordinamento = '0' , path_ord = '000-000'  where livello = 1 and path = 'TOTALE-SEZIONE A';
	update struttura_piani set ordinamento = '1' , path_ord = '000-001'  where livello = 1 and path = 'TOTALE-SEZIONE B';
	update struttura_piani set ordinamento = '2' , path_ord = '000-002'  where livello = 1 and path = 'TOTALE-SEZIONE C';
	update struttura_piani set ordinamento = '3' , path_ord = '000-003'  where livello = 1 and path = 'TOTALE-SEZIONE D';


	insert into struttura_piani (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(nextval('"Analisi_dev".seq_schema'), -2, 'PIANO', 'TOTALE-SEZIONE A-PIANO', 2, 77, 2019::int, 2, 0, '000-000-000');
	insert into struttura_piani (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(nextval('"Analisi_dev".seq_schema'), -3, 'ATTIVITA', 'TOTALE-SEZIONE A-ATTIVITA', 2, 77, 2019::int, 2, 1, '000-000-001');
	insert into struttura_piani (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(nextval('"Analisi_dev".seq_schema'), -4, 'PIANO', 'TOTALE-SEZIONE B-PIANO', 2, 78, 2019::int, 2, 0, '000-001-000');
	insert into struttura_piani (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(nextval('"Analisi_dev".seq_schema'), -5, 'ATTIVITA', 'TOTALE-SEZIONE B-ATTIVITA', 2, 78, 2019::int, 2, 1, '000-001-001');
	insert into struttura_piani (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(nextval('"Analisi_dev".seq_schema'), -6, 'PIANO', 'TOTALE-SEZIONE C-PIANO', 2, 79, 2019::int, 2, 0, '000-002-000');
	insert into struttura_piani (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(nextval('"Analisi_dev".seq_schema'), -7, 'ATTIVITA', 'TOTALE-SEZIONE C-ATTIVITA', 2, 79, 2019::int, 2, 1, '000-002-001');
	insert into struttura_piani (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(nextval('"Analisi_dev".seq_schema'), -8, 'PIANO', 'TOTALE-SEZIONE D-PIANO', 2, 80, 2019::int, 2, 0, '000-003-000');
	insert into struttura_piani (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(nextval('"Analisi_dev".seq_schema'), -9, 'ATTIVITA', 'TOTALE-SEZIONE D-ATTIVITA', 2, 80, 2019::int, 2, 1, '000-003-001');
	

	insert into struttura_piani (id_gisa, cod_raggruppamento, anno, descrizione, ordinamento, data_scadenza, stato, codice_interno, color, path, livello, parent, alias, path_ord ) 
	select distinct p.id as id_gisa, p.cod_raggruppamento, anno_corrente::int, p.descrizione, p.ordinamento, p.data_scadenza, p.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 3,  sp.id_gisa, p.alias_piano, sp.path_ord||'-'||lpad(p.ordinamento::text,'3','0') 
	from h_dpat_sez_new s join h_dpat_piano_attivita_new p on s.id = p.id_sezione join h_dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join struttura_piani sp on sp.id_gisa = case when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'A' then -2
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'A' then -3
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'B' then -4
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'B' then -5
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'C' then -6
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'C' then -7
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'D' then -8
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'D' then -9
												   END
	where i.anno = anno_corrente::int and p.anno = anno_corrente::int and s.anno = anno_corrente::int 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null;
	
	insert into struttura_piani (id_gisa, cod_raggruppamento, anno, descrizione, ordinamento, data_scadenza, stato, codice_interno, color, path, livello, parent, alias, path_ord )
	select i.id as id_gisa, i.cod_raggruppamento, anno_corrente::int, i.descrizione, i.ordinamento,i.data_scadenza, i.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 4,  sp.id_gisa, i.alias_indicatore,sp.path_ord||'-'||lpad(i.ordinamento::text,'3','0') 
	from h_dpat_sez_new s join h_dpat_piano_attivita_new p on s.id = p.id_sezione join h_dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join struttura_piani sp on sp.id_gisa = i.id_piano_attivita
	where i.anno = anno_corrente::int and p.anno = anno_corrente::int and s.anno = anno_corrente::int 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null;

	alter table struttura_piani add column descrizione_breve text;

	update struttura_piani set descrizione_breve = upper(descrizione);
	update struttura_piani set descrizione_breve = replace(upper(descrizione),'PIANO  DI MONIOTORAGGIO', 'P.M.') where upper(descrizione) like '%PIANO  DI MONIOTORAGGIO%';
	update struttura_piani set descrizione_breve = replace(upper(descrizione),'PIANO DI MONIOTORAGGIO', 'P.M.') where upper(descrizione) like '%PIANO DI MONIOTORAGGIO%';
	update struttura_piani set descrizione_breve = replace(upper(descrizione),'PIANO DI MONITORAGGIO', 'P.M.') where upper(descrizione) like '%PIANO DI MONITORAGGIO%';
	update struttura_piani set descrizione_breve = replace(upper(descrizione),'ATTIVITA', 'ATT.') where LIVELLO != 2 and upper(descrizione) like '%ATTIVITA%';
	update struttura_piani set descrizione_breve = replace(upper(descrizione),'ATTIVIT ', 'ATT. ') where upper(descrizione) like '%ATTIVIT %';
	update struttura_piani set descrizione_breve = replace(upper(descrizione),'ISPEZIONI ', 'ISP. ') where upper(descrizione) like 'ISPEZIONI%';

	alter table struttura_piani add column id_formula_ups bigint;
	alter table struttura_piani add column id_formula_uba bigint;

	alter table struttura_piani add column id_tipo_tecnica bigint;

	
	return 1;
end;
$$;


ALTER FUNCTION "Analisi_dev".create_struttura_piani() OWNER TO postgres;

--
-- Name: create_view_validi(text); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_view_validi(modalita text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	declare
	str character varying;
	nome_colonna character varying;
	C record;
	COL record;
	i integer;
	fields text;
	begin	
		
  	set search_path to "Analisi_dev";
	 
	 
	for C in select * from "Analisi_dev".gisadbi where enabled and ((giornaliero is true and modalita = 'giornaliero') or (istantaneo is true and modalita = 'istantaneo'))  and  status = 'C' loop
		str = 'drop view if exists "Analisi_dev".vw_'|| C.tname || '_validi cascade;';
		execute str;
		fields = '';
		i = 0;
		for COL in select cc.column_name, cc.data_type, cc.character_maximum_length
				from information_schema.columns cc 
				where table_catalog = 'mdgm_fvg' and table_schema = 'Analisi_dev' and table_name = 'h_'||C.tname and column_name != 'rng' loop 
			if strpos(col.column_name, ' ') > 0 then 
				col.column_name = '"'|| col.column_name ||'"';
			end if;
			if i > 0 then 
				fields  = fields || ','; 
			end if;	
			nome_colonna=    COL.column_name;
		    if(COL.data_type = 'character varying' or COL.data_type ='text' ) then
		      nome_colonna= 'regexp_replace('|| COL.column_name ||',''[\r\n\t\v]'','''',''g'')  ' || COL.column_name ;
		    end if;
			fields = fields ||nome_colonna;
		
		i = i + 1;
		end loop;
	
		str = 'create view "Analisi_dev".vw_'|| C.tname || '_validi as select '||fields||' from h_'|| C.tname ||' where  upper_inf(rng) is true;';
		raise notice '%', str;
		execute str;
	
	end loop;
	
	CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_sez_new_attivi
AS SELECT *
   FROM "Analisi_dev".vw_dpat_sez_new_validi vdsnv
  WHERE vdsnv.stato <> 1 AND (vdsnv.data_scadenza IS NULL OR vdsnv.data_scadenza > CURRENT_TIMESTAMP) AND vdsnv.descrizione <> 'SEZIONE E'::text AND vdsnv.anno > 0 AND vdsnv.anno IS NOT NULL;

 /*CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_piano_attivita_new_attivi
AS SELECT *
   FROM "Analisi_dev".vw_dpat_piano_attivita_new_validi vdpanv
  WHERE vdpanv.stato <> 1 AND (vdpanv.data_scadenza IS NULL OR vdpanv.data_scadenza > CURRENT_TIMESTAMP) AND vdpanv.anno > 0 AND vdpanv.anno IS NOT NULL AND (vdpanv.id_sezione IN ( SELECT vw_dpat_sez_new_attivi.id
           FROM "Analisi_dev".vw_dpat_sez_new_attivi));

    
 CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_indicatore_new_attivi
AS SELECT *
   FROM "Analisi_dev".vw_dpat_indicatore_new_validi vdinv
  WHERE vdinv.stato <> 1 AND (vdinv.data_scadenza IS NULL OR vdinv.data_scadenza > CURRENT_TIMESTAMP) AND vdinv.anno > 0 AND vdinv.anno IS NOT NULL AND (vdinv.id_piano_attivita IN ( SELECT vw_dpat_piano_attivita_new_attivi.id
           FROM "Analisi_dev".vw_dpat_piano_attivita_new_attivi));*/
 
  CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_piano_attivita_new_attivi
  AS select * from (
		select * ,
    	row_number () over (partition by cod_raggruppamento, anno order by coalesce(data_scadenza, '3000-01-01') desc) as pos
   		FROM "Analisi_dev".vw_dpat_piano_attivita_new_validi vdpanv
   	--	where  right(alias_piano ,1) in ('1','2','3','4','5','6','7','8','9','0')

  ) a
  where pos = 1;
          
   CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_indicatore_new_attivi
	AS select * from (
		select * ,
	    row_number () over (partition by cod_raggruppamento, anno order by coalesce(data_scadenza, '3000-01-01') desc) as pos
	   	FROM "Analisi_dev".vw_dpat_indicatore_new_validi vdinv
  	) a
  	where pos = 1;
          
   CREATE OR REPLACE VIEW "Analisi_dev".vw_oia_nodo_attivi  AS
  select * from (
SELECT *,
    row_number() OVER (PARTITION by CODICE_INTERNO_UNIVOCO, anno ORDER BY (COALESCE(data_scadenza, '3000-01-01 00:00:00'::timestamp without time zone)) DESC) AS pos
   FROM "Analisi_dev".vw_oia_nodo_validi
  WHERE (vw_oia_nodo_validi.stato = ANY (ARRAY[0, 2])) AND NOT vw_oia_nodo_validi.disabilitata AND vw_oia_nodo_validi.data_scadenza IS NULL AND vw_oia_nodo_validi.anno > 0 AND vw_oia_nodo_validi.anno IS NOT NULL AND vw_oia_nodo_validi.trashed_date IS NULL) a
 WHERE a.pos = 1;
	
	return 1;
end;

$$;


ALTER FUNCTION "Analisi_dev".create_view_validi(modalita text) OWNER TO postgres;

--
-- Name: create_view_validi2(text); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_view_validi2(modalita text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	declare
	str character varying;
	C record;
	COL record;
	i integer;
	fields text;
	begin	
		
  	set search_path to "Analisi_dev";
	 
	 
	for C in select * from "Analisi_dev".gisadbi where ((giornaliero is true and modalita = 'giornaliero') or (istantaneo is true and modalita = 'istantaneo'))  and  status = 'C' loop
		str = 'drop view if exists "Analisi_dev".vw_'|| C.tname || '_validi cascade;';
		execute str;
		fields = '';
		i = 0;
		for COL in select cc.column_name, cc.data_type, cc.character_maximum_length
				from information_schema.columns cc 
				where table_catalog = 'mdgm' and table_schema = 'Analisi_dev' and table_name = 'h_'||C.tname and column_name != 'rng' loop 
			if i > 0 then 
				fields  = fields || ','; 
			end if;	
			fields = fields || COL.column_name;
		i = i + 1;
		end loop;
	
		str = 'create view "Analisi_dev".vw_'|| C.tname || '_validi as select '||fields||' from h_'|| C.tname ||' where  upper_inf(rng) is true;';
		raise notice '%', str;
		execute str;
	
	end loop;
	
	CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_sez_new_attivi
AS SELECT *
   FROM "Analisi_dev".vw_dpat_sez_new_validi vdsnv
  WHERE vdsnv.stato <> 1 AND (vdsnv.data_scadenza IS NULL OR vdsnv.data_scadenza > CURRENT_TIMESTAMP) AND vdsnv.descrizione <> 'SEZIONE E'::text AND vdsnv.anno > 0 AND vdsnv.anno IS NOT NULL;

 /*CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_piano_attivita_new_attivi
AS SELECT *
   FROM "Analisi_dev".vw_dpat_piano_attivita_new_validi vdpanv
  WHERE vdpanv.stato <> 1 AND (vdpanv.data_scadenza IS NULL OR vdpanv.data_scadenza > CURRENT_TIMESTAMP) AND vdpanv.anno > 0 AND vdpanv.anno IS NOT NULL AND (vdpanv.id_sezione IN ( SELECT vw_dpat_sez_new_attivi.id
           FROM "Analisi_dev".vw_dpat_sez_new_attivi));

    
 CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_indicatore_new_attivi
AS SELECT *
   FROM "Analisi_dev".vw_dpat_indicatore_new_validi vdinv
  WHERE vdinv.stato <> 1 AND (vdinv.data_scadenza IS NULL OR vdinv.data_scadenza > CURRENT_TIMESTAMP) AND vdinv.anno > 0 AND vdinv.anno IS NOT NULL AND (vdinv.id_piano_attivita IN ( SELECT vw_dpat_piano_attivita_new_attivi.id
           FROM "Analisi_dev".vw_dpat_piano_attivita_new_attivi));*/
 
  CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_piano_attivita_new_attivi
  AS select * from (
		select * ,
    	row_number () over (partition by cod_raggruppamento, anno order by coalesce(data_scadenza, '3000-01-01') desc) as pos
   		FROM "Analisi_dev".vw_dpat_piano_attivita_new_validi vdpanv
  ) a
  where pos = 1;
          
   CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_indicatore_new_attivi
	AS select * from (
		select * ,
	    row_number () over (partition by cod_raggruppamento, anno order by coalesce(data_scadenza, '3000-01-01') desc) as pos
	   	FROM "Analisi_dev".vw_dpat_indicatore_new_validi vdinv
  	) a
  	where pos = 1;
          
          
  CREATE OR REPLACE VIEW "Analisi_dev".vw_oia_nodo_attivi
AS SELECT *
   FROM "Analisi_dev".vw_oia_nodo_validi
  WHERE vw_oia_nodo_validi.trashed_date IS NULL AND (vw_oia_nodo_validi.stato = ANY (ARRAY[0, 2])) AND (CURRENT_TIMESTAMP < vw_oia_nodo_validi.data_scadenza OR vw_oia_nodo_validi.data_scadenza IS NULL) AND vw_oia_nodo_validi.anno > 0 AND vw_oia_nodo_validi.anno IS NOT NULL AND NOT vw_oia_nodo_validi.disabilitata;

	
	return 1;
end;

$$;


ALTER FUNCTION "Analisi_dev".create_view_validi2(modalita text) OWNER TO postgres;

--
-- Name: create_view_validi_20210419(text); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_view_validi_20210419(modalita text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	declare
	str character varying;
	C record;

	begin	
		
	  set search_path to "Analisi_dev";
	 
	 
		for C in select * from "Analisi_dev".gisadbi where ((giornaliero is true and modalita = 'giornaliero') or (istantaneo is true and modalita = 'istantaneo'))  and  status = 'C' loop
			--str = 'drop view if exists "Analisi_dev".vw_'|| C.tname || '_validi cascade;';
			--execute str;
		
			str = 'create or replace view "Analisi_dev".vw_'|| C.tname || '_validi as select distinct * from h_'|| C.tname ||' where  upper_inf(rng) is true;';
			execute str;
		
		end loop;
	
	CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_sez_new_attivi
AS SELECT vdsnv.rng,
    vdsnv.id,
    vdsnv.cod_raggruppamento,
    vdsnv.anno,
    vdsnv.descrizione,
    vdsnv.ordinamento,
    vdsnv.data_scadenza,
    vdsnv.stato,
    vdsnv.codice_interno,
    vdsnv.color,
    vdsnv.entered,
    vdsnv.modified,
    vdsnv.entered_by,
    vdsnv.modified_by
   FROM "Analisi_dev".vw_dpat_sez_new_validi vdsnv
  WHERE vdsnv.stato <> 1 AND (vdsnv.data_scadenza IS NULL OR vdsnv.data_scadenza > CURRENT_TIMESTAMP) AND vdsnv.descrizione <> 'SEZIONE E'::text AND vdsnv.anno > 0 AND vdsnv.anno IS NOT NULL;

/* CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_piano_attivita_new_attivi
AS SELECT vdpanv.rng,
    vdpanv.id,
    vdpanv.cod_raggruppamento,
    vdpanv.id_sezione,
    vdpanv.anno,
    vdpanv.descrizione,
    vdpanv.ordinamento,
    vdpanv.data_scadenza,
    vdpanv.stato,
    vdpanv.codice_esame,
    vdpanv.tipo_attivita,
    vdpanv.codice_interno_piano,
    vdpanv.codice_interno_attivita,
    vdpanv.alias_piano,
    vdpanv.alias_attivita,
    vdpanv.codice_alias_attivita,
    vdpanv.entered,
    vdpanv.modified,
    vdpanv.entered_by,
    vdpanv.modified_by,
    vdpanv.note_hd
   FROM "Analisi_dev".vw_dpat_piano_attivita_new_validi vdpanv
  WHERE vdpanv.stato <> 1 AND (vdpanv.data_scadenza IS NULL OR vdpanv.data_scadenza > CURRENT_TIMESTAMP) AND vdpanv.anno > 0 AND vdpanv.anno IS NOT NULL AND (vdpanv.id_sezione IN ( SELECT vw_dpat_sez_new_attivi.id
           FROM "Analisi_dev".vw_dpat_sez_new_attivi));

          
 CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_indicatore_new_attivi
AS SELECT vdinv.rng,
    vdinv.id,
    vdinv.cod_raggruppamento,
    vdinv.id_piano_attivita,
    vdinv.anno,
    vdinv.descrizione,
    vdinv.ordinamento,
    vdinv.data_scadenza,
    vdinv.stato,
    vdinv.codice_esame,
    vdinv.codice_interno_indicatore,
    vdinv.alias_indicatore,
    vdinv.codice_interno_piani_gestione_cu,
    vdinv.codice_interno_attivita_gestione_cu,
    vdinv.codice_interno_univoco_tipo_attivita_gestione_cu,
    vdinv.codice_alias_indicatore,
    vdinv.flag_benessere,
    vdinv.entered,
    vdinv.modified,
    vdinv.entered_by,
    vdinv.modified_by
   FROM "Analisi_dev".vw_dpat_indicatore_new_validi vdinv
  WHERE vdinv.stato <> 1 AND (vdinv.data_scadenza IS NULL OR vdinv.data_scadenza > CURRENT_TIMESTAMP) AND vdinv.anno > 0 AND vdinv.anno IS NOT NULL AND (vdinv.id_piano_attivita IN ( SELECT vw_dpat_piano_attivita_new_attivi.id
           FROM "Analisi_dev".vw_dpat_piano_attivita_new_attivi));
          */
          
  CREATE OR REPLACE VIEW "Analisi_dev".vw_oia_nodo_attivi
AS SELECT vw_oia_nodo_validi.rng,
    vw_oia_nodo_validi.id,
    vw_oia_nodo_validi.id_padre,
    vw_oia_nodo_validi.id_asl,
    vw_oia_nodo_validi.descrizione_lunga,
    vw_oia_nodo_validi.n_livello,
    vw_oia_nodo_validi.entered,
    vw_oia_nodo_validi.entered_by,
    vw_oia_nodo_validi.modified,
    vw_oia_nodo_validi.modified_by,
    vw_oia_nodo_validi.trashed_date,
    vw_oia_nodo_validi.tipologia_struttura,
    vw_oia_nodo_validi.comune,
    vw_oia_nodo_validi.enabled,
    vw_oia_nodo_validi.obsoleto,
    vw_oia_nodo_validi.confermato,
    vw_oia_nodo_validi.id_strumento_calcolo,
    vw_oia_nodo_validi.codice_interno_fk,
    vw_oia_nodo_validi.nome,
    vw_oia_nodo_validi.id_utente,
    vw_oia_nodo_validi.mail,
    vw_oia_nodo_validi.indirizzo,
    vw_oia_nodo_validi.delegato,
    vw_oia_nodo_validi.descrizione_comune,
    vw_oia_nodo_validi.id_oia_nodo_temp,
    vw_oia_nodo_validi.data_scadenza,
    vw_oia_nodo_validi.disabilitata,
    vw_oia_nodo_validi.stato,
    vw_oia_nodo_validi.anno,
    vw_oia_nodo_validi.descrizione_area_struttura_complessa,
    vw_oia_nodo_validi.id_lookup_area_struttura_asl,
    vw_oia_nodo_validi.ui_struttura_foglio_att_iniziale,
    vw_oia_nodo_validi.ui_struttura_foglio_att_finale,
    vw_oia_nodo_validi.id_utente_edit,
    vw_oia_nodo_validi.percentuale_area_a,
    vw_oia_nodo_validi.stato_all2,
    vw_oia_nodo_validi.stato_all6,
    vw_oia_nodo_validi.codice_interno_univoco,
    vw_oia_nodo_validi.descrizione_area_struttura,
    vw_oia_nodo_validi.data_congelamento
   FROM "Analisi_dev".vw_oia_nodo_validi
  WHERE vw_oia_nodo_validi.trashed_date IS NULL AND (vw_oia_nodo_validi.stato = ANY (ARRAY[0, 2])) AND (CURRENT_TIMESTAMP < vw_oia_nodo_validi.data_scadenza OR vw_oia_nodo_validi.data_scadenza IS NULL) AND vw_oia_nodo_validi.anno > 0 AND vw_oia_nodo_validi.anno IS NOT NULL AND NOT vw_oia_nodo_validi.disabilitata;

 
   CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_piano_attivita_new_attivi
  AS select * from (
		select * ,
    	row_number () over (partition by cod_raggruppamento, anno order by coalesce(data_scadenza, '3000-01-01') desc) as pos
   		FROM "Analisi_dev".vw_dpat_piano_attivita_new_validi vdpanv
   		where  right(alias_piano ,1) in ('1','2','3','4','5','6','7','8','9','0')
  ) a
  where pos = 1;
          
   CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_indicatore_new_attivi
	AS select * from (
		select * ,
	    row_number () over (partition by cod_raggruppamento, anno order by coalesce(data_scadenza, '3000-01-01') desc) as pos
	   	FROM "Analisi_dev".vw_dpat_indicatore_new_validi vdinv
  	) a
  	where pos = 1;
	
	return 1;
end;

$$;


ALTER FUNCTION "Analisi_dev".create_view_validi_20210419(modalita text) OWNER TO postgres;

--
-- Name: create_view_validi_old(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_view_validi_old() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	declare
	str character varying;
	C record;

	begin	
		
	  set search_path to "Analisi_dev";
	 
	 
		for C in select * from "Analisi_dev".gisadbi where ((giornaliero is true and modalita = 'giornaliero') or (istantaneo is true and modalita = 'istantaneo'))  and  status = 'C' loop
			str = 'drop view if exists "Analisi_dev".vw_'|| C.tname || '_validi cascade;';
			execute str;
		
			str = 'create view "Analisi_dev".vw_'|| C.tname || '_validi as select * from h_'|| C.tname ||' where  upper_inf(rng) is true;';
			execute str;
		
		end loop;
	
	CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_sez_new_attivi
AS SELECT vdsnv.rng,
    vdsnv.id,
    vdsnv.cod_raggruppamento,
    vdsnv.anno,
    vdsnv.descrizione,
    vdsnv.ordinamento,
    vdsnv.data_scadenza,
    vdsnv.stato,
    vdsnv.codice_interno,
    vdsnv.color,
    vdsnv.entered,
    vdsnv.modified,
    vdsnv.entered_by,
    vdsnv.modified_by
   FROM "Analisi_dev".vw_dpat_sez_new_validi vdsnv
  WHERE vdsnv.stato <> 1 AND (vdsnv.data_scadenza IS NULL OR vdsnv.data_scadenza > CURRENT_TIMESTAMP) AND vdsnv.descrizione <> 'SEZIONE E'::text AND vdsnv.anno > 0 AND vdsnv.anno IS NOT NULL;

 CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_piano_attivita_new_attivi
AS SELECT vdpanv.rng,
    vdpanv.id,
    vdpanv.cod_raggruppamento,
    vdpanv.id_sezione,
    vdpanv.anno,
    vdpanv.descrizione,
    vdpanv.ordinamento,
    vdpanv.data_scadenza,
    vdpanv.stato,
    vdpanv.codice_esame,
    vdpanv.tipo_attivita,
    vdpanv.codice_interno_piano,
    vdpanv.codice_interno_attivita,
    vdpanv.alias_piano,
    vdpanv.alias_attivita,
    vdpanv.codice_alias_attivita,
    vdpanv.entered,
    vdpanv.modified,
    vdpanv.entered_by,
    vdpanv.modified_by,
    vdpanv.note_hd
   FROM "Analisi_dev".vw_dpat_piano_attivita_new_validi vdpanv
  WHERE vdpanv.stato <> 1 AND (vdpanv.data_scadenza IS NULL OR vdpanv.data_scadenza > CURRENT_TIMESTAMP) AND vdpanv.anno > 0 AND vdpanv.anno IS NOT NULL AND (vdpanv.id_sezione IN ( SELECT vw_dpat_sez_new_attivi.id
           FROM "Analisi_dev".vw_dpat_sez_new_attivi));

          
 CREATE OR REPLACE VIEW "Analisi_dev".vw_dpat_indicatore_new_attivi
AS SELECT vdinv.rng,
    vdinv.id,
    vdinv.cod_raggruppamento,
    vdinv.id_piano_attivita,
    vdinv.anno,
    vdinv.descrizione,
    vdinv.ordinamento,
    vdinv.data_scadenza,
    vdinv.stato,
    vdinv.codice_esame,
    vdinv.codice_interno_indicatore,
    vdinv.alias_indicatore,
    vdinv.codice_interno_piani_gestione_cu,
    vdinv.codice_interno_attivita_gestione_cu,
    vdinv.codice_interno_univoco_tipo_attivita_gestione_cu,
    vdinv.codice_alias_indicatore,
    vdinv.flag_benessere,
    vdinv.entered,
    vdinv.modified,
    vdinv.entered_by,
    vdinv.modified_by,
    vdinv.note_hd,
    vdinv.tipo_item_dpat
   FROM "Analisi_dev".vw_dpat_indicatore_new_validi vdinv
  WHERE vdinv.stato <> 1 AND (vdinv.data_scadenza IS NULL OR vdinv.data_scadenza > CURRENT_TIMESTAMP) AND vdinv.anno > 0 AND vdinv.anno IS NOT NULL AND (vdinv.id_piano_attivita IN ( SELECT vw_dpat_piano_attivita_new_attivi.id
           FROM "Analisi_dev".vw_dpat_piano_attivita_new_attivi));
          
          
  CREATE OR REPLACE VIEW "Analisi_dev".vw_oia_nodo_attivi
AS SELECT vw_oia_nodo_validi.rng,
    vw_oia_nodo_validi.id,
    vw_oia_nodo_validi.id_padre,
    vw_oia_nodo_validi.id_asl,
    vw_oia_nodo_validi.descrizione_lunga,
    vw_oia_nodo_validi.n_livello,
    vw_oia_nodo_validi.entered,
    vw_oia_nodo_validi.entered_by,
    vw_oia_nodo_validi.modified,
    vw_oia_nodo_validi.modified_by,
    vw_oia_nodo_validi.trashed_date,
    vw_oia_nodo_validi.tipologia_struttura,
    vw_oia_nodo_validi.comune,
    vw_oia_nodo_validi.enabled,
    vw_oia_nodo_validi.obsoleto,
    vw_oia_nodo_validi.confermato,
    vw_oia_nodo_validi.id_strumento_calcolo,
    vw_oia_nodo_validi.codice_interno_fk,
    vw_oia_nodo_validi.nome,
    vw_oia_nodo_validi.id_utente,
    vw_oia_nodo_validi.mail,
    vw_oia_nodo_validi.indirizzo,
    vw_oia_nodo_validi.delegato,
    vw_oia_nodo_validi.descrizione_comune,
    vw_oia_nodo_validi.id_oia_nodo_temp,
    vw_oia_nodo_validi.data_scadenza,
    vw_oia_nodo_validi.disabilitata,
    vw_oia_nodo_validi.stato,
    vw_oia_nodo_validi.anno,
    vw_oia_nodo_validi.descrizione_area_struttura_complessa,
    vw_oia_nodo_validi.id_lookup_area_struttura_asl,
    vw_oia_nodo_validi.ui_struttura_foglio_att_iniziale,
    vw_oia_nodo_validi.ui_struttura_foglio_att_finale,
    vw_oia_nodo_validi.id_utente_edit,
    vw_oia_nodo_validi.percentuale_area_a,
    vw_oia_nodo_validi.stato_all2,
    vw_oia_nodo_validi.stato_all6,
    vw_oia_nodo_validi.codice_interno_univoco,
    vw_oia_nodo_validi.descrizione_area_struttura,
    vw_oia_nodo_validi.data_congelamento
   FROM "Analisi_dev".vw_oia_nodo_validi
  WHERE vw_oia_nodo_validi.trashed_date IS NULL AND (vw_oia_nodo_validi.stato = ANY (ARRAY[0, 2])) AND (CURRENT_TIMESTAMP < vw_oia_nodo_validi.data_scadenza OR vw_oia_nodo_validi.data_scadenza IS NULL) AND vw_oia_nodo_validi.anno > 0 AND vw_oia_nodo_validi.anno IS NOT NULL AND NOT vw_oia_nodo_validi.disabilitata;

	
	return 1;
end;

$$;


ALTER FUNCTION "Analisi_dev".create_view_validi_old() OWNER TO postgres;

--
-- Name: create_vw_audit_autorita_cu(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_audit_autorita_cu() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	

	BEGIN

	BEGIN

		
	DROP MATERIALIZED  VIEW  IF EXISTS "Analisi_dev".vw_audit_autorita_cu CASCADE;


	CREATE MATERIALIZED VIEW  "Analisi_dev".vw_audit_autorita_cu AS 

	select 
	distinct -- ( si mette la distinct perchè la dbi restituisce anche la struttura controllata e questo fa duplicare i dati per il set di dati che invece si vede in DIGEMON
	dbi_audit.id_controllo id_controllo_ufficiale,
	dbi_audit.id_asl,
	dbi_audit.asl,
	l_tipo_controllo.description  as tipo_controllo ,
	dbi_audit.id_tecnica_cu  as code_tipo_controllo ,
	dbi_audit_ogg_controllo.tipo_audit as tipo_ispezione_o_audit,
	date_part('year',dbi_audit.data_inizio_controllo)::int anno_controllo,
		dbi_audit.data_inserimento,
	dbi_audit.data_inizio_controllo,
	dbi_audit.data_chiusura_controllo,
	dbi_audit.congruo_supervisione,
	dbi_audit.supervisionato_in_data,
	dbi_audit.supervisionato_da,
	dbi_audit.supervisione_note ,
	dbi_audit_ogg_controllo.oggetto_audit oggetto_del_controllo,
	--passaggio dbi_audit.note ,
		regexp_replace(dbi_audit.note,'[\r\n\t]','','g') note ,
	dbi_audit_percontodi.codice_interno_univoco_uo ,
	dbi_audit_percontodi.id_unita_operativa id_struttura_uo,
	dbi_audit_percontodi.per_conto_di_completo unita_operativa,
	dbi_audit_percontodi.struttura_complessa area_appartenenza_uo,

/*
	dbi_cu_nucleo_audit.nucleo_ispettivo_uno ,     dbi_cu_nucleo_audit.componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_audit.nucleo_ispettivo_due ,     dbi_cu_nucleo_audit.componente_nucleo_ispettivo_due,componentenucleoid_due,
	dbi_cu_nucleo_audit.nucleo_ispettivo_tre ,     dbi_cu_nucleo_audit.componente_nucleo_ispettivo_tre,componentenucleoid_tre,
	dbi_cu_nucleo_audit.nucleo_ispettivo_quattro , dbi_cu_nucleo_audit.componente_nucleo_ispettivo_quattro,  componentenucleoid_quattro,
	dbi_cu_nucleo_audit.nucleo_ispettivo_cinque ,  dbi_cu_nucleo_audit.componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sei ,     dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sei,  componentenucleoid_sei,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sette ,   dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
	dbi_cu_nucleo_audit.nucleo_ispettivo_otto ,    dbi_cu_nucleo_audit.componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_audit.nucleo_ispettivo_nove ,    dbi_cu_nucleo_audit.componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_audit.nucleo_ispettivo_dieci ,   dbi_cu_nucleo_audit.componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,*/
	dbi_cu_nucleo_audit.nucleo_ispettivo_uno ,         regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_uno,'[\r\n\t]','','g') componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_audit.nucleo_ispettivo_due ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_due,'[\r\n\t]','','g') componente_nucleo_ispettivo_due ,componentenucleoid_due,
	dbi_cu_nucleo_audit.nucleo_ispettivo_tre ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_tre,'[\r\n\t]','','g') componente_nucleo_ispettivo_tre ,componentenucleoid_tre,
	dbi_cu_nucleo_audit.nucleo_ispettivo_quattro , regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_quattro,'[\r\n\t]','','g') componente_nucleo_ispettivo_quattro ,  componentenucleoid_quattro,
	dbi_cu_nucleo_audit.nucleo_ispettivo_cinque ,  regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_cinque,'[\r\n\t]','','g') componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sei ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sei,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sei ,  componentenucleoid_sei,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sette ,   regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sette,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
	dbi_cu_nucleo_audit.nucleo_ispettivo_otto ,    regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_otto,'[\r\n\t]','','g')  componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_audit.nucleo_ispettivo_nove ,    regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_nove,'[\r\n\t]','','g')  componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_audit.nucleo_ispettivo_dieci ,   regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_dieci,'[\r\n\t]','','g')  componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,
    dbi_audit.punteggio,dbi_audit_percontodi.id_asl_struttura

	from "Analisi_dev".vw_get_controlli_audit_autorita_competenti_validi dbi_audit
	left join "Analisi_dev".lookup_tipo_controllo  l_tipo_controllo on l_tipo_controllo.code = dbi_audit.id_tecnica_cu 
	left join "Analisi_dev".vw_get_controlli_audit_sorv_percontodi_validi  dbi_audit_percontodi on dbi_audit.id_controllo = dbi_audit_percontodi.id_controllo 

	left join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_audit on dbi_cu_nucleo_audit.id_controllo=dbi_audit.id_controllo

	left join "Analisi_dev".vw_get_controlli_audit_autorita_competenti_oggetto_audit_validi   dbi_audit_ogg_controllo on dbi_audit_ogg_controllo.id_controllo = dbi_audit.id_controllo;
	
	
	END;
	
	return 1;

	


END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_audit_autorita_cu() OWNER TO postgres;

--
-- Name: create_vw_audit_autorita_cu_16_07(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_audit_autorita_cu_16_07() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	

	BEGIN

	BEGIN

		
	DROP MATERIALIZED  VIEW  IF EXISTS "Analisi_dev".vw_audit_autorita_cu CASCADE;


	CREATE MATERIALIZED VIEW  "Analisi_dev".vw_audit_autorita_cu AS 

	select 
	distinct -- ( si mette la distinct perchè la dbi restituisce anche la struttura controllata e questo fa duplicare i dati per il set di dati che invece si vede in DIGEMON
	dbi_audit.id_controllo id_controllo_ufficiale,
	dbi_audit.id_asl,
	dbi_audit.asl,
	l_tipo_controllo.description  as tipo_controllo ,
	dbi_audit.id_tecnica_cu  as code_tipo_controllo ,
	dbi_audit_ogg_controllo.tipo_audit as tipo_ispezione_o_audit,
	date_part('year',dbi_audit.data_inizio_controllo)::int anno_controllo,
	dbi_audit.data_inserimento,
	dbi_audit.data_inizio_controllo,
	dbi_audit.data_chiusura_controllo,
	dbi_audit.congruo_supervisione,
	dbi_audit.supervisionato_in_data,
	dbi_audit.supervisionato_da,
	dbi_audit.supervisione_note,
	dbi_audit_ogg_controllo.oggetto_audit oggetto_del_controllo,
	regexp_replace(dbi_audit.note,'[\r\n\t]','','g') note ,
	dbi_audit_percontodi.codice_interno_univoco_uo ,
	dbi_audit_percontodi.id_unita_operativa id_struttura_uo,
	dbi_audit_percontodi.per_conto_di_completo unita_operativa,
	dbi_audit_percontodi.struttura_complessa area_appartenenza_uo,


	dbi_cu_nucleo_audit.nucleo_ispettivo_uno ,         regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_uno,'[\r\n\t]','','g') componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_audit.nucleo_ispettivo_due ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_due,'[\r\n\t]','','g') componente_nucleo_ispettivo_due ,componentenucleoid_due,
	dbi_cu_nucleo_audit.nucleo_ispettivo_tre ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_tre,'[\r\n\t]','','g') componente_nucleo_ispettivo_tre ,componentenucleoid_tre,
	dbi_cu_nucleo_audit.nucleo_ispettivo_quattro , regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_quattro,'[\r\n\t]','','g') componente_nucleo_ispettivo_quattro ,  componentenucleoid_quattro,
	dbi_cu_nucleo_audit.nucleo_ispettivo_cinque ,  regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_cinque,'[\r\n\t]','','g') componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sei ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sei,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sei ,  componentenucleoid_sei,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sette ,   regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sette,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
	dbi_cu_nucleo_audit.nucleo_ispettivo_otto ,    regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_otto,'[\r\n\t]','','g')  componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_audit.nucleo_ispettivo_nove ,    regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_nove,'[\r\n\t]','','g')  componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_audit.nucleo_ispettivo_dieci ,   regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_dieci,'[\r\n\t]','','g')  componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,
    dbi_audit.punteggio

	from "Analisi_dev".vw_get_controlli_audit_autorita_competenti_validi dbi_audit
	left join "Analisi_dev".lookup_tipo_controllo  l_tipo_controllo on l_tipo_controllo.code = dbi_audit.id_tecnica_cu 
	left join "Analisi_dev".vw_get_controlli_audit_sorv_percontodi_validi  dbi_audit_percontodi on dbi_audit.id_controllo = dbi_audit_percontodi.id_controllo 

	left join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_audit on dbi_cu_nucleo_audit.id_controllo=dbi_audit.id_controllo

	left join "Analisi_dev".vw_get_controlli_audit_autorita_competenti_oggetto_audit_validi   dbi_audit_ogg_controllo on dbi_audit_ogg_controllo.id_controllo = dbi_audit.id_controllo;
	
	
	END;
	
	return 1;

	


END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_audit_autorita_cu_16_07() OWNER TO postgres;

--
-- Name: create_vw_audit_autorita_cu_richiesta_germana_2021(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_audit_autorita_cu_richiesta_germana_2021() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	

	BEGIN

	BEGIN

		
	DROP MATERIALIZED  VIEW  IF EXISTS "Analisi_dev".vw_audit_autorita_cu_richiesta_germana_2021 CASCADE;


	CREATE MATERIALIZED VIEW  "Analisi_dev".vw_audit_autorita_cu_richiesta_germana_2021 AS 

	select 
	distinct -- ( si mette la distinct perchè la dbi restituisce anche la struttura controllata e questo fa duplicare i dati per il set di dati che invece si vede in DIGEMON
	dbi_audit.id_controllo id_controllo_ufficiale,
	dbi_audit.id_asl,
	dbi_audit.asl,
	l_tipo_controllo.description  as tipo_controllo ,
	dbi_audit.id_tecnica_cu  as code_tipo_controllo ,
	dbi_audit_ogg_controllo.tipo_audit as tipo_ispezione_o_audit,
	date_part('year',dbi_audit.data_inizio_controllo)::int anno_controllo,
	dbi_audit.data_inizio_controllo,dbi_audit.data_inserimento,
	dbi_audit.data_chiusura_controllo,
	dbi_audit.congruo_supervisione,
	dbi_audit.supervisionato_in_data,
	dbi_audit.supervisionato_da,
	dbi_audit.supervisione_note,
	dbi_audit_ogg_controllo.oggetto_audit oggetto_del_controllo,
	regexp_replace(dbi_audit.note,'[\r\n\t]','','g') note ,
	dbi_audit_percontodi.codice_interno_univoco_uo ,
	dbi_audit_percontodi.id_unita_operativa id_struttura_uo,
	dbi_audit_percontodi.per_conto_di_completo unita_operativa,
	dbi_audit_percontodi.struttura_complessa area_appartenenza_uo,


	dbi_cu_nucleo_audit.nucleo_ispettivo_uno ,         regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_uno,'[\r\n\t]','','g') componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_audit.nucleo_ispettivo_due ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_due,'[\r\n\t]','','g') componente_nucleo_ispettivo_due ,componentenucleoid_due,
	dbi_cu_nucleo_audit.nucleo_ispettivo_tre ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_tre,'[\r\n\t]','','g') componente_nucleo_ispettivo_tre ,componentenucleoid_tre,
	dbi_cu_nucleo_audit.nucleo_ispettivo_quattro , regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_quattro,'[\r\n\t]','','g') componente_nucleo_ispettivo_quattro ,  componentenucleoid_quattro,
	dbi_cu_nucleo_audit.nucleo_ispettivo_cinque ,  regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_cinque,'[\r\n\t]','','g') componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sei ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sei,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sei ,  componentenucleoid_sei,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sette ,   regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sette,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
	dbi_cu_nucleo_audit.nucleo_ispettivo_otto ,    regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_otto,'[\r\n\t]','','g')  componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_audit.nucleo_ispettivo_nove ,    regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_nove,'[\r\n\t]','','g')  componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_audit.nucleo_ispettivo_dieci ,   regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_dieci,'[\r\n\t]','','g')  componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,
    dbi_audit.punteggio

	from "Analisi_dev".vw_get_controlli_audit_autorita_competenti_validi dbi_audit
	left join "Analisi_dev".lookup_tipo_controllo  l_tipo_controllo on l_tipo_controllo.code = dbi_audit.id_tecnica_cu 
	left join "Analisi_dev".vw_get_controlli_audit_sorv_percontodi_validi  dbi_audit_percontodi on dbi_audit.id_controllo = dbi_audit_percontodi.id_controllo 

	left join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_audit on dbi_cu_nucleo_audit.id_controllo=dbi_audit.id_controllo

	left join "Analisi_dev".vw_get_controlli_audit_autorita_competenti_oggetto_audit_validi   dbi_audit_ogg_controllo on dbi_audit_ogg_controllo.id_controllo = dbi_audit.id_controllo
	
	
	
    where date_part('year',dbi_audit.data_inizio_controllo)='2021';
	
	END;
	
	return 1;

	


END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_audit_autorita_cu_richiesta_germana_2021() OWNER TO postgres;

--
-- Name: create_vw_audit_cu(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_audit_cu() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	

	BEGIN

	BEGIN
	RAISE NOTICE 'create_vw_audit_cu';

		
	DROP MATERIALIZED VIEW  IF EXISTS "Analisi_dev".vw_audit_cu CASCADE;


	CREATE MATERIALIZED VIEW   "Analisi_dev".vw_audit_cu AS 
select 
	dbi_audit.id_controllo ,
	dbi_audit.id_asl,
	dbi_audit.asl,
	dbi_audit.riferimento_id,
	dbi_audit.riferimento_nome_tab,
	dbi_all_linee.norma  ,
	dbi_all_stab.ragione_sociale,
	dbi_all_stab.comune,
	dbi_all_stab.provincia_stab provincia,
	dbi_all_stab.partita_iva,
		dbi_all_linee.num_riconoscimento numero_riconoscimento,
	dbi_all_stab.n_reg numero_registrazione,
		    dbi_all_linee.macroarea,
	    dbi_all_linee.aggregazione,
	dbi_all_linee.attivita linea_attivita_sottoposta_a_controllo,
	dbi_all_linee.n_linea,
	dbi_all_linee.codice_macroarea,
	dbi_all_linee.codice_aggregazione,
	dbi_all_linee.codice_attivita,
	l_tipo_controllo.description  as tipo_controllo ,
	dbi_audit.id_tecnica_cu  as code_tipo_controllo ,
	dbi_audit_ogg_controllo.motivo_audit || ' - ' || dbi_audit_ogg_controllo.tipo_audit as motivo_tipo_audit,
	date_part('year',dbi_audit.data_inizio_controllo)::int anno_controllo,
	dbi_audit.data_inserimento,
	dbi_audit.data_inizio_controllo,
	dbi_audit.data_fine_controllo,
	dbi_audit.data_chiusura_controllo,
	dbi_audit.congruo_supervisione,
	dbi_audit_ogg_controllo.oggetto_bpi as tipo_controllo_bpi,
	dbi_audit_ogg_controllo.oggetto_haccp as tipo_controllo_haccp,
	dbi_audit_percontodi.id_unita_operativa id_struttura_uo,
	--REPLACE( substring(dbi_audit_percontodi.per_conto_di_completo,POSITION('>' in dbi_audit_percontodi.per_conto_di_completo)+1 ,LENGTH(dbi_audit_percontodi.per_conto_di_completo)) , '->','-')	 unita_operativa,
	dbi_audit_percontodi.per_conto_di_completo unita_operativa,
	dbi_audit_percontodi.area_appartenenza_uo area_appartenenza_uo,
	supervisionato_in_data,
	dbi_audit.supervisionato_da,
	dbi_audit.supervisione_note,
	CASE WHEN (dbi_audit.note='' ) THEN null else  	dbi_audit.note END AS note,
	dbi_audit.utente_inserimento,
	dbi_audit_percontodi.codice_interno_univoco_uo ,
	dbi_cu_nucleo_audit.nucleo_ispettivo_uno ,     dbi_cu_nucleo_audit.componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_audit.nucleo_ispettivo_due ,     dbi_cu_nucleo_audit.componente_nucleo_ispettivo_due,componentenucleoid_due,
	dbi_cu_nucleo_audit.nucleo_ispettivo_tre ,     dbi_cu_nucleo_audit.componente_nucleo_ispettivo_tre,componentenucleoid_tre,
	dbi_cu_nucleo_audit.nucleo_ispettivo_quattro , dbi_cu_nucleo_audit.componente_nucleo_ispettivo_quattro,  componentenucleoid_quattro,
	dbi_cu_nucleo_audit.nucleo_ispettivo_cinque ,  dbi_cu_nucleo_audit.componente_nucleo_ispettivo_cinque, componentenucleoid_cinque,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sei ,     dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sei,    componentenucleoid_sei,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sette ,   dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sette,  componentenucleoid_sette,
	dbi_cu_nucleo_audit.nucleo_ispettivo_otto ,    dbi_cu_nucleo_audit.componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_audit.nucleo_ispettivo_nove ,    dbi_cu_nucleo_audit.componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_audit.nucleo_ispettivo_dieci ,   dbi_cu_nucleo_audit.componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,
	dbi_audit.punteggio,dbi_all_linee.codice_norma ,dbi_all_linee.data_inizio_attivita linea_data_inizio_attivita ,dbi_all_linee.tipo_attivita linea_tipo_attivita
	from "Analisi_dev".vw_get_controlli_audit_validi dbi_audit
	join "Analisi_dev".lookup_tipo_controllo  l_tipo_controllo on l_tipo_controllo.code = dbi_audit.id_tecnica_cu 
	join "Analisi_dev".vw_get_controlli_audit_sorv_percontodi_validi  dbi_audit_percontodi on dbi_audit.id_controllo = dbi_audit_percontodi.id_controllo 

	left join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_audit on dbi_cu_nucleo_audit.id_controllo=dbi_audit.id_controllo

	left join(
		 select riferimento_id,riferimento_id_nome_tab,lc.id_linea ,lc.id_controllo ,	la.num_riconoscimento ,	la.norma,
		 		 la.macroarea ,la.aggregazione ,
		la.attivita ,
		la.n_linea,
		la.codice_macroarea,
		la.codice_aggregazione,
		la.codice_attivita,norma_lda.codice_norma ,la.data_inizio_attivita,la.tipo_attivita 
		 from  "Analisi_dev".vw_get_linee_attivita_controllo_validi lc
		 join "Analisi_dev".vw_dbi_get_all_linee_validi la on la.id_linea =lc.id_linea and lc.id_linea is not null
		  join "Analisi_dev".vw_dbi_get_norme_validi norma_lda ON norma_lda.code = la.id_norma
		 ) dbi_all_linee
		 on    dbi_all_linee.riferimento_id = dbi_audit.riferimento_id and dbi_audit.riferimento_nome_tab = dbi_all_linee.riferimento_id_nome_tab and dbi_all_linee.id_controllo=dbi_audit.id_controllo
	
	left join  "Analisi_dev".vw_get_controlli_audit_oggettodelcontrollo_validi dbi_audit_ogg_controllo on dbi_audit_ogg_controllo.id_controllo = dbi_audit.id_controllo

	
	

	 join  "Analisi_dev".vw_dbi_get_all_stabilimenti__validi dbi_all_stab on 
	 dbi_all_stab.riferimento_id=dbi_audit.riferimento_id and dbi_audit.riferimento_nome_tab=dbi_all_stab.riferimento_id_nome_tab 

 	 where dbi_audit.data_inizio_controllo <='2019-12-31' ; 
	END;

	return 1;
	
	

	


END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_audit_cu() OWNER TO postgres;

--
-- Name: create_vw_audit_cu_0411(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_audit_cu_0411() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	

	BEGIN

	BEGIN
	RAISE NOTICE 'create_vw_audit_cu';

		
	DROP MATERIALIZED VIEW  IF EXISTS "Analisi_dev".vw_audit_cu CASCADE;


	CREATE MATERIALIZED VIEW   "Analisi_dev".vw_audit_cu AS 
select 
	dbi_audit.id_controllo ,
	dbi_audit.id_asl,
	dbi_audit.asl,
	dbi_audit.riferimento_id,
	dbi_audit.riferimento_nome_tab,
	dbi_all_linee.norma  ,
	dbi_all_stab.ragione_sociale,
	dbi_all_stab.comune,
	dbi_all_stab.provincia_stab provincia,
	dbi_all_stab.partita_iva,
		dbi_all_linee.num_riconoscimento numero_riconoscimento,
	dbi_all_stab.n_reg numero_registrazione,
		    dbi_all_linee.macroarea,
	    dbi_all_linee.aggregazione,
	dbi_all_linee.attivita linea_attivita_sottoposta_a_controllo,
	dbi_all_linee.n_linea,
	dbi_all_linee.codice_macroarea,
	dbi_all_linee.codice_aggregazione,
	dbi_all_linee.codice_attivita,
	l_tipo_controllo.description  as tipo_controllo ,
	dbi_audit.id_tecnica_cu  as code_tipo_controllo ,
	dbi_audit_ogg_controllo.motivo_audit || ' - ' || dbi_audit_ogg_controllo.tipo_audit as motivo_tipo_audit,
	date_part('year',dbi_audit.data_inizio_controllo)::int anno_controllo,
	dbi_audit.data_inserimento,
	dbi_audit.data_inizio_controllo,
	dbi_audit.data_fine_controllo,
	dbi_audit.data_chiusura_controllo,
	dbi_audit.congruo_supervisione,
	dbi_audit_ogg_controllo.oggetto_bpi as tipo_controllo_bpi,
	dbi_audit_ogg_controllo.oggetto_haccp as tipo_controllo_haccp,
	dbi_audit_percontodi.id_unita_operativa id_struttura_uo,
	--REPLACE( substring(dbi_audit_percontodi.per_conto_di_completo,POSITION('>' in dbi_audit_percontodi.per_conto_di_completo)+1 ,LENGTH(dbi_audit_percontodi.per_conto_di_completo)) , '->','-')	 unita_operativa,
	dbi_audit_percontodi.per_conto_di_completo unita_operativa,
	dbi_audit_percontodi.area_appartenenza_uo area_appartenenza_uo,
	supervisionato_in_data,
	dbi_audit.supervisionato_da,
	dbi_audit.supervisione_note,
	--passaggio CASE WHEN (dbi_audit.note='' ) THEN null else  	dbi_audit.note END AS note,
	CASE WHEN (dbi_audit.note='' ) THEN null else  	regexp_replace(dbi_audit.note,'[\r\n\t]','','g')::TEXT END AS note,
	dbi_audit.utente_inserimento,
	dbi_audit_percontodi.codice_interno_univoco_uo ,
	/*passaggio dbi_cu_nucleo_audit.nucleo_ispettivo_uno ,     dbi_cu_nucleo_audit.componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_audit.nucleo_ispettivo_due ,     dbi_cu_nucleo_audit.componente_nucleo_ispettivo_due,componentenucleoid_due,
	dbi_cu_nucleo_audit.nucleo_ispettivo_tre ,     dbi_cu_nucleo_audit.componente_nucleo_ispettivo_tre,componentenucleoid_tre,
	dbi_cu_nucleo_audit.nucleo_ispettivo_quattro , dbi_cu_nucleo_audit.componente_nucleo_ispettivo_quattro,  componentenucleoid_quattro,
	dbi_cu_nucleo_audit.nucleo_ispettivo_cinque ,  dbi_cu_nucleo_audit.componente_nucleo_ispettivo_cinque, componentenucleoid_cinque,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sei ,     dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sei,    componentenucleoid_sei,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sette ,   dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sette,  componentenucleoid_sette,
	dbi_cu_nucleo_audit.nucleo_ispettivo_otto ,    dbi_cu_nucleo_audit.componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_audit.nucleo_ispettivo_nove ,    dbi_cu_nucleo_audit.componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_audit.nucleo_ispettivo_dieci ,   dbi_cu_nucleo_audit.componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,*/
	
	--dbi_audit_percontodi.codice_interno_univoco_uo ,
	dbi_cu_nucleo_audit.nucleo_ispettivo_uno ,         regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_uno,'[\r\n\t]','','g') componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_audit.nucleo_ispettivo_due ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_due,'[\r\n\t]','','g') componente_nucleo_ispettivo_due ,componentenucleoid_due,
	dbi_cu_nucleo_audit.nucleo_ispettivo_tre ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_tre,'[\r\n\t]','','g') componente_nucleo_ispettivo_tre ,componentenucleoid_tre,
	dbi_cu_nucleo_audit.nucleo_ispettivo_quattro , regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_quattro,'[\r\n\t]','','g') componente_nucleo_ispettivo_quattro ,  componentenucleoid_quattro,
	dbi_cu_nucleo_audit.nucleo_ispettivo_cinque ,  regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_cinque,'[\r\n\t]','','g') componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sei ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sei,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sei ,  componentenucleoid_sei,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sette ,   regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sette,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
	dbi_cu_nucleo_audit.nucleo_ispettivo_otto ,    regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_otto,'[\r\n\t]','','g')  componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_audit.nucleo_ispettivo_nove ,    regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_nove,'[\r\n\t]','','g')  componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_audit.nucleo_ispettivo_dieci ,   regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_dieci,'[\r\n\t]','','g')  componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,
	dbi_audit.punteggio
	from "Analisi_dev".vw_get_controlli_audit_validi dbi_audit
	join "Analisi_dev".lookup_tipo_controllo  l_tipo_controllo on l_tipo_controllo.code = dbi_audit.id_tecnica_cu 
	join "Analisi_dev".vw_get_controlli_audit_sorv_percontodi_validi  dbi_audit_percontodi on dbi_audit.id_controllo = dbi_audit_percontodi.id_controllo 

	left join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_audit on dbi_cu_nucleo_audit.id_controllo=dbi_audit.id_controllo

	left join(
		 select riferimento_id,riferimento_id_nome_tab,lc.id_linea ,lc.id_controllo ,	la.num_riconoscimento ,	la.norma,
		 		 la.macroarea ,la.aggregazione ,
		la.attivita ,
		la.n_linea,
		la.codice_macroarea,
		la.codice_aggregazione,
		la.codice_attivita
		 from  "Analisi_dev".vw_get_linee_attivita_controllo_validi lc
		 join "Analisi_dev".vw_dbi_get_all_linee_validi la on la.id_linea =lc.id_linea and lc.id_linea is not null) dbi_all_linee
		 on    dbi_all_linee.riferimento_id = dbi_audit.riferimento_id and dbi_audit.riferimento_nome_tab = dbi_all_linee.riferimento_id_nome_tab and dbi_all_linee.id_controllo=dbi_audit.id_controllo
	
	left join  "Analisi_dev".vw_get_controlli_audit_oggettodelcontrollo_validi dbi_audit_ogg_controllo on dbi_audit_ogg_controllo.id_controllo = dbi_audit.id_controllo

	
	

	 join  "Analisi_dev".vw_dbi_get_all_stabilimenti__validi dbi_all_stab on 
	 dbi_all_stab.riferimento_id=dbi_audit.riferimento_id and dbi_audit.riferimento_nome_tab=dbi_all_stab.riferimento_id_nome_tab 

 	 where dbi_audit.data_inizio_controllo <='2019-12-31' ; 
	END;

	return 1;
	
	

	


END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_audit_cu_0411() OWNER TO postgres;

--
-- Name: create_vw_audit_cu_16_07(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_audit_cu_16_07() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	

	BEGIN

	BEGIN
	RAISE NOTICE 'create_vw_audit_cu';

		
	DROP MATERIALIZED VIEW  IF EXISTS "Analisi_dev".vw_audit_cu CASCADE;


	CREATE MATERIALIZED VIEW   "Analisi_dev".vw_audit_cu AS 
select 
	dbi_audit.id_controllo ,
	dbi_audit.id_asl,
	dbi_audit.asl,
	dbi_audit.riferimento_id,
	dbi_audit.riferimento_nome_tab,
	dbi_all_linee.norma soggetto ,
	dbi_all_stab.ragione_sociale,
	dbi_all_stab.comune,
	dbi_all_stab.provincia_stab provincia,
	dbi_all_stab.partita_iva,
		dbi_all_linee.num_riconoscimento numero_riconoscimento,
	dbi_all_stab.n_reg numero_registrazione,
	dbi_all_linee.attivita linea_attivita_sottoposta_a_controllo,
	dbi_all_linee.n_linea,
	dbi_all_linee.codice_macroarea,
	dbi_all_linee.codice_aggregazione,
	dbi_all_linee.codice_attivita,
	l_tipo_controllo.description  as tipo_controllo ,
	dbi_audit.id_tecnica_cu  as code_tipo_controllo ,
	dbi_audit_ogg_controllo.motivo_audit || ' - ' || dbi_audit_ogg_controllo.tipo_audit as motivo_tipo_audit,
	date_part('year',dbi_audit.data_inizio_controllo)::int anno_controllo,
	dbi_audit.data_inserimento,
	dbi_audit.data_inizio_controllo,
	dbi_audit.data_fine_controllo,
	dbi_audit.data_chiusura_controllo,
	dbi_audit.congruo_supervisione,
	dbi_audit_ogg_controllo.oggetto_bpi as tipo_controllo_bpi,
	dbi_audit_ogg_controllo.oggetto_haccp as tipo_controllo_haccp,
	dbi_audit_percontodi.id_unita_operativa id_struttura_uo,
	--REPLACE( substring(dbi_audit_percontodi.per_conto_di_completo,POSITION('>' in dbi_audit_percontodi.per_conto_di_completo)+1 ,LENGTH(dbi_audit_percontodi.per_conto_di_completo)) , '->','-')	 unita_operativa,
	dbi_audit_percontodi.per_conto_di_completo unita_operativa,
	dbi_audit_percontodi.area_appartenenza_uo area_appartenenza_uo,
	supervisionato_in_data,
	dbi_audit.supervisionato_da,
dbi_audit.supervisione_note,	
	CASE WHEN (dbi_audit.note='' ) THEN null else  	regexp_replace(dbi_audit.note,'[\r\n\t]','','g')::TEXT END AS note,

	dbi_audit_percontodi.codice_interno_univoco_uo ,
	dbi_cu_nucleo_audit.nucleo_ispettivo_uno ,         regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_uno,'[\r\n\t]','','g') componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_audit.nucleo_ispettivo_due ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_due,'[\r\n\t]','','g') componente_nucleo_ispettivo_due ,componentenucleoid_due,
	dbi_cu_nucleo_audit.nucleo_ispettivo_tre ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_tre,'[\r\n\t]','','g') componente_nucleo_ispettivo_tre ,componentenucleoid_tre,
	dbi_cu_nucleo_audit.nucleo_ispettivo_quattro , regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_quattro,'[\r\n\t]','','g') componente_nucleo_ispettivo_quattro ,  componentenucleoid_quattro,
	dbi_cu_nucleo_audit.nucleo_ispettivo_cinque ,  regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_cinque,'[\r\n\t]','','g') componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sei ,     regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sei,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sei ,  componentenucleoid_sei,
	dbi_cu_nucleo_audit.nucleo_ispettivo_sette ,   regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_sette,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
	dbi_cu_nucleo_audit.nucleo_ispettivo_otto ,    regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_otto,'[\r\n\t]','','g')  componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_audit.nucleo_ispettivo_nove ,    regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_nove,'[\r\n\t]','','g')  componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_audit.nucleo_ispettivo_dieci ,   regexp_replace(dbi_cu_nucleo_audit.componente_nucleo_ispettivo_dieci,'[\r\n\t]','','g')  componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,
	dbi_audit.punteggio
	from "Analisi_dev".vw_get_controlli_audit_validi dbi_audit
	join "Analisi_dev".lookup_tipo_controllo  l_tipo_controllo on l_tipo_controllo.code = dbi_audit.id_tecnica_cu 
	join "Analisi_dev".vw_get_controlli_audit_sorv_percontodi_validi  dbi_audit_percontodi on dbi_audit.id_controllo = dbi_audit_percontodi.id_controllo 

	left join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_audit on dbi_cu_nucleo_audit.id_controllo=dbi_audit.id_controllo

	left join(
		 select riferimento_id,riferimento_id_nome_tab,lc.id_linea ,lc.id_controllo ,	la.num_riconoscimento ,	la.norma,
		la.attivita ,
		la.n_linea,
		la.codice_macroarea,
		la.codice_aggregazione,
		la.codice_attivita
		 from  "Analisi_dev".vw_get_linee_attivita_controllo_validi lc
		 join "Analisi_dev".vw_dbi_get_all_linee_validi la on la.id_linea =lc.id_linea and lc.id_linea is not null) dbi_all_linee
		 on    dbi_all_linee.riferimento_id = dbi_audit.riferimento_id and dbi_audit.riferimento_nome_tab = dbi_all_linee.riferimento_id_nome_tab and dbi_all_linee.id_controllo=dbi_audit.id_controllo
	
	left join  "Analisi_dev".vw_get_controlli_audit_oggettodelcontrollo_validi dbi_audit_ogg_controllo on dbi_audit_ogg_controllo.id_controllo = dbi_audit.id_controllo

	
	

	 join  "Analisi_dev".vw_dbi_get_all_stabilimenti__validi dbi_all_stab on 
	 dbi_all_stab.riferimento_id=dbi_audit.riferimento_id and dbi_audit.riferimento_nome_tab=dbi_all_stab.riferimento_id_nome_tab 

 	 where dbi_audit.data_inizio_controllo <='2019-12-31' ; 
	END;

	return 1;
	
	

	


END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_audit_cu_16_07() OWNER TO postgres;

--
-- Name: create_vw_audit_cuda2020(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_audit_cuda2020() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	
	BEGIN
	RAISE NOTICE 'create_vw_audit_cuda2020';
	
	DROP MATERIALIZED  VIEW  IF EXISTS "Analisi_dev".vw_audit_cuDA2020 CASCADE;

	CREATE MATERIALIZED VIEW  "Analisi_dev".vw_audit_cuDA2020 AS 
	
  select 
    dbi_audit.id_controllo,
	dbi_audit.asl,
	dbi_audit.id_asl,
	dbi_all_linee.norma  ,
	dbi_all_stab.ragione_sociale,
	dbi_all_stab.comune,
	dbi_all_stab.provincia_stab provincia,
	dbi_all_stab.partita_iva,
	dbi_all_linee.num_riconoscimento numero_riconoscimento,
	dbi_all_stab.n_reg numero_registrazione,	
	l_tipo_controllo.description  as  tecnica_del_controllo ,
	dbi_audit.id_tecnica_cu  as code_tipo_controllo ,
	concat_ws(': ',dbi_audit_motivi.descrizione_motivo_padre ,dbi_audit_motivi.descrizione_motivo_figlio )as  Motivo_audit ,
	
	
	dbi_audit_motivi.codice_interno_piano_attivita,
	dbi_audit_percontodi.codice_interno_univoco_uo ,
	dbi_audit_percontodi.per_conto_di_completo,
		    dbi_all_linee.macroarea,
	    dbi_all_linee.aggregazione,
	dbi_all_linee.attivita linea_attivita_sottoposta_a_controllo,
	dbi_all_linee.n_linea,
	dbi_all_linee.codice_macroarea,
	dbi_all_linee.codice_aggregazione,
	dbi_all_linee.codice_attivita,
	dbi_audit.data_inserimento,
	dbi_audit.data_inizio_controllo,
	dbi_audit.data_fine_controllo ,
	dbi_audit.data_chiusura_controllo ,
	dbi_audit_ogg_controllo.oggetto_del_controllo,
	dbi_audit.congruo_supervisione,
	dbi_audit.riferimento_id ,
	dbi_audit.riferimento_nome_tab ,
--	dbi_audit_ogg_controllo.descrizione_macrocategoria,
	dbi_audit.supervisionato_in_data,
	dbi_audit.supervisionato_da,
	dbi_audit.supervisione_note,
	/*--passaggio dbi_cu_nucleo_isp.nucleo_ispettivo_uno ,  dbi_cu_nucleo_isp.componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_isp.nucleo_ispettivo_due ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_due,componentenucleoid_due,
	dbi_cu_nucleo_isp.nucleo_ispettivo_tre ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_tre,componentenucleoid_tre,
	dbi_cu_nucleo_isp.nucleo_ispettivo_quattro , dbi_cu_nucleo_isp.componente_nucleo_ispettivo_quattro,  componentenucleoid_quattro,
	dbi_cu_nucleo_isp.nucleo_ispettivo_cinque ,  dbi_cu_nucleo_isp.componente_nucleo_ispettivo_cinque, componentenucleoid_cinque,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sei ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sei,  componentenucleoid_sei,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sette ,   dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sette,  componentenucleoid_sette,
	dbi_cu_nucleo_isp.nucleo_ispettivo_otto ,    dbi_cu_nucleo_isp.componente_nucleo_ispettivo_otto,componentenucleoid_otto,
	dbi_cu_nucleo_isp.nucleo_ispettivo_nove ,    dbi_cu_nucleo_isp.componente_nucleo_ispettivo_nove, componentenucleoid_nove,
	dbi_cu_nucleo_isp.nucleo_ispettivo_dieci ,   dbi_cu_nucleo_isp.componente_nucleo_ispettivo_dieci, componentenucleoid_dieci */
	dbi_cu_nucleo_isp.nucleo_ispettivo_uno ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_uno,'[\r\n\t]','','g') componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_isp.nucleo_ispettivo_due ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_due,'[\r\n\t]','','g') componente_nucleo_ispettivo_due ,componentenucleoid_due,
	dbi_cu_nucleo_isp.nucleo_ispettivo_tre ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_tre,'[\r\n\t]','','g') componente_nucleo_ispettivo_tre ,componentenucleoid_tre,
	dbi_cu_nucleo_isp.nucleo_ispettivo_quattro , regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_quattro,'[\r\n\t]','','g') componente_nucleo_ispettivo_quattro ,  componentenucleoid_quattro,
	dbi_cu_nucleo_isp.nucleo_ispettivo_cinque ,  regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_cinque,'[\r\n\t]','','g') componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sei ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sei,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sei ,  componentenucleoid_sei,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sette ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sette,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
	dbi_cu_nucleo_isp.nucleo_ispettivo_otto ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_otto,'[\r\n\t]','','g')  componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_isp.nucleo_ispettivo_nove ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_nove,'[\r\n\t]','','g')  componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_isp.nucleo_ispettivo_dieci ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_dieci,'[\r\n\t]','','g')  componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,
dbi_audit_percontodi.id_asl_struttura ,
			dbi_audit_percontodi.id_unita_operativa id_struttura_uo,dbi_audit_percontodi.area_appartenenza_uo 
   from "Analisi_dev".vw_get_controlli_audit_validi dbi_audit
   join "Analisi_dev".lookup_tipo_controllo  l_tipo_controllo on l_tipo_controllo.code = dbi_audit.id_tecnica_cu 
   join  "Analisi_dev".vw_get_controlli_audit_percontodi_2020_validi  dbi_audit_percontodi on dbi_audit.id_controllo = dbi_audit_percontodi.id_controllo 
  left  join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_isp on dbi_cu_nucleo_isp.id_controllo=dbi_audit.id_controllo
	

   	  
   left join(
		 select riferimento_id,riferimento_id_nome_tab,lc.id_linea ,lc.id_controllo ,	la.num_riconoscimento ,	la.norma,
		 		 la.macroarea ,la.aggregazione ,
		la.attivita ,
		la.n_linea,
		la.codice_macroarea,
		la.codice_aggregazione,
		la.codice_attivita
		 from  "Analisi_dev".vw_get_linee_attivita_controllo_validi lc
		 join "Analisi_dev".vw_dbi_get_all_linee_validi la on la.id_linea =lc.id_linea and lc.id_linea is not null)
    dbi_all_linee	 on    dbi_all_linee.riferimento_id = dbi_audit.riferimento_id and dbi_audit.riferimento_nome_tab = dbi_all_linee.riferimento_id_nome_tab and 
    dbi_all_linee.id_controllo=dbi_audit.id_controllo
		
	 
   join "Analisi_dev".vw_get_controlli_audit_motivi_2020_validi  dbi_audit_motivi on dbi_audit_motivi.id_controllo = dbi_audit.id_controllo and 
	dbi_audit_percontodi.id_motivo_audit=dbi_audit_motivi.id_motivo_audit and dbi_audit_percontodi.id_piano_audit=dbi_audit_motivi.id_piano

   left join "Analisi_dev".vw_get_controlli_audit_oggetto_del_controllo_2020_validi dbi_audit_ogg_controllo on dbi_audit_ogg_controllo.id_controllo = dbi_audit.id_controllo

   join  "Analisi_dev".vw_dbi_get_all_stabilimenti__validi dbi_all_stab on 
	 dbi_all_stab.riferimento_id=dbi_audit.riferimento_id and dbi_audit.riferimento_nome_tab=dbi_all_stab.riferimento_id_nome_tab 
	
	
	
   WITH DATA;


  return 1;



END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_audit_cuda2020() OWNER TO postgres;

--
-- Name: create_vw_audit_cuda2020_16_07(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_audit_cuda2020_16_07() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	
	BEGIN
	RAISE NOTICE 'create_vw_audit_cuda2020';
	
	DROP MATERIALIZED  VIEW  IF EXISTS "Analisi_dev".vw_audit_cuDA2020 CASCADE;

	CREATE MATERIALIZED VIEW  "Analisi_dev".vw_audit_cuDA2020 AS 
	
  select 
    dbi_audit.id_controllo,
	dbi_audit.asl,
	dbi_audit.id_asl,
	dbi_all_linee.norma soggetto ,
	dbi_all_stab.ragione_sociale,
	dbi_all_stab.comune,
	dbi_all_stab.provincia_stab provincia,
	dbi_all_stab.partita_iva,
	dbi_all_linee.num_riconoscimento numero_riconoscimento,
	dbi_all_stab.n_reg numero_registrazione,	
	l_tipo_controllo.description  as  tecnica_del_controllo ,
	dbi_audit.id_tecnica_cu  as code_tipo_controllo ,
	concat_ws(': ',dbi_audit_motivi.descrizione_motivo_padre ,dbi_audit_motivi.descrizione_motivo_figlio )as  Motivo_audit ,
	dbi_audit_motivi.codice_interno_piano_attivita,
	dbi_audit_percontodi.codice_interno_univoco_uo ,
	dbi_audit_percontodi.per_conto_di_completo,
	dbi_all_linee.attivita linea_attivita_sottoposta_a_controllo,
	dbi_all_linee.n_linea,
	dbi_all_linee.codice_macroarea,
	dbi_all_linee.codice_aggregazione,
	dbi_all_linee.codice_attivita,
	dbi_audit.data_inserimento,
	dbi_audit.data_inizio_controllo,
	dbi_audit.data_fine_controllo ,
	dbi_audit.data_chiusura_controllo ,
	dbi_audit_ogg_controllo.oggetto_del_controllo,
	dbi_audit.congruo_supervisione,
	dbi_audit.riferimento_id ,
	dbi_audit.riferimento_nome_tab ,
--	dbi_audit_ogg_controllo.descrizione_macrocategoria,
	dbi_audit.supervisionato_in_data,
	dbi_audit.supervisionato_da,
	dbi_audit.supervisione_note,
	dbi_cu_nucleo_isp.nucleo_ispettivo_uno ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_uno,'[\r\n\t]','','g') componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_isp.nucleo_ispettivo_due ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_due,'[\r\n\t]','','g') componente_nucleo_ispettivo_due ,componentenucleoid_due,
	dbi_cu_nucleo_isp.nucleo_ispettivo_tre ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_tre,'[\r\n\t]','','g') componente_nucleo_ispettivo_tre ,componentenucleoid_tre,
	dbi_cu_nucleo_isp.nucleo_ispettivo_quattro , regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_quattro,'[\r\n\t]','','g') componente_nucleo_ispettivo_quattro ,  componentenucleoid_quattro,
	dbi_cu_nucleo_isp.nucleo_ispettivo_cinque ,  regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_cinque,'[\r\n\t]','','g') componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sei ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sei,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sei ,  componentenucleoid_sei,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sette ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sette,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
	dbi_cu_nucleo_isp.nucleo_ispettivo_otto ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_otto,'[\r\n\t]','','g')  componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_isp.nucleo_ispettivo_nove ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_nove,'[\r\n\t]','','g')  componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_isp.nucleo_ispettivo_dieci ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_dieci,'[\r\n\t]','','g')  componente_nucleo_ispettivo_dieci, componentenucleoid_dieci
   from "Analisi_dev".vw_get_controlli_audit_validi dbi_audit
   join "Analisi_dev".lookup_tipo_controllo  l_tipo_controllo on l_tipo_controllo.code = dbi_audit.id_tecnica_cu 
   join  "Analisi_dev".vw_get_controlli_audit_percontodi_2020_validi  dbi_audit_percontodi on dbi_audit.id_controllo = dbi_audit_percontodi.id_controllo 
  left  join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_isp on dbi_cu_nucleo_isp.id_controllo=dbi_audit.id_controllo
	

   	  
   left join(
		 select riferimento_id,riferimento_id_nome_tab,lc.id_linea ,lc.id_controllo ,	la.num_riconoscimento ,	la.norma,
		la.attivita ,
		la.n_linea,
		la.codice_macroarea,
		la.codice_aggregazione,
		la.codice_attivita
		 from  "Analisi_dev".vw_get_linee_attivita_controllo_validi lc
		 join "Analisi_dev".vw_dbi_get_all_linee_validi la on la.id_linea =lc.id_linea and lc.id_linea is not null)
    dbi_all_linee	 on    dbi_all_linee.riferimento_id = dbi_audit.riferimento_id and dbi_audit.riferimento_nome_tab = dbi_all_linee.riferimento_id_nome_tab and 
    dbi_all_linee.id_controllo=dbi_audit.id_controllo
		
	 
   join "Analisi_dev".vw_get_controlli_audit_motivi_2020_validi  dbi_audit_motivi on dbi_audit_motivi.id_controllo = dbi_audit.id_controllo and 
	dbi_audit_percontodi.id_motivo_audit=dbi_audit_motivi.id_motivo_audit and dbi_audit_percontodi.id_piano_audit=dbi_audit_motivi.id_piano

   left join "Analisi_dev".vw_get_controlli_audit_oggetto_del_controllo_2020_validi dbi_audit_ogg_controllo on dbi_audit_ogg_controllo.id_controllo = dbi_audit.id_controllo

   join  "Analisi_dev".vw_dbi_get_all_stabilimenti__validi dbi_all_stab on 
	 dbi_all_stab.riferimento_id=dbi_audit.riferimento_id and dbi_audit.riferimento_nome_tab=dbi_all_stab.riferimento_id_nome_tab 
	
	
	
   WITH DATA;


  return 1;



END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_audit_cuda2020_16_07() OWNER TO postgres;

--
-- Name: create_vw_cu_totali(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_cu_totali() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	

	BEGIN

	BEGIN

		
	DROP  VIEW  IF EXISTS "Analisi_dev".vw_cu_totali CASCADE;



 
	CREATE  VIEW "Analisi_dev".vw_cu_totali AS 



	 SELECT 
	

	* FROM (


	SELECT 
	id_controllo_ufficiale,
	id_asl,
	asl,
	riferimento_id,
	riferimento_nome_tab,
	ragione_sociale,
	comune,
	provincia,
	partita_iva,
	categoria_rischio::text  ,
	prossimo_controllo::text  ,
	aggiornata_cat_controllo::text  ,
	'NON PREVISTO'::text   as numero_riconoscimento,
	numero_registrazione,	
	tipo_controllo,
	code_tipo_controllo ,
	anno_controllo,
	data_inserimento,
	data_inizio_controllo,
	data_chiusura_controllo,
	congruo_supervisione,
	supervisionato_in_data,
	supervisionato_da,
	supervisione_note,
	note,
	utente_inserimento,
	id_struttura_uo,
	unita_operativa,
	area_appartenenza_uo, id_asl_struttura,
	'NON PREVISTO'::text                AS targa_matricola,
	codice_interno_univoco_uo,
	'NON PREVISTO'::text                AS descrizione_macrocategoria,
	'NON PREVISTO'::text                AS oggetto_del_controllo,
	'NON PREVISTO'::text                AS macroarea,
	'NON PREVISTO'::text                AS aggregazione,
	'NON PREVISTO'::text                AS linea_attivita_sottoposta_a_controllo,
	'NON PREVISTO'::text                AS n_linea,
	'NON PREVISTO'::text                AS codice_macroarea,
	'NON PREVISTO'::text                AS codice_aggregazione,
	'NON PREVISTO'::text                AS codice_attivita,
	'NON PREVISTO'::text                AS norma,
	'NON PREVISTO'::text                AS tipo_ispezione_o_audit,
	'NON PREVISTO'::text                AS tipo_piano_monitoraggio,
	'NON PREVISTO'::text                AS codice_interno_piano,
	'NON PREVISTO'::text                AS id_piano,
	'NON PREVISTO'::text                AS id_attivita,
	coalesce(tipo_checklist, 'Non Presente') tipo_checklist,
	'NON PREVISTO'::text                AS tipo_controllo_bpi,
	'NON PREVISTO'::text                AS tipo_controllo_haccp,
	punteggio,
	nucleo_ispettivo_uno,
	componente_nucleo_ispettivo_uno,
	componentenucleoid_uno,
	nucleo_ispettivo_due,
	componente_nucleo_ispettivo_due,
	componentenucleoid_due,
	nucleo_ispettivo_tre,
	componente_nucleo_ispettivo_tre,
	componentenucleoid_tre,
	nucleo_ispettivo_quattro,
	componente_nucleo_ispettivo_quattro,
	componentenucleoid_quattro,
	nucleo_ispettivo_cinque,
	componente_nucleo_ispettivo_cinque,
	componentenucleoid_cinque,
	nucleo_ispettivo_sei,
	componente_nucleo_ispettivo_sei,
	componentenucleoid_sei,
	nucleo_ispettivo_sette,
	componente_nucleo_ispettivo_sette,
	componentenucleoid_sette,
	nucleo_ispettivo_otto,
	componente_nucleo_ispettivo_otto,
	componentenucleoid_otto,
	nucleo_ispettivo_nove,
	componente_nucleo_ispettivo_nove,
	componentenucleoid_nove,
	nucleo_ispettivo_dieci,
	componente_nucleo_ispettivo_dieci,
	componentenucleoid_dieci
	FROM "Analisi_dev".vw_ispezioni_sorveglianza_cu 

	UNION

	SELECT 
	id_controllo_ufficiale,
	id_asl,
	asl,
	riferimento_id,
	riferimento_nome_tab,
	ragione_sociale,
	comune,
	provincia,
	partita_iva,
	'NON PREVISTO'::text                as categoria_rischio,
	'NON PREVISTO'::text                as prossimo_controllo,
	'NON PREVISTO'::text                as aggiornata_cat_controllo,
	numero_riconoscimento,
	numero_registrazione,	
	tipo_controllo,
	code_tipo_controllo ,
	anno_controllo,
	data_inserimento,
	data_inizio_controllo,
	data_chiusura_controllo,
	congruo_supervisione,
	supervisionato_in_data,
	supervisionato_da,
	supervisione_note,
	note,
	utente_inserimento,
	id_struttura_uo,
	unita_operativa,
	area_appartenenza_uo,	id_asl_struttura,
	targa_matricola,
	codice_interno_univoco_uo,
	descrizione_macrocategoria,
	replace (oggetto_del_controllo ,'À','A') oggetto_del_controllo,
	 macroarea,
 	aggregazione,
	linea_attivita_sottoposta_a_controllo,
	n_linea,
	codice_macroarea,
	codice_aggregazione,
	codice_attivita,
	norma,
	tipo_ispezione_o_audit,
	tipo_piano_monitoraggio,
	codice_interno_piano,
	id_piano::text,
	id_attivita::text,
	'NON PREVISTO'::text                as tipo_checklist,
	'NON PREVISTO'::text                AS tipo_controllo_bpi,
	'NON PREVISTO'::text                AS tipo_controllo_haccp,
	punteggio,
	nucleo_ispettivo_uno,
	componente_nucleo_ispettivo_uno,
	componentenucleoid_uno,
	nucleo_ispettivo_due,
	componente_nucleo_ispettivo_due,
	componentenucleoid_due,
	nucleo_ispettivo_tre,
	componente_nucleo_ispettivo_tre,
	componentenucleoid_tre,
	nucleo_ispettivo_quattro,
	componente_nucleo_ispettivo_quattro,
	componentenucleoid_quattro,
	nucleo_ispettivo_cinque,
	componente_nucleo_ispettivo_cinque,
	componentenucleoid_cinque,
	nucleo_ispettivo_sei,
	componente_nucleo_ispettivo_sei,
	componentenucleoid_sei,
	nucleo_ispettivo_sette,
	componente_nucleo_ispettivo_sette,
	componentenucleoid_sette,
	nucleo_ispettivo_otto,
	componente_nucleo_ispettivo_otto,
	componentenucleoid_otto,
	nucleo_ispettivo_nove,
	componente_nucleo_ispettivo_nove,
	componentenucleoid_nove,
	nucleo_ispettivo_dieci,
	componente_nucleo_ispettivo_dieci,
	componentenucleoid_dieci
	from "Analisi_dev".vw_ispezioni_semplici_cu 

	/*UNION

	select
	id_controllo_ufficiale,
	id_asl,
	asl,
	riferimento_id,
	riferimento_nome_tab,
	ragione_sociale,
	comune,
	provincia,
	partita_iva,
	'NON PREVISTO'::text                as categoria_rischio,
	'NON PREVISTO'::text                as prossimo_controllo,
	'NON PREVISTO'::text                as aggiornata_cat_controllo,
	numero_riconoscimento,
	numero_registrazione,	
	tipo_controllo ,
	code_tipo_controllo ,
	anno_controllo,
	data_inizio_controllo,
	data_chiusura_controllo,
	congruo_supervisione,
	supervisionato_in_data,
	supervisionato_da,
	supervisione_note,
	note,
	id_struttura_uo,
	unita_operativa,
	area_appartenenza_uo,
	'NON PREVISTO'::text                AS targa_matricola,
	codice_interno_univoco_uo ,
	'NON PREVISTO'::text                AS descrizione_macrocategoria,
	'NON PREVISTO'::text                AS oggetto_del_controllo,
	linea_attivita_sottoposta_a_controllo,
	n_linea,
	codice_macroarea,
	codice_aggregazione,
	codice_attivita,
	norma  ,
	tipo_ispezione_o_audit,
	'NON PREVISTO'::text                AS tipo_piano_monitoraggio,
	'NON PREVISTO'::text                AS codice_interno_piano,
	'NON PREVISTO'::text                AS id_piano,
	'NON PREVISTO'::text                AS id_attivita,
	'NON PREVISTO'::text                as tipo_checklist,
	tipo_controllo_bpi,
	tipo_controllo_haccp,
	nucleo_ispettivo_uno,
	componente_nucleo_ispettivo_uno,
	componentenucleoid_uno,
	nucleo_ispettivo_due,
	componente_nucleo_ispettivo_due,
	componentenucleoid_due,
	nucleo_ispettivo_tre,
	componente_nucleo_ispettivo_tre,
	componentenucleoid_tre,
	nucleo_ispettivo_quattro,
	componente_nucleo_ispettivo_quattro,
	componentenucleoid_quattro,
	nucleo_ispettivo_cinque,
	componente_nucleo_ispettivo_cinque,
	componentenucleoid_cinque,
	nucleo_ispettivo_sei,
	componente_nucleo_ispettivo_sei,
	componentenucleoid_sei,
	nucleo_ispettivo_sette,
	componente_nucleo_ispettivo_sette,
	componentenucleoid_sette,
	nucleo_ispettivo_otto,
	componente_nucleo_ispettivo_otto,
	componentenucleoid_otto,
	nucleo_ispettivo_nove,
	componente_nucleo_ispettivo_nove,
	componentenucleoid_nove,
	nucleo_ispettivo_dieci,
	componente_nucleo_ispettivo_dieci,
	componentenucleoid_dieci
	FROM
	"Analisi_dev".vw_audit_cu 

*/
	UNION

	SELECT
	id_controllo_ufficiale,
	id_asl,
	asl,
	null             AS riferimento_id,
	'NON PREVISTO'::text                AS riferimento_nome_tab,
	'NON PREVISTO'::text                AS ragione_sociale,
	'NON PREVISTO'::text                AS comune,
	'NON PREVISTO'::text                AS provincia,
	'NON PREVISTO'::text                AS partita_iva,
	'NON PREVISTO'::text                AS categoria_rischio,
	'NON PREVISTO'::text                AS prossimo_controllo,
	'NON PREVISTO'::text                AS aggiornata_cat_controllo,
	'NON PREVISTO'::text                AS numero_riconoscimento,
	'NON PREVISTO'::text                AS numero_registrazione,	
	tipo_controllo ,
	code_tipo_controllo ,
	anno_controllo,
	data_inserimento,
	data_inizio_controllo,
	data_chiusura_controllo,
	congruo_supervisione,
	supervisionato_in_data,
	supervisionato_da,
	supervisione_note,
	note,
	' '::text                AS utente_inserimento,	
	id_struttura_uo,
	unita_operativa,
	area_appartenenza_uo,id_asl_struttura 
		id_asl_struttura,
	'NON PREVISTO'::text                AS targa_matricola,
	codice_interno_univoco_uo ,
	'NON PREVISTO'::text                AS descrizione_macrocategoria,
	replace (oggetto_del_controllo ,'À','A') oggetto_del_controllo,
    'NON PREVISTO'::text                AS macroarea,
	'NON PREVISTO'::text                AS aggregazione,
	'NON PREVISTO'::text                AS linea_attivita_sottoposta_a_controllo,
	'NON PREVISTO'::text                AS n_linea,
	'NON PREVISTO'::text                AS codice_macroarea,
	'NON PREVISTO'::text                AS codice_aggregazione,
	'NON PREVISTO'::text                AS codice_attivita,
	'NON PREVISTO'::text                AS norma,
	tipo_ispezione_o_audit,
	'NON PREVISTO'::text                AS tipo_piano_monitoraggio,
	'NON PREVISTO'::text                AS codice_interno_piano,
	'NON PREVISTO'::text                AS id_piano,
	'NON PREVISTO'::text                AS id_attivita,
	'NON PREVISTO'::text                AS tipo_checklist,
	'NON PREVISTO'::text                AS tipo_controllo_bpi,
	'NON PREVISTO'::text                AS tipo_controllo_haccp,
	punteggio,
	nucleo_ispettivo_uno,
	componente_nucleo_ispettivo_uno,
	componentenucleoid_uno,
	nucleo_ispettivo_due,
	componente_nucleo_ispettivo_due,
	componentenucleoid_due,
	nucleo_ispettivo_tre,
	componente_nucleo_ispettivo_tre,
	componentenucleoid_tre,
	nucleo_ispettivo_quattro,
	componente_nucleo_ispettivo_quattro,
	componentenucleoid_quattro,
	nucleo_ispettivo_cinque,
	componente_nucleo_ispettivo_cinque,
	componentenucleoid_cinque,
	nucleo_ispettivo_sei,
	componente_nucleo_ispettivo_sei,
	componentenucleoid_sei,
	nucleo_ispettivo_sette,
	componente_nucleo_ispettivo_sette,
	componentenucleoid_sette,
	nucleo_ispettivo_otto,
	componente_nucleo_ispettivo_otto,
	componentenucleoid_otto,
	nucleo_ispettivo_nove,
	componente_nucleo_ispettivo_nove,
	componentenucleoid_nove,
	nucleo_ispettivo_dieci,
	componente_nucleo_ispettivo_dieci,
	componentenucleoid_dieci
	FROM "Analisi_dev".vw_audit_autorita_cu 


	UNION

	SELECT 
	id_controllo_ufficiale,
	id_asl,
	asl,
	riferimento_id,
	riferimento_nome_tab,
	ragione_sociale,
	comune,
	provincia,
	partita_iva,
	'NON PREVISTO'::text                AS categoria_rischio,
	'NON PREVISTO'::text                AS prossimo_controllo,
	'NON PREVISTO'::text                AS aggiornata_cat_controllo,
	numero_riconoscimento,
	numero_registrazione,	
	tipo_controllo ,
	code_tipo_controllo ,
	anno_controllo,
	data_inserimento,
	data_inizio_controllo,
	data_chiusura_controllo,
	congruo_supervisione,
	supervisionato_in_data,
	supervisionato_da,
	supervisione_note,
	note,
	' '::text                AS utente_inserimento,	
	id_struttura_uo,
	unita_operativa,
	area_appartenenza_uo,id_asl_struttura,
	'NON PREVISTO'::text                AS targa_matricola,
	codice_interno_univoco_uo ,
	'NON PREVISTO'::text                AS descrizione_macrocategoria,
	'NON PREVISTO'::text                AS oggetto_del_controllo,
     macroarea,
    aggregazione,
	linea_attivita_sottoposta_a_controllo,
	n_linea,
	codice_macroarea,
	codice_aggregazione,
	codice_attivita,
	norma,
	'NON PREVISTO'::text                AS  tipo_ispezione_o_CU_NN_ESEGUITI,
	'NON PREVISTO'::text                AS tipo_piano_monitoraggio,
	'NON PREVISTO'::text                AS codice_interno_piano,
	'NON PREVISTO'::text                AS id_piano,
	'NON PREVISTO'::text                AS id_attivita,
	'NON PREVISTO'::text                AS tipo_checklist,
	'NON PREVISTO'::text                AS tipo_controllo_bpi,
	'NON PREVISTO'::text                AS tipo_controllo_haccp,
	punteggio,
	nucleo_ispettivo_uno,
	componente_nucleo_ispettivo_uno,
	componentenucleoid_uno,
	nucleo_ispettivo_due,
	componente_nucleo_ispettivo_due,
	componentenucleoid_due,
	nucleo_ispettivo_tre,
	componente_nucleo_ispettivo_tre,
	componentenucleoid_tre,
	nucleo_ispettivo_quattro,
	componente_nucleo_ispettivo_quattro,
	componentenucleoid_quattro,
	nucleo_ispettivo_cinque,
	componente_nucleo_ispettivo_cinque,
	componentenucleoid_cinque,
	nucleo_ispettivo_sei,
	componente_nucleo_ispettivo_sei,
	componentenucleoid_sei,
	nucleo_ispettivo_sette,
	componente_nucleo_ispettivo_sette,
	componentenucleoid_sette,
	nucleo_ispettivo_otto,
	componente_nucleo_ispettivo_otto,
	componentenucleoid_otto,
	nucleo_ispettivo_nove,
	componente_nucleo_ispettivo_nove,
	componentenucleoid_nove,
	nucleo_ispettivo_dieci,
	componente_nucleo_ispettivo_dieci,
	componentenucleoid_dieci
	FROM
	"Analisi_dev".vw_non_eseguiti_cu 

	UNION

	select 
	id_controllo_ufficiale,
	id_asl,
	asl,
	riferimento_id,
	riferimento_nome_tab,
	ragione_sociale,
	comune,
	provincia,
	partita_iva,
	'NON PREVISTO'::text                AS categoria_rischio,
	'NON PREVISTO'::text                AS prossimo_controllo,
	'NON PREVISTO'::text                AS aggiornata_cat_controllo,
	numero_riconoscimento,
	numero_registrazione,	
	tipo_controllo ,
	code_tipo_controllo ,
	anno_controllo,
	data_inserimento,
	data_inizio_controllo,
	data_chiusura_controllo,
	congruo_supervisione,
	supervisionato_in_data,
	supervisionato_da,
	supervisione_note,
	note,
    utente_inserimento,	
	id_struttura_uo,
	unita_operativa,
	area_appartenenza_uo,	id_asl_struttura,
	'NON PREVISTO'::text                AS targa_matricola,
	codice_interno_univoco_uo ,
	'NON PREVISTO'::text                AS descrizione_macrocategoria,
	'NON PREVISTO'::text                AS oggetto_del_controllo,
	macroarea,
	aggregazione,
	linea_attivita_sottoposta_a_controllo,
	n_linea,
	codice_macroarea,
	codice_aggregazione,
	codice_attivita,
	norma,
	'NON PREVISTO'::text                AS  tipo_ispezione_o_CU_NN_ESEGUITI,
	'NON PREVISTO'::text                AS tipo_piano_monitoraggio,
	'NON PREVISTO'::text                AS codice_interno_piano,
	'NON PREVISTO'::text                AS id_piano,
	'NON PREVISTO'::text                AS id_attivita,
	'NON PREVISTO'::text                AS tipo_checklist,
	'NON PREVISTO'::text                AS tipo_controllo_bpi,
	'NON PREVISTO'::text                AS tipo_controllo_haccp,
	punteggio,
	nucleo_ispettivo_uno,
	componente_nucleo_ispettivo_uno,
	componentenucleoid_uno,
	nucleo_ispettivo_due,
	componente_nucleo_ispettivo_due,
	componentenucleoid_due,
	nucleo_ispettivo_tre,
	componente_nucleo_ispettivo_tre,
	componentenucleoid_tre,
	nucleo_ispettivo_quattro,
	componente_nucleo_ispettivo_quattro,
	componentenucleoid_quattro,
	nucleo_ispettivo_cinque,
	componente_nucleo_ispettivo_cinque,
	componentenucleoid_cinque,
	nucleo_ispettivo_sei,
	componente_nucleo_ispettivo_sei,
	componentenucleoid_sei,
	nucleo_ispettivo_sette,
	componente_nucleo_ispettivo_sette,
	componentenucleoid_sette,
	nucleo_ispettivo_otto,
	componente_nucleo_ispettivo_otto,
	componentenucleoid_otto,
	nucleo_ispettivo_nove,
	componente_nucleo_ispettivo_nove,
	componentenucleoid_nove,
	nucleo_ispettivo_dieci,
	componente_nucleo_ispettivo_dieci,
	componentenucleoid_dieci
	FROM
	"Analisi_dev".vw_macello_giornaliero_cu 

	)A
	;

	



	

	END;
	return 1;

END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_cu_totali() OWNER TO postgres;

--
-- Name: create_vw_cu_totali_16_07(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_cu_totali_16_07() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	

	BEGIN

	BEGIN

		
	DROP  VIEW  IF EXISTS "Analisi_dev".vw_cu_totali CASCADE;



 
	CREATE  VIEW "Analisi_dev".vw_cu_totali AS 



	 SELECT 
	

	* FROM (


	SELECT 
	id_controllo_ufficiale,
	id_asl,
	asl,
	riferimento_id,
	riferimento_nome_tab,
	ragione_sociale,
	comune,
	provincia,
	partita_iva,
	categoria_rischio::text  ,
	prossimo_controllo::text  ,
	aggiornata_cat_controllo::text  ,
	'NON PREVISTO'::text   as numero_riconoscimento,
	numero_registrazione,	
	tipo_controllo,
	code_tipo_controllo ,
	anno_controllo,
	utente_inserimento,
	data_inserimento,
	data_inizio_controllo,
	data_chiusura_controllo,
	congruo_supervisione,
	supervisionato_in_data,
	supervisionato_da,
	supervisione_note,
	note,
	id_struttura_uo,
	unita_operativa,
	area_appartenenza_uo, 
	'NON PREVISTO'::text                AS targa_matricola,
	codice_interno_univoco_uo,
	'NON PREVISTO'::text                AS descrizione_macrocategoria,
	'NON PREVISTO'::text                AS oggetto_del_controllo,
	'NON PREVISTO'::text                AS linea_attivita_sottoposta_a_controllo,
	'NON PREVISTO'::text                AS n_linea,
	'NON PREVISTO'::text                AS codice_macroarea,
	'NON PREVISTO'::text                AS codice_aggregazione,
	'NON PREVISTO'::text                AS codice_attivita,
	'NON PREVISTO'::text                AS soggetto,
	'NON PREVISTO'::text                AS tipo_ispezione_o_audit,
	'NON PREVISTO'::text                AS tipo_piano_monitoraggio,
	'NON PREVISTO'::text                AS codice_interno_piano,
	'NON PREVISTO'::text                AS id_piano,
	'NON PREVISTO'::text                AS id_attivita,
	coalesce(tipo_checklist, 'Non Presente') tipo_checklist,
	'NON PREVISTO'::text                AS tipo_controllo_bpi,
	'NON PREVISTO'::text                AS tipo_controllo_haccp,
	punteggio,
	nucleo_ispettivo_uno,
	componente_nucleo_ispettivo_uno,
	componentenucleoid_uno,
	nucleo_ispettivo_due,
	componente_nucleo_ispettivo_due,
	componentenucleoid_due,
	nucleo_ispettivo_tre,
	componente_nucleo_ispettivo_tre,
	componentenucleoid_tre,
	nucleo_ispettivo_quattro,
	componente_nucleo_ispettivo_quattro,
	componentenucleoid_quattro,
	nucleo_ispettivo_cinque,
	componente_nucleo_ispettivo_cinque,
	componentenucleoid_cinque,
	nucleo_ispettivo_sei,
	componente_nucleo_ispettivo_sei,
	componentenucleoid_sei,
	nucleo_ispettivo_sette,
	componente_nucleo_ispettivo_sette,
	componentenucleoid_sette,
	nucleo_ispettivo_otto,
	componente_nucleo_ispettivo_otto,
	componentenucleoid_otto,
	nucleo_ispettivo_nove,
	componente_nucleo_ispettivo_nove,
	componentenucleoid_nove,
	nucleo_ispettivo_dieci,
	componente_nucleo_ispettivo_dieci,
	componentenucleoid_dieci
	FROM "Analisi_dev".vw_ispezioni_sorveglianza_cu 

	UNION

	SELECT 
	id_controllo_ufficiale,
	id_asl,
	asl,
	riferimento_id,
	riferimento_nome_tab,
	ragione_sociale,
	comune,
	provincia,
	partita_iva,
	'NON PREVISTO'::text                as categoria_rischio,
	'NON PREVISTO'::text                as prossimo_controllo,
	'NON PREVISTO'::text                as aggiornata_cat_controllo,
	numero_riconoscimento,
	numero_registrazione,	
	tipo_controllo,
	code_tipo_controllo ,
	anno_controllo,
	utente_inserimento,
	data_inserimento,
	data_inizio_controllo,
	data_chiusura_controllo,
	congruo_supervisione,
	supervisionato_in_data,
	supervisionato_da,
	supervisione_note,
	note,
	id_struttura_uo,
	unita_operativa,
	area_appartenenza_uo,
	targa_matricola,
	codice_interno_univoco_uo,
	descrizione_macrocategoria,
	replace (oggetto_del_controllo ,'À','A') oggetto_del_controllo,
	linea_attivita_sottoposta_a_controllo,
	n_linea,
	codice_macroarea,
	codice_aggregazione,
	codice_attivita,
	soggetto,
	tipo_ispezione_o_audit,
	tipo_piano_monitoraggio,
	codice_interno_piano,
	id_piano::text,
	id_attivita::text,
	'NON PREVISTO'::text                as tipo_checklist,
	'NON PREVISTO'::text                AS tipo_controllo_bpi,
	'NON PREVISTO'::text                AS tipo_controllo_haccp,
	punteggio,
	nucleo_ispettivo_uno,
	componente_nucleo_ispettivo_uno,
	componentenucleoid_uno,
	nucleo_ispettivo_due,
	componente_nucleo_ispettivo_due,
	componentenucleoid_due,
	nucleo_ispettivo_tre,
	componente_nucleo_ispettivo_tre,
	componentenucleoid_tre,
	nucleo_ispettivo_quattro,
	componente_nucleo_ispettivo_quattro,
	componentenucleoid_quattro,
	nucleo_ispettivo_cinque,
	componente_nucleo_ispettivo_cinque,
	componentenucleoid_cinque,
	nucleo_ispettivo_sei,
	componente_nucleo_ispettivo_sei,
	componentenucleoid_sei,
	nucleo_ispettivo_sette,
	componente_nucleo_ispettivo_sette,
	componentenucleoid_sette,
	nucleo_ispettivo_otto,
	componente_nucleo_ispettivo_otto,
	componentenucleoid_otto,
	nucleo_ispettivo_nove,
	componente_nucleo_ispettivo_nove,
	componentenucleoid_nove,
	nucleo_ispettivo_dieci,
	componente_nucleo_ispettivo_dieci,
	componentenucleoid_dieci
	from "Analisi_dev".vw_ispezioni_semplici_cu 

	/*UNION

	select
	id_controllo_ufficiale,
	id_asl,
	asl,
	riferimento_id,
	riferimento_nome_tab,
	ragione_sociale,
	comune,
	provincia,
	partita_iva,
	'NON PREVISTO'::text                as categoria_rischio,
	'NON PREVISTO'::text                as prossimo_controllo,
	'NON PREVISTO'::text                as aggiornata_cat_controllo,
	numero_riconoscimento,
	numero_registrazione,	
	tipo_controllo ,
	code_tipo_controllo ,
	anno_controllo,
	data_inizio_controllo,data_inserimento,
	data_chiusura_controllo,
	congruo_supervisione,
	supervisionato_in_data,
	supervisionato_da,
	supervisione_note,
	note,
	id_struttura_uo,
	unita_operativa,
	area_appartenenza_uo,
	'NON PREVISTO'::text                AS targa_matricola,
	codice_interno_univoco_uo ,
	'NON PREVISTO'::text                AS descrizione_macrocategoria,
	'NON PREVISTO'::text                AS oggetto_del_controllo,
	linea_attivita_sottoposta_a_controllo,
	n_linea,
	codice_macroarea,
	codice_aggregazione,
	codice_attivita,
	soggetto  ,
	tipo_ispezione_o_audit,
	'NON PREVISTO'::text                AS tipo_piano_monitoraggio,
	'NON PREVISTO'::text                AS codice_interno_piano,
	'NON PREVISTO'::text                AS id_piano,
	'NON PREVISTO'::text                AS id_attivita,
	'NON PREVISTO'::text                as tipo_checklist,
	tipo_controllo_bpi,
	tipo_controllo_haccp,
	nucleo_ispettivo_uno,
	componente_nucleo_ispettivo_uno,
	componentenucleoid_uno,
	nucleo_ispettivo_due,
	componente_nucleo_ispettivo_due,
	componentenucleoid_due,
	nucleo_ispettivo_tre,
	componente_nucleo_ispettivo_tre,
	componentenucleoid_tre,
	nucleo_ispettivo_quattro,
	componente_nucleo_ispettivo_quattro,
	componentenucleoid_quattro,
	nucleo_ispettivo_cinque,
	componente_nucleo_ispettivo_cinque,
	componentenucleoid_cinque,
	nucleo_ispettivo_sei,
	componente_nucleo_ispettivo_sei,
	componentenucleoid_sei,
	nucleo_ispettivo_sette,
	componente_nucleo_ispettivo_sette,
	componentenucleoid_sette,
	nucleo_ispettivo_otto,
	componente_nucleo_ispettivo_otto,
	componentenucleoid_otto,
	nucleo_ispettivo_nove,
	componente_nucleo_ispettivo_nove,
	componentenucleoid_nove,
	nucleo_ispettivo_dieci,
	componente_nucleo_ispettivo_dieci,
	componentenucleoid_dieci
	FROM
	"Analisi_dev".vw_audit_cu 

*/
	UNION

	SELECT
	id_controllo_ufficiale,
	id_asl,
	asl,
	null             AS riferimento_id,
	'NON PREVISTO'::text                AS riferimento_nome_tab,
	'NON PREVISTO'::text                AS ragione_sociale,
	'NON PREVISTO'::text                AS comune,
	'NON PREVISTO'::text                AS provincia,
	'NON PREVISTO'::text                AS partita_iva,
	'NON PREVISTO'::text                AS categoria_rischio,
	'NON PREVISTO'::text                AS prossimo_controllo,
	'NON PREVISTO'::text                AS aggiornata_cat_controllo,
	'NON PREVISTO'::text                AS numero_riconoscimento,
	'NON PREVISTO'::text                AS numero_registrazione,	
	tipo_controllo ,
	code_tipo_controllo ,
	anno_controllo,
	' '::text                AS utente_inserimento,
	data_inserimento,
	data_inizio_controllo,
	data_chiusura_controllo,
	congruo_supervisione,
	supervisionato_in_data,
	supervisionato_da,
	supervisione_note,
	note,
	id_struttura_uo,
	unita_operativa,
	area_appartenenza_uo,
	'NON PREVISTO'::text                AS targa_matricola,
	codice_interno_univoco_uo ,
	'NON PREVISTO'::text                AS descrizione_macrocategoria,
	replace (oggetto_del_controllo ,'À','A') oggetto_del_controllo,
	'NON PREVISTO'::text                AS linea_attivita_sottoposta_a_controllo,
	'NON PREVISTO'::text                AS n_linea,
	'NON PREVISTO'::text                AS codice_macroarea,
	'NON PREVISTO'::text                AS codice_aggregazione,
	'NON PREVISTO'::text                AS codice_attivita,
	'NON PREVISTO'::text                AS soggetto,
	tipo_ispezione_o_audit,
	'NON PREVISTO'::text                AS tipo_piano_monitoraggio,
	'NON PREVISTO'::text                AS codice_interno_piano,
	'NON PREVISTO'::text                AS id_piano,
	'NON PREVISTO'::text                AS id_attivita,
	'NON PREVISTO'::text                AS tipo_checklist,
	'NON PREVISTO'::text                AS tipo_controllo_bpi,
	'NON PREVISTO'::text                AS tipo_controllo_haccp,
	punteggio,
	nucleo_ispettivo_uno,
	componente_nucleo_ispettivo_uno,
	componentenucleoid_uno,
	nucleo_ispettivo_due,
	componente_nucleo_ispettivo_due,
	componentenucleoid_due,
	nucleo_ispettivo_tre,
	componente_nucleo_ispettivo_tre,
	componentenucleoid_tre,
	nucleo_ispettivo_quattro,
	componente_nucleo_ispettivo_quattro,
	componentenucleoid_quattro,
	nucleo_ispettivo_cinque,
	componente_nucleo_ispettivo_cinque,
	componentenucleoid_cinque,
	nucleo_ispettivo_sei,
	componente_nucleo_ispettivo_sei,
	componentenucleoid_sei,
	nucleo_ispettivo_sette,
	componente_nucleo_ispettivo_sette,
	componentenucleoid_sette,
	nucleo_ispettivo_otto,
	componente_nucleo_ispettivo_otto,
	componentenucleoid_otto,
	nucleo_ispettivo_nove,
	componente_nucleo_ispettivo_nove,
	componentenucleoid_nove,
	nucleo_ispettivo_dieci,
	componente_nucleo_ispettivo_dieci,
	componentenucleoid_dieci
	FROM "Analisi_dev".vw_audit_autorita_cu 


	UNION

	SELECT 
	id_controllo_ufficiale,
	id_asl,
	asl,
	riferimento_id,
	riferimento_nome_tab,
	ragione_sociale,
	comune,
	provincia,
	partita_iva,
	'NON PREVISTO'::text                AS categoria_rischio,
	'NON PREVISTO'::text                AS prossimo_controllo,
	'NON PREVISTO'::text                AS aggiornata_cat_controllo,
	numero_riconoscimento,
	numero_registrazione,	
	tipo_controllo ,
	code_tipo_controllo ,
	anno_controllo,
	' '::text                AS utente_inserimento,
	data_inserimento,
	data_inizio_controllo,
	data_chiusura_controllo,
	congruo_supervisione,
	supervisionato_in_data,
	supervisionato_da,
	supervisione_note,
	note,
	id_struttura_uo,
	unita_operativa,
	area_appartenenza_uo,
	'NON PREVISTO'::text                AS targa_matricola,
	codice_interno_univoco_uo ,
	'NON PREVISTO'::text                AS descrizione_macrocategoria,
	'NON PREVISTO'::text                AS oggetto_del_controllo,
	linea_attivita_sottoposta_a_controllo,
	n_linea,
	codice_macroarea,
	codice_aggregazione,
	codice_attivita,
	soggetto,
	'NON PREVISTO'::text                AS  tipo_ispezione_o_CU_NN_ESEGUITI,
	'NON PREVISTO'::text                AS tipo_piano_monitoraggio,
	'NON PREVISTO'::text                AS codice_interno_piano,
	'NON PREVISTO'::text                AS id_piano,
	'NON PREVISTO'::text                AS id_attivita,
	'NON PREVISTO'::text                AS tipo_checklist,
	'NON PREVISTO'::text                AS tipo_controllo_bpi,
	'NON PREVISTO'::text                AS tipo_controllo_haccp,
	punteggio,
	nucleo_ispettivo_uno,
	componente_nucleo_ispettivo_uno,
	componentenucleoid_uno,
	nucleo_ispettivo_due,
	componente_nucleo_ispettivo_due,
	componentenucleoid_due,
	nucleo_ispettivo_tre,
	componente_nucleo_ispettivo_tre,
	componentenucleoid_tre,
	nucleo_ispettivo_quattro,
	componente_nucleo_ispettivo_quattro,
	componentenucleoid_quattro,
	nucleo_ispettivo_cinque,
	componente_nucleo_ispettivo_cinque,
	componentenucleoid_cinque,
	nucleo_ispettivo_sei,
	componente_nucleo_ispettivo_sei,
	componentenucleoid_sei,
	nucleo_ispettivo_sette,
	componente_nucleo_ispettivo_sette,
	componentenucleoid_sette,
	nucleo_ispettivo_otto,
	componente_nucleo_ispettivo_otto,
	componentenucleoid_otto,
	nucleo_ispettivo_nove,
	componente_nucleo_ispettivo_nove,
	componentenucleoid_nove,
	nucleo_ispettivo_dieci,
	componente_nucleo_ispettivo_dieci,
	componentenucleoid_dieci
	FROM
	"Analisi_dev".vw_non_eseguiti_cu 

	UNION

	select 
	id_controllo_ufficiale,
	id_asl,
	asl,
	riferimento_id,
	riferimento_nome_tab,
	ragione_sociale,
	comune,
	provincia,
	partita_iva,
	'NON PREVISTO'::text                AS categoria_rischio,
	'NON PREVISTO'::text                AS prossimo_controllo,
	'NON PREVISTO'::text                AS aggiornata_cat_controllo,
	numero_riconoscimento,
	numero_registrazione,	
	tipo_controllo ,
	code_tipo_controllo ,
	anno_controllo,
	utente_inserimento,
	data_inserimento,
	data_inizio_controllo,
	data_chiusura_controllo,
	congruo_supervisione,
	supervisionato_in_data,
	supervisionato_da,
	supervisione_note,
	note,
	id_struttura_uo,
	unita_operativa,
	area_appartenenza_uo,
	'NON PREVISTO'::text                AS targa_matricola,
	codice_interno_univoco_uo ,
	'NON PREVISTO'::text                AS descrizione_macrocategoria,
	'NON PREVISTO'::text                AS oggetto_del_controllo,
	linea_attivita_sottoposta_a_controllo,
	n_linea,
	codice_macroarea,
	codice_aggregazione,
	codice_attivita,
	soggetto,
	'NON PREVISTO'::text                AS  tipo_ispezione_o_CU_NN_ESEGUITI,
	'NON PREVISTO'::text                AS tipo_piano_monitoraggio,
	'NON PREVISTO'::text                AS codice_interno_piano,
	'NON PREVISTO'::text                AS id_piano,
	'NON PREVISTO'::text                AS id_attivita,
	'NON PREVISTO'::text                AS tipo_checklist,
	'NON PREVISTO'::text                AS tipo_controllo_bpi,
	'NON PREVISTO'::text                AS tipo_controllo_haccp,
	punteggio,
	nucleo_ispettivo_uno,
	componente_nucleo_ispettivo_uno,
	componentenucleoid_uno,
	nucleo_ispettivo_due,
	componente_nucleo_ispettivo_due,
	componentenucleoid_due,
	nucleo_ispettivo_tre,
	componente_nucleo_ispettivo_tre,
	componentenucleoid_tre,
	nucleo_ispettivo_quattro,
	componente_nucleo_ispettivo_quattro,
	componentenucleoid_quattro,
	nucleo_ispettivo_cinque,
	componente_nucleo_ispettivo_cinque,
	componentenucleoid_cinque,
	nucleo_ispettivo_sei,
	componente_nucleo_ispettivo_sei,
	componentenucleoid_sei,
	nucleo_ispettivo_sette,
	componente_nucleo_ispettivo_sette,
	componentenucleoid_sette,
	nucleo_ispettivo_otto,
	componente_nucleo_ispettivo_otto,
	componentenucleoid_otto,
	nucleo_ispettivo_nove,
	componente_nucleo_ispettivo_nove,
	componentenucleoid_nove,
	nucleo_ispettivo_dieci,
	componente_nucleo_ispettivo_dieci,
	componentenucleoid_dieci
	FROM
	"Analisi_dev".vw_macello_giornaliero_cu 

	)A
	;

	



	

	END;
	return 1;

END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_cu_totali_16_07() OWNER TO postgres;

--
-- Name: create_vw_ispezioni_semplici_cu(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_ispezioni_semplici_cu() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	
	BEGIN

		
	DROP MATERIALIZED  VIEW  IF EXISTS "Analisi_dev".vw_ispezioni_semplici_cu CASCADE;

	CREATE MATERIALIZED VIEW  "Analisi_dev".vw_ispezioni_semplici_cu AS 



   select
		dbi_isp_sempl.id_controllo id_controllo_ufficiale,
		dbi_isp_sempl.id_asl,
		dbi_isp_sempl.asl,
		dbi_isp_sempl.riferimento_id,
		dbi_isp_sempl.riferimento_nome_tab,
		dbi_all_linee.norma  ,
		dbi_all_stab.ragione_sociale,
		dbi_all_stab.comune,
		dbi_all_stab.provincia_stab provincia,
		dbi_all_stab.partita_iva,
		dbi_all_linee.num_riconoscimento numero_riconoscimento,
		dbi_all_stab.n_reg numero_registrazione,	
		dbi_all_linee.macroarea,
	    dbi_all_linee.aggregazione,	
		dbi_all_linee.attivita linea_attivita_sottoposta_a_controllo,
		dbi_all_linee.n_linea,
		dbi_all_linee.codice_macroarea,
		dbi_all_linee.codice_aggregazione,
		dbi_all_linee.codice_attivita,
		l_tipo_controllo.description  as tipo_controllo ,
		dbi_isp_sempl.id_tecnica_cu  as code_tipo_controllo ,
	
	/*	case when dbi_isp_sempl_percontodi.id_piano_ispezione =-1
			  THEN  concat_ws(' ', REPLACE(dbi_isp_sempl_motivi.alias_padre, '-ISPEZIONE', '' ),dbi_isp_sempl_motivi.descrizione_motivo_padre )
			 ELSE  concat_ws(' ', dbi_isp_sempl_motivi.alias_padre, dbi_isp_sempl_motivi.descrizione_motivo_padre )
		END as tipo_ispezione_o_audit,
	  
		concat_ws(': ',dbi_isp_sempl_motivi.alias_indicatore  ,dbi_isp_sempl_motivi.descrizione_motivo_figlio )as tipo_piano_monitoraggio,
		 dbi_isp_sempl_motivi.codice_interno_piano_attivita  as codice_interno_piano ,*/
		 
		 case when dbi_isp_sempl_percontodi.id_piano_ispezione =-1
			  THEN  concat_ws(' ', REPLACE(dbi_isp_sempl_motivi.alias_padre, '-ISPEZIONE', '' ),public.unaccent(dbi_isp_sempl_motivi.descrizione_motivo_padre) )
			 ELSE  concat_ws(' ', dbi_isp_sempl_motivi.alias_padre, public.unaccent(dbi_isp_sempl_motivi.descrizione_motivo_padre) )
		END as tipo_ispezione_o_audit,
	  
		--concat_ws(': ',dbi_isp_sempl_motivi.alias_indicatore  ,public.unaccent(dbi_isp_sempl_motivi.descrizione_motivo_figlio ))as tipo_piano_monitoraggio,
		
		 concat_ws(': ',dbi_isp_sempl_motivi.alias_indicatore  ,public.unaccent(dbi_isp_sempl_motivi.descrizione_motivo_figlio )) as tipo_piano_monitoraggio,
		dbi_isp_sempl_motivi.codice_interno_piano_attivita  as codice_interno_piano ,
	
		date_part('year',dbi_isp_sempl.data_inizio_controllo)::int anno_controllo,
		dbi_isp_sempl.data_inserimento,
		dbi_isp_sempl.data_inizio_controllo,
		dbi_isp_sempl.data_chiusura_controllo,
		dbi_isp_sempl.congruo_supervisione,
		dbi_isp_semp_ogg_controllo.descrizione_macrocategoria,
		dbi_isp_semp_ogg_controllo.oggetto_del_controllo,
		dbi_isp_sempl.supervisionato_in_data,
		dbi_isp_sempl.supervisionato_da,
		dbi_isp_sempl.supervisione_note,
		dbi_isp_sempl.note,
		dbi_isp_sempl.utente_inserimento,
		dbi_isp_sempl_percontodi.codice_interno_univoco_uo ,
		case when dbi_isp_sempl_percontodi.id_piano_ispezione =-1 THEN NULL ELSE dbi_isp_sempl_percontodi.id_piano_ispezione END as id_piano,
		case when dbi_isp_sempl_percontodi.id_motivo_ispezione =89 THEN NULL ELSE dbi_isp_sempl_percontodi.id_motivo_ispezione  END as id_attivita,
		dbi_isp_sempl_percontodi.id_unita_operativa id_struttura_uo,
		dbi_isp_sempl_percontodi.per_conto_di_completo unita_operativa,
		dbi_isp_sempl_percontodi.struttura_complessa area_appartenenza_uo,
		dbi_isp_sempl.targa_matricola ,
		
		dbi_cu_nucleo_isp.nucleo_ispettivo_uno ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_uno,componentenucleoid_uno,
		dbi_cu_nucleo_isp.nucleo_ispettivo_due ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_due,componentenucleoid_due,
		dbi_cu_nucleo_isp.nucleo_ispettivo_tre ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_tre,componentenucleoid_tre,
		dbi_cu_nucleo_isp.nucleo_ispettivo_quattro , dbi_cu_nucleo_isp.componente_nucleo_ispettivo_quattro, componentenucleoid_quattro,
		dbi_cu_nucleo_isp.nucleo_ispettivo_cinque ,  dbi_cu_nucleo_isp.componente_nucleo_ispettivo_cinque, componentenucleoid_cinque,
		dbi_cu_nucleo_isp.nucleo_ispettivo_sei ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sei, componentenucleoid_sei,
		dbi_cu_nucleo_isp.nucleo_ispettivo_sette ,   dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sette,  componentenucleoid_sette,
		dbi_cu_nucleo_isp.nucleo_ispettivo_otto ,    dbi_cu_nucleo_isp.componente_nucleo_ispettivo_otto,componentenucleoid_otto,
		dbi_cu_nucleo_isp.nucleo_ispettivo_nove ,    dbi_cu_nucleo_isp.componente_nucleo_ispettivo_nove,componentenucleoid_nove,
		dbi_cu_nucleo_isp.nucleo_ispettivo_dieci ,   dbi_cu_nucleo_isp.componente_nucleo_ispettivo_dieci,componentenucleoid_dieci,
		dbi_isp_sempl.punteggio,dbi_isp_sempl_percontodi.id_asl_struttura ,
		dbi_all_linee.data_inizio_attivita linea_data_inizio_attivita ,dbi_all_linee.tipo_attivita linea_tipo_attivita,
		dbi_all_linee.codice_linea ,dbi_all_linee.id_norma,dbi_all_linee.codice_norma
		from "Analisi_dev".vw_get_controlli_ispezioni_semplici_validi dbi_isp_sempl
		join "Analisi_dev".lookup_tipo_controllo  l_tipo_controllo on l_tipo_controllo.code = dbi_isp_sempl.id_tecnica_cu
		left join "Analisi_dev".vw_get_controlli_ispezioni_semplici_percontodi_validi  dbi_isp_sempl_percontodi on dbi_isp_sempl.id_controllo = dbi_isp_sempl_percontodi.id_controllo
	
		left join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_isp on dbi_cu_nucleo_isp.id_controllo=dbi_isp_sempl.id_controllo
		 
		 
		 left join(
		 select riferimento_id,riferimento_id_nome_tab,lc.id_linea ,lc.id_controllo ,	la.num_riconoscimento ,	la.norma,
		 la.macroarea ,la.aggregazione ,
		la.attivita ,
		la.n_linea,
		la.codice_macroarea,
		la.codice_aggregazione,
		la.codice_attivita, la.data_inizio_attivita ,la.tipo_attivita,lc.codice_linea,la.id_norma,norma_lda.codice_norma 
		 from  "Analisi_dev".vw_get_linee_attivita_controllo_validi lc
		 join "Analisi_dev".vw_dbi_get_all_linee_validi la on la.id_linea =lc.id_linea and lc.id_linea is not null
		 join "Analisi_dev".vw_dbi_get_norme_validi norma_lda ON norma_lda.code = la.id_norma
		 ) dbi_all_linee
		 on    dbi_all_linee.riferimento_id = dbi_isp_sempl.riferimento_id
		 and dbi_isp_sempl.riferimento_nome_tab = dbi_all_linee.riferimento_id_nome_tab and dbi_all_linee.id_controllo=dbi_isp_sempl.id_controllo
		
		
	
		
		LEFT join "Analisi_dev".vw_get_controlli_ispezioni_semplici_motivi_validi  dbi_isp_sempl_motivi on dbi_isp_sempl_motivi.id_controllo = dbi_isp_sempl.id_controllo and
		dbi_isp_sempl_percontodi.id_motivo_ispezione=dbi_isp_sempl_motivi.id_motivo_ispezione and dbi_isp_sempl_percontodi.id_piano_ispezione=dbi_isp_sempl_motivi.id_piano
	
		left join "Analisi_dev".vw_get_controlli_ispezioni_semplici_oggetto_del_controllo_validi dbi_isp_semp_ogg_controllo on dbi_isp_semp_ogg_controllo.id_controllo = dbi_isp_sempl.id_controllo
	
		join  "Analisi_dev".vw_dbi_get_all_stabilimenti__validi dbi_all_stab on
   	   dbi_all_stab.riferimento_id=dbi_isp_sempl.riferimento_id and dbi_isp_sempl.riferimento_nome_tab=dbi_all_stab.riferimento_id_nome_tab
	
		 
	WITH DATA;



	return 1;





END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_ispezioni_semplici_cu() OWNER TO postgres;

--
-- Name: create_vw_ispezioni_semplici_cu_04_11(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_ispezioni_semplici_cu_04_11() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	
	BEGIN

		
	DROP MATERIALIZED  VIEW  IF EXISTS "Analisi_dev".vw_ispezioni_semplici_cu CASCADE;

	CREATE MATERIALIZED VIEW  "Analisi_dev".vw_ispezioni_semplici_cu AS 



   select
		dbi_isp_sempl.id_controllo id_controllo_ufficiale,
		dbi_isp_sempl.id_asl,
		dbi_isp_sempl.asl,
		dbi_isp_sempl.riferimento_id,
		dbi_isp_sempl.riferimento_nome_tab,
		dbi_all_linee.norma  ,
		dbi_all_stab.ragione_sociale,
		dbi_all_stab.comune,
		dbi_all_stab.provincia_stab provincia,
		dbi_all_stab.partita_iva,
		dbi_all_linee.num_riconoscimento numero_riconoscimento,
		dbi_all_stab.n_reg numero_registrazione,	
		dbi_all_linee.macroarea,
	    dbi_all_linee.aggregazione,	
		dbi_all_linee.attivita linea_attivita_sottoposta_a_controllo,
		dbi_all_linee.n_linea,
		dbi_all_linee.codice_macroarea,
		dbi_all_linee.codice_aggregazione,
		dbi_all_linee.codice_attivita,
		l_tipo_controllo.description  as tipo_controllo ,
		dbi_isp_sempl.id_tecnica_cu  as code_tipo_controllo ,
	
	/*	case when dbi_isp_sempl_percontodi.id_piano_ispezione =-1
			  THEN  concat_ws(' ', REPLACE(dbi_isp_sempl_motivi.alias_padre, '-ISPEZIONE', '' ),dbi_isp_sempl_motivi.descrizione_motivo_padre )
			 ELSE  concat_ws(' ', dbi_isp_sempl_motivi.alias_padre, dbi_isp_sempl_motivi.descrizione_motivo_padre )
		END as tipo_ispezione_o_audit,
	  
		concat_ws(': ',dbi_isp_sempl_motivi.alias_indicatore  ,dbi_isp_sempl_motivi.descrizione_motivo_figlio )as tipo_piano_monitoraggio,
		 dbi_isp_sempl_motivi.codice_interno_piano_attivita  as codice_interno_piano ,*/
		 
		 case when dbi_isp_sempl_percontodi.id_piano_ispezione =-1
			  THEN  concat_ws(' ', REPLACE(dbi_isp_sempl_motivi.alias_padre, '-ISPEZIONE', '' ),public.unaccent(dbi_isp_sempl_motivi.descrizione_motivo_padre) )
			 ELSE  concat_ws(' ', dbi_isp_sempl_motivi.alias_padre, public.unaccent(dbi_isp_sempl_motivi.descrizione_motivo_padre) )
		END as tipo_ispezione_o_audit,
	  
		--concat_ws(': ',dbi_isp_sempl_motivi.alias_indicatore  ,public.unaccent(dbi_isp_sempl_motivi.descrizione_motivo_figlio ))as tipo_piano_monitoraggio,
		
		--passaggio concat_ws(': ',dbi_isp_sempl_motivi.alias_indicatore  ,public.unaccent(dbi_isp_sempl_motivi.descrizione_motivo_figlio )) as tipo_piano_monitoraggio,
		regexp_replace(concat_ws(': ',dbi_isp_sempl_motivi.alias_indicatore  ,public.unaccent(dbi_isp_sempl_motivi.descrizione_motivo_figlio )),'[\r\n\t]','','g') as tipo_piano_monitoraggio,

		dbi_isp_sempl_motivi.codice_interno_piano_attivita  as codice_interno_piano ,
	
		date_part('year',dbi_isp_sempl.data_inizio_controllo)::int anno_controllo,
		dbi_isp_sempl.data_inserimento,
		dbi_isp_sempl.data_inizio_controllo,
		dbi_isp_sempl.data_chiusura_controllo,
		dbi_isp_sempl.congruo_supervisione,
		dbi_isp_semp_ogg_controllo.descrizione_macrocategoria,
		dbi_isp_semp_ogg_controllo.oggetto_del_controllo,
		dbi_isp_sempl.supervisionato_in_data,
		dbi_isp_sempl.supervisionato_da,
		--passaggio dbi_isp_sempl.supervisione_note,
		--passaggio dbi_isp_sempl.note,
		regexp_replace(dbi_isp_sempl.supervisione_note,'[\r\n\t\;]','','g') as supervisione_note,
		regexp_replace(dbi_isp_sempl.note,'[\r\n\t\;]','','g') note,
		dbi_isp_sempl.utente_inserimento,
		dbi_isp_sempl_percontodi.codice_interno_univoco_uo ,
		case when dbi_isp_sempl_percontodi.id_piano_ispezione =-1 THEN NULL ELSE dbi_isp_sempl_percontodi.id_piano_ispezione END as id_piano,
		case when dbi_isp_sempl_percontodi.id_motivo_ispezione =89 THEN NULL ELSE dbi_isp_sempl_percontodi.id_motivo_ispezione  END as id_attivita,
		dbi_isp_sempl_percontodi.id_unita_operativa id_struttura_uo,
		dbi_isp_sempl_percontodi.per_conto_di_completo unita_operativa,
		dbi_isp_sempl_percontodi.struttura_complessa area_appartenenza_uo,
		dbi_isp_sempl.targa_matricola ,
		/* passsaggio
		dbi_cu_nucleo_isp.nucleo_ispettivo_uno ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_uno,componentenucleoid_uno,
		dbi_cu_nucleo_isp.nucleo_ispettivo_due ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_due,componentenucleoid_due,
		dbi_cu_nucleo_isp.nucleo_ispettivo_tre ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_tre,componentenucleoid_tre,
		dbi_cu_nucleo_isp.nucleo_ispettivo_quattro , dbi_cu_nucleo_isp.componente_nucleo_ispettivo_quattro, componentenucleoid_quattro,
		dbi_cu_nucleo_isp.nucleo_ispettivo_cinque ,  dbi_cu_nucleo_isp.componente_nucleo_ispettivo_cinque, componentenucleoid_cinque,
		dbi_cu_nucleo_isp.nucleo_ispettivo_sei ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sei, componentenucleoid_sei,
		dbi_cu_nucleo_isp.nucleo_ispettivo_sette ,   dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sette,  componentenucleoid_sette,
		dbi_cu_nucleo_isp.nucleo_ispettivo_otto ,    dbi_cu_nucleo_isp.componente_nucleo_ispettivo_otto,componentenucleoid_otto,
		dbi_cu_nucleo_isp.nucleo_ispettivo_nove ,    dbi_cu_nucleo_isp.componente_nucleo_ispettivo_nove,componentenucleoid_nove,
		dbi_cu_nucleo_isp.nucleo_ispettivo_dieci ,   dbi_cu_nucleo_isp.componente_nucleo_ispettivo_dieci,componentenucleoid_dieci,*/
			
		dbi_cu_nucleo_isp.nucleo_ispettivo_uno ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_uno,'[\r\n\t]','','g') componente_nucleo_ispettivo_uno,componentenucleoid_uno,
		dbi_cu_nucleo_isp.nucleo_ispettivo_due ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_due,'[\r\n\t]','','g') componente_nucleo_ispettivo_due ,componentenucleoid_due,
		dbi_cu_nucleo_isp.nucleo_ispettivo_tre ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_tre,'[\r\n\t]','','g') componente_nucleo_ispettivo_tre ,componentenucleoid_tre,
		dbi_cu_nucleo_isp.nucleo_ispettivo_quattro , regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_quattro,'[\r\n\t]','','g') componente_nucleo_ispettivo_quattro ,  componentenucleoid_quattro,
		dbi_cu_nucleo_isp.nucleo_ispettivo_cinque ,  regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_cinque,'[\r\n\t]','','g') componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
		dbi_cu_nucleo_isp.nucleo_ispettivo_sei ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sei,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sei ,  componentenucleoid_sei,
		dbi_cu_nucleo_isp.nucleo_ispettivo_sette ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sette,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
		dbi_cu_nucleo_isp.nucleo_ispettivo_otto ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_otto,'[\r\n\t]','','g')  componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
		dbi_cu_nucleo_isp.nucleo_ispettivo_nove ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_nove,'[\r\n\t]','','g')  componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
		dbi_cu_nucleo_isp.nucleo_ispettivo_dieci ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_dieci,'[\r\n\t]','','g')  componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,

		dbi_isp_sempl.punteggio,dbi_isp_sempl_percontodi.id_asl_struttura 
		from "Analisi_dev".vw_get_controlli_ispezioni_semplici_validi dbi_isp_sempl
		join "Analisi_dev".lookup_tipo_controllo  l_tipo_controllo on l_tipo_controllo.code = dbi_isp_sempl.id_tecnica_cu
		left join "Analisi_dev".vw_get_controlli_ispezioni_semplici_percontodi_validi  dbi_isp_sempl_percontodi on dbi_isp_sempl.id_controllo = dbi_isp_sempl_percontodi.id_controllo
	
		left join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_isp on dbi_cu_nucleo_isp.id_controllo=dbi_isp_sempl.id_controllo
		 
		 
		 left join(
		 select riferimento_id,riferimento_id_nome_tab,lc.id_linea ,lc.id_controllo ,	la.num_riconoscimento ,	la.norma,
		 la.macroarea ,la.aggregazione ,
		la.attivita ,
		la.n_linea,
		la.codice_macroarea,
		la.codice_aggregazione,
		la.codice_attivita
		 from  "Analisi_dev".vw_get_linee_attivita_controllo_validi lc
		 join "Analisi_dev".vw_dbi_get_all_linee_validi la on la.id_linea =lc.id_linea and lc.id_linea is not null) dbi_all_linee
		 on    dbi_all_linee.riferimento_id = dbi_isp_sempl.riferimento_id
		 and dbi_isp_sempl.riferimento_nome_tab = dbi_all_linee.riferimento_id_nome_tab and dbi_all_linee.id_controllo=dbi_isp_sempl.id_controllo
		
		
	
		
		LEFT join "Analisi_dev".vw_get_controlli_ispezioni_semplici_motivi_validi  dbi_isp_sempl_motivi on dbi_isp_sempl_motivi.id_controllo = dbi_isp_sempl.id_controllo and
		dbi_isp_sempl_percontodi.id_motivo_ispezione=dbi_isp_sempl_motivi.id_motivo_ispezione and dbi_isp_sempl_percontodi.id_piano_ispezione=dbi_isp_sempl_motivi.id_piano
	
		left join "Analisi_dev".vw_get_controlli_ispezioni_semplici_oggetto_del_controllo_validi dbi_isp_semp_ogg_controllo on dbi_isp_semp_ogg_controllo.id_controllo = dbi_isp_sempl.id_controllo
	
		join  "Analisi_dev".vw_dbi_get_all_stabilimenti__validi dbi_all_stab on
   	   dbi_all_stab.riferimento_id=dbi_isp_sempl.riferimento_id and dbi_isp_sempl.riferimento_nome_tab=dbi_all_stab.riferimento_id_nome_tab
	
		 
	WITH DATA;



	return 1;





END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_ispezioni_semplici_cu_04_11() OWNER TO postgres;

--
-- Name: create_vw_ispezioni_sorveglianza_cu(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_ispezioni_sorveglianza_cu() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	

	BEGIN

	DROP MATERIALIZED VIEW IF EXISTS  "Analisi_dev".vw_ispezioni_sorveglianza_cu CASCADE;

	CREATE MATERIALIZED VIEW  "Analisi_dev".vw_ispezioni_sorveglianza_cu AS 

	select 
	coalesce(tipo_checklist, 'Non Presente') tipo_checklist,
	dbi_isp_sorvl.id_controllo id_controllo_ufficiale,
	dbi_isp_sorvl.id_asl,
	dbi_isp_sorvl.asl,
	dbi_isp_sorvl.riferimento_id,
	dbi_isp_sorvl.riferimento_nome_tab,
	dbi_all_stab.ragione_sociale,
	dbi_all_stab.comune,
	dbi_all_stab.provincia_stab provincia,
	dbi_all_stab.partita_iva,
	dbi_isp_sorvl.categoria_rischio,
	dbi_isp_sorvl.data_prossimo_controllo prossimo_controllo,
	case    when dbi_isp_sorvl.data_chiusura_controllo is not null then 'CONTROLLO CATEGORIZZATO'     else 'CONTROLLO NON CATEGORIZZATO'    end as aggiornata_cat_controllo,
	dbi_all_stab.n_reg numero_registrazione,
	l_tipo_controllo.description  as tipo_controllo ,
	dbi_isp_sorvl.id_tecnica_cu  as code_tipo_controllo ,
	date_part('year',dbi_isp_sorvl.data_inizio_controllo)::int anno_controllo,
	dbi_isp_sorvl.data_inserimento,
	dbi_isp_sorvl.data_inizio_controllo,
	dbi_isp_sorvl.data_chiusura_controllo,
	dbi_isp_sorvl.congruo_supervisione,
	dbi_isp_sorvl_percontodi.id_unita_operativa id_struttura_uo,
	dbi_isp_sorvl_percontodi.per_conto_di_completo unita_operativa,
	dbi_isp_sorvl_percontodi.struttura_complessa area_appartenenza_uo,
	dbi_isp_sorvl.supervisionato_in_data,
	dbi_isp_sorvl.supervisionato_da,
	dbi_isp_sorvl.supervisione_note,
	regexp_replace(dbi_isp_sorvl.note,'[\r\n\t]','','g') note ,
	dbi_isp_sorvl.utente_inserimento, 
	dbi_isp_sorvl_percontodi.codice_interno_univoco_uo ,
    dbi_isp_sorvl.stato_controllo,
    dbi_isp_sorvl.id_stato_controllo,
	
	dbi_cu_nucleo_isp.nucleo_ispettivo_uno ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_uno,'[\r\n\t]','','g') componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_isp.nucleo_ispettivo_due ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_due,'[\r\n\t]','','g') componente_nucleo_ispettivo_due ,componentenucleoid_due,
	dbi_cu_nucleo_isp.nucleo_ispettivo_tre ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_tre,'[\r\n\t]','','g') componente_nucleo_ispettivo_tre ,componentenucleoid_tre,
	dbi_cu_nucleo_isp.nucleo_ispettivo_quattro , regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_quattro,'[\r\n\t]','','g') componente_nucleo_ispettivo_quattro ,  componentenucleoid_quattro,
	dbi_cu_nucleo_isp.nucleo_ispettivo_cinque ,  regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_cinque,'[\r\n\t]','','g') componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sei ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sei,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sei ,  componentenucleoid_sei,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sette ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sette,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
	dbi_cu_nucleo_isp.nucleo_ispettivo_otto ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_otto,'[\r\n\t]','','g')  componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_isp.nucleo_ispettivo_nove ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_nove,'[\r\n\t]','','g')  componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_isp.nucleo_ispettivo_dieci ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_dieci,'[\r\n\t]','','g')  componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,

	dbi_isp_sorvl.punteggio ,dbi_isp_sorvl_percontodi.id_asl_struttura 
	from "Analisi_dev".vw_get_controlli_sorveglianze_validi dbi_isp_sorvl
    join "Analisi_dev".lookup_tipo_controllo  l_tipo_controllo on l_tipo_controllo.code = dbi_isp_sorvl.id_tecnica_cu 
	join "Analisi_dev".vw_get_controlli_audit_sorv_percontodi_validi  dbi_isp_sorvl_percontodi on dbi_isp_sorvl.id_controllo = dbi_isp_sorvl_percontodi.id_controllo 

	left join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_isp on dbi_cu_nucleo_isp.id_controllo=dbi_isp_sorvl.id_controllo


	left join
	(select id_controllo,min(stato),max(stato),case when min(stato) != max(stato) then 'Presenti più checklist' else min(stato) end
	 as  tipo_checklist
	from "Analisi_dev".vw_get_checklist_sorveglianza_validi
	group by 1) dbi_isp_checklist on dbi_isp_checklist.id_controllo= dbi_isp_sorvl.id_controllo

	left join
	( select DISTINCT n_reg ,regexp_replace(ragione_sociale,'[\r\n\t]','','g') ragione_sociale , partita_iva,riferimento_id,riferimento_id_nome_tab,comune,provincia_stab

	FROM "Analisi_dev".vw_dbi_get_all_stabilimenti__validi
	) dbi_all_stab on dbi_all_stab.riferimento_id=dbi_isp_sorvl.riferimento_id and dbi_isp_sorvl.riferimento_nome_tab=dbi_all_stab.riferimento_id_nome_tab;


	
	return 1;

	


END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_ispezioni_sorveglianza_cu() OWNER TO postgres;

--
-- Name: create_vw_ispezioni_sorveglianza_cuNEW(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev"."create_vw_ispezioni_sorveglianza_cuNEW"() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	

	BEGIN

	DROP MATERIALIZED VIEW IF EXISTS  "Analisi_dev".vw_ispezioni_sorveglianza_cu CASCADE;

	CREATE MATERIALIZED VIEW  "Analisi_dev".vw_ispezioni_sorveglianza_cu AS 

	select 
	coalesce(tipo_checklist, 'Non Presente') tipo_checklist,
	dbi_isp_sorvl.id_controllo id_controllo_ufficiale,
	dbi_isp_sorvl.id_asl,
	dbi_isp_sorvl.asl,
	dbi_isp_sorvl.riferimento_id,
	dbi_isp_sorvl.riferimento_nome_tab,
	dbi_all_stab.ragione_sociale,
	dbi_all_stab.comune,
	dbi_all_stab.provincia_stab provincia,
	dbi_all_stab.partita_iva,
	dbi_isp_sorvl.categoria_rischio,
	dbi_isp_sorvl.data_prossimo_controllo prossimo_controllo,
	case    when dbi_isp_sorvl.data_chiusura_controllo is not null then 'CONTROLLO CATEGORIZZATO'     else 'CONTROLLO NON CATEGORIZZATO'    end as aggiornata_cat_controllo,
	dbi_all_stab.n_reg numero_registrazione,
	l_tipo_controllo.description  as tipo_controllo ,
	dbi_isp_sorvl.id_tecnica_cu  as code_tipo_controllo ,
	date_part('year',dbi_isp_sorvl.data_inizio_controllo)::int anno_controllo,
	dbi_isp_sorvl.data_inserimento,
	dbi_isp_sorvl.data_inizio_controllo,
	dbi_isp_sorvl.data_chiusura_controllo,
	dbi_isp_sorvl.congruo_supervisione,
	dbi_isp_sorvl_percontodi.id_unita_operativa id_struttura_uo,
	dbi_isp_sorvl_percontodi.per_conto_di_completo unita_operativa,
	dbi_isp_sorvl_percontodi.struttura_complessa area_appartenenza_uo,
	dbi_isp_sorvl.supervisionato_in_data,
	dbi_isp_sorvl.supervisionato_da,
	dbi_isp_sorvl.supervisione_note,
	regexp_replace(dbi_isp_sorvl.note,'[\r\n\t]','','g') note ,
	dbi_isp_sorvl.utente_inserimento, 
	dbi_isp_sorvl_percontodi.codice_interno_univoco_uo ,

	
	dbi_cu_nucleo_isp.nucleo_ispettivo_uno ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_uno,'[\r\n\t]','','g') componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_isp.nucleo_ispettivo_due ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_due,'[\r\n\t]','','g') componente_nucleo_ispettivo_due ,componentenucleoid_due,
	dbi_cu_nucleo_isp.nucleo_ispettivo_tre ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_tre,'[\r\n\t]','','g') componente_nucleo_ispettivo_tre ,componentenucleoid_tre,
	dbi_cu_nucleo_isp.nucleo_ispettivo_quattro , regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_quattro,'[\r\n\t]','','g') componente_nucleo_ispettivo_quattro ,  componentenucleoid_quattro,
	dbi_cu_nucleo_isp.nucleo_ispettivo_cinque ,  regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_cinque,'[\r\n\t]','','g') componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sei ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sei,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sei ,  componentenucleoid_sei,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sette ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sette,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
	dbi_cu_nucleo_isp.nucleo_ispettivo_otto ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_otto,'[\r\n\t]','','g')  componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_isp.nucleo_ispettivo_nove ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_nove,'[\r\n\t]','','g')  componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_isp.nucleo_ispettivo_dieci ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_dieci,'[\r\n\t]','','g')  componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,

	dbi_isp_sorvl.punteggio 
	from "Analisi_dev".vw_get_controlli_sorveglianze_validi dbi_isp_sorvl
    join "Analisi_dev".lookup_tipo_controllo  l_tipo_controllo on l_tipo_controllo.code = dbi_isp_sorvl.id_tecnica_cu 
	join "Analisi_dev".vw_get_controlli_audit_sorv_percontodi_validi  dbi_isp_sorvl_percontodi on dbi_isp_sorvl.id_controllo = dbi_isp_sorvl_percontodi.id_controllo 

	left join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_isp on dbi_cu_nucleo_isp.id_controllo=dbi_isp_sorvl.id_controllo


	left join
	(select id_controllo,min(stato),max(stato),case when min(stato) != max(stato) then 'Presenti più checklist' else min(stato) end
	 as  tipo_checklist
	from "Analisi_dev".vw_get_checklist_sorveglianza_validi
	group by 1) dbi_isp_checklist on dbi_isp_checklist.id_controllo= dbi_isp_sorvl.id_controllo

	left join
	( select DISTINCT n_reg ,regexp_replace(ragione_sociale,'[\r\n\t]','','g') ragione_sociale , partita_iva,riferimento_id,riferimento_id_nome_tab,comune,provincia_stab

	FROM "Analisi_dev".vw_dbi_get_all_stabilimenti__validi
	) dbi_all_stab on dbi_all_stab.riferimento_id=dbi_isp_sorvl.riferimento_id and dbi_isp_sorvl.riferimento_nome_tab=dbi_all_stab.riferimento_id_nome_tab;


	
	return 1;

	


END;
$$;


ALTER FUNCTION "Analisi_dev"."create_vw_ispezioni_sorveglianza_cuNEW"() OWNER TO postgres;

--
-- Name: create_vw_macello_giornaliero_cu(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_macello_giornaliero_cu() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	


	BEGIN

		
	DROP MATERIALIZED VIEW  IF EXISTS "Analisi_dev".vw_macello_giornaliero_cu CASCADE;


	CREATE MATERIALIZED VIEW  "Analisi_dev".vw_macello_giornaliero_cu AS 

	select 
	dbi_isp_carni.id_controllo id_controllo_ufficiale,
	dbi_isp_carni.id_asl,
	dbi_isp_carni.asl,
	dbi_isp_carni.riferimento_id,
	dbi_isp_carni.riferimento_nome_tab,
	dbi_all_linee.norma  ,
	dbi_all_stab.ragione_sociale,
	dbi_all_stab.comune,
	dbi_all_stab.provincia_stab provincia,
	dbi_all_stab.partita_iva,
	dbi_all_linee.num_riconoscimento numero_riconoscimento,
	dbi_all_stab.n_reg numero_registrazione,	
	dbi_all_linee.macroarea,
    dbi_all_linee.aggregazione,
	dbi_all_linee.attivita linea_attivita_sottoposta_a_controllo,
	dbi_all_linee.n_linea,
	dbi_all_linee.codice_macroarea,
	dbi_all_linee.codice_aggregazione,
	dbi_all_linee.codice_attivita,
	l_tipo_controllo.description  as tipo_controllo ,
	dbi_isp_carni.id_tecnica_cu  as code_tipo_controllo ,
	date_part('year',dbi_isp_carni.data_inizio_controllo)::int anno_controllo,
		dbi_isp_carni.data_inserimento,
	dbi_isp_carni.data_inizio_controllo,
	dbi_isp_carni.data_chiusura_controllo,
	dbi_isp_carni_percontodi.id_unita_operativa id_struttura_uo,
	dbi_isp_carni_percontodi.per_conto_di_completo unita_operativa,
	dbi_isp_carni_percontodi.struttura_complessa area_appartenenza_uo,

	dbi_isp_carni.congruo_supervisione,
	dbi_isp_carni.supervisionato_in_data,
	dbi_isp_carni.supervisionato_da,
	dbi_isp_carni.supervisione_note,
	-- passaggio dbi_isp_carni.note,
	regexp_replace(dbi_isp_carni.note,'[\r\n\t]','','g') note ,
	dbi_isp_carni.utente_inserimento,
	dbi_isp_carni_percontodi.codice_interno_univoco_uo ,

	/* passaggio
	dbi_cu_nucleo_isp.nucleo_ispettivo_uno ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_isp.nucleo_ispettivo_due ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_due,componentenucleoid_due,
	dbi_cu_nucleo_isp.nucleo_ispettivo_tre ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_tre,componentenucleoid_tre,
	dbi_cu_nucleo_isp.nucleo_ispettivo_quattro , dbi_cu_nucleo_isp.componente_nucleo_ispettivo_quattro, componentenucleoid_quattro,
	dbi_cu_nucleo_isp.nucleo_ispettivo_cinque ,  dbi_cu_nucleo_isp.componente_nucleo_ispettivo_cinque, componentenucleoid_cinque,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sei ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sei, componentenucleoid_sei,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sette ,   dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sette, componentenucleoid_sette,
	dbi_cu_nucleo_isp.nucleo_ispettivo_otto ,    dbi_cu_nucleo_isp.componente_nucleo_ispettivo_otto,componentenucleoid_otto,
	dbi_cu_nucleo_isp.nucleo_ispettivo_nove ,    dbi_cu_nucleo_isp.componente_nucleo_ispettivo_nove, componentenucleoid_nove,
	dbi_cu_nucleo_isp.nucleo_ispettivo_dieci ,   dbi_cu_nucleo_isp.componente_nucleo_ispettivo_dieci,componentenucleoid_dieci,*/
		
	dbi_cu_nucleo_isp.nucleo_ispettivo_uno ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_uno,'[\r\n\t]','','g') componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_isp.nucleo_ispettivo_due ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_due,'[\r\n\t]','','g') componente_nucleo_ispettivo_due ,componentenucleoid_due,
	dbi_cu_nucleo_isp.nucleo_ispettivo_tre ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_tre,'[\r\n\t]','','g') componente_nucleo_ispettivo_tre ,componentenucleoid_tre,
	dbi_cu_nucleo_isp.nucleo_ispettivo_quattro , regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_quattro,'[\r\n\t]','','g') componente_nucleo_ispettivo_quattro ,  componentenucleoid_quattro,
	dbi_cu_nucleo_isp.nucleo_ispettivo_cinque ,  regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_cinque,'[\r\n\t]','','g') componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sei ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sei,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sei ,  componentenucleoid_sei,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sette ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sette,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
	dbi_cu_nucleo_isp.nucleo_ispettivo_otto ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_otto,'[\r\n\t]','','g')  componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_isp.nucleo_ispettivo_nove ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_nove,'[\r\n\t]','','g')  componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_isp.nucleo_ispettivo_dieci ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_dieci,'[\r\n\t]','','g')  componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,

	dbi_isp_carni.punteggio,dbi_isp_carni_percontodi.id_asl_struttura
	from "Analisi_dev".vw_get_controlli_ispezioni_carni_validi dbi_isp_carni
	join "Analisi_dev".lookup_tipo_controllo l_tipo_controllo on l_tipo_controllo.code = dbi_isp_carni.id_tecnica_cu 
	 
	join "Analisi_dev".vw_get_controlli_audit_sorv_percontodi_validi dbi_isp_carni_percontodi on dbi_isp_carni.id_controllo = dbi_isp_carni_percontodi.id_controllo  
	
    left join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_isp on dbi_cu_nucleo_isp.id_controllo=dbi_isp_carni_percontodi.id_controllo
		 
	
	  
	 left join(
		 select riferimento_id,riferimento_id_nome_tab,lc.id_linea ,lc.id_controllo ,	la.num_riconoscimento ,	la.norma,
		 la.macroarea ,la.aggregazione ,
		la.attivita ,
		la.n_linea,
		la.codice_macroarea,
		la.codice_aggregazione,
		la.codice_attivita
		 from  "Analisi_dev".vw_get_linee_attivita_controllo_validi lc
		 join "Analisi_dev".vw_dbi_get_all_linee_validi la on la.id_linea =lc.id_linea and lc.id_linea is not null)
	 dbi_all_linee	 on    dbi_all_linee.riferimento_id = dbi_isp_carni.riferimento_id and dbi_isp_carni.riferimento_nome_tab = dbi_all_linee.riferimento_id_nome_tab and dbi_all_linee.id_controllo=dbi_isp_carni.id_controllo
		
	
	
	 join  "Analisi_dev".vw_dbi_get_all_stabilimenti__validi dbi_all_stab on 
	 dbi_all_stab.riferimento_id=dbi_isp_carni.riferimento_id and dbi_isp_carni.riferimento_nome_tab=dbi_all_stab.riferimento_id_nome_tab ;
	 

	return 1;


END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_macello_giornaliero_cu() OWNER TO postgres;

--
-- Name: create_vw_macello_giornaliero_cu_16_07(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_macello_giornaliero_cu_16_07() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	


	BEGIN

		
	DROP MATERIALIZED VIEW  IF EXISTS "Analisi_dev".vw_macello_giornaliero_cu CASCADE;


	CREATE MATERIALIZED VIEW  "Analisi_dev".vw_macello_giornaliero_cu AS 

	select 
	dbi_isp_carni.id_controllo id_controllo_ufficiale,
	dbi_isp_carni.id_asl,
	dbi_isp_carni.asl,
	dbi_isp_carni.riferimento_id,
	dbi_isp_carni.riferimento_nome_tab,
	dbi_all_linee.norma soggetto ,
	dbi_all_stab.ragione_sociale,
	dbi_all_stab.comune,
	dbi_all_stab.provincia_stab provincia,
	dbi_all_stab.partita_iva,
	dbi_all_linee.num_riconoscimento numero_riconoscimento,
	dbi_all_stab.n_reg numero_registrazione,	
	dbi_all_linee.attivita linea_attivita_sottoposta_a_controllo,
	dbi_all_linee.n_linea,
	dbi_all_linee.codice_macroarea,
	dbi_all_linee.codice_aggregazione,
	dbi_all_linee.codice_attivita,
	l_tipo_controllo.description  as tipo_controllo ,
	dbi_isp_carni.id_tecnica_cu  as code_tipo_controllo ,
	date_part('year',dbi_isp_carni.data_inizio_controllo)::int anno_controllo,
	dbi_isp_carni.data_inserimento,
	dbi_isp_carni.data_inizio_controllo,
	dbi_isp_carni.data_chiusura_controllo,
	dbi_isp_carni_percontodi.id_unita_operativa id_struttura_uo,
	dbi_isp_carni_percontodi.per_conto_di_completo unita_operativa,
	dbi_isp_carni_percontodi.struttura_complessa area_appartenenza_uo,

	dbi_isp_carni.congruo_supervisione,
	dbi_isp_carni.supervisionato_in_data,
	dbi_isp_carni.supervisionato_da,
	dbi_isp_carni.supervisione_note,
	regexp_replace(dbi_isp_carni.note,'[\r\n\t]','','g') note ,
	dbi_isp_carni.utente_inserimento,
	dbi_isp_carni_percontodi.codice_interno_univoco_uo ,

	
	dbi_cu_nucleo_isp.nucleo_ispettivo_uno ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_uno,'[\r\n\t]','','g') componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_isp.nucleo_ispettivo_due ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_due,'[\r\n\t]','','g') componente_nucleo_ispettivo_due ,componentenucleoid_due,
	dbi_cu_nucleo_isp.nucleo_ispettivo_tre ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_tre,'[\r\n\t]','','g') componente_nucleo_ispettivo_tre ,componentenucleoid_tre,
	dbi_cu_nucleo_isp.nucleo_ispettivo_quattro , regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_quattro,'[\r\n\t]','','g') componente_nucleo_ispettivo_quattro ,  componentenucleoid_quattro,
	dbi_cu_nucleo_isp.nucleo_ispettivo_cinque ,  regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_cinque,'[\r\n\t]','','g') componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sei ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sei,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sei ,  componentenucleoid_sei,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sette ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sette,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
	dbi_cu_nucleo_isp.nucleo_ispettivo_otto ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_otto,'[\r\n\t]','','g')  componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_isp.nucleo_ispettivo_nove ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_nove,'[\r\n\t]','','g')  componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_isp.nucleo_ispettivo_dieci ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_dieci,'[\r\n\t]','','g')  componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,
	dbi_isp_carni.punteggio
	from "Analisi_dev".vw_get_controlli_ispezioni_carni_validi dbi_isp_carni
	join "Analisi_dev".lookup_tipo_controllo l_tipo_controllo on l_tipo_controllo.code = dbi_isp_carni.id_tecnica_cu 
	 
	join "Analisi_dev".vw_get_controlli_audit_sorv_percontodi_validi dbi_isp_carni_percontodi on dbi_isp_carni.id_controllo = dbi_isp_carni_percontodi.id_controllo  
	
    left join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_isp on dbi_cu_nucleo_isp.id_controllo=dbi_isp_carni_percontodi.id_controllo
		 
	
	  
	 left join(
		 select riferimento_id,riferimento_id_nome_tab,lc.id_linea ,lc.id_controllo ,	la.num_riconoscimento ,	la.norma,
		la.attivita ,
		la.n_linea,
		la.codice_macroarea,
		la.codice_aggregazione,
		la.codice_attivita
		 from  "Analisi_dev".vw_get_linee_attivita_controllo_validi lc
		 join "Analisi_dev".vw_dbi_get_all_linee_validi la on la.id_linea =lc.id_linea and lc.id_linea is not null)
	 dbi_all_linee	 on    dbi_all_linee.riferimento_id = dbi_isp_carni.riferimento_id and dbi_isp_carni.riferimento_nome_tab = dbi_all_linee.riferimento_id_nome_tab and dbi_all_linee.id_controllo=dbi_isp_carni.id_controllo
		
	
	
	 join  "Analisi_dev".vw_dbi_get_all_stabilimenti__validi dbi_all_stab on 
	 dbi_all_stab.riferimento_id=dbi_isp_carni.riferimento_id and dbi_isp_carni.riferimento_nome_tab=dbi_all_stab.riferimento_id_nome_tab ;
	 

	return 1;


END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_macello_giornaliero_cu_16_07() OWNER TO postgres;

--
-- Name: create_vw_non_eseguiti_cu(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_non_eseguiti_cu() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	

	BEGIN

		
	DROP MATERIALIZED VIEW  IF EXISTS "Analisi_dev".vw_non_eseguiti_cu CASCADE;


	CREATE MATERIALIZED VIEW  "Analisi_dev".vw_non_eseguiti_cu AS 
	select 
	dbi_cu_nn_eseguiti.id_controllo id_controllo_ufficiale,
	dbi_cu_nn_eseguiti.id_asl,
	dbi_cu_nn_eseguiti.asl,
	dbi_cu_nn_eseguiti.riferimento_id,
	dbi_cu_nn_eseguiti.riferimento_nome_tab,
	dbi_all_linee.norma norma ,
	dbi_all_stab.ragione_sociale,
	dbi_all_stab.comune,
	dbi_all_stab.provincia_stab provincia,
	dbi_all_stab.partita_iva,
	dbi_all_linee.num_riconoscimento numero_riconoscimento,
	dbi_all_stab.n_reg numero_registrazione,	
	dbi_all_linee.macroarea,
	dbi_all_linee.aggregazione,
	dbi_all_linee.attivita linea_attivita_sottoposta_a_controllo,
	dbi_all_linee.n_linea,
	dbi_all_linee.codice_macroarea,
	dbi_all_linee.codice_aggregazione,
	dbi_all_linee.codice_attivita,
	l_tipo_controllo.description  as tipo_controllo ,
	dbi_cu_nn_eseguiti.id_tecnica_cu  as code_tipo_controllo ,
	date_part('year',dbi_cu_nn_eseguiti.data_inizio_controllo) anno_controllo,
	dbi_cu_nn_eseguiti.data_inserimento,
	dbi_cu_nn_eseguiti.data_inizio_controllo,
	dbi_cu_nn_eseguiti.data_chiusura_controllo,
	dbi_cu_nn_eseguiti.congruo_supervisione,
	dbi_cu_nn_eseguiti.supervisionato_in_data,
	dbi_cu_nn_eseguiti.supervisionato_da,
	dbi_cu_nn_eseguiti.supervisione_note,
	--passaggio dbi_cu_nn_eseguiti.note,
	regexp_replace(dbi_cu_nn_eseguiti.note,'[\r\n\t]','','g') note ,
	dbi_cu_nn_eseguiti_percontodi.codice_interno_univoco_uo ,
	dbi_cu_nn_eseguiti_percontodi.id_unita_operativa id_struttura_uo,
	dbi_cu_nn_eseguiti_percontodi.per_conto_di_completo unita_operativa,
	dbi_cu_nn_eseguiti_percontodi.struttura_complessa area_appartenenza_uo,
	/* passaggio
	dbi_cu_nucleo_isp.nucleo_ispettivo_uno ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_isp.nucleo_ispettivo_due ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_due,componentenucleoid_due,
	dbi_cu_nucleo_isp.nucleo_ispettivo_tre ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_tre,componentenucleoid_tre,
	dbi_cu_nucleo_isp.nucleo_ispettivo_quattro , dbi_cu_nucleo_isp.componente_nucleo_ispettivo_quattro, componentenucleoid_quattro,
	dbi_cu_nucleo_isp.nucleo_ispettivo_cinque ,  dbi_cu_nucleo_isp.componente_nucleo_ispettivo_cinque, componentenucleoid_cinque,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sei ,     dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sei, componentenucleoid_sei,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sette ,   dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sette,  componentenucleoid_sette,
	dbi_cu_nucleo_isp.nucleo_ispettivo_otto ,    dbi_cu_nucleo_isp.componente_nucleo_ispettivo_otto,componentenucleoid_otto,
	dbi_cu_nucleo_isp.nucleo_ispettivo_nove ,    dbi_cu_nucleo_isp.componente_nucleo_ispettivo_nove, componentenucleoid_nove,
	dbi_cu_nucleo_isp.nucleo_ispettivo_dieci ,   dbi_cu_nucleo_isp.componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,*/
	dbi_cu_nucleo_isp.nucleo_ispettivo_uno ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_uno,'[\r\n\t]','','g') componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_isp.nucleo_ispettivo_due ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_due,'[\r\n\t]','','g') componente_nucleo_ispettivo_due ,componentenucleoid_due,
	dbi_cu_nucleo_isp.nucleo_ispettivo_tre ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_tre,'[\r\n\t]','','g') componente_nucleo_ispettivo_tre ,componentenucleoid_tre,
	dbi_cu_nucleo_isp.nucleo_ispettivo_quattro , regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_quattro,'[\r\n\t]','','g') componente_nucleo_ispettivo_quattro ,  componentenucleoid_quattro,
	dbi_cu_nucleo_isp.nucleo_ispettivo_cinque ,  regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_cinque,'[\r\n\t]','','g') componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sei ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sei,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sei ,  componentenucleoid_sei,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sette ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sette,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
	dbi_cu_nucleo_isp.nucleo_ispettivo_otto ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_otto,'[\r\n\t]','','g')  componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_isp.nucleo_ispettivo_nove ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_nove,'[\r\n\t]','','g')  componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_isp.nucleo_ispettivo_dieci ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_dieci,'[\r\n\t]','','g')  componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,
	punteggio,dbi_cu_nn_eseguiti_percontodi.id_asl_struttura
	from "Analisi_dev".vw_get_controlli_non_eseguito_validi dbi_cu_nn_eseguiti
	left join 
	(select * from"Analisi_dev".lookup_tipo_controllo ) l_tipo_controllo on l_tipo_controllo.code = dbi_cu_nn_eseguiti.id_tecnica_cu
	left join 
	(select * from  "Analisi_dev".vw_get_controlli_audit_sorv_percontodi_validi ) dbi_cu_nn_eseguiti_percontodi on dbi_cu_nn_eseguiti.id_controllo = dbi_cu_nn_eseguiti_percontodi.id_controllo 

	left join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_isp on dbi_cu_nucleo_isp.id_controllo=dbi_cu_nn_eseguiti.id_controllo
		 

	left join(
		 select riferimento_id,riferimento_id_nome_tab,lc.id_linea ,lc.id_controllo ,	la.num_riconoscimento ,	la.norma,
		 la.macroarea ,la.aggregazione ,
		la.attivita ,
		la.n_linea,
		la.codice_macroarea,
		la.codice_aggregazione,
		la.codice_attivita
		 from  "Analisi_dev".vw_get_linee_attivita_controllo_validi lc
		 join "Analisi_dev".vw_dbi_get_all_linee_validi la on la.id_linea =lc.id_linea and lc.id_linea is not null) dbi_all_linee
		 on    dbi_all_linee.riferimento_id = dbi_cu_nn_eseguiti.riferimento_id and dbi_cu_nn_eseguiti.riferimento_nome_tab = dbi_all_linee.riferimento_id_nome_tab and dbi_all_linee.id_controllo=dbi_cu_nn_eseguiti.id_controllo
	
	
	left join  "Analisi_dev".vw_dbi_get_all_stabilimenti__validi dbi_all_stab on 
	 dbi_all_stab.riferimento_id=dbi_cu_nn_eseguiti.riferimento_id and dbi_cu_nn_eseguiti.riferimento_nome_tab=dbi_all_stab.riferimento_id_nome_tab 	;
 	
 	
 	

	return 1;
	 

	


END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_non_eseguiti_cu() OWNER TO postgres;

--
-- Name: create_vw_non_eseguiti_cu_16_07(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".create_vw_non_eseguiti_cu_16_07() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	

	BEGIN

		
	DROP MATERIALIZED VIEW  IF EXISTS "Analisi_dev".vw_non_eseguiti_cu CASCADE;


	CREATE MATERIALIZED VIEW  "Analisi_dev".vw_non_eseguiti_cu AS 
	select 
	dbi_cu_nn_eseguiti.id_controllo id_controllo_ufficiale,
	dbi_cu_nn_eseguiti.id_asl,
	dbi_cu_nn_eseguiti.asl,
	dbi_cu_nn_eseguiti.riferimento_id,
	dbi_cu_nn_eseguiti.riferimento_nome_tab,
	dbi_all_linee.norma soggetto ,
	dbi_all_stab.ragione_sociale,
	dbi_all_stab.comune,
	dbi_all_stab.provincia_stab provincia,
	dbi_all_stab.partita_iva,
	dbi_all_linee.num_riconoscimento numero_riconoscimento,
	dbi_all_stab.n_reg numero_registrazione,	
	dbi_all_linee.attivita linea_attivita_sottoposta_a_controllo,
	dbi_all_linee.n_linea,
	dbi_all_linee.codice_macroarea,
	dbi_all_linee.codice_aggregazione,
	dbi_all_linee.codice_attivita,
	l_tipo_controllo.description  as tipo_controllo ,
	dbi_cu_nn_eseguiti.id_tecnica_cu  as code_tipo_controllo ,
	date_part('year',dbi_cu_nn_eseguiti.data_inizio_controllo) anno_controllo,	
	dbi_cu_nn_eseguiti.data_inserimento,
	dbi_cu_nn_eseguiti.data_inizio_controllo,
	dbi_cu_nn_eseguiti.data_chiusura_controllo,
	dbi_cu_nn_eseguiti.congruo_supervisione,
	dbi_cu_nn_eseguiti.supervisionato_in_data,
	dbi_cu_nn_eseguiti.supervisionato_da,
	dbi_cu_nn_eseguiti.supervisione_note,
	regexp_replace(dbi_cu_nn_eseguiti.note,'[\r\n\t]','','g') note ,
	dbi_cu_nn_eseguiti_percontodi.codice_interno_univoco_uo ,
	dbi_cu_nn_eseguiti_percontodi.id_unita_operativa id_struttura_uo,
	dbi_cu_nn_eseguiti_percontodi.per_conto_di_completo unita_operativa,
	dbi_cu_nn_eseguiti_percontodi.struttura_complessa area_appartenenza_uo,
	
	dbi_cu_nucleo_isp.nucleo_ispettivo_uno ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_uno,'[\r\n\t]','','g') componente_nucleo_ispettivo_uno,componentenucleoid_uno,
	dbi_cu_nucleo_isp.nucleo_ispettivo_due ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_due,'[\r\n\t]','','g') componente_nucleo_ispettivo_due ,componentenucleoid_due,
	dbi_cu_nucleo_isp.nucleo_ispettivo_tre ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_tre,'[\r\n\t]','','g') componente_nucleo_ispettivo_tre ,componentenucleoid_tre,
	dbi_cu_nucleo_isp.nucleo_ispettivo_quattro , regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_quattro,'[\r\n\t]','','g') componente_nucleo_ispettivo_quattro ,  componentenucleoid_quattro,
	dbi_cu_nucleo_isp.nucleo_ispettivo_cinque ,  regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_cinque,'[\r\n\t]','','g') componente_nucleo_ispettivo_cinque ,  componentenucleoid_cinque,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sei ,     regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sei,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sei ,  componentenucleoid_sei,
	dbi_cu_nucleo_isp.nucleo_ispettivo_sette ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_sette,'[\r\n\t]','','g')  componente_nucleo_ispettivo_sette ,  componentenucleoid_sette,
	dbi_cu_nucleo_isp.nucleo_ispettivo_otto ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_otto,'[\r\n\t]','','g')  componente_nucleo_ispettivo_otto ,componentenucleoid_otto,
	dbi_cu_nucleo_isp.nucleo_ispettivo_nove ,    regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_nove,'[\r\n\t]','','g')  componente_nucleo_ispettivo_nove ,  componentenucleoid_nove,
	dbi_cu_nucleo_isp.nucleo_ispettivo_dieci ,   regexp_replace(dbi_cu_nucleo_isp.componente_nucleo_ispettivo_dieci,'[\r\n\t]','','g')  componente_nucleo_ispettivo_dieci, componentenucleoid_dieci,
    punteggio
	from "Analisi_dev".vw_get_controlli_non_eseguito_validi dbi_cu_nn_eseguiti
	left join 
	(select * from"Analisi_dev".lookup_tipo_controllo ) l_tipo_controllo on l_tipo_controllo.code = dbi_cu_nn_eseguiti.id_tecnica_cu
	left join 
	(select * from  "Analisi_dev".vw_get_controlli_audit_sorv_percontodi_validi ) dbi_cu_nn_eseguiti_percontodi on dbi_cu_nn_eseguiti.id_controllo = dbi_cu_nn_eseguiti_percontodi.id_controllo 

	left join "Analisi_dev".vw_get_controlli_nucleoispettivo_crosstab dbi_cu_nucleo_isp on dbi_cu_nucleo_isp.id_controllo=dbi_cu_nn_eseguiti.id_controllo
		 

	left join(
		 select riferimento_id,riferimento_id_nome_tab,lc.id_linea ,lc.id_controllo ,	la.num_riconoscimento ,	la.norma,
		la.attivita ,
		la.n_linea,
		la.codice_macroarea,
		la.codice_aggregazione,
		la.codice_attivita
		 from  "Analisi_dev".vw_get_linee_attivita_controllo_validi lc
		 join "Analisi_dev".vw_dbi_get_all_linee_validi la on la.id_linea =lc.id_linea and lc.id_linea is not null) dbi_all_linee
		 on    dbi_all_linee.riferimento_id = dbi_cu_nn_eseguiti.riferimento_id and dbi_cu_nn_eseguiti.riferimento_nome_tab = dbi_all_linee.riferimento_id_nome_tab and dbi_all_linee.id_controllo=dbi_cu_nn_eseguiti.id_controllo
	
	
	left join  "Analisi_dev".vw_dbi_get_all_stabilimenti__validi dbi_all_stab on 
	 dbi_all_stab.riferimento_id=dbi_cu_nn_eseguiti.riferimento_id and dbi_cu_nn_eseguiti.riferimento_nome_tab=dbi_all_stab.riferimento_id_nome_tab 	;
 	
 	
 	

	return 1;
	 

	


END;
$$;


ALTER FUNCTION "Analisi_dev".create_vw_non_eseguiti_cu_16_07() OWNER TO postgres;

--
-- Name: creazione_vw_per_tabellone_cu(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".creazione_vw_per_tabellone_cu() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	msg text ;
	

	BEGIN

	BEGIN
		DROP  VIEW  IF EXISTS "Analisi_dev".vw_cu_totali CASCADE;
		
	PERFORM  * from "Analisi_dev".create_vw_ispezioni_sorveglianza_cu();

	PERFORM  * from "Analisi_dev".create_vw_ispezioni_semplici_cu();
	
	PERFORM  * from "Analisi_dev".create_vw_audit_cu();

    PERFORM  * from "Analisi_dev".create_vw_audit_cuDA2020();

	PERFORM  * from "Analisi_dev".create_vw_audit_autorita_cu();

    PERFORM  * from "Analisi_dev".create_vw_macello_giornaliero_cu();

	PERFORM  * from "Analisi_dev".create_vw_non_eseguiti_cu();

	PERFORM  * from "Analisi_dev".create_vw_cu_totali();


	END;

	
	return 1;

	


END;
$$;


ALTER FUNCTION "Analisi_dev".creazione_vw_per_tabellone_cu() OWNER TO postgres;

--
-- Name: crypt(text, text); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".crypt(text, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT PARALLEL SAFE
    AS '$libdir/pgcrypto', 'pg_crypt';


ALTER FUNCTION "Analisi_dev".crypt(text, text) OWNER TO postgres;

--
-- Name: dbi_get_elenco_cu_audit(integer, date, date); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".dbi_get_elenco_cu_audit(_id_asl integer, _data_inizio date, _data_fine date) RETURNS TABLE(id_controllo_ufficiale integer, id_asl integer, asl text, soggetto text, ragione_sociale text, linea_attivita_sottoposta_a_controllo text, n_linea character varying, codice_macroarea text, codice_aggregazione text, codice_attivita text, tipo_ispezione_o_audit text, anno_controllo double precision, data_inizio_controllo timestamp without time zone, data_chiusura_controllo timestamp without time zone, congruo_supervisione text, tipo_controllo_bpi text, tipo_controllo_haccp text, id_struttura_uo integer, unita_operativa text, area_appartenza_uo text, supervisionato_in_data timestamp without time zone, supervisionato_da integer, supervisione_note text, note text, codice_interno_univoco_uo integer, nucleo_ispettivo_uno text, componente_nucleo_ispettivo_uno text, nucleo_ispettivo_due text, componente_nucleo_ispettivo_due text, nucleo_ispettivo_tre text, componente_nucleo_ispettivo_tre text, nucleo_ispettivo_quattro text, componente_nucleo_ispettivo_quattro text, nucleo_ispettivo_cinque text, componente_nucleo_ispettivo_cinque text, nucleo_ispettivo_sei text, componente_nucleo_ispettivo_sei text, nucleo_ispettivo_sette text, componente_nucleo_ispettivo_sette text, nucleo_ispettivo_otto text, componente_nucleo_ispettivo_otto text, nucleo_ispettivo_nove text, componente_nucleo_ispettivo_nove text, nucleo_ispettivo_dieci text, componente_nucleo_ispettivo_dieci text)
    LANGUAGE plpgsql
    AS $$
BEGIN

 

/*

 IF ( (_id_asl<201 or _id_asl > 207 ) and _id_asl<>-1 ) THEN
      RAISE EXCEPTION  'Il campo id_asl non appartiene ai valori permessi. Il campo id_asl ha valori da 201 a 207 per una specifica ASL oppure -1 per indicare tutte le ASL ' ;
 END IF;


 IF ( (_id_asl<201 or _id_asl > 207 ) and _id_asl<>-1 ) THEN
      RAISE EXCEPTION  'Il campo id_asl non appartiene ai valori permessi. Il campo id_asl ha valori da 201 a 207 per una specifica ASL oppure -1 per indicare tutte le ASL ' ;
 END IF;

*/


RETURN QUERY

  SELECT 	
	cu.id_controllo_ufficiale, 
	cu.id_asl, 
	cu.asl::text, 
	cu.soggetto, 
	cu.ragione_sociale, 
	cu.linea_attivita_sottoposta_a_controllo, 
	cu.n_linea, 
	cu.codice_macroarea, 
	cu.codice_aggregazione, 
	cu.codice_attivita,  
	cu.tipo_ispezione_o_audit,
	cu.anno_controllo, 
	cu.data_inizio_controllo, 
	cu.data_chiusura_controllo,
	cu.congruo_supervisione, 
	cu.tipo_controllo_bpi, 
	cu.tipo_controllo_haccp, 
	cu.id_struttura_uo, 
	cu.unita_operativa, 
	cu.area_appartenenza_uo, 
	cu.supervisionato_in_data, 
	cu.supervisionato_da, 
	cu.supervisione_note, 
	cu.note, 
	cu.codice_interno_univoco_uo, 
	cu.nucleo_ispettivo_uno, 
	cu.componente_nucleo_ispettivo_uno, 
	cu.nucleo_ispettivo_due, 
	cu.componente_nucleo_ispettivo_due, 
	cu.nucleo_ispettivo_tre, 
	cu.componente_nucleo_ispettivo_tre,
	cu.nucleo_ispettivo_quattro, 
	cu.componente_nucleo_ispettivo_quattro, 
	cu.nucleo_ispettivo_cinque, 
	cu.componente_nucleo_ispettivo_cinque, 
	cu.nucleo_ispettivo_sei, 
	cu.componente_nucleo_ispettivo_sei, 
	cu.nucleo_ispettivo_sette, 
	cu.componente_nucleo_ispettivo_sette, 
	cu.nucleo_ispettivo_otto, 
	cu.componente_nucleo_ispettivo_otto,
	cu.nucleo_ispettivo_nove, 
	cu.componente_nucleo_ispettivo_nove, 
	cu.nucleo_ispettivo_dieci, 
	cu.componente_nucleo_ispettivo_dieci 
 FROM  "Analisi_dev".vw_audit_cu  cu
 where  
  cu.data_inizio_controllo>=_data_inizio and cu.data_inizio_controllo<=_data_fine
  and cu.id_asl=_id_asl
ORDER BY 
	id_asl;









END;

$$;


ALTER FUNCTION "Analisi_dev".dbi_get_elenco_cu_audit(_id_asl integer, _data_inizio date, _data_fine date) OWNER TO postgres;

--
-- Name: dbi_get_elenco_cu_audit(text, integer, integer, date, date, integer); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".dbi_get_elenco_cu_audit(_id_norma text, _id_asl integer, _id_struttura_uo integer, _data_inizio date, _data_fine date, _stato_cu integer) RETURNS TABLE(id_controllo_ufficiale_out integer, norma_out text, partita_iva_out character varying, ragione_sociale_out text, linea_attivita_sottoposta_a_controllo_out text, numero_registrazione_out character varying, tipo_controllo_out character varying, anno_controllo_out integer, asl_out character varying, id_asl_out integer, codice_norma_out text, codice_tipo_controllo_out integer, data_inizio_controllo_out date, data_chiusura_controllo_out date, area_appartenenza_uo_out text, unita_operativa_out text)
    LANGUAGE plpgsql
    AS $$
BEGIN
 



 IF ( (_id_asl<201 or _id_asl > 207 ) and _id_asl<>-1 ) THEN
      RAISE EXCEPTION  'Il campo id_asl non appartiene ai valori permessi. Il campo id_asl ha valori da 201 a 207 per una specifica ASL oppure -1 per indicare tutte le ASL ' ;
 END IF;


 if(_id_norma <>'-1' ) THEN
  IF NOT EXISTS (select 1 from lookup_norme where codice_norma = _id_norma and enabled) THEN

      RAISE EXCEPTION  'Il campo id_norma non appartiene ai valori permessi.' ;
  END IF;
  END IF;



 IF ( (_id_asl<201 or _id_asl > 207 ) and _id_asl<>-1 ) THEN
      RAISE EXCEPTION  'Il campo id_asl non appartiene ai valori permessi. Il campo id_asl ha valori da 201 a 207 per una specifica ASL oppure -1 per indicare tutte le ASL ' ;
 END IF;

 IF (_stato_cu<>-1  and _stato_cu<> 0 and _stato_cu<>1 and _stato_cu<>2 ) THEN
      RAISE EXCEPTION  'Il campo stato_CU non appartiene ai valori permessi. Il campo stato_CU ha valori da -1(TUTTI),O(TOTALI),1(CHIUSI),2(DA CHIUDERE)';
 END IF;


--- ISPEZIONI SEMPLICI TOTALI
IF (_stato_cu = 0) THEN
RETURN QUERY
SELECT distinct 

	
					id_controllo_ufficiale,
					soggetto,
					partita_iva,	
					regexp_replace(cu.ragione_sociale,'[\r\n\t]','','g') ragione_sociale,
					regexp_replace(cu.linea_attivita_sottoposta_a_controllo,'[\r\n\t]','','g') linea_attivita_sottoposta_a_controllo , 
   					COALESCE (numero_registrazione, numero_riconoscimento) numero_registrazione, 
   					tipo_controllo,
					anno_controllo::int,
					asl,
					id_asl,
					ln.codice_norma codice_norma,
					ltc.code codice_tipo_controllo,
					data_inizio_controllo, 
					data_chiusura_controllo,
					cu.area_appartenenza_uo,
					regexp_replace(cu.unita_operativa,'[\r\n\t]','','g')  unita_operativa   

			FROM 
					report_vista_controlli_ufficiali_new_uo_1 cu
					left join lookup_norme ln on ln.description=cu.soggetto
					left join lookup_tipo_controllo ltc on ltc.description=cu.tipo_controllo
		

WHERE
  cu.data_inizio_controllo>=_data_inizio and cu.data_inizio_controllo<=_data_fine
  and lower(tipo_controllo)='audit'
  and ( _id_norma ='-1' or ln.codice_norma =_id_norma )
  and ( _id_struttura_uo  =-1 or id_struttura_uo = _id_struttura_uo )
  and id_asl=_id_asl
ORDER BY 
	id_asl,codice_norma;
END IF;





IF (_stato_cu = 1) THEN
RETURN QUERY
--- ISPEZIONI SEMPLICI CHIUSI
SELECT distinct 
     	
					id_controllo_ufficiale,
					soggetto,
					partita_iva,	
					regexp_replace(cu.ragione_sociale,'[\r\n\t]','','g') ragione_sociale,
					regexp_replace(cu.linea_attivita_sottoposta_a_controllo,'[\r\n\t]','','g') linea_attivita_sottoposta_a_controllo , 
   					COALESCE (numero_registrazione, numero_riconoscimento) numero_registrazione, 
   					tipo_controllo,
					anno_controllo::int,
					asl,
					id_asl,
					ln.codice_norma codice_norma,
					ltc.code codice_tipo_controllo,
					data_inizio_controllo, 
					data_chiusura_controllo,
					cu.area_appartenenza_uo,
					regexp_replace(cu.unita_operativa,'[\r\n\t]','','g')  unita_operativa   

			FROM 
					report_vista_controlli_ufficiali_new_uo_1 cu
					left join lookup_norme ln on ln.description=cu.soggetto
					left join lookup_tipo_controllo ltc on ltc.description=cu.tipo_controllo
		
			WHERE
			  cu.data_inizio_controllo>=_data_inizio and cu.data_inizio_controllo<=_data_fine
			  and lower(tipo_controllo)='audit'
			  and id_asl=_id_asl
			  and ( _id_norma ='-1' or ln.codice_norma =_id_norma )
			  and ( _id_struttura_uo  =-1 or id_struttura_uo = _id_struttura_uo )
			  and data_chiusura_controllo is not null
			ORDER BY 
				id_asl,codice_norma;
END IF;





IF (_stato_cu = 2) THEN
RETURN QUERY
--- ISPEZIONI SEMPLICI APERTE DA CHIUDERE
SELECT distinct 
     
					id_controllo_ufficiale,
					soggetto,
					partita_iva,	
					regexp_replace(cu.ragione_sociale,'[\r\n\t]','','g') ragione_sociale,
					regexp_replace(cu.linea_attivita_sottoposta_a_controllo,'[\r\n\t]','','g') linea_attivita_sottoposta_a_controllo , 
   					COALESCE (numero_registrazione, numero_riconoscimento) numero_registrazione, 
   					tipo_controllo,
					anno_controllo::int,
					asl,
					id_asl,
					ln.codice_norma codice_norma,
					ltc.code codice_tipo_controllo,
					data_inizio_controllo, 
					data_chiusura_controllo,
					cu.area_appartenenza_uo,
					regexp_replace(cu.unita_operativa,'[\r\n\t]','','g')  unita_operativa   

			FROM 
					report_vista_controlli_ufficiali_new_uo_1 cu
					left join lookup_norme ln on ln.description=cu.soggetto
					left join lookup_tipo_controllo ltc on ltc.description=cu.tipo_controllo
		
		WHERE
	  cu.data_inizio_controllo>=_data_inizio and cu.data_inizio_controllo<=_data_fine
	  and lower(tipo_controllo)='audit'
	  and ( _id_norma ='-1' or ln.codice_norma =_id_norma )
	  and id_asl=_id_asl
	  and ( _id_struttura_uo  =-1 or id_struttura_uo = _id_struttura_uo )
	  and data_chiusura_controllo is null
	ORDER BY 
		id_asl,codice_norma;
	END IF;





END;

$$;


ALTER FUNCTION "Analisi_dev".dbi_get_elenco_cu_audit(_id_norma text, _id_asl integer, _id_struttura_uo integer, _data_inizio date, _data_fine date, _stato_cu integer) OWNER TO postgres;

--
-- Name: move_rng(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".move_rng() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	declare
	str character varying;
	C record;

	begin	
		
  set search_path to "Analisi_dev";
for C in select * from "Analisi_dev".gisadbi where enabled is true and status = 'C' loop

	execute 'create table h_'||C.tname||'_temp as select rng as rng2, * from "Analisi_dev".h_'||C.tname||';';
	
	execute 'alter table h_'||C.tname||'_temp  drop column rng;';
	
	execute 'alter table h_'||C.tname||'_temp  rename column rng2 to rng;';

end loop;

return 1;
end;
$$;


ALTER FUNCTION "Analisi_dev".move_rng() OWNER TO postgres;

--
-- Name: pg_terminate_backend_mdgm(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".pg_terminate_backend_mdgm() RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare 
rec record;
BEGIN
    for rec in select * from   pg_stat_activity WHERE pid <> pg_backend_pid() AND datname = 'mdgm' loop 
		raise notice 'terminate pid: %', rec.pid;
		perform pg_terminate_backend(rec.pid) ;
	end loop;
   return 1;
END;
$$;


ALTER FUNCTION "Analisi_dev".pg_terminate_backend_mdgm() OWNER TO postgres;

--
-- Name: purge_duplicati(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".purge_duplicati() RETURNS text
    LANGUAGE plpgsql
    AS $$
	declare
		cnt integer;
		curr_version text;
		C record;
		col record;
		i integer;
		dbname text;
		dbaddress text;
	    dbschema text;
		field_list character varying;
		fields character varying;
		str_PURGE character varying;
		parentesi character varying;
		str_information_schema character varying;
	begin	
    
	select value from "Analisi_dev".config where descr = 'GISA_ADDRESS' into dbaddress;

  for C in select * from "Analisi_dev".gisadbi where status = 'C' loop
  
  	field_list := '';
	fields := '';
	i:=0;

	dbschema := C.schema;
	select value from "Analisi_dev".config where id = C.id_config_db into dbname;

	
	str_information_schema :=  'select c.column_name as parameter_name, c.data_type, c.character_maximum_length
		from information_schema.columns c 
		where table_catalog = ''mdgm_fvg'' and table_schema = ''Analisi_dev'' and table_name = ''h_'|| C.tname ||''' and c.column_name != ''rng''';

	
	--raise notice '%', 'INFOSCHEMA! '||str_information_schema ||'';

 	 for col in EXECUTE str_information_schema loop

			 if (i>0) then field_list := field_list ||','; fields  = fields || ','; end if;
			field_list = field_list || col.parameter_name ||' '||col.data_type;
			if col.data_type = 'character' then
				field_list:=field_list||' varying';
			end if;
			if strpos(col.parameter_name, ' ') > 0 then 
				col.parameter_name = '"'|| col.parameter_name ||'"';
			end if;
			fields  = fields || col.parameter_name;
			i:=i+1;
		end loop;
	
		str_PURGE := 'DELETE FROM "Analisi_dev".h_'|| C.tname ||'
               WHERE ctid IN (SELECT ctid
               FROM   (SELECT ctid,
                              ROW_NUMBER() OVER ( PARTITION BY '||fields||') AS rn
                       FROM   "Analisi_dev".h_'|| C.tname ||') t
               WHERE  rn > 1)';
       str_PURGE := 'select count(*) FROM "Analisi_dev".h_'|| C.tname ||'
               WHERE ctid IN (SELECT ctid
               FROM   (SELECT ctid,
                              ROW_NUMBER() OVER ( PARTITION BY '||fields||') AS rn
                       FROM   "Analisi_dev".h_'|| C.tname ||' where upper(rng) is null) t
               WHERE  rn > 1)';
      --  raise notice '%', str_PURGE; 
        execute str_PURGE into cnt;
     --  raise notice 'Purged %', cnt; 
      
      insert into "Analisi_dev".check_duplicati values (C.tname, cnt, now());

  end loop;
  
 return '1';
	end;
$$;


ALTER FUNCTION "Analisi_dev".purge_duplicati() OWNER TO postgres;

--
-- Name: remove_temp(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".remove_temp() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	declare
	str character varying;
	C record;

	begin	
		
  set search_path to "Analisi_dev";
for C in select * from "Analisi_dev".gisadbi where enabled is true and status = 'C' loop

		execute 'alter table h_'||C.tname||'_temp rename to h_'||C.tname||'';


end loop;

return 1;
end;
$$;


ALTER FUNCTION "Analisi_dev".remove_temp() OWNER TO postgres;

--
-- Name: update_dbi(text, text, integer); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".update_dbi(modalita text, sistema text DEFAULT NULL::text, id_gisadbi integer DEFAULT NULL::integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	declare
		curr_version text;
		C record;
		col record;
		i integer;
		dbname text;
		dbaddress text;
	    dbschema text;
   	   	str_DEL character varying;
	   	str_NEXTVAL character varying;
		str character varying;
		str_CREATE character varying;
		str_DECLARE character varying;
		str_PROC character varying;
		str_FETCH character varying;
		field_list character varying;
		fields character varying;
		str_CU character varying;
		str_INS_CU character varying;
		str_MVW character varying;
		parentesi character varying;
		str_information_schema character varying;
		rec record;
	begin	
		
	  set search_path to "Analisi_dev";
	 
	 select value from "Analisi_dev".config where descr = 'GISA_DB' into dbname;
	 select value from "Analisi_dev".config where descr = 'GISA_ADDRESS' into dbaddress;
	 if modalita = 'istantaneo' then
	 	 select value from "Analisi_dev".config where descr = 'GISA_ADDRESS_PROD' into dbaddress;
	 end if;
	-- select value from config where descr = 'DBI_SCHEMA' into dbschema;
	raise notice '%', dbaddress;
	
	
	for C in select * from "Analisi_dev".gisadbi where enabled and ((giornaliero is true and modalita = 'giornaliero') or (istantaneo is true and modalita = 'istantaneo')) and status = 'D' and (id_config_db in (select id from "Analisi_dev".config where value = sistema) or sistema is null) and (id = id_gisadbi or id_gisadbi is null) loop
		STR_DEL := 'drop table if exists h_'||C.tname||' CASCADE';
		execute STR_DEL;
		STR_DEL := 'drop view if exists vw_'||C.tname||' CASCADE';
		execute STR_DEL;
	end loop;

	   str_NEXTVAL := ' insert into versioni values(nextval(''"Analisi_dev".vers_seq''), current_timestamp, current_user ); 
						';
  	   curr_version = 'currval(''"Analisi_dev".vers_seq'')';
		str := '';
		str_CU := '';
		str_INS_CU := '';

		str_CREATE := 'CREATE OR REPLACE FUNCTION "Analisi_dev".update_dbi_values(
						)
					RETURNS text
						LANGUAGE ''plpgsql''
						COST 100
						VOLATILE 
					AS $b$ ';
		str_DECLARE := 'DECLARE
							rec record;';
		str_FETCH := 'begin 
			set search_path to "Analisi_dev";
		' || str_NEXTVAL;
		for C in select * from "Analisi_dev".gisadbi where enabled and ((giornaliero is true and modalita = 'giornaliero') or (istantaneo is true and modalita = 'istantaneo')) and (status = 'A' or status = 'C')  and (id_config_db in (select id from "Analisi_dev".config where value = sistema) or sistema is null) and (id = id_gisadbi or id_gisadbi is null) loop
			str = 'drop view if exists "Analisi_dev".vw_'|| C.tname || ';';
			raise notice 'ALLINEO: %', C.tname;
			execute str;
		
			 select value from config where id = C.id_config_db into dbname;
			raise notice 'DBNAME: %', dbname;

			if C.is_function = true then
				parentesi := '('||coalesce(C.params, '')||')';
				str_information_schema := 'SELECT parameter_name, parameters.data_type, parameters.character_maximum_length
					FROM information_schema.routines 
    				LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name  
					WHERE routines.specific_catalog='''||dbname||''' and routine_name = '''|| C.tname ||''' and parameter_mode = ''OUT'' and parameters.specific_schema = '''||C.schema||''' ';
			else
				parentesi := '';
				str_information_schema :=  'select c.column_name as parameter_name, c.data_type, c.character_maximum_length
 					from information_schema.columns c 
					where table_catalog = '''||dbname||''' and table_schema = '''||C.schema||''' and table_name = '''|| C.tname ||''' ';
			end if;	
			
			dbschema := C.schema;
		
			str = ' create or replace view  "Analisi_dev".vw_'|| C.tname || 
			' AS SELECT * from public.dblink(''dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres'',
				''select * from '||dbschema||'.'|| C.tname||parentesi||''') AS T(';
			field_list := '';
			fields := '';
			i:=0;
		
			raise notice '%', 'select * FROM public.dblink(dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres, '||str_information_schema||') AS T(parameter_name character varying, data_type character varying,character_maximum_length character varying)'; 

			for col in select * FROM public.dblink('dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres',
				''||str_information_schema||'')
				--' SELECT parameter_name, parameters.data_type, parameters.character_maximum_length
				--	FROM information_schema.routines 
    			--	LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name  
				--	WHERE routines.specific_catalog='''||dbname||''' and routine_name = '''|| C.tname ||''' and parameter_mode = ''OUT'' and parameters.specific_schema = '''||dbschema||''' ')
				 AS T(parameter_name character varying, data_type character varying,character_maximum_length character varying) loop
				if strpos(col.parameter_name, ' ') > 0 then 
					col.parameter_name = '"'|| col.parameter_name ||'"';
				end if;
				 if (i>0) then field_list := field_list ||','; fields  = fields || ','; end if;
				field_list = field_list || col.parameter_name ||' '||col.data_type;
				--if col.character_maximum_length is not null then
				--	field_list:=field_list||'('||col.character_maximum_length||')';
				if col.data_type = 'character' then
					field_list:=field_list||' varying';
				end if;
				fields  = fields || col.parameter_name;
				i:=i+1;
			end loop;
			if C.is_function and i = 0 then 
				--str_information_schema := '	select attribute_name as parameter_name, data_type, 
				--					character_maximum_length from information_schema."attributes" a where a.udt_name = '''|| C.tname ||''' ';
				
				str_information_schema := 'select distinct a.attribute_name as parameter_name, a.data_type, a.character_maximum_length , ordinal_position
					from information_schema.attributes a
					join  information_schema.routines r on a.udt_name = r.type_udt_name and a.udt_schema = r.routine_schema 
					where r.routine_name = '''|| C.tname ||''' order by ordinal_position';
				
				raise notice '%', 'SETOF! '||str_information_schema ||'';

				for col in select * FROM public.dblink('dbname='||dbname||' port=5432 host='||dbaddress||' user=postgres',
					''||str_information_schema||'')
					--' SELECT parameter_name, parameters.data_type, parameters.character_maximum_length
					--	FROM information_schema.routines 
	    			--	LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name  
					--	WHERE routines.specific_catalog='''||dbname||''' and routine_name = '''|| C.tname ||''' and parameter_mode = ''OUT'' and parameters.specific_schema = '''||dbschema||''' ')
					 AS T(parameter_name character varying, data_type character varying,character_maximum_length character varying, ordinal_position int) loop
					if strpos(col.parameter_name, ' ') > 0 then 
						col.parameter_name = '"'|| col.parameter_name ||'"';
					end if;
					 if (i>0) then field_list := field_list ||','; fields  = fields || ','; end if;
					field_list = field_list || col.parameter_name ||' '||col.data_type;
					--if col.character_maximum_length is not null then
					--	field_list:=field_list||'('||col.character_maximum_length||')';
					if col.data_type = 'character' then
						field_list:=field_list||' varying';
					end if;
					fields  = fields || col.parameter_name;
					i:=i+1;
				end loop;
			end if;
			str = str ||field_list||'); ';
			str_DECLARE = str_DECLARE || '
							curs_'||C.tname||' CURSOR FOR 
								select count(*),max(rowid) as rowid,max(f),min(f),row(rng, '|| fields ||') as r 
								from
								(select ctid as rowid, ''m'' as f, int8range('||curr_version||', null ) as rng, '|| fields ||'
								from "Analisi_dev".h_'||C.tname||' m where upper(rng) is null
								union
								select null as rowid,''v'' as f, int8range('||curr_version||', null ) as rng, '||fields||'
								from "Analisi_dev".vw_'||C.tname||' vw) s
								group by '||fields||', rng
								order by count(*);
							rec_'||C.tname||'  "Analisi_dev".h_'||C.tname||'%ROWTYPE; 
						';
			str_FETCH = str_FETCH || '
							raise notice ''% open cursor '||C.tname||' '', clock_timestamp();
							open curs_'||C.tname||';
							loop
								fetch curs_'||C.tname||' into rec;
								EXIT WHEN NOT FOUND;
								if rec.count <2 then
									if rec.max = ''m'' then
										update "Analisi_dev".h_'||C.tname||' m set rng = int8range(lower(rng), '||curr_version||')
										where m.ctid = rec.rowid;
									end if;
									if rec.min = ''v'' then
										rec_'||C.tname||' = rec.r;
										insert into "Analisi_dev".h_'||C.tname||' values (rec_'||C.tname||'.*);
									end if;
								end if;
							end loop;
						 	CLOSE curs_'||C.tname||';
							analyze verbose "Analisi_dev".h_'||C.tname||';
							raise notice ''% close cursor '||C.tname||' '', clock_timestamp();
							raise notice ''--------------------------'';
						  --  DEALLOCATE curs_'||C.tname||';
						';
			raise notice '%', str;
			begin
			EXECUTE str;
			exception when others then return str;
			end;
		
			
			
			if C.status = 'A' then
				EXECUTE 'drop table if exists "Analisi_dev".h_'||C.tname||' CASCADE';
				--exception when others then str:=str||'';
				--end;
				str = 'create table "Analisi_dev".h_'||C.tname ||  '  '||
				' AS select int8range(null,null) as rng, *  from "Analisi_dev".vw_'|| C.tname || ' where 1=0';
				--raise notice '%', str;
				EXECUTE str;
			end if;
			
			if sistema is null and id_gisadbi is null then
			if C.is_controllo then
				/*str_CU = '
					drop table if exists gisa_controlli_ufficiali;
					create table gisa_controlli_ufficiali(id_controllo bigint, id_asl int, asl text, data_inizio_controllo timestamp, data_fine_controllo timestamp, data_chiusura_controllo timestamp, id_dbi_gisa bigint);
					';*/
				str_CU = '
					perform "Analisi_dev".pg_terminate_backend_mdgm();
					delete from gisa_controlli_ufficiali;
				';
				
				str_INS_CU = str_INS_CU || '
						insert into gisa_controlli_ufficiali select id_controllo, id_asl, asl, data_inizio_controllo, data_fine_controllo, data_chiusura_controllo, (select id from gisadbi where tname = '''||C.tname||''') as id_dbi_gisa from h_'||C.tname||' where upper_inf(rng) is true;
						';
			end if;
			end if;
			
			update gisadbi set status = 'C' where id = C.id;
		
		end loop;
		str_MVW := '';
		if modalita = 'giornaliero' then 
			str_MVW = '
				perform create_view_validi('''||modalita||''');
				perform ra.create_mvw();
				/*perform ra.create_mvw_iuv();
				perform ra.create_mvw_adhoc();
				perform ra.update_h_gisa_controlli_ufficiali();
				
				--perform matrix.create_view_consuntivati();

				perform creazione_vw_per_tabellone_cu();
				--perform digemon.create_view_digemon();
				--perform digemon.create_view_ocse();
				*/
				perform "Analisi_dev".purge_duplicati();

				execute ''update "Analisi_dev".check_columns_log set id_versione = (select max(id) from "Analisi_dev".versioni) where id_versione is null''; 

				 ';
		end if;
	
		str_PROC = str_CREATE || str_DECLARE || str_FETCH || str_CU || str_INS_CU || str_MVW || ' return ''1'';
					end;
					$b$;';	
		raise notice '%', str_PROC;			
		EXECUTE str_PROC;
	 	
		/*if id_gisadbi is null then
			update gisadbi set status = 'C' where status = 'A';
		end if;*/
		
		return str_PROC;
	end;
$_$;


ALTER FUNCTION "Analisi_dev".update_dbi(modalita text, sistema text, id_gisadbi integer) OWNER TO postgres;

--
-- Name: update_dbi_values(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".update_dbi_values() RETURNS text
    LANGUAGE plpgsql
    AS $$ DECLARE
							rec record;
							curs_dpat_piano_attivita_new CURSOR FOR 
								select count(*),max(rowid) as rowid,max(f),min(f),row(rng, id,cod_raggruppamento,id_sezione,anno,descrizione,ordinamento,data_scadenza,stato,codice_esame,tipo_attivita,codice_interno_piano,codice_interno_attivita,alias_piano,alias_attivita,codice_alias_attivita,entered,modified,entered_by,modified_by,note_hd) as r 
								from
								(select ctid as rowid, 'm' as f, int8range(currval('"Analisi_dev".vers_seq'), null ) as rng, id,cod_raggruppamento,id_sezione,anno,descrizione,ordinamento,data_scadenza,stato,codice_esame,tipo_attivita,codice_interno_piano,codice_interno_attivita,alias_piano,alias_attivita,codice_alias_attivita,entered,modified,entered_by,modified_by,note_hd
								from "Analisi_dev".h_dpat_piano_attivita_new m where upper(rng) is null
								union
								select null as rowid,'v' as f, int8range(currval('"Analisi_dev".vers_seq'), null ) as rng, id,cod_raggruppamento,id_sezione,anno,descrizione,ordinamento,data_scadenza,stato,codice_esame,tipo_attivita,codice_interno_piano,codice_interno_attivita,alias_piano,alias_attivita,codice_alias_attivita,entered,modified,entered_by,modified_by,note_hd
								from "Analisi_dev".vw_dpat_piano_attivita_new vw) s
								group by id,cod_raggruppamento,id_sezione,anno,descrizione,ordinamento,data_scadenza,stato,codice_esame,tipo_attivita,codice_interno_piano,codice_interno_attivita,alias_piano,alias_attivita,codice_alias_attivita,entered,modified,entered_by,modified_by,note_hd, rng
								order by count(*);
							rec_dpat_piano_attivita_new  "Analisi_dev".h_dpat_piano_attivita_new%ROWTYPE; 
						
							curs_dpat_get_nominativi CURSOR FOR 
								select count(*),max(rowid) as rowid,max(f),min(f),row(rng, id_nominativo,id_anagrafica_nominativo,nominativo,codice_fiscale,qualifica,data_scadenza_nominativo,id_struttura_semplice,desc_strutt_semplice,stato_strutt_semplice,data_scadenza_strutt_semplice,id_strutt_complessa,desc_strutt_complessa,data_scadenza_strutt_complessa,stato_strutt_complessa,id_asl,anno) as r 
								from
								(select ctid as rowid, 'm' as f, int8range(currval('"Analisi_dev".vers_seq'), null ) as rng, id_nominativo,id_anagrafica_nominativo,nominativo,codice_fiscale,qualifica,data_scadenza_nominativo,id_struttura_semplice,desc_strutt_semplice,stato_strutt_semplice,data_scadenza_strutt_semplice,id_strutt_complessa,desc_strutt_complessa,data_scadenza_strutt_complessa,stato_strutt_complessa,id_asl,anno
								from "Analisi_dev".h_dpat_get_nominativi m where upper(rng) is null
								union
								select null as rowid,'v' as f, int8range(currval('"Analisi_dev".vers_seq'), null ) as rng, id_nominativo,id_anagrafica_nominativo,nominativo,codice_fiscale,qualifica,data_scadenza_nominativo,id_struttura_semplice,desc_strutt_semplice,stato_strutt_semplice,data_scadenza_strutt_semplice,id_strutt_complessa,desc_strutt_complessa,data_scadenza_strutt_complessa,stato_strutt_complessa,id_asl,anno
								from "Analisi_dev".vw_dpat_get_nominativi vw) s
								group by id_nominativo,id_anagrafica_nominativo,nominativo,codice_fiscale,qualifica,data_scadenza_nominativo,id_struttura_semplice,desc_strutt_semplice,stato_strutt_semplice,data_scadenza_strutt_semplice,id_strutt_complessa,desc_strutt_complessa,data_scadenza_strutt_complessa,stato_strutt_complessa,id_asl,anno, rng
								order by count(*);
							rec_dpat_get_nominativi  "Analisi_dev".h_dpat_get_nominativi%ROWTYPE; 
						
							curs_dpat_indicatore_new CURSOR FOR 
								select count(*),max(rowid) as rowid,max(f),min(f),row(rng, id,cod_raggruppamento,id_piano_attivita,anno,descrizione,ordinamento,data_scadenza,stato,codice_esame,codice_interno_indicatore,alias_indicatore,codice_interno_piani_gestione_cu,codice_interno_attivita_gestione_cu,codice_interno_univoco_tipo_attivita_gestione_cu,codice_alias_indicatore,flag_benessere,entered,modified,entered_by,modified_by,note_hd,tipo_item_dpat,rendic_per_campioni) as r 
								from
								(select ctid as rowid, 'm' as f, int8range(currval('"Analisi_dev".vers_seq'), null ) as rng, id,cod_raggruppamento,id_piano_attivita,anno,descrizione,ordinamento,data_scadenza,stato,codice_esame,codice_interno_indicatore,alias_indicatore,codice_interno_piani_gestione_cu,codice_interno_attivita_gestione_cu,codice_interno_univoco_tipo_attivita_gestione_cu,codice_alias_indicatore,flag_benessere,entered,modified,entered_by,modified_by,note_hd,tipo_item_dpat,rendic_per_campioni
								from "Analisi_dev".h_dpat_indicatore_new m where upper(rng) is null
								union
								select null as rowid,'v' as f, int8range(currval('"Analisi_dev".vers_seq'), null ) as rng, id,cod_raggruppamento,id_piano_attivita,anno,descrizione,ordinamento,data_scadenza,stato,codice_esame,codice_interno_indicatore,alias_indicatore,codice_interno_piani_gestione_cu,codice_interno_attivita_gestione_cu,codice_interno_univoco_tipo_attivita_gestione_cu,codice_alias_indicatore,flag_benessere,entered,modified,entered_by,modified_by,note_hd,tipo_item_dpat,rendic_per_campioni
								from "Analisi_dev".vw_dpat_indicatore_new vw) s
								group by id,cod_raggruppamento,id_piano_attivita,anno,descrizione,ordinamento,data_scadenza,stato,codice_esame,codice_interno_indicatore,alias_indicatore,codice_interno_piani_gestione_cu,codice_interno_attivita_gestione_cu,codice_interno_univoco_tipo_attivita_gestione_cu,codice_alias_indicatore,flag_benessere,entered,modified,entered_by,modified_by,note_hd,tipo_item_dpat,rendic_per_campioni, rng
								order by count(*);
							rec_dpat_indicatore_new  "Analisi_dev".h_dpat_indicatore_new%ROWTYPE; 
						
							curs_dpat_sez_new CURSOR FOR 
								select count(*),max(rowid) as rowid,max(f),min(f),row(rng, id,cod_raggruppamento,anno,descrizione,ordinamento,data_scadenza,stato,codice_interno,color,entered,modified,entered_by,modified_by) as r 
								from
								(select ctid as rowid, 'm' as f, int8range(currval('"Analisi_dev".vers_seq'), null ) as rng, id,cod_raggruppamento,anno,descrizione,ordinamento,data_scadenza,stato,codice_interno,color,entered,modified,entered_by,modified_by
								from "Analisi_dev".h_dpat_sez_new m where upper(rng) is null
								union
								select null as rowid,'v' as f, int8range(currval('"Analisi_dev".vers_seq'), null ) as rng, id,cod_raggruppamento,anno,descrizione,ordinamento,data_scadenza,stato,codice_interno,color,entered,modified,entered_by,modified_by
								from "Analisi_dev".vw_dpat_sez_new vw) s
								group by id,cod_raggruppamento,anno,descrizione,ordinamento,data_scadenza,stato,codice_interno,color,entered,modified,entered_by,modified_by, rng
								order by count(*);
							rec_dpat_sez_new  "Analisi_dev".h_dpat_sez_new%ROWTYPE; 
						
							curs_oia_nodo CURSOR FOR 
								select count(*),max(rowid) as rowid,max(f),min(f),row(rng, id,id_padre,id_asl,descrizione_lunga,n_livello,entered,entered_by,modified,modified_by,trashed_date,tipologia_struttura,comune,enabled,obsoleto,confermato,id_strumento_calcolo,codice_interno_fk,nome,id_utente,mail,indirizzo,delegato,descrizione_comune,id_oia_nodo_temp,data_scadenza,disabilitata,stato,anno,descrizione_area_struttura_complessa,id_lookup_area_struttura_asl,ui_struttura_foglio_att_iniziale,ui_struttura_foglio_att_finale,id_utente_edit,percentuale_area_a,stato_all2,stato_all6,codice_interno_univoco,descrizione_area_struttura,data_congelamento) as r 
								from
								(select ctid as rowid, 'm' as f, int8range(currval('"Analisi_dev".vers_seq'), null ) as rng, id,id_padre,id_asl,descrizione_lunga,n_livello,entered,entered_by,modified,modified_by,trashed_date,tipologia_struttura,comune,enabled,obsoleto,confermato,id_strumento_calcolo,codice_interno_fk,nome,id_utente,mail,indirizzo,delegato,descrizione_comune,id_oia_nodo_temp,data_scadenza,disabilitata,stato,anno,descrizione_area_struttura_complessa,id_lookup_area_struttura_asl,ui_struttura_foglio_att_iniziale,ui_struttura_foglio_att_finale,id_utente_edit,percentuale_area_a,stato_all2,stato_all6,codice_interno_univoco,descrizione_area_struttura,data_congelamento
								from "Analisi_dev".h_oia_nodo m where upper(rng) is null
								union
								select null as rowid,'v' as f, int8range(currval('"Analisi_dev".vers_seq'), null ) as rng, id,id_padre,id_asl,descrizione_lunga,n_livello,entered,entered_by,modified,modified_by,trashed_date,tipologia_struttura,comune,enabled,obsoleto,confermato,id_strumento_calcolo,codice_interno_fk,nome,id_utente,mail,indirizzo,delegato,descrizione_comune,id_oia_nodo_temp,data_scadenza,disabilitata,stato,anno,descrizione_area_struttura_complessa,id_lookup_area_struttura_asl,ui_struttura_foglio_att_iniziale,ui_struttura_foglio_att_finale,id_utente_edit,percentuale_area_a,stato_all2,stato_all6,codice_interno_univoco,descrizione_area_struttura,data_congelamento
								from "Analisi_dev".vw_oia_nodo vw) s
								group by id,id_padre,id_asl,descrizione_lunga,n_livello,entered,entered_by,modified,modified_by,trashed_date,tipologia_struttura,comune,enabled,obsoleto,confermato,id_strumento_calcolo,codice_interno_fk,nome,id_utente,mail,indirizzo,delegato,descrizione_comune,id_oia_nodo_temp,data_scadenza,disabilitata,stato,anno,descrizione_area_struttura_complessa,id_lookup_area_struttura_asl,ui_struttura_foglio_att_iniziale,ui_struttura_foglio_att_finale,id_utente_edit,percentuale_area_a,stato_all2,stato_all6,codice_interno_univoco,descrizione_area_struttura,data_congelamento, rng
								order by count(*);
							rec_oia_nodo  "Analisi_dev".h_oia_nodo%ROWTYPE; 
						begin 
			set search_path to "Analisi_dev";
		 insert into versioni values(nextval('"Analisi_dev".vers_seq'), current_timestamp, current_user ); 
						
							raise notice '% open cursor dpat_piano_attivita_new ', clock_timestamp();
							open curs_dpat_piano_attivita_new;
							loop
								fetch curs_dpat_piano_attivita_new into rec;
								EXIT WHEN NOT FOUND;
								if rec.count <2 then
									if rec.max = 'm' then
										update "Analisi_dev".h_dpat_piano_attivita_new m set rng = int8range(lower(rng), currval('"Analisi_dev".vers_seq'))
										where m.ctid = rec.rowid;
									end if;
									if rec.min = 'v' then
										rec_dpat_piano_attivita_new = rec.r;
										insert into "Analisi_dev".h_dpat_piano_attivita_new values (rec_dpat_piano_attivita_new.*);
									end if;
								end if;
							end loop;
						 	CLOSE curs_dpat_piano_attivita_new;
							analyze verbose "Analisi_dev".h_dpat_piano_attivita_new;
							raise notice '% close cursor dpat_piano_attivita_new ', clock_timestamp();
							raise notice '--------------------------';
						  --  DEALLOCATE curs_dpat_piano_attivita_new;
						
							raise notice '% open cursor dpat_get_nominativi ', clock_timestamp();
							open curs_dpat_get_nominativi;
							loop
								fetch curs_dpat_get_nominativi into rec;
								EXIT WHEN NOT FOUND;
								if rec.count <2 then
									if rec.max = 'm' then
										update "Analisi_dev".h_dpat_get_nominativi m set rng = int8range(lower(rng), currval('"Analisi_dev".vers_seq'))
										where m.ctid = rec.rowid;
									end if;
									if rec.min = 'v' then
										rec_dpat_get_nominativi = rec.r;
										insert into "Analisi_dev".h_dpat_get_nominativi values (rec_dpat_get_nominativi.*);
									end if;
								end if;
							end loop;
						 	CLOSE curs_dpat_get_nominativi;
							analyze verbose "Analisi_dev".h_dpat_get_nominativi;
							raise notice '% close cursor dpat_get_nominativi ', clock_timestamp();
							raise notice '--------------------------';
						  --  DEALLOCATE curs_dpat_get_nominativi;
						
							raise notice '% open cursor dpat_indicatore_new ', clock_timestamp();
							open curs_dpat_indicatore_new;
							loop
								fetch curs_dpat_indicatore_new into rec;
								EXIT WHEN NOT FOUND;
								if rec.count <2 then
									if rec.max = 'm' then
										update "Analisi_dev".h_dpat_indicatore_new m set rng = int8range(lower(rng), currval('"Analisi_dev".vers_seq'))
										where m.ctid = rec.rowid;
									end if;
									if rec.min = 'v' then
										rec_dpat_indicatore_new = rec.r;
										insert into "Analisi_dev".h_dpat_indicatore_new values (rec_dpat_indicatore_new.*);
									end if;
								end if;
							end loop;
						 	CLOSE curs_dpat_indicatore_new;
							analyze verbose "Analisi_dev".h_dpat_indicatore_new;
							raise notice '% close cursor dpat_indicatore_new ', clock_timestamp();
							raise notice '--------------------------';
						  --  DEALLOCATE curs_dpat_indicatore_new;
						
							raise notice '% open cursor dpat_sez_new ', clock_timestamp();
							open curs_dpat_sez_new;
							loop
								fetch curs_dpat_sez_new into rec;
								EXIT WHEN NOT FOUND;
								if rec.count <2 then
									if rec.max = 'm' then
										update "Analisi_dev".h_dpat_sez_new m set rng = int8range(lower(rng), currval('"Analisi_dev".vers_seq'))
										where m.ctid = rec.rowid;
									end if;
									if rec.min = 'v' then
										rec_dpat_sez_new = rec.r;
										insert into "Analisi_dev".h_dpat_sez_new values (rec_dpat_sez_new.*);
									end if;
								end if;
							end loop;
						 	CLOSE curs_dpat_sez_new;
							analyze verbose "Analisi_dev".h_dpat_sez_new;
							raise notice '% close cursor dpat_sez_new ', clock_timestamp();
							raise notice '--------------------------';
						  --  DEALLOCATE curs_dpat_sez_new;
						
							raise notice '% open cursor oia_nodo ', clock_timestamp();
							open curs_oia_nodo;
							loop
								fetch curs_oia_nodo into rec;
								EXIT WHEN NOT FOUND;
								if rec.count <2 then
									if rec.max = 'm' then
										update "Analisi_dev".h_oia_nodo m set rng = int8range(lower(rng), currval('"Analisi_dev".vers_seq'))
										where m.ctid = rec.rowid;
									end if;
									if rec.min = 'v' then
										rec_oia_nodo = rec.r;
										insert into "Analisi_dev".h_oia_nodo values (rec_oia_nodo.*);
									end if;
								end if;
							end loop;
						 	CLOSE curs_oia_nodo;
							analyze verbose "Analisi_dev".h_oia_nodo;
							raise notice '% close cursor oia_nodo ', clock_timestamp();
							raise notice '--------------------------';
						  --  DEALLOCATE curs_oia_nodo;
						 return '1';
					end;
					$$;


ALTER FUNCTION "Analisi_dev".update_dbi_values() OWNER TO postgres;

--
-- Name: update_descrizioni_brevi(text); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".update_descrizioni_brevi(_tipo text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
		declare
			r record; 
			t record;
			cmd varchar;
		begin 
			for T in --select distinct tabella  from matrix.upd_descr_breve where tipo = _tipo
			select distinct tabella, ordine  from matrix.upd_descr_breve where tipo = _tipo order by ordine asc
			loop
				execute 'UPDATE '||T.tabella||' set descrizione_breve = upper(descrizione)';
			end loop;
			--update matrix.struttura_asl set descrizione_breve = upper(descrizione);
			for r in select * from matrix.upd_descr_breve where tipo = _tipo order by ordine asc loop
				if upper(r.metodo) = 'REPLACE' then
					execute 'UPDATE '||R.tabella||' SET DESCRIZIONE_BREVE = replace(upper(descrizione_breve),'''||replace(R.to_be_rep, '''', '''''')||''', '''||replace(R.rep, '''', '''''')||''') where descrizione_breve ilike '''||replace(R.condition, '''', '''''')||''' ';
				end if;
				if upper(r.metodo) = 'REGEXP_REPLACE' then
					cmd:= 'UPDATE '||R.tabella||' SET DESCRIZIONE_BREVE = regexp_replace(upper(descrizione_breve),'''||replace(R.to_be_rep, '''', '''''')||''', '''||replace(R.rep, '''', '''''')||''') where descrizione_breve ~ '''||replace(R.condition, '''', '''''')||''' ';
					raise notice 'CMD %',cmd;
					execute cmd;
				end if;
			end loop;
			return 1;
		end;
		$$;


ALTER FUNCTION "Analisi_dev".update_descrizioni_brevi(_tipo text) OWNER TO postgres;

--
-- Name: update_h_gisa_controlli_ufficiali(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".update_h_gisa_controlli_ufficiali() RETURNS bigint
    LANGUAGE plpgsql
    AS $$ 
declare

	rec record;

	versione_corrente bigint;

	curs_gisa_controlli_ufficiali CURSOR FOR 
		select count(*),max(rowid) as rowid,max(f),min(f),row(id_controllo , codice_linea , id_motivo , id_unita_operativa , data_inizio_controllo , riferimento_id , riferimento_nome_tab , eseguiti , fonte, rng) as r 
		from
		(select ctid as rowid, 'm' as f,id_controllo , codice_linea , id_motivo , id_unita_operativa , data_inizio_controllo , riferimento_id , riferimento_nome_tab , eseguiti , fonte , int8range(versione_corrente, null ) as rng
		from "Analisi_dev".h_gisa_controlli_ufficiali m where upper(rng) is null
		union
		select null as rowid,'v' as f,id_controllo , codice_linea , id_motivo , id_unita_operativa , data_inizio_controllo , riferimento_id , riferimento_nome_tab , eseguiti , fonte  , int8range(versione_corrente, null ) as rng
		from "Analisi_dev".vw_gisa_controlli_ufficiali vw) s
		group by id_controllo , codice_linea , id_motivo , id_unita_operativa , data_inizio_controllo , riferimento_id , riferimento_nome_tab , eseguiti , fonte , rng 
		order by count(*);
	rec_gisa_controlli_ufficiali  "Analisi_dev".h_gisa_controlli_ufficiali%ROWTYPE;

begin
	
	set search_path to "Analisi_dev";

	select max(id) into versione_corrente from versioni;



	open curs_gisa_controlli_ufficiali;
	loop
		fetch curs_gisa_controlli_ufficiali into rec;
		EXIT WHEN NOT FOUND;
		if rec.count <2 then
			if rec.max = 'm' then
				update "Analisi_dev".h_gisa_controlli_ufficiali m set rng = int8range(lower(rng), versione_corrente)
				where m.ctid = rec.rowid;
			end if;
			if rec.min = 'v' then
				rec_gisa_controlli_ufficiali = rec.r;
				insert into "Analisi_dev".h_gisa_controlli_ufficiali values (rec_gisa_controlli_ufficiali.*);
			end if;
		end if;
	end loop;

	return 1;
	
end;
$$;


ALTER FUNCTION "Analisi_dev".update_h_gisa_controlli_ufficiali() OWNER TO postgres;

--
-- Name: update_rendic_per_campioni(); Type: FUNCTION; Schema: Analisi_dev; Owner: postgres
--

CREATE FUNCTION "Analisi_dev".update_rendic_per_campioni() RETURNS integer
    LANGUAGE plpgsql
    AS $$
 begin
	 update matrix.struttura_piani set ha_campioni = false;
	 update matrix.struttura_piani p set ha_campioni = true from "Analisi_dev".vw_dpat_indicatore_new_validi i where rendic_per_campioni and p.id_gisa = i.id;
	 return 1;
 end;
 $$;


ALTER FUNCTION "Analisi_dev".update_rendic_per_campioni() OWNER TO postgres;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: result_type; Type: TABLE; Schema: ag_types; Owner: postgres
--

CREATE TABLE ag_types.result_type (
    esito boolean,
    valore text,
    msg character varying,
    info character varying,
    err_msg character varying
);


ALTER TABLE ag_types.result_type OWNER TO postgres;

--
-- Name: get_ag_conf(json, bigint); Type: FUNCTION; Schema: ag_conf; Owner: postgres
--

CREATE FUNCTION ag_conf.get_ag_conf(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idelabcal bigint;
	proc_name varchar;
	R_CAL agenda.vw_calendari%ROWTYPE;
	R_EC agenda.vw_elab_cals%ROWTYPE;
	REC Record;
	rt json;

	begin
		proc_name:='ag_conf.get_ag_conf';
	
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(c.*)) into rt from ag_conf.vw_ag_conf c;

		raise notice '%',rt;
	
		if rt is null then
			ret.esito:=false;	
    		--ret.msg:='ealb_cal_params non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'get_ag_conf_valori_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
 		
 		
 					ret.info:='{"dati":' || rt;
			ret.info:=ret.info || '}';
	 		--ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION ag_conf.get_ag_conf(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_manuali(json, bigint); Type: FUNCTION; Schema: ag_conf; Owner: postgres
--

CREATE FUNCTION ag_conf.get_manuali(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idelabcal bigint;
	proc_name varchar;
	R_CAL agenda.vw_calendari%ROWTYPE;
	R_EC agenda.vw_elab_cals%ROWTYPE;
	REC Record;
	rt json;

	begin
		proc_name:='ag_conf.get_manuali';
	
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(c.*)) into rt from ag_conf.vw_manuali c;

		raise notice '%',rt;
	
		if rt is null then
			ret.esito:=false;	
    		--ret.msg:='ealb_cal_params non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'get_manuali_valori_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
 		
 		
 			ret.info:='{"dati":' || rt;
			ret.info:=ret.info || '}';
	 		--ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION ag_conf.get_manuali(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_value(character varying, timestamp without time zone); Type: FUNCTION; Schema: ag_conf; Owner: postgres
--

CREATE FUNCTION ag_conf.get_value(c character varying, ts timestamp without time zone) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare
       v varchar;
       k integer;
	begin
		select value::decimal into v from ag_conf.vw_ag_conf where cod=c and validita @> ts order by valido_da desc limit 1;
		get diagnostics k = row_count; 
		raise notice 'ag_conf.get_value (%,%) TROVATI % valori' ,c,ts,v;
		if k <= 0 then
			return null;
		end if;
		return v;
	end;
end;
$$;


ALTER FUNCTION ag_conf.get_value(c character varying, ts timestamp without time zone) OWNER TO postgres;

--
-- Name: load_piano_tipo_linee(json, bigint); Type: FUNCTION; Schema: ag_conf; Owner: postgres
--

CREATE FUNCTION ag_conf.load_piano_tipo_linee(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	proc_name varchar;
	begin
		proc_name:='ag_conf.load_piano_tipo_linee';

delete from agenda.piano_tipo_linea ;

insert into agenda.piano_tipo_linea 

select id,id_node, nextval('agenda.agenda_id_seq') from (
select distinct a.id,u.id_node
from (
			select distinct p.id,p.alias,tipo_linea,descrizione,
				case when tipo_linea ilike '%allevamenti%' then 
					case
					when descrizione ilike '%vitelli%' then 'bovini'
					when descrizione ilike '%avicoli%' then 'avicoli'
					when descrizione ilike '%broiler%' then 'avicoli'
					when descrizione ilike '%ovaiol%' then 'avicoli'
					when descrizione ilike '%apiar%' then 'api'
					when descrizione ilike '%equidi%' then 'cavalli'
					when descrizione ilike '%annutol%' then 'bufalini'
					else split_part( regexp_replace(descrizione,
						'.*allevament. *',''),' ',1) end else tipo_linea end a ,
			tipo_linea,f.* from conf_ext.dpar_piani_tipolinea_frequenze f 
			join matrix.struttura_piani p on p.alias =f.alias_indicatore
			where tipo_linea is not null and upper(tipo_linea) not in ('','TUTTE','CONTROLLO',',','ISPEZIONE')
			order by alias) a
			 join agenda.vw_tipo_linee tl on upper(tl.descr) =upper(a.a)
			join agenda.vw_ag_tree_nodes_down n on tl.id=n.id_node_ref
			join agenda.vw_ag_tree_nodes_up   u on  u.id_node=n.id_node
			and u.lv =4 ) c;

insert into agenda.piano_tipo_linea 


select id,id_node, nextval('agenda.agenda_id_seq') 
from (
select distinct a.id,u.id id_node
from (
			select distinct p.id,p.alias,tipo_linea,descrizione,
				tipo_linea a ,
			tipo_linea,f.* from conf_ext.dpar_piani_tipolinea_frequenze f 
			join matrix.struttura_piani p on p.alias =f.alias_indicatore
			where tipo_linea is not null and upper(tipo_linea) not in ('','TUTTE','CONTROLLO',',','ISPEZIONE')
			order by alias) a
			 join agenda.vw_ag_tree_nodes_up tl on upper(split_part(tl.node_descr ,'-',1)) =upper(a.a)
			join agenda.vw_ag_tree_nodes_down n on tl.id_node=n.id_node_ref
			join agenda.vw_ag_tree_nodes_up_tipo_linee    u on  u.id_node=n.id_node
			and u.livello  =4 ) c;


/*select id,tl_id, nextval('agenda.agenda_id_seq') from (


			select   distinct a.id, tl.id tl_id--a.alias,,tl.descr 
			--,upper(split_part(a.a,' ',1)),upper(split_part(split_part(t.cod,'-',1),' ',1))
			from (
			select p.id,p.alias,tipo_linea,descrizione,
				case when tipo_linea ilike '%allevamenti%' then 
					case
					when descrizione ilike '%avicoli%' then 'avicoli'
					when descrizione ilike '%broiler%' then 'avicoli'
					when descrizione ilike '%ovaiol%' then 'avicoli'
					when descrizione ilike '%apiar%' then 'api'
					when descrizione ilike '%equidi%' then 'cavalli'
					when descrizione ilike '%annutol%' then 'bufalini'
					else split_part( regexp_replace(descrizione,
						'.*allevament. *',''),' ',1) end else tipo_linea end a ,
			tipo_linea,f.* from conf_ext.dpar_piani_tipolinea_frequenze f 
			join matrix.struttura_piani p on p.alias =f.alias_indicatore
			where tipo_linea is not null and upper(tipo_linea) not in ('','TUTTE','CONTROLLO',',','ISPEZIONE')
			order by alias) a  join agenda.vw_ag_tree_nodes_up_tipo_linee t
				on upper(split_part(a.a,' ',1))=upper(split_part(split_part(t.cod,'-',1),' ',1))
				
				
				join agenda.vw_ag_tree_nodes_down n on t.id_node=n.id_node_ref
				--where t.livello =4
				join agenda.vw_ag_tree_nodes_up_tipo_linee tl on tl.id_node =n.id_node and tl.livello=4   ) b;*/
				
					 	return ret;
	end;
end;
$$;


ALTER FUNCTION ag_conf.load_piano_tipo_linee(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ag_conf(json, bigint); Type: FUNCTION; Schema: ag_conf; Owner: postgres
--

CREATE FUNCTION ag_conf.upd_ag_conf(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        proc_name varchar; -- end
        R Record;
       n integer;
        --R_EC agenda.elab_cals%ROWTYPE;
        begin
		proc_name:='ag_conf.upd_ag_conf';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V=%',v_j;
	
		for R in select id_ag_conf,value from json_populate_recordset(null::record,v_j->'valori') as
					(id_ag_conf int8,value varchar) loop
			update ag_conf.ag_conf set value=R.value where id=R.id_ag_conf;
			n:=ag_log.upd_record('ag_conf.ag_conf',idtransazione,R,'U');
		end loop;
		
		/*from (select id_ag_conf,value from json_populate_recordset(null::record,v_j->'valori') as
					(id_ag_conf int8,value varchar)) s
			where id=s.id_ag_conf;*/
		
    	ret.esito:=true;	
		ret:=ag_ui.build_ret(ret,proc_name,null::varchar);
		return ret;
	end;
END
$$;


ALTER FUNCTION ag_conf.upd_ag_conf(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: end_op(character varying, bigint, character varying); Type: FUNCTION; Schema: ag_log; Owner: postgres
--

CREATE FUNCTION ag_log.end_op(pname character varying, idtransazione bigint, v character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	begin
		insert into ag_log.call_logs   values (nextval('ag_log.call_logs_id_seq'),idtransazione,pname,'END',CLOCK_TIMESTAMP(),v);
		/*if length(v)>0 then
			update ag_log.operazioni set ret=v,ts_end=CLOCK_TIMESTAMP()
			where id_transazione=idtransazione and ret is null and procedura=pname;
		else
			update ag_log.operazioni set ret=v,ts_end=CLOCK_TIMESTAMP()
			where id_transazione=idtransazione and ret is null and procedura=pname;
		end if;*/
		return(currval('ag_log.call_logs_id_seq'));
	end;
END
$$;


ALTER FUNCTION ag_log.end_op(pname character varying, idtransazione bigint, v character varying) OWNER TO postgres;

--
-- Name: get_id_transazione(bigint); Type: FUNCTION; Schema: ag_log; Owner: postgres
--

CREATE FUNCTION ag_log.get_id_transazione(iduser bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare R_T ag_log.transazioni%ROWTYPE;
	begin
		R_T.id=nextval('ag_log.transazioni_id_seq');
		R_T.id_user=iduser;
		R_T.ts:=current_timestamp;
		insert into ag_log.transazioni values (R_T.*);
		return R_T.id;
	end;
END
$$;


ALTER FUNCTION ag_log.get_id_transazione(iduser bigint) OWNER TO postgres;

--
-- Name: get_id_transazione(bigint, character varying); Type: FUNCTION; Schema: ag_log; Owner: postgres
--

CREATE FUNCTION ag_log.get_id_transazione(iduser bigint, titolo character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare R_T ag_log.transazioni%ROWTYPE;
	begin
		raise notice 'id_utente%',iduser;
		R_T.id=nextval('ag_log.transazioni_id_seq');
		R_T.id_user=iduser;
		R_T.ts:=current_timestamp;
		R_T.descr:=titolo;
		insert into ag_log.transazioni values (R_T.*);
		return R_T.id;
	end;
END
$$;


ALTER FUNCTION ag_log.get_id_transazione(iduser bigint, titolo character varying) OWNER TO postgres;

--
-- Name: op(character varying, bigint, character varying, json, timestamp without time zone, bigint, character varying); Type: FUNCTION; Schema: ag_log; Owner: postgres
--

CREATE FUNCTION ag_log.op(pname character varying, idtransazione bigint, param character varying, v json, tsstart timestamp without time zone, idtrattato bigint DEFAULT '-1'::integer, tipooperazione character varying DEFAULT ''::character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	stmt varchar;
	begin
		
		/*stmt:= format('insert into ag_log.operazioni (id,id_transazione,procedura,fase,ts_start,ts_end,ts_transazione,val,id_trattato,ret) 
		values (nextval(''ag_log.operazioni_id_seq''),%L,''%s'',''%s'',''%s'',CLOCK_TIMESTAMP(),current_timestamp,''%s'',
			%L,    		''%s'')',idtransazione,pname,tipooperazione,tsstart::varchar,param,idtrattato,v::varchar);
		perform dblink_exec('dbname=mdgm_fvg',stmt);*/
		insert into ag_log.operazioni  
			(id,id_transazione,procedura,fase,ts_start,ts_end,ts_transazione,val,id_trattato,ret) 
		values 
			(nextval('ag_log.operazioni_id_seq'),idtransazione,pname,tipooperazione,tsstart,CLOCK_TIMESTAMP(),current_timestamp,param,
			idtrattato,
				 '"esito":' ||coalesce(v->>'esito','')  ||
				',"valore":'||coalesce(v->>'valore','') ||
				',"msg":'   ||coalesce(v->>'msg'  ,''));

    	return(currval('ag_log.operazioni_id_seq'));
	end;
END
$$;


ALTER FUNCTION ag_log.op(pname character varying, idtransazione bigint, param character varying, v json, tsstart timestamp without time zone, idtrattato bigint, tipooperazione character varying) OWNER TO postgres;

--
-- Name: start_op(character varying, bigint, character varying, bigint); Type: FUNCTION; Schema: ag_log; Owner: postgres
--

CREATE FUNCTION ag_log.start_op(pname character varying, idtransazione bigint, param character varying, idtrattato bigint DEFAULT '-1'::integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	begin
		insert into ag_log.call_logs   values (nextval('ag_log.call_logs_id_seq'),idtransazione,pname,'START',CLOCK_TIMESTAMP(),param);
		--insert into ag_log.operazioni  (id,id_transazione,procedura,fase,ts_start,ts_transazione,val,id_trattato) values 
	--(nextval('ag_log.operazioni_id_seq'),idtransazione,pname,'START',CLOCK_TIMESTAMP(),current_timestamp,param,idtrattato);
		return(currval('ag_log.call_logs_id_seq'));
	end;
END
$$;


ALTER FUNCTION ag_log.start_op(pname character varying, idtransazione bigint, param character varying, idtrattato bigint) OWNER TO postgres;

--
-- Name: upd_record(character varying, bigint, record, character varying); Type: FUNCTION; Schema: ag_log; Owner: postgres
--

CREATE FUNCTION ag_log.upd_record(tbl character varying, idtransazione bigint, r record, act character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	r_new record;
	begin
		act = upper(act);
		raise notice 'TBL=% ACT=%',tbl,act;
		if act = 'D' or act = 'U' then
			raise notice 'D U TBL %',tbl;
			if    tbl = 'agenda.eventi'              then
				update ag_his.eventi             					set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id=R.id and upper_inf(his_validita);

			elsif tbl = 'trf.trf_attivita_forfet' then 
				update trf_his.trf_attivita_forfet      			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'ag_conf.ag_conf' then 
				update ag_conf.ag_conf      			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'trf.clienti' then 
				update trf_his.clienti     			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'trf.tariffa_strutture' then 
				update trf_his.tariffa_strutture     			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'trf.tariffa_voci' then 
				update trf_his.tariffa_voci   			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'trf.tariffa_voci_calcolo' then 
				update trf_his.tariffa_voci_calcolo   			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'trf.tariffe' then 
				update trf_his.tariffe   			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'trf.trf_att_inviate' then 
				update trf_his.trf_att_inviate   			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'trf.trf_attivita' then 
				update trf_his.trf_attivita   			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'trf.trf_attivita_dettagli' then 
				update trf_his.trf_attivita_dettagli   			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'trf.trf_att_inviate_stati' then 
				update trf_his.trf_att_inviate_stati   			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.asl_piani' then 
				update ag_his.asl_piani			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.attivita' then 
				update ag_his.attivita			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.avvisi' then 
				update ag_his.avvisi		set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.avviso_risorse' then 
				update ag_his.avviso_risorse 		set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.linea_piani' then 
				update ag_his.linea_piani		set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.linee_selezionate' then 
				update ag_his.linee_selezionate			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.nominativo_az_sedi' then 
				update ag_his.nominativo_az_sedi		set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.nominativo_comuni' then 
				update ag_his.nominativo_comuni		set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.nominativo_linee' then 
				update ag_his.nominativo_linee 		set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.nominativo_piani' then 
				update ag_his.nominativo_piani 		set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.piano_freq' then 
				update ag_his.piano_freq 		set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.piano_periodo' then 
				update ag_his.piano_periodo		set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.piano_tipo_linea' then 
				update ag_his.piano_tipo_linea		set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.struttura_asl' then 
				update ag_his.struttura_asl			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.struttura_comuni' then 
				update ag_his.struttura_comuni			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.struttura_piani' then 
				update ag_his.struttura_piani		set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.tipo_lista_piano' then 
				update ag_his.tipo_lista_piano			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.tipo_liste' then 
				update ag_his.tipo_liste			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.tipologia_controllo_piani' then 
				update ag_his.tipologia_controllo_piani 		set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.tree_nodes' then 
				update ag_his.tree_nodes			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.unita_di_crisi' then 
				update ag_his.unita_di_crisi			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.utente_strutture' then 
				update ag_his.utente_strutture			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.cf_liste' then 
				update ag_his.cf_liste			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.lista_import' then 
				update ag_his.lista_import			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.elab_cals' then 
				update ag_his.elab_cals			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.elab_cals_params' then 
				update ag_his.elab_cals_param		set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			elsif tbl = 'agenda.elab_cal_param_ns_piani' then 
				update ag_his.elab_cal_param_ns_piani		set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
					where id  =R.id and upper_inf(his_validita);
			else
				return -1;
			end if;
		end if;
		if act = 'U' or act = 'I' then
			raise notice 'I U TBL %',tbl;
			if    tbl = 'agenda.eventi'              then
				insert into ag_his.eventi
				select nextval('ag_log.his_id_seq'),              tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
					from agenda.eventi e           where id=r.id;				
			elsif tbl = 'trf.trf_attivita_forfet'               then
				insert into trf_his.trf_attivita_forfet 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, i.*           
					from trf.trf_attivita_forfet i where id=r.id;
			elsif tbl = 'ag_conf.ag_conf'               then
				insert into ag_conf.ag_conf 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, ic.*           
					from ag_conf.ag_conf ic where id=r.id;	
			elsif tbl = 'trf.clienti'               then
				insert into trf_his.clienti 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, c.*           
					from trf.clienti c  where id=r.id;
			elsif tbl = 'trf.tariffa_strutture'               then
				insert into trf_his.tariffa_strutture  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, ts.*           
					from trf.tariffa_strutture ts  where id=r.id;
			elsif tbl = 'trf.tariffa_voci'               then
				insert into trf_his.tariffa_voci 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, tv.*           
					from trf.tariffa_voci tv where id=r.id;
			elsif tbl = 'trf.tariffa_voci_calcolo'               then
				insert into trf_his.tariffa_voci_calcolo  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, tvc.*           
					from trf.tariffa_voci_calcolo tvc  where id=r.id;
			elsif tbl = 'trf.tariffe'               then
				insert into trf_his.tariffe 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, t.*           
					from trf.tariffe t  where id=r.id;
			elsif tbl = 'trf.trf_att_inviate'               then
				insert into trf_his.trf_att_inviate 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, tai.*           
					from trf.trf_att_inviate tai where id=r.id;
			elsif tbl = 'trf.trf_attivita'               then
				insert into trf_his.trf_attivita  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, ta.*           
					from trf.trf_attivita ta where id=r.id;
			elsif tbl = 'trf.trf_attivita_dettagli'               then
				insert into trf_his.trf_attivita_dettagli
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, tad.*           
					from trf.trf_attivita_dettagli tad where id=r.id;
			elsif tbl = 'trf.trf_attivita_forfet'               then
				insert into trf_his.trf_attivita_forfet
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, taf.*           
					from trf.trf_attivita_forfet taf where id=r.id;
			elsif tbl = 'trf.trf_att_inviate_stati'               then
				insert into trf_his.trf_att_inviate_stati
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, taf.*           
					from trf.trf_att_inviate_stati taf where id=r.id;
			elsif tbl = 'agenda.asl_piani'              then
				insert into ag_his.asl_piani  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, ap.*           
					from agenda.asl_piani ap where id=r.id;
			elsif tbl = 'agenda.attivita'              then
				insert into ag_his.attivita  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, a.*           
					from agenda.attivita a where id=r.id;
			elsif tbl = 'agenda.avvisi'              then
				insert into ag_his.avvisi  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, a.*           
					from agenda.avvisi a where id=r.id;
			elsif tbl = 'agenda.avviso_risorse'              then
				insert into ag_his.avviso_risorse  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, ar.*           
					from agenda.avviso_risorse ar where id=r.id;
			elsif tbl = 'agenda.linea_piani'              then
				insert into ag_his.linea_piani 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, lp.*           
					from agenda.linea_piani lp  where id=r.id;
			elsif tbl = 'agenda.linee_selezionate'              then
				insert into ag_his.linee_selezionate 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, ls.*           
					from agenda.linee_selezionate ls where id=r.id;
			elsif tbl = 'agenda.nominativo_az_sedi'              then
				insert into ag_his.nominativo_az_sedi 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, nas.*           
					from agenda.nominativo_az_sedi nas where id=r.id;
			elsif tbl = 'agenda.nominativo_comuni'              then
				insert into ag_his.nominativo_comuni  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, nc.*           
					from agenda.nominativo_comuni nc where id=r.id;
			elsif tbl = 'agenda.nominativo_linee'              then
				insert into ag_his.nominativo_linee  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, nl.*           
					from agenda.nominativo_linee nl  where id=r.id;
			elsif tbl = 'agenda.nominativo_piani'              then
				insert into ag_his.nominativo_piani  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, np.*           
					from agenda.nominativo_piani np  where id=r.id;
			elsif tbl = 'agenda.piano_freq'              then
				insert into ag_his.piano_freq  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, pf.*           
					from agenda.piano_freq pf  where id=r.id;
			elsif tbl = 'agenda.piano_periodo'              then
				insert into ag_his.piano_periodo 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, pp.*           
					from agenda.piano_periodo pp  where id=r.id;
			elsif tbl = 'agenda.piano_tipo_linea'              then
				insert into ag_his.piano_tipo_linea  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, ptl.*           
					from agenda.piano_tipo_linea ptl  where id=r.id;
			elsif tbl = 'agenda.struttura_asl'              then
				insert into ag_his.struttura_asl  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, sa.*           
					from matrix.struttura_asl sa  where id=r.id;
			elsif tbl = 'agenda.struttura_piani'              then
				insert into ag_his.struttura_piani 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, sp.*           
					from matrix.struttura_piani sp  where id=r.id;
			elsif tbl = 'agenda.struttura_comuni'              then
				insert into ag_his.struttura_comuni  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, sc.*           
					from agenda.struttura_comuni sc  where id=r.id;
			elsif tbl = 'agenda.tipo_lista_piano'              then
				insert into ag_his.tipo_lista_piano  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, tlp.*           
					from agenda.tipo_lista_piano tlp  where id=r.id;
			elsif tbl = 'agenda.tipo_liste'              then
				insert into ag_his.tipo_liste  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, tl.*           
					from agenda.tipo_liste tl  where id=r.id;
			elsif tbl = 'agenda.tipologia_controllo_piani'              then
				insert into ag_his.tipologia_controllo_piani  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, tcp.*           
					from agenda.tipologia_controllo_piani tcp  where id=r.id;
			elsif tbl = 'agenda.tree_nodes'              then
				insert into ag_his.tree_nodes  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, tn.*           
					from matrix.tree_nodes tn  where id=r.id;
			elsif tbl = 'agenda.unita_di_crisi'              then
				insert into ag_his.unita_di_crisi  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, udc.*           
					from agenda.unita_di_crisi udc  where id=r.id;
			elsif tbl = 'agenda.utente_strutture'              then
				insert into ag_his.utente_strutture  
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, us.*           
					from rbac.utente_strutture us  where id=r.id;
			elsif tbl = 'agenda.cf_liste'              then
				insert into ag_his.cf_liste 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, cl.*           
					from agenda.cf_liste cl  where id=r.id;
			elsif tbl = 'agenda.lista_import'              then
				insert into ag_his.lista_import 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, li.*           
					from agenda.lista_import li where id=r.id;
			elsif tbl = 'agenda.elab_cals'              then
				insert into ag_his.elab_cals 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, ec.*           
					from agenda.elab_cals ec where id=r.id;
			elsif tbl = 'agenda.elab_cals_params'              then
				insert into ag_his.elab_cals_param 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, ec.*           
					from agenda.elab_cal_params ec where id=r.id;
			elsif tbl = 'agenda.elab_cal_param_ns_piani'              then
				insert into ag_his.elab_cal_param_ns_piani 
			 	select nextval('ag_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, vecpnp.id, vecpnp.id_elab_cal, vecpnp.id_piano       
					from agenda.vw_elab_cal_param_ns_piani vecpnp where id=r.id;
			else
				return -1;
			end if;
		end if;
		return 0;
	end;
END
$$;


ALTER FUNCTION ag_log.upd_record(tbl character varying, idtransazione bigint, r record, act character varying) OWNER TO postgres;

--
-- Name: get_dati(character varying, character varying, bigint, json); Type: PROCEDURE; Schema: ag_srv; Owner: postgres
--

CREATE PROCEDURE ag_srv.get_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json)
    LANGUAGE plpgsql
    AS $$
begin
	declare
		proc_name varchar;
	begin
		proc_name:='ag_srv.get_dati';
		call agenda.get_dati(operazione,v,idutente,joutput);
	end;
END
$$;


ALTER PROCEDURE ag_srv.get_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json) OWNER TO postgres;

--
-- Name: get_dati_f(character varying, character varying, bigint); Type: FUNCTION; Schema: ag_srv; Owner: postgres
--

CREATE FUNCTION ag_srv.get_dati_f(operazione character varying, v character varying, idutente bigint) RETURNS TABLE(j json)
    LANGUAGE plpgsql
    AS $$
begin
	declare
		proc_name varchar;
		joutput json;
	begin
		proc_name:='ag_srv.get_dati_f';
		call agenda.get_dati(operazione,v,idutente,joutput);
		return query select joutput j;
	end;
END
$$;


ALTER FUNCTION ag_srv.get_dati_f(operazione character varying, v character varying, idutente bigint) OWNER TO postgres;

--
-- Name: get_id_transazione(bigint); Type: FUNCTION; Schema: ag_srv; Owner: postgres
--

CREATE FUNCTION ag_srv.get_id_transazione(iduser bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare R_T ag_log.transazioni%ROWTYPE;
	proc_name varchar;
	id_op bigint;

	begin
		proc_name:='ag_srv.get_id_transazione';
	    R_T.id:=ag_log.get_id_transazione(iduser);
		id_op:=ag_log.start_op(proc_name, R_T.id ,'');
		id_op:=ag_log.end_op(proc_name, R_T.id , '');
		return R_T.id;

	end;
END
$$;


ALTER FUNCTION ag_srv.get_id_transazione(iduser bigint) OWNER TO postgres;

--
-- Name: ins_evento(character varying, bigint); Type: FUNCTION; Schema: ag_srv; Owner: postgres
--

CREATE FUNCTION ag_srv.ins_evento(v character varying, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare
	proc_name varchar;
	ret ag_types.result_type%ROWTYPE;
	id_op bigint;
	rt character varying;
		text_msg1 varchar;	
		text_msg2 varchar;	
		text_msg3 varchar;	
		text_msg4 varchar;
begin
	proc_name:='ag_srv.ins_evento';
	id_op:=ag_log.start_op(proc_name,idtransazione ,v);
	ret:= agenda.ins_evento(v,idtransazione) ;
	ret:=ag_ui.build_ret(ret,proc_name, ret.valore);
	rt:=row_to_json(ret);
	id_op:=ag_log.end_op(proc_name,idtransazione ,rt::varchar);
	return rt;
		exception when others then
			GET STACKED DIAGNOSTICS text_msg1 = MESSAGE_TEXT,
                          			text_msg2 = PG_EXCEPTION_DETAIL,
                          			text_msg3 = PG_EXCEPTION_HINT,
                         			text_msg4 = PG_EXCEPTION_CONTEXT;
			ret.esito:=false;
			ret.valore:= null;
			ret.msg:=coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');
			rt:=row_to_json(ret);
			id_op:=ag_log.end_op(proc_name,idtransazione ,rt);
			return rt;
end;
end
$$;


ALTER FUNCTION ag_srv.ins_evento(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_dati(character varying, character varying, bigint, json); Type: PROCEDURE; Schema: ag_srv; Owner: postgres
--

CREATE PROCEDURE ag_srv.upd_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json)
    LANGUAGE plpgsql
    AS $$

	declare
		proc_name varchar;
		text_msg1 varchar;	
	text_msg2 varchar;	
	text_msg3 varchar;	
	text_msg4 varchar;
	ret ag_types.result_type;
	begin
		proc_name:='ag_srv.upd_dati';
		call agenda.upd_dati(operazione,v,idutente,joutput);

	end;

$$;


ALTER PROCEDURE ag_srv.upd_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json) OWNER TO postgres;

--
-- Name: build_ret(ag_types.result_type, character varying, bigint); Type: FUNCTION; Schema: ag_ui; Owner: postgres
--

CREATE FUNCTION ag_ui.build_ret(r ag_types.result_type, pname character varying, val bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	begin
		r.valore:= val;
		--if not r.esito then
			--r.msg:=coalesce(r.msg,'') || ' ('|| coalesce(r.valore,-1)||')' ;
			r.msg:=coalesce(r.msg,'') ||' '||CHR(13)|| ag_ui.get_proc_msg(pname,r.valore) || ' ['||coalesce(pname,'PROC UNDEFINED') ||' ('||val||') ]';
		-- ||'  ' ['||coalesce(pname,'PROC UNDEFINED')||' ('||val||') ] 
		--end if;
		return r;
	end;
END
$$;


ALTER FUNCTION ag_ui.build_ret(r ag_types.result_type, pname character varying, val bigint) OWNER TO postgres;

--
-- Name: build_ret(ag_types.result_type, character varying, character varying); Type: FUNCTION; Schema: ag_ui; Owner: postgres
--

CREATE FUNCTION ag_ui.build_ret(r ag_types.result_type, pname character varying, val character varying) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	begin
		--r.valore:= val;
		--if not r.esito then
			--r.msg:=coalesce(r.msg,'') || ' ('|| coalesce(r.valore,-1)||')' ;
			r.msg:=/*coalesce(r.msg,'')||' '||CHR(13)||*/ag_ui.get_proc_msg(pname,val);
			if r.msg is null then 
				r.msg:='Messaggio non presente in tabella '||val;
				r.err_msg :=' ['||coalesce(pname,'PROC UNDEFINED')||' ('||val||') ] ';
			end if;
		--end if;
		return r;
	end;
END
$$;


ALTER FUNCTION ag_ui.build_ret(r ag_types.result_type, pname character varying, val character varying) OWNER TO postgres;

--
-- Name: build_ret_old(ag_types.result_type, character varying, bigint); Type: FUNCTION; Schema: ag_ui; Owner: postgres
--

CREATE FUNCTION ag_ui.build_ret_old(r ag_types.result_type, pname character varying, val bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	begin
		r.valore:= val;
		if not r.esito then
			--r.msg:=coalesce(r.msg,'') || ' ('|| coalesce(r.valore,-1)||')' ;
			r.msg:=coalesce(r.msg,'')||' '||CHR(13)||ag_ui.get_proc_msg(pname,r.valore)||' ['||coalesce(pname,'PROC UNDEFINED')||' ('||val||') ] ';
		end if;
		return r;
	end;
END
$$;


ALTER FUNCTION ag_ui.build_ret_old(r ag_types.result_type, pname character varying, val bigint) OWNER TO postgres;

--
-- Name: get_menu(json, bigint); Type: FUNCTION; Schema: ag_ui; Owner: postgres
--

CREATE FUNCTION ag_ui.get_menu(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	v_mn varchar;
	rt json;
	lv numeric;
	idasl numeric;
	idruolo bigint;
	begin
		proc_name:='ag_ui.get_menu';
		raise notice 'v=%',v;
		v_mn:=replace((v->'menu')::varchar,'"','');
	
		--return rbac_ui.get_menu(v, idtransazione); --26/06/2024

		
		if v_mn is null then
			ret.esito:=false;
			--ret.msg:='parametro menu non specificato';
		    ret:=ag_ui.build_ret(ret,proc_name, 'parametro_menu_non_specificato');
			ret.info:=rt;
			return ret;
		end if;
		
		lv:=v->'user_info'->'livello';
		idasl:=v->'user_info'->'id_asl';
		idruolo:=v->'user_info'->'id_ruolo';
		raise notice 'lv -> %', lv;
	
		raise notice 'v_mn=%',v_mn;	
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (
		select * from (
					select distinct on (mi.cod)  mi.cod, mi.icon, lv lev/*mm.lev*/,ord,mi.descr, mm.modality
					from ag_ui.menu m join ag_ui.menu_items mi on m.id=mi.id_menu 
				join ag_ui.menu_item_modes mm on mm.id_menu_item =mi.id
			where m.cod = v_mn
				and mm.lev_range @>lv
				and (mm.id_asl is null or mm.id_asl =idasl)
				and (mm.id_ruolo is null or mm.id_ruolo =idruolo)
				order by mi.cod ,ord
		) b order by b.ord) a;
	
		--ret.valore:= id_record;
	
	
	
		/*	select json_agg(row_to_json(a.*))  from (
		select * from (
					select distinct on (mi.cod)  mi.cod ,mm.lev,ord,mi.descr, mm.modality from ag_ui.menu m join ag_ui.menu_items mi on m.id=mi.id_menu 
				join ag_ui.menu_item_modes mm on mm.id_menu_item =mi.id
			where m.cod = 'config' and mm.lev>=2 order by mi.cod , mm.lev,ord
		) b order by b.ord) a*/
	
		raise notice '%',json_array_length(rt);

    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=rt;
	 	return ret;
	 	
	 	
	end;
end;
$$;


ALTER FUNCTION ag_ui.get_menu(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_proc_msg(character varying, bigint); Type: FUNCTION; Schema: ag_ui; Owner: postgres
--

CREATE FUNCTION ag_ui.get_proc_msg(proc character varying, cod bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare n integer;
	R_msg ag_ui.messaggi_ui%ROWTYPE;
begin
	select * into R_msg from ag_ui.messaggi_ui where procedura=proc and valore=cod::text;
	if R_msg.id is not null then
		return coalesce(R_msg.msg,'');
	end if;
	if cod < 0 then
		return 'ERRORE GENERICO ';
	end if;

	if cod = 0 then
		return 'DATI SALVATI';
	end if;
	return /*'ERRORE ['||proc||'] */'( '||cod||' )' ;
end;
end
$$;


ALTER FUNCTION ag_ui.get_proc_msg(proc character varying, cod bigint) OWNER TO postgres;

--
-- Name: get_proc_msg(character varying, character varying); Type: FUNCTION; Schema: ag_ui; Owner: postgres
--

CREATE FUNCTION ag_ui.get_proc_msg(proc character varying, cod character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare n integer;
	R_msg ag_ui.messaggi_ui%ROWTYPE;
begin
	select * into R_msg from ag_ui.messaggi_ui where procedura=proc and valore=cod;
	if R_msg.id is not null then
		return coalesce(R_msg.msg,'');
	end if;
	if cod is null and cod != '0' then
		return 'ERRORE GENERICO ('|| cod ||')';
	end if;

	if cod = '0' then
		return 'DATI SALVATI';
	end if;
	return /* 'ERRORE ['||proc||'] */ '( '||cod||' )' ;
end;
end
$$;


ALTER FUNCTION ag_ui.get_proc_msg(proc character varying, cod character varying) OWNER TO postgres;

--
-- Name: get_ui_definition(character varying, character varying, bigint, bigint); Type: FUNCTION; Schema: ag_ui; Owner: postgres
--

CREATE FUNCTION ag_ui.get_ui_definition(type_info character varying, fnct character varying, id_ns bigint, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare
	R_NS matrix.vw_nominativi_struttura;
	R_GD ag_ui.grid_definition;
	proc_name varchar;
	begin
		proc_name:='age_ui.get_ui_definition';
		raise notice 'type_info % fcnt % id_ns %',type_info,fnct,id_ns;

		case type_info
			when  'grid' then
			
				select * into R_GD from ag_ui.grid_definition gd join matrix.vw_tree_nodes_down t on t.id_node_ref=gd.id_user
					where t.id_node=id_ns and funct=fnct order by dist_node limit 1;
				/*select * into R_GD from ag_ui.grid_definition gd where gd.id_user =id_ns  and funct=fnct;
				if R_GD.id_user is null then
					select * into R_NS from matrix.vw_nominativi_struttura ns where id=id_ns;
	
					select * into R_GD from ag_ui.grid_definition gd join matrix.vw_tree_nodes_down t on t.id_node_ref=gd.id_user
					where t.id_node=R_NS.id_node_struttura and funct=fnct order by dist_node limit 1;
				end if;*/
			else
				select * into R_GD from ag_ui.grid_definition gd join matrix.vw_tree_nodes_down t on t.id_node_ref=gd.id_user
					where t.id_node=id_ns and funct=fnct order by dist_node limit 1;
		end case;
		return R_GD.str_conf;
	end;
end;
$$;


ALTER FUNCTION ag_ui.get_ui_definition(type_info character varying, fnct character varying, id_ns bigint, idtransazione bigint) OWNER TO postgres;

--
-- Name: aggiorna_linee_selezionate(bigint, integer); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.aggiorna_linee_selezionate(idelabcal bigint, v_anno integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare
	n bigint; 
	v_data varchar;
	v_piani varchar;
	v_ns varchar;
	begin
		delete from agenda.linee_selezionate where id_elab_cal =idelabcal;
		select trim(value)  into v_data from agenda.elab_cal_params
		where id_elab_cal=idelabcal and type_param='non_visitati_dal';
		if v_data='' then v_data = null; end if;
	
		select replace(replace(array_agg(id_piano)::varchar,'{','['),'}',']') into v_piani from agenda.elab_cal_param_piani 
		where id_elab_cal=idelabcal;
			
		select replace(replace(array_agg(id_ns)::varchar,'{','['),'}',']')  into v_ns from agenda.elab_cal_param_ns 
		where id_elab_cal=idelabcal;
	
		insert into agenda.linee_selezionate
		select  nextval('agenda.agenda_id_seq'),idelabcal,l.id_linea,l.id_piano from (

		
		select  distinct l.id_linea,np.id_piano--,l.denominazione_sede_operativa ,--l.indirizzo ,l.comune, 
		--sp.alias || ' - ' || sp.descrizione  descrizione_breve , l.cod_tipo_linea,l.piva,l.indirizzo_completo,
		--l.sd_cod_regionale
		from
		--select distinct l.id_linea from 
			matrix.nominativi_struttura ns
			join (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
			join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			join (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
			--join matrix.vw_struttura_piani sp on sp.id=p.id_piano
			join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
			join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune
			and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'
				or l.cod_tipologia_struttura in ('BDN', 'ALL'))
				left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
			left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=v_anno		
			left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
			left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=v_anno and lp.id_linea=l.id_linea
			where  coalesce(assegnate,0)<coalesce(pf.freq,1)
				and	 (tlp.id_piano is null or (tlp.id_piano is not null and lp.id_linea is not null))
				and ( (l.data_ultima_visita <=v_data::date or v_data is null) or l.data_ultima_visita is null or coalesce(pf.freq,1)>=1)
				and l.id not in (select id_linea from agenda.nominativo_linee nl)
		union
		select  distinct l.id_linea,np.id_piano--,l.denominazione_sede_operativa ,--l.indirizzo ,l.comune, 
		--sp.alias || ' - ' || sp.descrizione  descrizione_breve , l.cod_tipo_linea,l.piva,l.indirizzo_completo,
		--l.sd_cod_regionale
		from
		--select distinct l.id_linea from 
			matrix.nominativi_struttura ns
			join (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
			join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			join (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
			--join matrix.vw_struttura_piani sp on sp.id=p.id_piano
			join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
			join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune
			join agenda.nominativo_linee nl on nl.id_linea=l.id and 	a.id_ns=nl.id_nominativo_struttura 	
			and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'
				or l.cod_tipologia_struttura in ('BDN', 'ALL')) 
			left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
			left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=v_anno		
			left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
			left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=v_anno and lp.id_linea=l.id_linea
			where  coalesce(assegnate,0)<coalesce(pf.freq,1)
				and	 (tlp.id_piano is null or (tlp.id_piano is not null and lp.id_linea is not null))
				and ( (l.data_ultima_visita <=v_data::date or v_data is null) or l.data_ultima_visita is null or coalesce(pf.freq,1)>=1)
							
					) l;
	
		GET DIAGNOSTICS n = ROW_COUNT;
    	raise notice 'NS inseriti % record',  n;

 		return n;
	end;
END
$$;


ALTER FUNCTION agenda.aggiorna_linee_selezionate(idelabcal bigint, v_anno integer) OWNER TO postgres;

--
-- Name: annulla_elab_cal(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.annulla_elab_cal(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idelabcal bigint;
	proc_name varchar;
	n integer;
	rt json;
	R_EC agenda.elab_cals;
	R_A agenda.attivita;
	begin
		proc_name:='agenda.annulla_elab_cal';
	
		idelabcal:=v->'id_elab_cal';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');

	
		update agenda.elab_cals set tm_last_elab=null,tm_last_elab_start=null where id=idelabcal returning * into R_EC;
		n:=ag_log.upd_record('agenda.elab_cals',idtransazione,R_EC,'U');
		delete from agenda.attivita where  id_elab_cal=idelabcal;
		n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'D');
		select row_to_json(c.*) into rt from agenda.vw_elab_cals c
		where id=idelabcal;
	    delete from agenda.elab_cal_logs where id_elab_cal =idelabcal;
		raise notice '%',rt;
	
		if rt is null then
			ret.esito:=false;	
    		ret.msg:='ealb_cal non trovata';
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.annulla_elab_cal(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: att_elimina_data(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.att_elimina_data(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idns bigint;
        proc_name varchar; -- END
       	R_EV agenda.attivita; 
        idevento bigint;
        v_j json;
       	n integer;
        begin
		proc_name:='agenda.att_elimina_data';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		raise notice 'V=%',v;

		update agenda.attivita set dt=null 
			where id in (select (value::varchar)::bigint id from 
			json_array_elements(v_j->'id_attivita') ) returning * into R_EV;
		n:=ag_log.upd_record('agenda.attivita',idtransazione,R_EV,'D');

    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,R_EV.id);
        ret:=ag_ui.build_ret(ret,proc_name,'eliminazione_effettuata_con_successo');
		ret.info='0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.att_elimina_data(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: att_elimina_linea(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.att_elimina_linea(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idns bigint;
        proc_name varchar; -- END
       	R_EV agenda.attivita; 
        idevento bigint;
        v_j json;
       	n integer;
        begin
		proc_name:='agenda.att_elimina_linea';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		raise notice 'V=%',v;

		update agenda.attivita set id_linea=null 
			where id in (select (value::varchar)::bigint id from 
			json_array_elements(v_j->'id_attivita') ) returning * into R_EV;
		n:=ag_log.upd_record('agenda.attivita',idtransazione,R_EV,'D');

    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,R_EV.id);
       ret:=ag_ui.build_ret(ret,proc_name,'eliminazione_effettuata_con_successo');
		ret.info='0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.att_elimina_linea(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: att_elimina_nominativo(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.att_elimina_nominativo(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idns bigint;
        proc_name varchar; -- END
       	R_EV agenda.attivita; 
        idevento bigint;
        v_j json;
       	n integer;
        begin
		--proc_name:='agenda.att_elimina_data';
			proc_name:='agenda.att_elimina_nominativo';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		raise notice 'V=%',v;

		update agenda.attivita set id_risorsa=null 
			where id in (select (value::varchar)::bigint id from 
			json_array_elements(v_j->'id_attivita') ) returning * into R_EV;
		n:=ag_log.upd_record('agenda.attivita',idtransazione,R_EV,'D');

    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,R_EV.id);
        ret:=ag_ui.build_ret(ret,proc_name,'eliminazione_effettuata_con_successo');
		ret.info='0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.att_elimina_nominativo(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: carica_aziende(); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.carica_aziende() RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	begin

		
		delete from linee;
	delete from agenda.az_sedi;
delete from agenda.aziende;


insert into agenda.aziende select  nextval('agenda.agenda_id_seq'), * from (
select distinct "Approval Number" app_number,
"Ragione Sociale Impresa" rag_soc,"Partita Iva" piva,"Codice Fiscale" codfis
from config.az_853
union select distinct "Approval Number" app_number,
"Ragione Sociale Impresa" rag_soc,"Partita Iva" piva,"Codice Fiscale" codfis
from config.az_1069
union select distinct "Approval Number" app_number,
"Ragione Sociale Impresa" rag_soc,"Partita Iva" piva,"Codice Fiscale" codfis
from config.az_aromi
union select distinct "Approval Number" app_number,
"Ragione Sociale Impresa" rag_soc,"Partita Iva" piva,"Codice Fiscale" codfis
from config.az_particolari
union select distinct null,linea,null,null from config.stabfc852 s) a
where rag_soc is not null and rag_soc != '';

insert into agenda.az_sedi
select nextval('agenda.agenda_id_seq') id,* from (
select distinct a.id id_azienda,"Stato sede operativa","Denominazione sede operativa" ,indirizzo ,
c.id id_comune,sa.id id_struttura from config.az_1069 s
join agenda.aziende a on a.rag_soc=s."Ragione Sociale Impresa" and a.piva= s."Partita Iva" 
join agenda.comuni c on trim(upper(c.comune)) =trim(upper(s.comune))
left join matrix.struttura_asl sa on sa.id_asl = s."Cod. Ufficio Veterinario"
union select distinct
a.id id_azienda,"Stato sede operativa","Denominazione sede operativa" ,indirizzo ,
c.id id_comune,sa.id id_struttura from config.az_853 s
join agenda.aziende a on a.rag_soc=s."Ragione Sociale Impresa" and a.piva= s."Partita Iva" 
join agenda.comuni c on trim(upper(c.comune)) =trim(upper(s.comune))
left join matrix.struttura_asl sa on sa.id_asl = s."Cod. Ufficio Veterinario"
union select distinct
a.id id_azienda,"Stato sede operativa","Denominazione sede operativa" ,indirizzo ,
c.id id_comune,sa.id id_struttura from config.az_aromi s
join agenda.aziende a on a.rag_soc=s."Ragione Sociale Impresa" and a.piva= s."Partita Iva" 
join agenda.comuni c on trim(upper(c.comune)) =trim(upper(s.comune))
left join matrix.struttura_asl sa on sa.id_asl = s."Cod. Ufficio Veterinario"
union select distinct
a.id id_azienda,"Stato sede operativa","Denominazione sede operativa" ,indirizzo ,
c.id id_comune,sa.id id_struttura from config.az_particolari  s
join agenda.aziende a on a.rag_soc=s."Ragione Sociale Impresa" and a.piva= s."Partita Iva" 
join agenda.comuni c on trim(upper(c.comune)) =trim(upper(s.comune))
left join matrix.struttura_asl sa on sa.id_asl = s."Cod. Ufficio Veterinario"
union 
select distinct a.id id_azienda,'ATTIVO',linea,indirizzo,l.id,6019410
from config.stabfc852 s  left join vw_comuni_lookup l on replace(l.comune ,'AL TORRE - ','')=s.comune
join agenda.aziende a on a.rag_soc=s.linea and a.piva is null )a;





insert into linee  select  nextval('agenda_id_seq'), * from ( select distinct
null::int4 a ,null b ,linea,l.indirizzo,null::int4 c ,null d ,null e ,s.id_az_sede,null::int4 f ,c.id,null::int4 g,
null::int4 h ,null::int4 i,null::int4 l,null::int4 m,null::int4 n ,null o ,null p ,null q ,null::int4 r ,'852' tipo
 from config.stabfc852 l join vw_comuni_lookup c on replace(c.comune ,'AL TORRE - ','')=l.comune
 join agenda.vw_az_sedi s on s.denominazione_sede_operativa=l.linea and s.indirizzo=l.indirizzo) a;
 
 insert into linee  
 select  nextval('agenda_id_seq'), * from ( select distinct
null::int4 a ,null b ,"Denominazione sede operativa",l.indirizzo,null::int4 c ,null d ,null e ,s.id_az_sede,null::int4 f ,c.id,null::int4 g,
null::int4 h ,null::int4 i,null::int4 l,null::int4 m,null::int4 n ,null o ,null p ,null q ,null::int4 r ,'1069' tipo
 from config.az_1069 l join vw_comuni_lookup c on replace(c.comune ,'AL TORRE - ','')=l.comune
 join agenda.vw_az_sedi s on l."Denominazione sede operativa"=s.denominazione_sede_operativa and s.indirizzo=l.indirizzo) a;
 
 insert into linee
 select  nextval('agenda_id_seq'), * from ( select distinct
null::int4 a ,null b ,"Denominazione sede operativa",l.indirizzo,null::int4 c ,null d ,null e ,s.id_az_sede,null::int4 f ,c.id,null::int4 g,
null::int4 h ,null::int4 i,null::int4 l,null::int4 m,null::int4 n ,null o ,null p ,null q ,null::int4 r ,'853' tipo
 from config.az_853 l join vw_comuni_lookup c on replace(c.comune ,'AL TORRE - ','')=l.comune
 join agenda.vw_az_sedi s on l."Denominazione sede operativa"=s.denominazione_sede_operativa and s.indirizzo=l.indirizzo) a;
 
 insert into linee
 select  nextval('agenda_id_seq'), * from ( select distinct
null::int4 a ,null b ,"Denominazione sede operativa",l.indirizzo,null::int4 c ,null d ,null e ,s.id_az_sede,null::int4 f ,c.id,null::int4 g,
null::int4 h ,null::int4 i,null::int4 l,null::int4 m,null::int4 n ,null o ,null p ,null q ,null::int4 r ,'particolari' tipo
 from config.az_particolari l join vw_comuni_lookup c on replace(c.comune ,'AL TORRE - ','')=l.comune
 join agenda.vw_az_sedi s on l."Denominazione sede operativa"=s.denominazione_sede_operativa and s.indirizzo=l.indirizzo) a;
 
 insert into linee  
   select distinct  nextval('agenda_id_seq'), * from ( select distinct
null::int4 a ,null b ,"Denominazione sede operativa",l.indirizzo,null::int4 c ,null d ,null e ,s.id_az_sede,null::int4 f ,c.id,null::int4 g,
null::int4 h ,null::int4 i,null::int4 l,null::int4 m,null::int4 n ,null o ,null p ,null q ,null::int4 r ,'aromi' tipo
 from config.az_aromi l join vw_comuni_lookup c on replace(c.comune ,'AL TORRE - ','')=l.comune
 join agenda.vw_az_sedi s on l."Denominazione sede operativa"=s.denominazione_sede_operativa and s.indirizzo=l.indirizzo) a;
 

 		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.carica_aziende() OWNER TO postgres;

--
-- Name: crea_calendario(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.crea_calendario(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	iduser bigint;
	R agenda.calendari;
	rt json;

	begin
		proc_name:='agenda.crea_calendario';
		R:=json_to_record(v);
		R.id:=nextval('agenda.agenda_id_seq');
		R.anno:=extract(year from current_timestamp);
raise notice 'RANNO %',R.anno;
		insert into agenda.calendari values(R.*);
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.crea_calendario(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: crea_cu_from_evento(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.crea_cu_from_evento(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idevento bigint;
	idcu bigint;
	R_EV agenda.vw_eventi_singoli;
	rt json;
	cmd_par varchar;
	jres json;
	res ag_types.result_type;
	jinfo json;
	info varchar;
	R_EV_LOCK agenda.eventi;
	n integer;
	begin
		proc_name:='agenda.crea_cu_from_evento';
	    ret.esito:=true;
	 	ret.info:=null;
		idevento:=v->'id_evento';
	
		select * into R_EV_LOCK from agenda.eventi e where id=idevento for update;
		if R_EV_LOCK.id_cu is not null or R_EV_LOCK.id is null then
			ret.esito:=false;
		    ret:=ag_ui.build_ret(ret,proc_name,'cu_gia_creato');
	 		return ret;
		end if;
		select * into R_EV from agenda.vw_eventi_singoli e where id=idevento;
		raise notice 'idevento=%',idevento;

		raise notice 'idevento=%',idevento;
		if R_EV.sigla_tipo_evento is null then
		   	ret.esito:=false;
		    ret:=ag_ui.build_ret(ret,proc_name,'evento_non_fornito');
	 		return ret;
		end if;
		if R_EV.sigla_tipo_evento != 'CU' and R_EV.sigla_tipo_evento != 'FU' and R_EV.sigla_tipo_evento != 'PL' and 
           R_EV.sigla_tipo_evento != 'CS' and R_EV.sigla_tipo_evento != 'AS' and R_EV.sigla_tipo_evento != 'FS' and 
           R_EV.sigla_tipo_evento != 'CT' then
		    ret:=ag_ui.build_ret(ret,proc_name,'evento_non_cu');
	 		return ret;
		end if;
		if R_EV.id_cu is not null then
		    ret:=ag_ui.build_ret(ret,proc_name,'evento_con_cu_gia_associato');
	 		return ret;
		end if;
	
		raise notice 'idlinea=%',R_EV.id_linea;
		if R_EV.id_linea is null or not exists( select id from cu_anag.linee where id = R_EV.id_linea) then
		    ret:=ag_ui.build_ret(ret,proc_name,'evento_senza_linea');
		   	ret.esito:=false;
	 		return ret;
		end if;
	
		if R_EV.sigla_tipo_evento in ('CU', 'FU', 'CS', 'AS', 'FS','CT') then 
		
			if R_EV.sigla_tipo_evento in ('FU') then
				select id_piano into R_EV.id_piano from cu_conf.vw_cu_piani_speciali vcps 
				where sigla='FU_PIANO_DEF';
			end if;
			raise notice 'PRIMA DI CDM_PAR EV % RISO % LINEA% PIANO % ',idevento,R_EV.id_risorsa,R_EV.id_linea,R_EV.id_piano;
			cmd_par:='{"id_evento":'||idevento||',"risorsa":'||R_EV.id_risorsa|| coalesce(',"partner_per_conto_di":'||R_EV.partner_per_conto::varchar,'')
				 ||coalesce(',"id_partner":'||R_EV.id_partner::varchar,'')||',"id_linea":'
			 		|| R_EV.id_linea||',"id_piano":'||R_EV.id_piano||coalesce(',"per_conto_di":'||R_EV.id_per_conto::varchar,'')||'}';
			raise notice 'CDM_PAR=%',cmd_par;
			--select * into jres from dblink('cu_dblink','select cu.crea_cu_from_evento('''||cmd_par||'''::json,'||idtransazione||')') as T(ret json);
			jres:=cu.crea_cu_from_evento(cmd_par::json,idtransazione); --- as T(ret json);
		 	raise notice 'RET cu.crea_cu_from_evento= %',jres;
			if not ((jres->'esito')::varchar)::bool then
				ret.esito:=false;
				ret:=ag_ui.build_ret(ret,proc_name,jres->>'msg');
				return ret;
			end if;
			--jres:=ret::json;
			raise notice 'JRES=%',jres;
			jinfo:=jres->'info';
			raise notice 'JINFO=%',jinfo;
			info:=replace(jinfo::varchar,'\','');
			raise notice 'INFO =%',info;
			info:=substring(info,2,length(info)-2);
			raise notice 'INFO =%',info;
			jinfo:=info::json;
			idcu:=jinfo->'id_cu';
			raise notice 'IDCU=%',idcu;
		
		elsif R_EV.sigla_tipo_evento = 'PL' then
		
			cmd_par:='{"id_evento":'||coalesce(idevento::text, 'null')
			||',"veterinari":['||
				coalesce((select id from matrix.vw_nominativi_struttura vns where id_nominativo  = R_EV.id_risorsa and id_struttura = R_EV.id_per_conto)::text, 'null')
				||coalesce(','||(select id from matrix.vw_nominativi_struttura vns where id_nominativo  = R_EV.id_partner and id_struttura = R_EV.partner_per_conto)::text, '')
			||']'
			||',"id_piano_matrix":'||coalesce(R_EV.id_piano::text, 'null')
			||',"cod_azienda":"'||coalesce((select id_esterno from cu_anag.vw_linee l where l.id = R_EV.id_linea)::text, 'null')||'"'
			||',"cod_gruppo_specie":"'||coalesce((select lpad(split_part(cod_tipo_linea, '-', 2), 4, '0') from cu_anag.vw_linee l where l.id = R_EV.id_linea)::text, 'null')||'"'
			--(select riferimento_id from matrix.stabilimenti_linee where id = R_EV.id_linea)
			||',"dt":"'||coalesce(R_EV.inizio::text, 'null')||'"'
			||',"dt_fine":"'||coalesce(R_EV.fine::text, 'null')||'"'
			||'}';
			raise notice 'CDM_PAR=%','select bdn.crea_intervento('''||cmd_par||'''::json,'||idtransazione||')';
		
			select * into res from dblink('bdn_fvg','select * from bdn.crea_intervento('''||cmd_par||'''::json,'||idtransazione||')') T(esito boolean, valore text, msg varchar, info varchar, err_msg varchar);
					
			raise notice 'jres=%',res;

			idcu:=(res.info)::json->'id';
			raise notice 'IDCU=%',idcu;
		
		end if;
		if idcu is null then
			ret:=ag_ui.build_ret(ret,proc_name,'errore_generazione_cu');
			if res.msg is not null then
				ret:=ag_ui.build_ret(ret,proc_name,res.msg);
			end if;
	 		return ret;
		end if;

		update agenda.eventi set id_cu=idcu where id=idevento returning * into R_EV_LOCK;
		n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV_LOCK,'U');

    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:='{"id_cu":'||idcu||'}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.crea_cu_from_evento(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: crea_def_matrix(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.crea_def_matrix(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	declare
	ret ag_types.result_type; 
	idtrffattura bigint;   
	proc_name varchar;
	R_FATT RECORD;
	rt json;
	v_j json;
	j_dett json;
	idtrfstato bigint;
	act varchar;
	n_res bigint;

	begin
		proc_name:='agenda.crea_def_matrix';

	delete from  matrix.struttura_piano_target --set target=0  
	where id_struttura in (select id from matrix.struttura_asl
	where anno=(select value from "Analisi_dev".config where descr='ANNO CORRENTE')::integer);


insert into matrix.struttura_piano_target 
select nextval('matrix.struttura_piano_target_id_seq'),id_node_ref,a.id_piano,sum(n*a.num/a.den::float *f.freq)::integer	from (
	select pc.id_piano,pc.id_comune,sp.id_struttura,pc.n,sp.n num,p.n den from
		(	select tpl.id_piano ,s.id_comune,count(*) n from agenda.vw_piano_tipo_linea tpl
		join cu_anag.linee l on l.id_tipo_linea =tpl.id_tipo_linea 
		join cu_anag.vw_stabilimenti s on l.id_stabilimento =s.id_stabilimento 
		group by 1,2) pc join
	
			(	select a.id_struttura  ,tpl.id_piano ,count(*) n from agenda.vw_piano_tipo_linea tpl
		join cu_anag.linee l on l.id_tipo_linea =tpl.id_tipo_linea 
		join cu_anag.vw_stabilimenti s on l.id_stabilimento =s.id_stabilimento 
		join agenda.vw_struttura_comuni sc on sc.id_comune =s.id_comune
		join agenda.asl_piani a on a.id_struttura =sc.id_struttura and a.id_piano =tpl.id_piano 
		group by 1,2 order by 2,1) sp on pc.id_piano=sp.id_piano join
	
				(	select tpl.id_piano  ,count(*) n from agenda.vw_piano_tipo_linea tpl
		join cu_anag.linee l on l.id_tipo_linea =tpl.id_tipo_linea --and linea_principale
		join cu_anag.vw_stabilimenti s on l.id_stabilimento =s.id_stabilimento 
		join agenda.vw_struttura_comuni sc on sc.id_comune =s.id_comune
		join agenda.asl_piani a on a.id_struttura =sc.id_struttura and a.id_piano =tpl.id_piano 
		group by 1 order by 1) p on p.id_piano=sp.id_piano) a 
		join  matrix.vw_tree_nodes_down_asl da on a.id_struttura=da.id_node
		join agenda.vw_piano_freq_all f on f.id_piano=a.id_piano 
		group by id_node_ref,a.id_piano;

	n_res:=matrix.update_valori_somme();


/* CARICAMENTO PER IVAN 
 * 
 * select id_piano,da.id_node_ref,da.descrizione,count(*)
from prog_2024.liste p
	join cu_anag.vw_stabilimenti s on p.id_ua =s.sd_id
	join agenda.vw_struttura_comuni sc on sc.id_comune =s.id_comune and replace(descrizione_breve,' ','') ilike '%VETB%' and anno=2024

	join cu_anag.linee l on l.id_stabilimento=s.id and linea_principale
	join agenda.vw_piano_tipo_linea ptl on l.id_tipo_linea=ptl.id_tipo_linea and (alias_piano ilike '%C4%' or alias_piano ilike '%C5%')
	join  matrix.vw_tree_nodes_down_asl da on da.id_node=sc.id_struttura
group by 1,2,3

	n_res:=matrix.update_valori_somme();
 */
	return ret;
	end;
$$;


ALTER FUNCTION agenda.crea_def_matrix(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: del_calendario(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.del_calendario(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; -- START
	id_op bigint;   
	proc_name varchar; -- END
	v_j json;
	n integer;
	id_elab_da_eliminare integer;
	begin
	proc_name:='agenda.del_calendario';

	raise notice '%', v;
	--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
	v_j:=v::json;
	raise notice 'id_cal: %', v_j->>'id_calendario';

	for id_elab_da_eliminare in select ec.id from agenda.elab_cals ec where ec.id_calendario = (v_j->>'id_calendario')::bigint loop 
		raise notice 'id_elab_da_eliminare: %', '{"id_elab": '||id_elab_da_eliminare||'}';
		perform agenda.del_calendario_elab('{"id_elab": '||id_elab_da_eliminare||'}', idtransazione); 
	end loop;

	delete from agenda.calendari where id = (v_j->>'id_calendario')::bigint;
	

    ret.esito:=true;	
	--ret:=ag_ui.build_ret(ret,proc_name,(v_j->>'id_calendario')::bigint);
     ret:=ag_ui.build_ret(ret,proc_name, 'calendario_eliminato');
    ret.info='0';
 
	return ret;
	end;
END
$$;


ALTER FUNCTION agenda.del_calendario(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: del_calendario_elab(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.del_calendario_elab(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; -- START
	id_op bigint;   
	proc_name varchar; -- END
	R agenda.elab_cals%ROWTYPE; 
	v_j json;
	n integer;
	begin
	proc_name:='agenda.del_calendario_elab';

	raise notice '%', v;
	--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
	v_j:=v::json;
	raise notice '%', v_j->>'id_elab';

delete from agenda.elab_cal_logs  where id_elab_cal::text = v_j->>'id_elab';
	delete from agenda.linee_selezionate  where id_elab_cal::text = v_j->>'id_elab';
	delete from agenda.elab_cal_params  where id_elab_cal::text = v_j->>'id_elab';
	delete from agenda.elab_cal_param_piani  where id_elab_cal::text = v_j->>'id_elab';
	delete from agenda.elab_cal_param_ns  where id_elab_cal::text = v_j->>'id_elab';
	delete from agenda.elab_cal_param_asl  where id_elab_cal::text = v_j->>'id_elab';
    delete from agenda.attivita  where id_elab_cal::text = v_j->>'id_elab';
    delete from agenda.elab_cals where id::text = v_j->>'id_elab';
	--DA IMPLEMENTARE n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'I');

    ret.esito:=true;	
	--ret:=ag_ui.build_ret(ret,proc_name,R.id);
      ret:=ag_ui.build_ret(ret,proc_name,'elaborazione_eliminata_con_successo');
		ret.info='0';
	return ret;
	end;
END
$$;


ALTER FUNCTION agenda.del_calendario_elab(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: del_cf_tipo_lista(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.del_cf_tipo_lista(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;  
	v_j json;
	n integer;

	begin
	proc_name:='agenda.del_cf_tipo_lista';
	raise notice '%', v;
 
	v_j:=v::json;
	raise notice 'id: %', v_j->>'id';

	update agenda.cf_tipo_liste	set enabled=false , trashed_date =current_timestamp 	where id= (v_j->>'id')::bigint;

    ret.esito:=true;	

    ret:=ag_ui.build_ret(ret,proc_name, 'tipolista disabilitato');
    ret.info='0';
 
	return ret;
	end;
END
$$;


ALTER FUNCTION agenda.del_cf_tipo_lista(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: del_elab_cal_params(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.del_elab_cal_params(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idelabcal bigint;
	proc_name varchar;
	R_CAL agenda.vw_calendari%ROWTYPE;
	R_EC agenda.vw_elab_cals%ROWTYPE;
	REC Record;
	rt json;
	p json;
	begin
		proc_name:='agenda.del_elab_cal_params';
	
		idelabcal:=v_j->'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v_j->>'id_gen_cal';
		end if;
		p:=v_j->'params';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		delete from agenda.elab_cal_params where id_elab_cal = idelabcal;

        ret.esito:=true;
        ret.msg:=null;
        ret.info:=rt;

        return ret;

	end;
end;
$$;


ALTER FUNCTION agenda.del_elab_cal_params(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: del_elab_linee(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.del_elab_linee(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
        ret ag_types.result_type; -- START
        proc_name varchar; -- end
        R_EC agenda.elab_cals%ROWTYPE;
       	R_L agenda.linee_selezionate;
       	n integer;
        begin
		proc_name:='agenda.del_elab_linee';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V=%',v_j;

		R_EC.id:=v_j->>'id_elab_cal';
		if R_EC.id is null then
			R_EC.id:=v_j->>'id_gen_cal';
		end if;
	
		delete from agenda.linee_selezionate where id_elab_cal = R_EC.id returning * into R_L;
		n:=ag_log.upd_record('agenda.linee_selezionate',idtransazione,R_L,'D');
        
        ret.esito:=true;	
		ret:=ag_ui.build_ret(ret,proc_name,R_EC.id);
        
        return ret;
	end;
END
$$;


ALTER FUNCTION agenda.del_elab_linee(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: del_elab_ns_piani(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.del_elab_ns_piani(dati json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idselected bigint;
	proc_name varchar;
	R_CAL agenda.vw_calendari%ROWTYPE;
	R_EC agenda.elab_cals%ROWTYPE;
	REC Record;
	rt json;
	n integer;
	anno_calendario integer;

	begin
	proc_name:='agenda.del_elab_ns_piani';

	R_EC.id:=dati->>'id_elab_cal';
	if R_EC.id is null then
		R_EC.id:=dati->>'id_gen_cal';
	end if;
	R_EC.id_user:= ((dati->>'user_info')::json)->>'id_utente';

	raise notice 'ID_ELAB_CAL ID=% ID_USER=%', R_EC.id,R_EC.id_user;

	select * into R_EC from agenda.elab_cals ec where id =R_EC.id;

	select left(value,4)::integer into anno_calendario from agenda.elab_cal_params ecp where id_elab_cal =R_EC.id and type_param ='periodo_da';

	delete from agenda.linee_selezionate where id_elab_cal =R_EC.id
	and (id_linea,id_piano) not in (
		select distinct lps.id_linea,lps.id_piano from
			matrix.nominativi_struttura ns
			join (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements((dati->>'ns')  ::json) a ) a on ns.id =a.id_ns
			join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			join (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements((dati->>'piani')::json) p) p on np.id_piano=p.id_piano
			join agenda.vw_linee_piano_struttura lps on lps.id_piano=np.id_piano and lps.id_comune =nc.id_comune 
			
			left join agenda.vw_piano_freq pf on pf.id_piano = lps.id_piano and livello=1
			left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=lps.id_linea and ass.id_piano=lps.id_piano and ass.anno=anno_calendario
			where  coalesce(assegnate,0)<coalesce(pf.freq,1)
	);

	delete from agenda.elab_cal_param_ns    where id_elab_cal=R_EC.id ;
	delete from agenda.elab_cal_param_piani where id_elab_cal=R_EC.id ;

	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'NS inseriti % record',  n;

    select count(*) into n from agenda.linee_selezionate ls where id_elab_cal=R_EC.id ;
    ret.esito:=true;
    ret.msg:=null;
	ret.info:='{"linee_selezione":'||n||'}';

	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.del_elab_ns_piani(dati json, idtransazione bigint) OWNER TO postgres;

--
-- Name: del_tipo_lista(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.del_tipo_lista(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;  
	v_j json;
	n integer;
    c integer;
   	idtipolista bigint;
  	R_L agenda.tipo_liste;

	begin
	proc_name:='agenda.del_tipo_lista';
	raise notice '%', v;
 
	v_j:=v::json;
	idtipolista:=v_j->'id';
	raise notice 'id: %', v_j->'id';
 
	select count(*)  into c
	from  agenda.tipo_liste l
	inner join  agenda.lista_import i on i.id_tipo_lista =l.id
	where dt is not null and l.id=  idtipolista;

 
  
  	raise notice '%', c;
 	if c > 0 then
    	 
    	ret.esito:=false;
		ret.msg:='Ci sono liste di import associate';

	else
		
		--delete from agenda.tipo_liste	where id= (v_j->>'id')::bigint;
		update agenda.tipo_liste set validita=tsrange(lower(validita)::timestamp,current_timestamp::timestamp,'[)')
	where id=idtipolista returning * into R_L;
	n:=ag_log.upd_record('agenda.tipo_liste',idtransazione,R_L,'D');
		GET DIAGNOSTICS n = ROW_COUNT;
		if n > 0 then
		ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'eliminazione_avvenuta_con_successo');
		ret.info ='0';
    		--ret.esito:=true;	
    		--ret.msg:='Cancellazione avvenuta con successo';
		else
			ret.esito:=false;
			ret.msg:='Nessuna lista cancellata';
		end if;
	 	
		--ret:=ag_ui.build_ret(ret,proc_name,(v_j->>'id')::bigint);
	
	end if;
  
	
	return ret;
	end;
END
$$;


ALTER FUNCTION agenda.del_tipo_lista(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: exp_ns_comuni(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.exp_ns_comuni(v json, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	rt varchar;

	begin
		proc_name:='agenda.agenda.exp_ns_comuni';
		idstruttura=v->'user_info'->'id_struttura_root';
	/*
		select json_agg(row_to_json(c.*)) into rt from 
			(select v.descrizione_breve,v.nominativo,v.comune from agenda.vw_nominativo_comuni v 
		     join matrix.vw_tree_nodes_down d on d.id_node =v.id_struttura and d.id_node_ref =idstruttura) c;
	*/
	
	select string_agg(
		    		regexp_replace(regexp_replace(
		    		regexp_replace(row_to_json(c.*)::varchar,'"[^"]+":','','g'),'^{','['),'}$',']'),',')
		    	 into rt from 
			(
				select a.descrizione_breve,ns.nominativo risorsa,v.comune 
				FROM matrix.vw_asl_tree_by_ref a join matrix.vw_nominativi_struttura ns on a.id=ns.id_struttura
				left join agenda.vw_nominativo_comuni v on v.id_nominativo_struttura =ns.id
				where a.id_node_ref=idstruttura and a.n_livello=3 order by 1,2,3
			
			
			/*select v.descrizione_breve,v.nominativo risorsa,v.comune from agenda.vw_nominativo_comuni v 
		     join matrix.vw_tree_nodes_down d on d.id_node =v.id_struttura and d.id_node_ref =idstruttura*/
		    ) c;
	 	return '['||rt||']';
	end;
end;
$_$;


ALTER FUNCTION agenda.exp_ns_comuni(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: exp_ns_linee(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.exp_ns_linee(v json, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	rt varchar;

	begin
		proc_name:='agenda.agenda.exp_ns_linee';
		idstruttura=v->'user_info'->'id_struttura_root';
	/*	select json_agg(row_to_json(c.*)) into rt from 
			(select v.descrizione_breve,v.nominativo,v.denominazione_sede_operativa,v.comune from agenda.vw_nominativo_linee v 
		     join matrix.vw_tree_nodes_down d on d.id_node =v.id_struttura and d.id_node_ref =idstruttura) c;*/
	
		    
		    	select string_agg(
		    		regexp_replace(regexp_replace(
		    		regexp_replace(row_to_json(c.*)::varchar,'"[^"]+":','','g'),'^{','['),'}$',']')
		    		,',') into rt from 
		    					(
		    					
		    					select v.descrizione_breve,v.nominativo risorsa,v.denominazione_sede_operativa,v.comune
		    					FROM matrix.vw_asl_tree_by_ref a join matrix.vw_nominativi_struttura ns on a.id=ns.id_struttura
		    					left join  agenda.vw_nominativo_linee v on v.id_nominativo_struttura =ns.id
		     					where a.id_node_ref=idstruttura and a.n_livello=3
		     					order by 1,2,3,4
		    					
		    					
		    					
		    					/*select v.descrizione_breve,v.nominativo risorsa,v.denominazione_sede_operativa,v.comune from agenda.vw_nominativo_linee v 
		     					join matrix.vw_tree_nodes_down d on d.id_node =v.id_struttura and d.id_node_ref =idstruttura*/
		    		) c;

	 	return '['||rt||']';
	end;
end;
$_$;


ALTER FUNCTION agenda.exp_ns_linee(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: exp_ns_piani(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.exp_ns_piani(v json, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	rt varchar;

	begin
		proc_name:='agenda.agenda.exp_ns_piani';
		idstruttura=v->'user_info'->'id_struttura_root';
		/*select json_agg(row_to_json(c.*)) into rt from 
			(select v.descrizione_breve,v.nominativo,v.descrizione,v.alias from agenda.vw_nominativo_piani v 
		     join matrix.vw_tree_nodes_down d on d.id_node =v.id_struttura and d.id_node_ref =idstruttura) c;*/

		    
		    		    	select string_agg(
		    		regexp_replace(regexp_replace(
		    		regexp_replace(row_to_json(c.*)::varchar,'"[^"]+":','','g'),'^{','['),'}$',']')
		    		,',') into rt from 
			(
			select a.descrizione_breve,ns.nominativo risorsa,v.descrizione,v.alias 
			FROM matrix.vw_asl_tree_by_ref a join matrix.vw_nominativi_struttura ns on a.id=ns.id_struttura
			left join agenda.vw_nominativo_piani v on v.id_nominativo_struttura =ns.id
			where a.id_node_ref=idstruttura and a.n_livello=3	
			order by 1,2,4
			
			
			/*select v.descrizione_breve,v.nominativo risorsa,v.descrizione,v.alias from agenda.vw_nominativo_piani v 
		     join matrix.vw_tree_nodes_down d on d.id_node =v.id_struttura and d.id_node_ref =idstruttura*/
		    ) c;

		    	 	return '['||rt||']';
	 	--return rt::varchar;
	end;
end;
$_$;


ALTER FUNCTION agenda.exp_ns_piani(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: exp_piano_freq(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.exp_piano_freq(v json, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	rt varchar;

	begin
		proc_name:='agenda.agenda.exp_piano_freq';
		idstruttura=v->'user_info'->'id_struttura_root';
		/*select json_agg(row_to_json(c.*)) into rt from 
			(select  v0.descrizione, v0.alias_piano,v0.num,v0.den,v1.num,v1.den,v2.num,v2.den from agenda.vw_piano_freq v0
					join agenda.vw_piano_freq v1 on v0.id_piano=v1.id_piano and v1.livello=1
					join agenda.vw_piano_freq v2 on v0.id_piano=v2.id_piano and v1.livello=2
			where v1.livello=0) c;*/
	
		
				    	select string_agg(
		    		regexp_replace(regexp_replace(
		    		regexp_replace(row_to_json(c.*)::varchar,'"[^"]+":','','g'),'^{','['),'}$',']')
		    		,',') into rt from 
		    					(
		    					select p.alias alias_piano,v0.num,v0.den,v1.num,v1.den,v2.num,v2.den from matrix.vw_struttura_piani p left join agenda.vw_piano_freq v0 on p.id=v0.id_piano and v0.livello=0
					left join agenda.vw_piano_freq v1 on v0.id_piano=v1.id_piano and v1.livello=1
					left join agenda.vw_piano_freq v2 on v0.id_piano=v2.id_piano and v2.livello=2
					where anno=(select value::integer  from "Analisi_dev".config where descr='ANNO CORRENTE') and p.livello=3
					order by 1
		    					/*select  v0.descrizione, v0.alias_piano,v0.num,v0.den,v1.num,v1.den,v2.num,v2.den from agenda.vw_piano_freq v0
					join agenda.vw_piano_freq v1 on v0.id_piano=v1.id_piano and v1.livello=1
					join agenda.vw_piano_freq v2 on v0.id_piano=v2.id_piano and v1.livello=2
			where v1.livello=0*/
		) c;


	 	return '['||rt||']';
	end;
end;
$_$;


ALTER FUNCTION agenda.exp_piano_freq(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: exp_piano_periodo(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.exp_piano_periodo(v json, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	rt varchar;

	begin
		proc_name:='agenda.agenda.exp_piano_periodo';
		idstruttura=v->'user_info'->'id_struttura_root';

		select string_agg(
    		regexp_replace(regexp_replace(
    		regexp_replace(row_to_json(c.*)::varchar,'"[^"]+":','','g'),'^{','['),'}$',']')
    		,',') into rt from  
				(
				select p.descrizione descrizione_piano,p.alias alias_piano,to_char(v.da,'dd-mm-yyyy') inizio,to_char(v.a,'dd-mm-yyyy') fine
					from matrix.vw_struttura_piani p
						left join agenda.vw_piani_periodo v on p.id=v.id_piano 
						where anno=(select value::integer  from "Analisi_dev".config where descr='ANNO CORRENTE') and p.livello=3
						order by 2
				
			/*select v.descrizione_piano,v.alias_piano,v.da,v.a from agenda.vw_piani_periodo v*/
    			) c;
	 	return '['||rt||']';
	end;
end;
$_$;


ALTER FUNCTION agenda.exp_piano_periodo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: exp_piano_profilassi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.exp_piano_profilassi(v json, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	rt varchar;

	begin
		proc_name:='agenda.agenda.exp_piano_profilassi';
		idstruttura=v->'user_info'->'id_struttura_root';	
	    select string_agg(
		regexp_replace(regexp_replace(
		regexp_replace(row_to_json(c.*)::varchar,'"[^"]+":','','g'),'^{','['),'}$',']')
		,',') into rt from (
			select p.descrizione,p.alias,T.malattia
	        FROM dblink('dbname=bdn_fvg','select id_piano,malattia from bdn_prof.vw_piano_profilassi')
	         as T(id_piano INT8,malattia varchar) join matrix.struttura_piani p on p.id=T.id_piano
				where anno=(select value::integer  from "Analisi_dev".config where descr='ANNO CORRENTE') 
				order by 1
			) c;
	 	return '['||rt||']';
	end;
end;
$_$;


ALTER FUNCTION agenda.exp_piano_profilassi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: exp_piano_tariffe(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.exp_piano_tariffe(v json, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	rt varchar;

	begin
		proc_name:='agenda.agenda.exp_piano_tariffe';
		idstruttura=v->'user_info'->'id_struttura_root';
		/*select json_agg(row_to_json(c.*)) into rt from 
			(select v.descrizione_piano,v.alias_piano,v.descrizione_breve_tariffa from trf.vw_trf_piano_tariffa v ) c;*/

		
						    	select string_agg(
		    		regexp_replace(regexp_replace(
		    		regexp_replace(row_to_json(c.*)::varchar,'"[^"]+":','','g'),'^{','['),'}$',']')
		    		,',') into rt from  
		    					(
								select p.descrizione descrizione_piano,p.alias alias_piano,v.descrizione_breve_tariffa from  matrix.vw_struttura_piani p
								left join trf.vw_trf_piano_tariffa v on p.id=v.id_piano
								where anno=(select value::integer  from "Analisi_dev".config where descr='ANNO CORRENTE') and p.livello=3
								order by 2,3
		    					/*select v.descrizione_piano,v.alias_piano,v.descrizione_breve_tariffa from trf.vw_trf_piano_tariffa v*/
		    				
		    					) c;
	 	return '['||rt||']';
	end;
end;
$_$;


ALTER FUNCTION agenda.exp_piano_tariffe(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: exp_piano_tipolinee(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.exp_piano_tipolinee(v json, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	rt varchar;

	begin
		proc_name:='agenda.agenda.exp_ns_linee';
		idstruttura=v->'user_info'->'id_struttura_root';
		/*select json_agg(row_to_json(c.*)) into rt from 
			(select v.descr_piano,v.alias_piano,v.descr_tipo_linea from agenda.vw_piano_tipo_linea v ) c;*/
	
	
		select string_agg(
    		regexp_replace(regexp_replace(
    		regexp_replace(row_to_json(c.*)::varchar,'"[^"]+":','','g'),'^{','['),'}$',']')
    		,',') into rt from (	
		    		select v.descr_piano,v.alias_piano, v.cod cod_tipo_linea from  matrix.vw_struttura_piani p
					left join agenda.vw_piano_tipo_linea v on p.id=v.id_piano
					where anno=(select value::integer  from "Analisi_dev".config where descr='ANNO CORRENTE') and p.livello=3	
    				
					order by 2,3/*select v.descr_piano,v.alias_piano,v.descr_tipo_linea from agenda.vw_piano_tipo_linea v */
    			) c;

	 	return '['||rt||']';
	end;
end;
$_$;


ALTER FUNCTION agenda.exp_piano_tipolinee(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: exp_uoc_piani(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.exp_uoc_piani(v json, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	rt varchar;

	begin
		proc_name:='agenda.exp_uoc_piani';
		idstruttura=v->'user_info'->'id_struttura_root';
		/*select json_agg(row_to_json(c.*)) into rt from 
			(select ap.descrizione_breve_asl ,ap.descr_unique  from agenda.vw_asl_piani ap 
		     join matrix.vw_tree_nodes_down d on d.id_node =ap.id_struttura and d.id_node_ref =idstruttura) c;*/

		    
		 select  string_agg(
		    		regexp_replace(regexp_replace(
		    		regexp_replace(row_to_json(c.*)::varchar,'"[^"]+":','','g'),'^{','['),'}$',']')
		    		,',') into rt from 
			(
			 /*select ap.descrizione_breve_asl ,ap.descr_unique  from agenda.vw_asl_piani ap 
		     join matrix.vw_tree_nodes_down d on d.id_node =ap.id_struttura and d.id_node_ref =idstruttura*/
			
			
					     SELECT  a.descrizione_breve AS descrizione_breve_asl,COALESCE(sp.alias, ''::text)  AS descr_unique
					        FROM matrix.vw_asl_tree_by_ref a
   							left join agenda.asl_piani ap ON a.id = ap.id_struttura
     						LEFT JOIN matrix.struttura_piani sp ON sp.id = ap.id_piano
							where a.id_node_ref=idstruttura and a.n_livello=3
							order by 1,2

		    ) c;		    		

		    return '['||rt||']';		    		
	end;
end;
$_$;


ALTER FUNCTION agenda.exp_uoc_piani(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: exp_uos_comuni(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.exp_uos_comuni(v json, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	rt varchar;

	begin
		proc_name:='agenda.exp_uos_comuni';
		idstruttura=v->'user_info'->'id_struttura_root';
		/*select json_agg(row_to_json(c.*)) into rt from 
			(select ac.descrizione_breve ,ac.comune  from agenda.vw_struttura_comuni ac 
		     --join matrix.vw_tree_nodes_down d on d.id_node =ac.id_struttura and d.id_node_ref =idstruttura
		    ) c;*/
		   
   		 select string_agg(
    		regexp_replace(regexp_replace(
    		regexp_replace(row_to_json(c.*)::varchar,'"[^"]+":','','g'),'^{','['),'}$',']')
    		,',') into rt from 
			(
				SELECT  a.descrizione_breve,c.comune 
		        FROM matrix.vw_asl_tree_by_ref a
				left join agenda.struttura_comuni ac ON a.id = ac.id_struttura
				LEFT JOIN agenda.vw_comuni c ON c.id = ac.id_comune
				where a.id_node_ref=idstruttura and a.n_livello=3
				order by 1,2
			
			/*select ac.descrizione_breve ,ac.comune  from agenda.vw_struttura_comuni ac 
		     join matrix.vw_tree_nodes_down d on d.id_node =ac.id_struttura and d.id_node_ref =idstruttura*/
		    ) c;		   
		   
	 	return '['||rt||']';

	end;
end;
$_$;


ALTER FUNCTION agenda.exp_uos_comuni(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: genera_calendario(bigint, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.genera_calendario(id_record bigint, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idselected bigint;
	proc_name varchar;
	R_CAL agenda.vw_calendari%ROWTYPE;
	REC Record;
	rt json;

	begin
		proc_name:='agenda.genera_calendario';

    --select  nextval('agenda.agenda_id_seq'),1,'PIANO',* from json_to_recordset('[{"id":1},{"id":2}]') as  x(id bigint);	
	--select  nextval('agenda.agenda_id_seq'),1,'ASL',* from json_to_recordset('[{"id":1},{"id":2}]') as  x(id bigint);
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
	delete from agenda.elab_cal_params ecp  where id_elab_cal=1;
	insert into agenda.elab_cal_params select  nextval('agenda.agenda_id_seq'),1,'ASL', id from matrix.struttura_asl    where descrizione='Azienda Sanitaria Universitaria FRIULI CENTRALE VET C';
    insert into agenda.elab_cal_params select  nextval('agenda.agenda_id_seq'),1,'PIANO' id from matrix.struttura_piani where descrizione='Sanità Animale';
   
	delete from agenda.attivita where id_elab_cal=1;
	delete from agenda.linee_selezionate  where id_elab_cal=1;
	insert into agenda.attivita
	select nextval('agenda.attivita_id_seq'),
	ec.id,sd.id_node as id_struttura_asl,p.id id_piano,null id_linea,null dt,null id_risorsa,
			target,n.contatore,target*fattore_fin ups--,sd.descrizione_breve as uos,p.descrizione 
	from matrix.struttura_piano_target t
			join matrix.vw_tree_nodes_down_asl_descr sd on sd.id_node=t.id_struttura 
			join matrix.vw_tree_nodes_down_piani pd on pd.id_node=t.id_piano
			join matrix.struttura_piani p on t.id_piano = p.id
			join matrix.formule f on p.id_formula_ups =f.id
			join (SELECT generate_series as  contatore FROM generate_series(1,10000)) n on n.contatore <= t.target
			join agenda.elab_cals ec on 1=1
			join agenda.elab_cal_params pa on sd.id_node_ref=pa.value and pa.id_elab_cal=ec.id and pa.type_param='ASL'
			join agenda.elab_cal_params pp on pd.id_node_ref=pp.value and pp.id_elab_cal=ec.id and pp.type_param='PIANO'
			where    sd.n_livello =3 and ec.id=1		;
			
update agenda.attivita set id_risorsa=sub.id_nominativo FROM
(select id_struttura,id_piano,row_number() over (partition by id_struttura,id_piano order by id_struttura,id_piano,id_nominativo) contatore,
 id_nominativo from (
select id_nominativo,ns.id_struttura,m4.ups*(100.0-ms.sottr)/200/ms.ups frazione --,*
from matrix.vw_nominativi_struttura ns
			join matrix.vw_tree_nodes_down_asl_descr sd on sd.id_node=ns.id_struttura 
			join matrix.mod4_nominativi m4 on m4.id_nominativo_struttura =ns.id
			join matrix.mod4_strutture ms on ms.id_struttura =ns.id_struttura 
			join agenda.elab_cal_params pa on type_param='ASL' and id_elab_cal=1 and pa.value =sd.id_node_ref 

			/*where sd.id_node_ref=6019421*/) r join (
			select --nextval('attivita_id_seq'),
sd.id_node as id_struttura_asl,p.id id_piano,null id_linea,null dt,null id_risorsa,target,/*n.contatore,*/target*fattore_fin ups--,sd.descrizione_breve as uos,p.descrizione 
	from matrix.struttura_piano_target t
			join matrix.vw_tree_nodes_down_asl_descr sd on sd.id_node=t.id_struttura 
			join matrix.vw_tree_nodes_down_piani pd on pd.id_node=t.id_piano
			join matrix.struttura_piani p on t.id_piano = p.id
			join matrix.formule f on p.id_formula_ups =f.id
join agenda.elab_cal_params pa on pa.type_param='ASL'   and pa.id_elab_cal=1 and pa.value =sd.id_node_ref 
join agenda.elab_cal_params pp on pp.type_param='PIANO' and pp.id_elab_cal=1 and pp.value =pd.id_node_ref
			where /*sd.id_node_ref=6019421  and pd.id_node_ref=19499 and */ sd.n_livello =3) s
			on r.id_struttura=s.id_struttura_asl 
			join (SELECT generate_series as  contatore FROM generate_series(1,10000)) n on n.contatore <= round(frazione*target)) as sub
where attivita.id_struttura =sub.id_struttura and attivita.id_piano=sub.id_piano and attivita.contatore=sub.contatore and attivita.id_elab_cal=1;

delete from agenda.attivita where id_risorsa is null;
update agenda.attivita set dt=sub.giorno,durata='04:00:00'::interval * fattore_ups from
(select id_risorsa,id_struttura,id_piano,contatore,
'2023-01-02 09:00:00'::timestamp + ((trunc(giorni/5))*7 + mod(giorni,5))* interval '1 days' as giorno,fattore_ups
from (
select a.id_risorsa,a.id_struttura,a.id_piano,a.contatore, sp.fattore_ups,row_number() over (partition by id_risorsa) -1 as giorni
from agenda.attivita a left join matrix.vw_struttura_piani sp on sp.id= a.id_piano where id_elab_cal =1 and id_risorsa is not null) d) sub
where attivita.id_struttura =sub.id_struttura and attivita.id_piano=sub.id_piano
and attivita.contatore=sub.contatore and attivita.id_elab_cal=1 ;

delete from agenda.linea_piani;

insert into agenda.linea_piani select nextval('agenda.agenda_id_seq'),l.id,19757 from agenda.linee l;
insert into agenda.linea_piani select nextval('agenda.agenda_id_seq'),l.id,19577 from agenda.linee l;
insert into agenda.linea_piani select nextval('agenda.agenda_id_seq'),l.id,19724 from agenda.linee l;


insert into agenda.linee_selezionate 
select nextval('agenda.linee_selezionate_id_seq'),
1,id_linea ,id_piano,row_number() over () from agenda.linea_piani lp
join agenda.linee l on l.id=lp.id_linea join agenda.az_sedi s on s.id=l.id_az_sede 
 join agenda.comuni vcl on vcl.id =s.id_comune 
 join matrix.vw_tree_nodes_down_piani p on lp.id_piano =p.id_node 
 join matrix.vw_tree_nodes_down_asl sd 
 join agenda.struttura_comuni sc on sc.id_struttura =sd.id_node on sc.id_comune=vcl.id 
 join agenda.elab_cal_params pa on pa.type_param='ASL'   and pa.id_elab_cal=1 and pa.value =sd.id_node_ref 
join agenda.elab_cal_params pp on pp.type_param='PIANO' and pp.id_elab_cal=1 and pp.value =p.id_node_ref
--where sd.id_node_ref=6019421 and p.id_node_ref=19499
order by id_linea+id_piano limit 5000;

for REC in select ls.*,cl.id as id_comune from agenda.linee_selezionate ls
	join agenda.linee l on l.id=ls.id_linea join agenda.vw_comuni_lookup cl on cl.id=l.id_comune
	join agenda.az_sedi s on s.id=l.id_az_sede 
	-- join agenda.comuni cl on cl.id =s.id_comune 
	where id_elab_cal = 1 order by ordine loop
	select a.id into idselected  from agenda.attivita a join matrix.nominativi_struttura ns on ns.id_nominativo=a.id_risorsa
	join agenda.nominativo_comuni n on ns.id  =n.id_nominativo_struttura join agenda.struttura_comuni sc on sc.id_struttura =ns.id_struttura 
	where id_piano=REC.id_piano and sc.id_comune=REC.id_comune and a.id_linea is null order by dt limit 1;
	if idselected is not null then
		update agenda.attivita set id_linea = REC.id_linea where id=idselected ;
	end if;
end loop;



	select json_agg(row_to_json(g.*)) into rt from (select 
		 l.denominazione linea,c.comune,sa.descrizione_breve uos,n.nominativo ,dt as giorno,replace(sp.path_descr,'Totale/','') attivita from
		agenda.attivita a  join agenda.linee l on a.id_linea =l.id
		--left join agenda.vw_comuni_lookup c on c.com_id =l.id_comune
		join agenda.az_sedi s on s.id=l.id_az_sede 
	 	join agenda.comuni c on c.id =s.id_comune 
		join matrix.struttura_asl sa  on sa.id =a.id_struttura
		join matrix.vw_tree_nodes_up_piani sp on sp.id_node=a.id_piano
		join matrix.nominativi n on n.id=a.id_risorsa 
		
		) g;

		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		ret.msg:='calendario non generato';
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;

	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.genera_calendario(id_record bigint, idtransazione bigint) OWNER TO postgres;

--
-- Name: genera_calendario(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.genera_calendario(dati json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	declare
	id_op bigint;   
	ret ag_types.result_type;
	idselected bigint;
	proc_name varchar;
	dt_da timestamp;
	dt_a timestamp;
	R_CAL agenda.vw_calendari%ROWTYPE;
	R_EC agenda.vw_elab_cals%ROWTYPE;
	REC Record;
	rt json;
	n integer;
	fract_time decimal;

	param_periodo_da timestamp;
	param_periodo_a timestamp;
	param_non_visitati_dal_valore decimal;
	param_non_visitati_dal timestamp;
	param_ultima_visita decimal;
	param_machine decimal;
	param_casuale decimal;
	param_linea boolean;
	param_ispettore boolean;
	time_start timestamp;
	n_cicli integer;
	n_associate integer;
	n_multiple integer;
	n_disassociate integer;
	cap integer;
    stmt varchar;
    cnt_day integer;
  
  	def_freq_rischio_alta  decimal;
	def_freq_rischio_media decimal;
	def_freq_rischio_bassa decimal;
	def_ups                decimal;
	def_uba                decimal;

	begin
	proc_name:='agenda.genera_calendario_proc';
	time_start := clock_timestamp();
	n_cicli := 0;
	ret.esito:=true;

	/* START ACQUISIZIONE PARAMETRI */
	R_EC.id:=dati->>'id_elab_cal';
	if R_EC.id is null then
		R_EC.id:=dati->>'id_gen_cal';
	end if;

	if R_EC.id is null then
		ret.esito:=false;
		return ret;
	end if;

	/* Svuotamento LOG */
	stmt:='delete from agenda.elab_cal_logs where id_elab_cal='||R_EC.id;
	perform dblink_exec('local_dblink',stmt); 
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''START ELABORAZIONE'')';
	perform dblink_exec('local_dblink',stmt); 

	raise notice 'ID_ELAB_CAL ID=% ID_USER=%', R_EC.id,R_EC.id_user;

	/* Svuotamento Calendario */
	delete from agenda.attivita where id_elab_cal=R_EC.id;

	select * into R_EC from agenda.vw_elab_cals ec where id =R_EC.id;
	if R_EC.bloccato then
		ret.esito:=false;	 
	 	ret:=ag_ui.build_ret(ret,proc_name, 'calendario_bloccato_non_generato');
	 	return ret;
	end if;

	/* START ACQUISIZIONE PARAMETRI */
	select value::timestamp into param_periodo_da from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='periodo_da';
	select value::timestamp into param_periodo_a  from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='periodo_a';
	if param_periodo_da is null then
		param_periodo_da:=date_trunc('year',current_timestamp);
	end if;
	if param_periodo_a is null then
		param_periodo_a:=date_trunc('year',param_periodo_da)+ interval '1 year';
	end if;
	fract_time= (extract(epoch from param_periodo_a) - extract(epoch from param_periodo_da)) /(365*24*3600);

	select value::decimal   into param_non_visitati_dal_valore from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='non_visitati_dal_valore';
	select value::timestamp into param_non_visitati_dal        from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='non_visitati_dal';
	select value::decimal   into param_ultima_visita           from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='ultima_visita';
	select value::decimal   into param_machine                 from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='machine';
	select value::decimal   into param_casuale                 from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='casuale';
	select value::boolean   into param_linea                   from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='linea';
	select value::boolean   into param_ispettore               from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='ispettore';

	select value::decimal   into def_freq_rischio_alta  from ag_conf.ag_conf where cod='freq_rischio_alta';
	select value::decimal   into def_freq_rischio_media from ag_conf.ag_conf where cod='freq_rischio_media';
	select value::decimal   into def_freq_rischio_bassa from ag_conf.ag_conf where cod='freq_rischio_bassa';
	select value::decimal   into def_ups                from ag_conf.ag_conf where cod='ups';
	select value::decimal   into def_uba                from ag_conf.ag_conf where cod='uba';

	raise notice 'FRACT_TIME=%',fract_time;
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''INIZIALIZZAZIONE'')';
	perform dblink_exec('local_dblink',stmt); 

	/* END ACQUISIZIONE PARAMETRI */


	/* START GENERAZIONE ATTIVITA */

	select count(*) into n from agenda.az_sedi_selezionate a_s where id_elab_cal =R_EC.id;
	raise notice 'SEDI SELEZIONATE %',  n;
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''SEDI SELEZIONATE  ('|| n||')'')';
    raise notice 'STMT %',stmt;
	perform dblink_exec('local_dblink',stmt); 
  
	/* CREA LA LISTA DELLE ATTIVITA POSSIBILI tenendo condo di:
	 * associazioni risorse/piani
	 * associazioni strutture/piani
	 * attività già programmate e presenti in agenda.eventi
	 * programmzione in matrix pp.periodo
	 * come periodo temporale usa l'intero anno */
	insert into agenda.attivita (id,id_elab_cal,id_struttura,id_piano,id_linea,dt,id_risorsa,target,
				contatore,ups,durata,validita,prog)
	select nextval('agenda.attivita_id_seq'),
			R_EC.id  ,t.id_struttura as id_struttura_asl,t.id_piano as id_piano,
			null id_linea, null dt, null id_risorsa, t.target, n.contatore,coalesce(fattore_fin,def_ups) ups,
			interval '1 minutes' * 4 * 60 * coalesce(fattore_fin,def_ups),
			coalesce(periodo,tsrange(param_periodo_da,param_periodo_a,'[]'))*tsrange(param_periodo_da,param_periodo_a,'[]'),
			row_number () over(order by t.id_piano,t.id_struttura)
			from matrix.struttura_piano_target t	
			join (
				select distinct np.id_piano,mns.id_node_struttura id_struttura from agenda.nominativo_piani np
					join agenda.elab_cal_param_ns ns on ns.id_ns =np.id_nominativo_struttura
					join matrix.vw_nominativi_struttura mns on mns.id=ns.id_ns 
					join agenda.elab_cal_param_piani ep on ep.id_elab_cal =ns.id_elab_cal and ep.id_piano =np.id_piano 
					where ns.id_elab_cal =R_EC.id 
			) p on t.id_struttura=p.id_struttura and t.id_piano =p.id_piano 
			join matrix.struttura_piani sp on sp.id=t.id_piano 
			left join agenda.piano_periodo pp on pp.id_piano=t.id_piano 
			left join (select per_conto id_struttura,id_piano,count(*) pianificati from agenda.eventi where extract (year from eventi.inizio ) = R_EC.anno group by 1,2) a on t.id_struttura =a.id_struttura and t.id_piano =a.id_piano
			left join matrix.formule f on sp.id_formula_ups =f.id
			join (SELECT generate_series as  contatore FROM generate_series(1,10000)) n on n.contatore <= t.target-coalesce(a.pianificati,0)
			where coalesce(periodo,tsrange(param_periodo_da,param_periodo_a,'[]')) && tsrange(param_periodo_da,param_periodo_a,'[]');

	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'ATTIVITA GENERATE %',  n;
	stmt := 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),' ||R_EC.id|| ',clock_timestamp(),''CREAZIONE ATTIVITA ('||n||')'')';
    raise notice 'STMT %',stmt;
	perform dblink_exec('local_dblink',stmt); 
	if n <=0 then
    	raise notice 'NESSUN ATTIVITA GENERATA';
		stmt := 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),' ||R_EC.id|| ',clock_timestamp(),''CREAZIONE NON POSSIBILE: 0 ATTIVITA'')';
		perform dblink_exec('local_dblink',stmt); 
	    ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=null;
	 
	    update agenda.elab_cals set tm_last_elab =current_timestamp where id=R_EC.id;
		return ret;
	end if;
	/* END GENERAZIONE ATTIVITA */

	/* START SELEZIONE LINEE */
	if param_linea then
	
		/* ASSOCIA LE LINEE PRINCIPALI SELEZIONATE IN BASE A:
		 * piano
		 * struttura
		 * numero progressivo piano-struttura
		 */
		update agenda.attivita a
		set id_linea = sub.id_linea
		from (
			select a.id_linea,a.id_piano,a.id_struttura_asl,row_number() over (partition by  id_piano,id_struttura_asl order by rnd) contatore from (
				select  lp.id_linea, ss.id_piano,lps.id_struttura_asl, /*,n.contatore,coalesce(pf.freq,1)*10,*/random() rnd from
	     				agenda.az_sedi_selezionate ss
	     				join agenda.linee_principali lp on lp.id_az_sede=ss.id_az_sede 
						join agenda.vw_linee l on l.id =lp.id_linea 
						left join agenda.vw_piano_freq pf on pf.id_piano = ss.id_piano and livello=1						
						left join agenda.vw_linea_piano_anno_assegnate a on a.id_piano=ss.id_piano and a.id_linea=lp.id_linea and a.anno=R_EC.anno
						join      (SELECT generate_series as  contatore FROM generate_series(1,100)) n on n.contatore <= (ceil(coalesce(pf.freq,1))
						-coalesce(a.assegnate,0) )
						join agenda.vw_linee_piano_struttura lps on lps.id_piano=ss.id_piano and lps.id_linea =lp.id_linea 
						join agenda.elab_cal_param_piani ep on ep.id_elab_cal =ss.id_elab_cal and ss.id_piano =ep.id_piano 
						join (select distinct id_node_struttura as id_struttura,id_elab_cal from agenda.vw_elab_cal_param_ns pa  ) pa 
									on lps.id_struttura_asl =pa.id_struttura and ss.id_elab_cal =pa.id_elab_cal
				where ss.id_elab_cal =R_EC.id) a
		) as sub
		where a.id_piano=sub.id_piano and a.id_struttura =sub.id_struttura_asl and a.contatore =sub.contatore and a.id_elab_cal =R_EC.id;
		GET DIAGNOSTICS n = ROW_COUNT;
    	raise notice 'ATTIVITA ASSOCIATE A LINEE STEP 1 %',  n;
    
		insert into agenda.attivita (id,id_elab_cal,id_struttura,id_piano,id_linea,dt,id_risorsa,target,
				contatore,ups,durata,validita,prog)
		select nextval('agenda.attivita_id_seq'),a.id_elab_cal,a.id_struttura,a.id_piano,
			l.id_linea,	a.dt,a.id_risorsa,a.target,a.contatore,a.ups,a.durata,a.validita,a.prog
			from agenda.attivita a
			join agenda.linee_principali lp on a.id_linea =lp.id_linea
			join agenda.vw_linee l on l.id_az_sede =lp.id_az_sede 
			where id_elab_cal =R_EC.id --and id_risorsa is not null
			and a.id_linea!=l.id_linea
			order by a.prog	;
	
		GET DIAGNOSTICS n = ROW_COUNT;
    	raise notice 'ATTIVITA ASSOCIATE A LINEE % STEP 2',  n;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''ATTIVITA ASSOCIATE A LINEE ('||n||')'')';
		raise notice 'STMT=%',stmt;
		perform dblink_exec('local_dblink',stmt); 
	end if;	

	/* END SELEZIONE LINEE PRINCIPALI*/



	/* START CALCOLO CAPACITA PER OGNI RISORSA */
	update agenda.elab_cal_param_ns p set
		cap_tot=sub.capacita,cap_ev=sub.prog_e,excluded=false,to_be_excluded=false,
		cap_used=0/*sub.prog_a*/ from (
			select ns.id id_ns,ns.id_node_struttura id_struttura,
				(m4.ups*(100.0-ms.sottr)/200) *fract_time capacita,coalesce(e.prog_e,0) prog_e--,coalesce(a.prog_a,0) prog_a
			from matrix.vw_nominativi_struttura ns
			join matrix.mod4_nominativi m4 on m4.id_nominativo_struttura =ns.id
			join matrix.vw_mod4_strutture ms on ms.id_struttura =ns.id_struttura 
			join agenda.vw_elab_cal_param_ns pns on  pns.id_ns =ns.id
			left join (
				select ns.id as id_ns,coalesce(sum(coalesce(fattore_ups,def_ups)),0) prog_e from agenda.eventi e 
				join matrix.vw_nominativi_struttura ns on e.id_nominativo =ns.id_nominativo and e.per_conto =ns.id_node_struttura
				join matrix.vw_struttura_piani p on p.id=e.id_piano
				where e.inizio between param_periodo_da and param_periodo_a group  by 1
			) e on e.id_ns=ns.id
			where  pns.id_elab_cal=R_EC.id
	) sub where p.id_elab_cal=R_EC.id and p.id_ns=sub.id_ns	;
    
	GET DIAGNOSTICS cap = ROW_COUNT;
    raise notice 'CALCOLATA CAPACITA %',  cap;
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''CALCOLATA CAPACITA ('||cap||')'')';
    raise notice 'STMT %',stmt;
		perform dblink_exec('local_dblink',stmt); 
	/* END CALCOLO CAPACITA */

	n_associate:=1000;
	n_disassociate:=0;
	select sum(cap_tot)-sum(cap_ev) into n from agenda.elab_cal_param_ns			where  id_elab_cal=R_EC.id;
	if n <=0 or n is null then
    	raise notice 'NESSUNA RISORSA DISPONIBILE';
		stmt := 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),' ||R_EC.id|| ',clock_timestamp(),''CREAZIONE NON POSSIBILE: 0 RISORSE'')';
		perform dblink_exec('local_dblink',stmt); 
	    ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=null;
	 	update agenda.elab_cals set tm_last_elab =current_timestamp where id=R_EC.id;
		return ret;
	end if;
	while n_cicli < 100 and ( clock_timestamp() - time_start ) < interval '3 minutes' and n_associate >n_disassociate and cap >0 loop
		n_cicli:= n_cicli+1;
	    raise notice ' ASSOCIATE % DISASSOCIATE % CAP %',n_associate ,n_disassociate, cap;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''START CICLO ('||n_cicli||')'')';
	    raise notice 'STMT %',stmt;
		perform dblink_exec('local_dblink',stmt); 
		--commit;
/* START ASSOCIA RISORSE */ 
		update agenda.attivita a set id_risorsa = sub.id_nominativo,dt=param_periodo_da
			from
			(
			select id_attivita,id_nominativo from (
			select a.id id_attivita, a.id_piano,l.id_comune , row_number() over(partition by id_piano,id_comune) n 
			from agenda.attivita a join agenda.vw_linee l on l.id=a.id_linea
			where id_elab_cal=R_EC.id and id_risorsa is null) a
			join
			(select id_piano,id_comune, id_nominativo,id_struttura,row_number() over(partition by id_piano,id_comune order by rnd desc) n from (
			select mns.id_nominativo,mns.id_node_struttura id_struttura,np.id_piano , nc.id_comune,
					(case when ns.cap_tot -ns.cap_ev> coalesce(ns.cap_used,0) then ns.cap_tot -ns.cap_ev -coalesce(ns.cap_used,0) else 0 end) * random() rnd 
			from agenda.elab_cal_param_ns ns 
			join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id_ns 
			join agenda.elab_cal_param_piani pp on pp.id_elab_cal =ns.id_elab_cal and pp.id_piano =np.id_piano 
			join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id_ns 
			join matrix.vw_nominativi_struttura mns on mns.id=ns.id_ns
			join (SELECT generate_series as  contatore FROM generate_series(1,100)) c on 1=1
				where ns.id_elab_cal=R_EC.id and not ns.excluded 
				) b) b on a.id_piano=b.id_piano and a.id_comune=b.id_comune and a.n=b.n) sub 
		where a.id=sub.id_attivita;

		GET DIAGNOSTICS n_associate = ROW_COUNT;
    	raise notice 'ASSOCIAZIONE ATTIVITA RISORSE %',  n_associate;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    ASSOCIAZIONE RISORSE-ATTIVITA ('||n_associate||')'')';
		perform dblink_exec('local_dblink',stmt); 
		/* END ASSOCIA RISORSE */
	 
	 	/*CANCELLA LE LINEE VISITATE PIU VOLTE RISPETTO ALLA FREQUENZA PREVISTA */
	    delete from agenda.attivita where id in 
	 		(select id from (
				select a.id,a.id_linea,a.id_piano,f.freq f,row_number() over(partition by a.id_linea,a.id_piano) n_seq
				from agenda.attivita a join agenda.vw_piano_freq f on f.id_piano=a.id_piano and f.livello =1
				where a.id_linea is not null and
				id_elab_cal=R_EC.id) a where n_seq>ceil(f));
		GET DIAGNOSTICS n_multiple = ROW_COUNT;
    	raise notice 'ELIMINAZIONE LINEE VISITATE TROPPO SPESSO %',  n_multiple;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    ELIMINAZIONI LINEE MULTIPLE ('||n_multiple||')'')';
		perform dblink_exec('local_dblink',stmt); 
	 
	--	commit;
	 /* SELEZIONA LE RISORSE CHE HANNO ESAURITO LA CAPACITA' A TO-BE-EXLUDED */
		update agenda.elab_cal_param_ns set to_be_excluded= true where id_elab_cal =R_EC.id and id_ns in (
		select a.id_ns from (
			select ns.id_ns,sum(ups) tot,ns.cap_tot,ns.cap_used,ns.cap_ev
			from agenda.attivita a 
			join agenda.vw_elab_cal_param_ns ns on ns.id_elab_cal=a.id_elab_cal and  ns.id_nominativo =a.id_risorsa 
			where  a.id_elab_cal=R_EC.id group by 1,3,4,5) a
		where cap_tot-cap_ev < tot);
		GET DIAGNOSTICS n_disassociate = ROW_COUNT;	
		raise notice 'DISASSOCIATE STEP 1 %',n_disassociate;
	
	/* DISASSOCIA LE ATTIVITA' CHE NON POSSONO ESSERE EFFETTUATE PER RAGGIUNGIMENTO CAPACITA' DA PARTE DELLA RISORSA */
		update agenda.attivita set id_risorsa=null where id in (
		select id from (
			select a.id,id_risorsa,ups ,sum(ups) over (partition by id_risorsa order by prog rows between unbounded preceding and current row) over_b,
				ns.cap_tot,ns.cap_used,ns.cap_ev
			from agenda.attivita a 
			join agenda.vw_elab_cal_param_ns ns on ns.id_elab_cal=a.id_elab_cal and  ns.id_nominativo =a.id_risorsa 
			where  a.id_elab_cal=R_EC.id and a.id_risorsa is not null and ns.to_be_excluded) a
		where cap_tot-cap_ev < over_b);
		GET DIAGNOSTICS n_disassociate = ROW_COUNT;
    	raise notice 'ASSOCIAZIONE  RISORSE DISASSOCIATE %',  n_disassociate;
    	n_disassociate:= n_disassociate+n_multiple;
    	raise notice '	DISASSOCIAZIONE ATTIVITA RISORSE %',  n_disassociate;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    DISASSOCIAZIONE RISORSE-ATTIVITA ('||n_disassociate||') '')';
		perform dblink_exec('local_dblink',stmt); 
		/* END ASSOCIA RISORSE */

		/* START CALCOLO CAPACITA */
		update agenda.elab_cal_param_ns p set cap_used=sub.prog_a from (
			select ns.id as id_ns,coalesce(sum(ups),0) prog_a from agenda.attivita a 
			join matrix.vw_nominativi_struttura ns on a.id_risorsa =ns.id_nominativo and a.id_struttura =ns.id_node_struttura
			where   a.id_elab_cal =R_EC.id  group  by 1
		) sub where p.id_elab_cal=R_EC.id and p.id_ns=sub.id_ns	and to_be_excluded;

		/* ESCLUDE LE RISORSE SEGNATE COME TO-BE-EXCLUDED */
		update agenda.elab_cal_param_ns set excluded=true ,to_be_excluded=false where to_be_excluded and id_elab_cal =R_EC.id ;
		GET DIAGNOSTICS cap = ROW_COUNT;
		raise notice 'RISORSE ESCLUSE %', cap;

		select count(*) into cap from agenda.elab_cal_param_ns where id_elab_cal=R_EC.id and not excluded;

    	raise notice 'CALCOLATA CAPACITA RESIDUA %', cap;

   		raise notice ' ASSOCIATE % DISASSOCIATE % CAP %',n_associate ,n_disassociate, cap;

	end loop;
	/* END WHILE */


   /* START ASSOCIAZIONE DATA */
   
	update agenda.attivita set dt=sub.giorno/*,durata= (interval '4 hour')* sub.fattore_ups*/ from
	(select id_struttura,id_piano,contatore,dd as giorno/*,coalesce(p.fattore_ups,0.75) fattore_ups*/ from (
		/*(select id_risorsa,id_struttura,id_piano,contatore, row_number() over (partition by id_risorsa order by id_risorsa)  as giorni
		from agenda.attivita where id_elab_cal =R_EC.id and id_risorsa is not null) d*/
	      (select id_anagrafica,id_struttura,id_piano,contatore, row_number() over (partition by id_anagrafica order by id_anagrafica)  as giorni
		from agenda.attivita a join matrix.nominativi n on n.id =a.id_risorsa  where id_elab_cal =R_EC.id and id_risorsa is not null) d
		join 
			(select dd,row_number() over(order by extract (hour from dd),dd) prog from (
				select dd +(interval '1 hour') * 9  as dd FROM generate_series( param_periodo_da, param_periodo_a, '1 day'::interval) dd
				union 
				select dd +(interval '1 hour') * 14  FROM generate_series     ( param_periodo_da, param_periodo_a, '1 day'::interval) dd) a
				where extract (dow from dd) between 1 and 5
				and dd::date not in (select dt from agenda.festivita)) g on d.giorni=g.prog) a
	/* left join matrix.vw_struttura_piani p on p.id=a.id_piano */
	
	)sub	where attivita.id_struttura =sub.id_struttura and attivita.id_piano=sub.id_piano
				and attivita.contatore=sub.contatore and attivita.id_elab_cal=R_EC.id ;
   
	GET DIAGNOSTICS n = ROW_COUNT;
	raise notice 'ATTIVITA ASSOCIATE CON DATA %',  n;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''ATTIVITA ASSOCIATE CON DATA ('||n||') '')';
    raise notice 'STMT %',stmt;
		perform dblink_exec('local_dblink',stmt); 

	select count(*) into cnt_day from (
	select dd dt,row_number() over(order by extract (hour from dd),dd) prog from (
				select dd +(interval '1 hour') * 9  as dd FROM generate_series( param_periodo_da, param_periodo_a, '1 day'::interval) dd
				union 
				select dd +(interval '1 hour') * 14  FROM generate_series     ( param_periodo_da, param_periodo_a, '1 day'::interval) dd) a
				where extract (dow from dd) between 1 and 5
				and dd::date not in (select dt from agenda.festivita)) a;
			
			
	update agenda.attivita set dt=s.dt_new
	from 
	(select id id_attivita,dt dt_new from 
		(select id,row_number() over (order by id) prog from agenda.attivita a2
		where id_risorsa is null and extract(hour from dt)=0 and id_elab_cal =R_EC.id  ) a
		join 
		(select dd dt,row_number() over(order by extract (hour from dd),dd) prog from (
				select dd +(interval '1 hour') * 9  as dd FROM generate_series( param_periodo_da, param_periodo_a, '1 day'::interval) dd
				union 
				select dd +(interval '1 hour') * 14  FROM generate_series     ( param_periodo_da, param_periodo_a, '1 day'::interval) dd) a
				where extract (dow from dd) between 1 and 5
				and dd::date not in (select dt from agenda.festivita)) b
		on mod(a.prog,cnt_day)=b.prog) s
	where id=s.id_attivita;
	
	update agenda.attivita a set dt=dt+(interval '1 hour')*8 
	where id_risorsa is null and extract(hour from dt)=0 and id_elab_cal =R_EC.id ;

	select json_agg(row_to_json(g.*)) into rt from (select 
		 a.id,l.denominazione_sede_operativa  linea,c.comune,sa.descrizione_breve uos,n.nominativo ,dt as giorno, 
		 sp.alias || ' - '||sp.descrizione_breve  /*replace(sp.path_descr,'Totale/','')*/ attivita,
		 e.id is null as selezionabile
		 
		 from		agenda.attivita a  join agenda.vw_linee l on a.id_linea =l.id_linea
		--left join agenda.vw_comuni_lookup c on c.com_id =l.id_comune
		left join agenda.vw_az_sedi s on s.id=l.id_az_sede 
	 	join agenda.comuni c on c.id =s.id_comune 
		join matrix.struttura_asl sa  on sa.id =a.id_struttura
		join matrix.vw_tree_nodes_up_piani sp on sp.id_node=a.id_piano
		left join matrix.nominativi n on n.id=a.id_risorsa 
		left join agenda.eventi e on e.id_attivita =a.id
		where a.id_elab_cal=R_EC.id order by a.dt,n.nominativo,c.comune,l.denominazione_sede_operativa 
		) g;

		raise notice '%',json_array_length(rt);
    	update agenda.elab_cals set tm_last_elab =current_timestamp where id=R_EC.id;
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
	 		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''FINE GENERAZIONE CALENDARIO'')';
   		raise notice 'STMT %',stmt;
		perform dblink_exec('local_dblink',stmt); 
		return ret;
	end;
$$;


ALTER FUNCTION agenda.genera_calendario(dati json, idtransazione bigint) OWNER TO postgres;

--
-- Name: genera_calendario_da_eliminare(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.genera_calendario_da_eliminare(dati json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idselected bigint;
	proc_name varchar;
	R_CAL agenda.vw_calendari%ROWTYPE;
	R_EC agenda.elab_cals%ROWTYPE;
	REC Record;
	rt json;
	n integer;

	begin
	proc_name:='agenda.genera_calendario';

	R_EC.id:=dati->>'id_elab_cal';
	if R_EC.id is null then
		R_EC.id:=dati->>'id_gen_cal';
	end if;
	R_EC.id_user:= ((dati->>'user_info')::json)->>'id_utente';

	raise notice 'ID_ELAB_CAL ID=% ID_USER=%', R_EC.id,R_EC.id_user;

	select * into R_EC from agenda.elab_cals ec where id =R_EC.id;
	/* 
	delete from agenda.elab_cal_params          where id_elab_cal=R_EC.id;
	insert into agenda.elab_cal_params
	select  nextval('agenda.agenda_id_seq'),R_EC.id,'PIANO',replace(x.value::varchar,'"','')::bigint
	from json_array_elements((dati->>'piani')::json) x;
	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'PIANI inseriti % record',  n;

	insert into agenda.elab_cal_params
	select  nextval('agenda.agenda_id_seq'),R_EC.id,'ASL',replace(x.value::varchar,'"','')::bigint
	from json_array_elements((dati->>'asl')::json) x;
	
	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'ASL inseriti % record',  n; */

   
	delete from agenda.attivita where id_elab_cal=R_EC.id;

	select count(*) into n from agenda.linee_selezionate ls where id_elab_cal =R_EC.id;
	raise notice 'LINEE SELEZIONATE DEL COUNT %',  n;
	raise notice 'CANCELLAZIONE ATTIVITA e LINEE';

	insert into agenda.attivita
	select nextval('agenda.attivita_id_seq'),pa.id_elab_cal ,t.id_struttura as id_struttura_asl,t.id_piano as id_piano,
			null id_linea, null dt, null id_risorsa, target, n.contatore,target * coalesce(fattore_fin,0.74) ups
	from 	matrix.struttura_piano_target t	
			join agenda.elab_cal_param_asl pa on t.id_struttura=pa.id_asl    and pa.id_elab_cal=R_EC.id-- and pa.type_param='ASL' 
			join agenda.elab_cal_param_piani pp on t.id_piano  =pp.id_piano  and pp.id_elab_cal=R_EC.id --and pp.type_param='PIANO'
			join matrix.struttura_piani p on p.id=t.id_piano
			left join matrix.formule f on p.id_formula_ups =f.id
			join (SELECT generate_series as  contatore FROM generate_series(1,10000)) n on n.contatore <= t.target;
	
	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'ATTIVITA GENERATE %',  n;

   
   update agenda.attivita set id_risorsa=sub.id_nominativo FROM
(select id_struttura,id_piano,row_number() over (partition by id_struttura,id_piano order by id_struttura,id_piano,id_nominativo) contatore,
 id_nominativo from (
select id_nominativo,ns.id_node_struttura id_struttura,m4.ups*(100.0-ms.sottr)/200/ms.ups frazione --,*
from matrix.vw_nominativi_struttura ns
			join matrix.vw_tree_nodes_down_asl_descr sd on sd.id_node=ns.id_node_struttura 
			join matrix.mod4_nominativi m4 on m4.id_nominativo_struttura =ns.id
			join matrix.vw_mod4_strutture ms on ms.id_node_struttura =ns.id_node_struttura 
			join agenda.elab_cal_param_asl pa on /*type_param='ASL' and */ id_elab_cal=R_EC.id and pa.id_asl =sd.id_node_ref 
) r join (
			select 
t.id_struttura as id_struttura_asl,p.id id_piano,null id_linea,null dt,null id_risorsa,target,/*n.contatore,*/target*coalesce(fattore_fin,0.74) ups--,sd.descrizione_breve as uos,p.descrizione 
from matrix.struttura_piano_target t
			join agenda.elab_cal_param_asl   pa on t.id_struttura=pa.id_asl   and pa.id_elab_cal=R_EC.id --and pa.type_param='ASL' 
			join agenda.elab_cal_param_piani pp on t.id_piano    =pp.id_piano   and pp.id_elab_cal=R_EC.id --and pp.type_param='PIANO'
				join matrix.struttura_piani p on p.id=t.id_piano
			left join matrix.formule f on p.id_formula_ups =f.id) s
			on r.id_struttura=s.id_struttura_asl 
			join (SELECT generate_series as  contatore FROM generate_series(1,10000)) n on n.contatore <= round(frazione*target)) as sub
where attivita.id_struttura =sub.id_struttura and attivita.id_piano=sub.id_piano and attivita.contatore=sub.contatore and attivita.id_elab_cal=R_EC.id;

	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'ATTIVITA ASSOCIATE A NOMINATIVO %',  n;

delete from agenda.attivita where id_risorsa is null;

	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'ATTIVITA NON ASSOCIATE A NOMINATIVO %',  n;

update agenda.attivita set dt=sub.giorno,durata='03:00:00'::interval from
(select id_risorsa,id_struttura,id_piano,contatore,dd as giorno from (
(select id_risorsa,id_struttura,id_piano,contatore, row_number() over (partition by id_risorsa order by id_risorsa)  as giorni
from agenda.attivita where id_elab_cal =R_EC.id and id_risorsa is not null) d
join 
(select dd,row_number() over(order by extract (hour from dd),dd) prog from (select * FROM generate_series
        ( '2023-01-01 09:00:00'::timestamp 
        , '2024-01-01'::timestamp
        , '1 day'::interval) dd
union 
select * FROM generate_series
        ( '2023-01-01 14:00:00'::timestamp 
        , '2024-01-01'::timestamp
        , '1 day'::interval) dd) a
where extract (dow from dd) between 1 and 5
and dd::date not in (select dt from agenda.festivita)) g on d.giorni=g.prog) a)sub
where attivita.id_struttura =sub.id_struttura and attivita.id_piano=sub.id_piano
and attivita.contatore=sub.contatore and attivita.id_elab_cal=R_EC.id ;
   
GET DIAGNOSTICS n = ROW_COUNT;
raise notice 'ATTIVITA ASSOCIATE CON DATA %',  n;

select count(*) into n from agenda.linee_selezionate ls where id_elab_cal =R_EC.id;
raise notice 'LINEE SELEZIONATE PRE COUNT %',  n;

raise notice 'LINEE SELEZIONATE %',  n;

select count(*) into n from agenda.linee_selezionate ls where id_elab_cal =R_EC.id;
raise notice 'LINEE SELEZIONATE POST COUNT %',  n;

n:=0;
for REC in select ls.*,s.id_comune as id_comune from agenda.linee_selezionate ls
	join agenda.linee l on l.id=ls.id_linea --join agenda.vw_comuni_lookup cl on cl.id=l.id_comune
	join agenda.az_sedi s on s.id=l.id_az_sede 
	-- join agenda.comuni cl on cl.id =s.id_comune 
	where id_elab_cal = R_EC.id order by ordine loop
	select a.id into idselected  from agenda.attivita a join matrix.vw_nominativi_struttura ns on ns.id_nominativo=a.id_risorsa
	join agenda.nominativo_comuni n on ns.id  =n.id_nominativo_struttura join agenda.struttura_comuni sc on sc.id =n.id_struttura_comune  
	where id_piano=REC.id_piano and sc.id_comune=REC.id_comune and a.id_linea is null and id_elab_cal= R_EC.id order by dt limit 1;
	if idselected is not null then
		update agenda.attivita set id_linea = REC.id_linea where id=idselected ;
		n:=n+1;
	end if;
end loop;
raise notice 'LINEE ASSOCIATE POST FOR  %',  n;

	select json_agg(row_to_json(g.*)) into rt from (select 
		 l.denominazione_sede_operativa  linea,c.comune,sa.descrizione_breve uos,n.nominativo ,dt as giorno,replace(sp.path_descr,'Totale/','') attivita from
		agenda.attivita a  join agenda.vw_linee l on a.id_linea =l.id_linea
		--left join agenda.vw_comuni_lookup c on c.com_id =l.id_comune
		join agenda.az_sedi s on s.id=l.id_az_sede 
	 	join agenda.comuni c on c.id =s.id_comune 
		join matrix.struttura_asl sa  on sa.id =a.id_struttura
		join matrix.vw_tree_nodes_up_piani sp on sp.id_node=a.id_piano
		join matrix.nominativi n on n.id=a.id_risorsa 
		where a.id_elab_cal=R_EC.id
		
		) g;
update agenda.elab_cals set tm_last_elab =clock_timestamp() where id = R_EC.id;
		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		ret.msg:='calendario non generato';
    		ret.info:=null; 
    	else
    		update agenda.elab_cals set tm_last_elab =current_timestamp where id=R_EC.id;
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;

	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.genera_calendario_da_eliminare(dati json, idtransazione bigint) OWNER TO postgres;

--
-- Name: genera_calendario_funct(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.genera_calendario_funct(dati json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	declare
	ret ag_types.result_type;
	id_op bigint;   
	idselected bigint;
	proc_name varchar;
	dt_da timestamp;
	dt_a timestamp;
	R_CAL agenda.vw_calendari%ROWTYPE;
	R_EC agenda.vw_elab_cals%ROWTYPE;
	REC Record;
	rt json;
	n integer;
	fract_time decimal;

	param_periodo_da timestamp;
	param_periodo_a timestamp;
	param_periodo tsrange;
	param_non_visitati_dal_valore decimal;
	param_non_visitati_dal timestamp;
	v_param_non_visitati_dal varchar;
	param_ultima_visita decimal;
	param_machine decimal;
	param_casuale decimal;
	param_linea boolean;
	param_ispettore boolean;
	time_start timestamp;
	n_cicli integer;
	n_associate integer;
	n_multiple integer;
	n_disassociate integer;
	cap integer;
	rid integer;
	db_log varchar;
	--anno_elab integer;
    stmt varchar;
   cnt_day integer;
  
  	def_freq_rischio_alta  decimal;
	def_freq_rischio_media decimal;
	def_freq_rischio_bassa decimal;
	def_ups                decimal;
	def_uba                decimal;
	def_min_start          decimal;
	def_ora_start          decimal;
	ora_start interval;
	def_min_end          decimal;
	def_ora_end          decimal;
	ora_end interval;
	ore_lavoro interval;
	nnn integer;
	giorni_anno integer;
	begin
	proc_name:='agenda.genera_calendario_proc';
	time_start := clock_timestamp();
	n_cicli := 0;
	/* START ACQUISIZIONE PARAMETRI */
	R_EC.id:=dati->>'id_elab_cal';
	if R_EC.id is null then
		R_EC.id:=dati->>'id_gen_cal';
	end if;

	if R_EC.id is null then
		ret.esito:=false;
		return ret;
	end if;
    update agenda.elab_cals set tm_last_elab_start =clock_timestamp(),tm_last_elab=null where id=R_EC.id and tm_last_elab_start is null;
    GET DIAGNOSTICS n = ROW_COUNT;
    if n!= 1 then
    	ret.esito:=false;
		return ret;
    end if;
	select 'dbname='||valore into db_log  from config.config where nome='MDGM_DB' and validita @> current_timestamp::timestamp;
	/* Svuotamento LOG */
	stmt:='delete from agenda.elab_cal_logs where id_elab_cal='||R_EC.id;
	perform dblink_exec(db_log,stmt);
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''START ELABORAZIONE'')';
	perform dblink_exec(db_log,stmt);

	raise notice 'ID_ELAB_CAL ID=% ID_USER=%', R_EC.id,R_EC.id_user;

	select * into R_EC from agenda.vw_elab_cals ec where id =R_EC.id;
   
	delete from agenda.attivita where id_elab_cal=R_EC.id;

	select value::timestamp into param_periodo_da from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='periodo_da';
	select value::timestamp into param_periodo_a  from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='periodo_a';
	if param_periodo_da is null then
		param_periodo_da:=date_trunc('year',current_timestamp);
	end if;
	if param_periodo_da is null then
		param_periodo_a:=date_trunc('year',param_periodo_da)+ interval '1 year';
	end if;
	giorni_anno:=(extract (epoch from ((R_EC.anno+1)::varchar||'-01-01')::timestamp) - extract (epoch from ((R_EC.anno)::varchar||'-01-01')::timestamp))/3600/24;

	param_periodo:=tsrange(param_periodo_da,param_periodo_a + interval '1 day','[)');
	fract_time= (extract(epoch from param_periodo_a) - extract(epoch from param_periodo_da)) /(giorni_anno*24*3600);

	select value::decimal   into param_non_visitati_dal_valore from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='non_visitati_dal_valore';
	select value            into v_param_non_visitati_dal        from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='non_visitati_dal';
	if trim(v_param_non_visitati_dal) = '' then
		param_non_visitati_dal=null;
	else
		param_non_visitati_dal:=v_param_non_visitati_dal::timestamp;
	end if;
	select value::decimal   into param_ultima_visita           from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='ultima_visita';
	select value::decimal   into param_machine                 from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='machine';
	select value::decimal   into param_casuale                 from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='casuale';
	select value::boolean   into param_linea                   from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='linea';
	select value::boolean   into param_ispettore               from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='ispettore';

	select value::decimal   into def_freq_rischio_alta  from ag_conf.ag_conf where cod='freq_rischio_alta';
	select value::decimal   into def_freq_rischio_media from ag_conf.ag_conf where cod='freq_rischio_media';
	select value::decimal   into def_freq_rischio_bassa from ag_conf.ag_conf where cod='freq_rischio_bassa';
	select value::decimal   into def_ups                from ag_conf.ag_conf where cod='ups' ;
	select value::decimal   into def_uba                from ag_conf.ag_conf where cod='uba';
	select value::decimal   into def_ora_start          from ag_conf.ag_conf where cod='cal_start_ora';
	select value::decimal   into def_min_start          from ag_conf.ag_conf where cod='cal_start_minuti';
	select value::decimal   into def_ora_end            from ag_conf.ag_conf where cod='cal_end_ora';
	select value::decimal   into def_min_end            from ag_conf.ag_conf where cod='cal_end_minuti';
	select value::decimal* (interval '1 hours')   into ore_lavoro            from ag_conf.ag_conf where cod='cal_ore_lavoro';
	ora_start:= (interval '1 hour')*def_ora_start + (interval '1 minute')*def_min_start;
	ora_end  := (interval '1 hour')*def_ora_end + (interval '1 minute')*def_min_end;
	if ora_start   is null then ora_start := interval '9 hours'; end if;
	if ora_end     is null then ora_end   := ora_start + (interval '9 hours'); end if;
	raise notice 'FRACT_TIME=%',fract_time;
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''INIZIALIZZAZIONE'')';
	perform dblink_exec(db_log,stmt);
	--COMMIT;
	/* END ACQUISIZIONE PARAMETRI */


	/* START SELEZIONE PIANI */

	select count(*) into n from agenda.linee_selezionate ls where id_elab_cal =R_EC.id;
	raise notice 'LINEE SELEZIONATE DEL COUNT %',  n;
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''LINEE SELEZIONATE  ('|| n||')'')';
    raise notice 'STMT %',stmt;
	perform dblink_exec(db_log,stmt);
  
	/* CREA LA LISTA DELLE ATTIVITA POSSIBILI tenendo condo di:
	 * associazioni risorse/piani
	 * associazioni strutture/piani
	 * attività già programmate e presenti in agenda.eventi
	 * programmzione in matrix pp.periodo
	 * come periodo temporale usa l'intero anno */
	insert into agenda.attivita (id,id_elab_cal,id_struttura,id_piano,id_linea,dt,id_risorsa,target,contatore,ups,durata,validita,prog)
	select nextval('agenda.attivita_id_seq'),
			R_EC.id  ,t.id_struttura as id_struttura_asl,t.id_piano as id_piano,
			null id_linea, null dt, null id_risorsa, t.target, n.contatore,coalesce(fattore_fin,def_ups) ups,
			interval '1 minutes' * 4 * 60 * coalesce(fattore_fin,def_ups),
			coalesce(tsrange((R_EC.anno::varchar||to_char( lower(periodo),'-MM-DD'))::timestamp,
			                 (R_EC.anno::varchar||to_char( upper(periodo),'-MM-DD'))::timestamp,'[]'),param_periodo /*tsrange(param_periodo_da,param_periodo_a,'[]')*/)*param_periodo /*tsrange(param_periodo_da,param_periodo_a,'[]')*/,row_number () over(order by t.id_piano,t.id_struttura)
			from matrix.struttura_piano_target t	
			join (/*select distinct np.id_piano,mns.id_node_struttura id_struttura from agenda.nominativo_piani np
					join agenda.elab_cal_param_ns ns on ns.id_ns =np.id_nominativo_struttura
					join matrix.vw_nominativi_struttura mns on mns.id=ns.id_ns 
					where ns.id_elab_cal =R_EC.id */
			select distinct np.id_piano,mns.id_node_struttura id_struttura from agenda.nominativo_piani np
					join agenda.elab_cal_param_ns ns on ns.id_ns =np.id_nominativo_struttura
					join matrix.vw_nominativi_struttura mns on mns.id=ns.id_ns 
					join agenda.elab_cal_param_piani ep on ep.id_elab_cal =ns.id_elab_cal and ep.id_piano =np.id_piano 
					where ns.id_elab_cal =R_EC.id 
			) p on t.id_struttura=p.id_struttura and t.id_piano =p.id_piano 
			join matrix.struttura_piani sp on sp.id=t.id_piano 
			
			left join agenda.piano_periodo pp on pp.id_piano=t.id_piano 

			left join (select per_conto id_struttura,id_piano,count(*) pianificati from agenda.eventi where extract (year from eventi.inizio ) = R_EC.anno group by 1,2) a on t.id_struttura =a.id_struttura and t.id_piano =a.id_piano
			left join matrix.formule f on sp.id_formula_ups =f.id
			join (SELECT generate_series as  contatore FROM generate_series(1,10000)) n on n.contatore <= t.target-coalesce(a.pianificati,0)
			
			
			where coalesce(periodo,tsrange(param_periodo_da,param_periodo_a,'[]')) && tsrange(param_periodo_da,param_periodo_a,'[]');
	
	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'ATTIVITA GENERATE %',  n;
	stmt := 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),' ||R_EC.id|| ',clock_timestamp(),''CREAZIONE ATTIVITA ('||n||')'')';
    raise notice 'STMT %',stmt;
	perform dblink_exec(db_log,stmt);
	if n <=0 then
    	raise notice 'NESSUN ATTIVITA GENERATA';
		stmt := 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),' ||R_EC.id|| ',clock_timestamp(),''CREAZIONE NON POSSIBILE: 0 ATTIVITA'')';
		perform dblink_exec(db_log,stmt);
	    ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=null;
	 
	    update agenda.elab_cals set tm_last_elab =clock_timestamp() where id=R_EC.id;
		return ret;
	end if;
	--COMMIT;


	/* END SELEZIONE PIANI */


	/* START SELEZIONE LINEE */

	if param_linea then
	
		/* ASSOCIA LE LINEE SELEZIONATE IN BASE A:
		 * piano
		 * struttura
		 * numero progressivo piano-struttura
		 */
		raise notice 'PARAM LINEA';
		update  agenda.attivita a
		set id_linea = sub.id_linea,validita =coalesce(validita,sub.val)*sub.val
		from (
			/*select distinct on (id_piano,id_struttura_asl,contatore) id_piano,id_struttura_asl,contatore,id_linea,
					tsrange( case when extract (day from lower(s.val)) <= 4 then date_trunc ('month',lower(s.val)) when extract (day from lower(s.val)) >= 27 then date_trunc ('month',lower(s.val) +interval '15 days') else lower(s.val) end,
							 case when extract (day from lower(s.val)) <= 4 then date_trunc ('month',upper(s.val)) when extract (day from lower(s.val)) >= 27 then date_trunc ('month',upper(s.val) +interval '15 days') else upper(s.val) end,
							 '[)') val*/
							 
			select distinct on (id_piano,id_struttura_asl,contatore) id_piano,id_struttura_asl,contatore,id_linea,--s.val from ( 
					tsrange( case when extract (DAY from lower(s.val)) <= 4 then date_trunc ('month',lower(s.val)) when extract (DAY from lower(s.val)) >= 27 then date_trunc ('month',lower(s.val) +interval '15 days') else lower(s.val) end,
							 case when extract (DAY from lower(s.val)) <= 4 then date_trunc ('month',upper(s.val)) when extract (DAY from lower(s.val)) >= 27 then date_trunc ('month',upper(s.val) +interval '15 days') else upper(s.val) end,
							 '[)') val					 
			
				from ( 
				select a.id_linea,a.id_piano,a.id_struttura_asl,a.val,row_number() over (partition by  id_piano,id_struttura_asl order by rnd) contatore from (
				
				
				
					/*select  ls.id_linea, ls.id_piano,sc.id_struttura id_struttura_asl, /*n.contatore,,coalesce(pf.freq,1)*10,*/random() rnd from
		     				 agenda.linee_selezionate ls		--where  ls.id_elab_cal=3709
		     				join cu_anag.linee l on l.id=ls.id_linea
		     				join cu_anag.vw_stabilimenti s on s.id=l.id_stabilimento
		     				JOIN agenda.struttura_comuni sc ON sc.id_comune = s.id_comune
							left join agenda.vw_linea_piano_anno_assegnate a on a.id_piano=ls.id_piano and a.id_linea=ls.id_linea
							and a.anno=R_EC.anno --and ls.id_elab_cal=3709	
	     					left join agenda.vw_piano_freq pf on pf.id_piano = ls.id_piano and livello=s.categoria_rischio
							join      (SELECT generate_series as  contatore FROM generate_series(1,20)) n on n.contatore <= (ceil(coalesce(pf.freq*1,1))
							-coalesce(a.assegnate,0) )
					where ls.id_elab_cal =R_EC.id*/
					
					select  ls.id_linea, ls.id_piano,sc.id_struttura id_struttura_asl, /*n.contatore,,coalesce(pf.freq,1)*10,*/random() rnd,
							 n.contatore,(ceil(coalesce(pf.freq*1,1))),a.assegnate,
		     				 tsrange((R_EC.anno::varchar||'-01-01')::timestamp+(interval '1 day') * ceil((n.contatore -1) * giorni_anno/(coalesce(pf.freq*1,1))),
		     				         (R_EC.anno::varchar||'-01-01')::timestamp+(interval '1 day') * ceil((n.contatore   ) * giorni_anno/(coalesce(pf.freq*1,1))),'[)') val
					from
		     				 agenda.linee_selezionate ls	
		     				join cu_anag.linee l on l.id=ls.id_linea
		     				join cu_anag.vw_stabilimenti s on s.id=l.id_stabilimento
		     				JOIN agenda.struttura_comuni sc ON sc.id_comune = s.id_comune
							left join agenda.vw_linea_piano_anno_assegnate a on a.id_piano=ls.id_piano and a.id_linea=ls.id_linea
							and a.anno=R_EC.anno --and ls.id_elab_cal=3709	
	     					left join agenda.vw_piano_freq pf on pf.id_piano = ls.id_piano and livello=s.categoria_rischio
							join      (SELECT generate_series as  contatore FROM generate_series(1,20)) n on n.contatore <= ceil(coalesce(pf.freq*1,1))
							and n.contatore >coalesce(a.assegnate,0) 
					where ls.id_elab_cal =R_EC.id
					--order by id_linea,id_piano,contatore
					
					
					
					) a where a.val && param_periodo
			) as s
		
		

		) as sub
		where a.id_piano=sub.id_piano and a.id_struttura =sub.id_struttura_asl and a.contatore =sub.contatore and a.id_elab_cal =R_EC.id
		;

		GET DIAGNOSTICS n = ROW_COUNT;
    	raise notice 'ATTIVITA ASSOCIATE A LINEE %',  n;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''ATTIVITA ASSOCIATE A LINEE ('||n||')'')';
		raise notice 'STMT=%',stmt;
		perform dblink_exec(db_log,stmt);
	
		/*
		insert into agenda.attivita (id,id_elab_cal,id_struttura,id_piano,id_linea,dt,id_risorsa,target,
				contatore,ups,durata,validita,prog)
		select nextval('agenda.attivita_id_seq'),a.id_elab_cal,a.id_struttura,a.id_piano,
			l.id_linea,	a.dt,a.id_risorsa,a.target,a.contatore,a.ups,a.durata,a.validita,a.prog
			from agenda.attivita a
			join agenda.linee_principali lp on a.id_linea =lp.id_linea
			join agenda.vw_linee l on l.id_az_sede =lp.id_az_sede 
			where id_elab_cal =R_EC.id --and id_risorsa is not null
			and a.id_linea!=l.id_linea
			order by a.prog	;
		GET DIAGNOSTICS n = ROW_COUNT;
    	raise notice 'ATTIVITA ASSOCIATE A LINEE SECONDARIE  %',  n;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''ATTIVITA ASSOCIATE A LINEE SECONDARIE ('||n||')'')';
		raise notice 'STMT=%',stmt;
		perform dblink_exec(db_log,stmt); */

	end if;	
	--COMMIT;
    	/*	ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
	 	return ;*/
	/* END SELEZIONE LINEE */



	/* START CALCOLO CAPACITA PER OGNI RISORSA */ 
	update agenda.elab_cal_param_ns p set
		cap_tot=coalesce(sub.capacita,0),cap_ev=coalesce(sub.prog_e,0),excluded=false,to_be_excluded=false,
		cap_used=0/*sub.prog_a*/ from (
			select ns.id id_ns,ns.id_node_struttura id_struttura,
				(m4.ups*(100.0-ms.sottr)/200) *fract_time capacita,coalesce(e.prog_e,0) prog_e--,coalesce(a.prog_a,0) prog_a
			from matrix.vw_nominativi_struttura ns
			join matrix.mod4_nominativi m4 on m4.id_nominativo_struttura =ns.id
			join matrix.vw_mod4_strutture ms on ms.id_struttura =ns.id_struttura 
			join agenda.vw_elab_cal_param_ns pns on  pns.id_ns =ns.id
			left join (
				select ns.id as id_ns,coalesce(sum(coalesce(fattore_ups,def_ups)),0) prog_e from agenda.eventi e 
				join matrix.vw_nominativi_struttura ns on e.id_nominativo =ns.id_nominativo and e.per_conto =ns.id_node_struttura
				join matrix.vw_struttura_piani p on p.id=e.id_piano
				where e.inizio between param_periodo_da and param_periodo_a group  by 1/* AF 2024-01-30
				select ns.id as id_ns,sum(durata) prog_e from (
						select inizio,fine-inizio as durata,id_nominativo,per_conto from agenda.eventi union
						select inizio,fine-inizio as durata,id_partner,partner_per_conto from agenda.eventi 
						) e
						join matrix.vw_nominativi_struttura ns on e.id_nominativo =ns.id_nominativo and e.per_conto =ns.id_node_struttura
						where e.inizio between param_periodo_da and param_periodo_a group  by 1*/
			) e on e.id_ns=ns.id
			/*left join (
				select ns.id as id_ns,coalesce(sum(coalesce(fattore_ups,0.75)),0) prog_a from agenda.attivita a 
				join matrix.vw_nominativi_struttura ns on a.id_risorsa =ns.id_nominativo and a.id_struttura =ns.id_node_struttura
				join matrix.vw_struttura_piani p on p.id=a.id_piano 
				where   a.id_elab_cal =R_EC.id and a.dt between param_periodo_da and param_periodo_a group  by 1
			)  a on a.id_ns=ns.id*/
			where  pns.id_elab_cal=R_EC.id
	) sub where p.id_elab_cal=R_EC.id and p.id_ns=sub.id_ns	;
	GET DIAGNOSTICS cap = ROW_COUNT;
    raise notice 'CALCOLATA CAPACITA %',  cap;
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''CALCOLATA CAPACITA ('||cap||')'')';
    raise notice 'STMT %',stmt;
	perform dblink_exec(db_log,stmt);

	update agenda.elab_cal_param_ns p set
		cap_tot=0,cap_ev=0,excluded=true,to_be_excluded=false,
		cap_used=0 where p.id_elab_cal=R_EC.id  and (cap_tot is null or cap_tot<=0);

	
	
	/* RIDUZIONE PER DISPONIBILITA TEMPO */

	
	
	
	

	/*  */
	update agenda.elab_cal_param_ns p set fact_disponibilita=sub.fact,cap_tot=cap_tot*sub.fact from

		(
			select id_ns,case when richiesta_tot=0 then 0 else disponibilita/richiesta_tot end fact from
		(select ns.id_anagrafica,id_ns,coalesce(p.cap_tot,0) richiesta_ns, sum (coalesce(p.cap_tot,0)) over(partition by ns.id_anagrafica) richiesta_tot,
		sum(extract (epoch from o.disponibilita) * 2/ extract (epoch from (ore_lavoro/*ora_end-ora_start*/))) disponibilita
				from agenda.elab_cal_param_ns p
			join matrix.vw_nominativi_struttura ns on p.id_ns=ns.id and  id_elab_cal =R_EC.id
			join
		(
	select id_anagrafica,dd,ore_lavoro /*ora_end-ora_start*/ -sum(occupato) disponibilita
						 from (
				select e.id,r.id_anagrafica,dd ,tsrange(e.inizio,e.fine,'[)') ev ,tsrange(e.inizio,e.fine,'[)') * dd,
			case when e.inizio is null then interval '0 seconds' else
			coalesce(upper(tsrange(e.inizio,e.fine,'[)') * dd) -lower(tsrange(e.inizio,e.fine,'[)') * dd),interval '0 seconds') end occupato
 			from
 			
 			(select distinct id_anagrafica from agenda.elab_cal_param_ns  a
				join matrix.vw_nominativi_struttura ns on ns.id=a.id_ns
				where id_elab_cal =R_EC.id ) r
				
				
				/*(select distinct id_anagrafica from agenda.attivita a
				join matrix.vw_nominativi_struttura ns on ns.id_nominativo=a.id_risorsa
				where id_elab_cal =R_EC.id and id_risorsa is not null) r*/
				join
				(select tsrange(d::timestamp+ora_start,d::timestamp+ora_end,'[)') dd 
					FROM generate_series(param_periodo_da,param_periodo_a, '1 day'::interval) d
				 where d not in (select dt from agenda.festivita) and extract (dow from d) between 1 and 5) g
				on 1=1
				left join agenda.vw_eventi_occupazione e on e.id_anagrafica=r.id_anagrafica and (tsrange(e.inizio,e.fine,'[)') && dd)
		) o group by 1,2)
		o on o.id_anagrafica=ns.id_anagrafica
		group by 1,2,3) q where richiesta_tot > disponibilita
		
		) sub
		where p.id_elab_cal=R_EC.id and p.id_ns=sub.id_ns;
	
		
	GET DIAGNOSTICS rid = ROW_COUNT;
    raise notice 'RIDUZIONE CAPACITA %',  rid;
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''RIDUZIONE CAPACITA ('||rid||')'')';
    raise notice 'STMT %',stmt;
		perform dblink_exec(db_log,stmt);
	
	update agenda.elab_cal_param_ns p set
		cap_tot=0,cap_ev=0,excluded=true,to_be_excluded=false,
		cap_used=0 where p.id_elab_cal=R_EC.id  and (cap_tot is null or cap_tot<=0);

	GET DIAGNOSTICS nnn = ROW_COUNT;
	raise notice '===============>    UPDATE A 0 %',  nnn;		
	
	/* END CALCOLO CAPACITA */
	--commit;

    	/*ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
	 	return ;*/
	n_associate:=1000;
	n_disassociate:=0;
	select sum(cap_tot)-sum(cap_ev) into n from agenda.elab_cal_param_ns			where  id_elab_cal=R_EC.id;
	if n <=0 or n is null then
    	raise notice 'NESSUNA RISORSA DISPONIBILE';
		stmt := 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),' ||R_EC.id|| ',clock_timestamp(),''CREAZIONE NON POSSIBILE: 0 RISORSE'')';
		perform dblink_exec(db_log,stmt);
	    ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=null;
	 	update agenda.elab_cals set tm_last_elab =clock_timestamp() where id=R_EC.id;
		return ret;
	end if;
	n_cicli := 0;
	while n_cicli < 100 and ( clock_timestamp() - time_start ) < interval '5 minutes' and n_associate >n_disassociate and cap >0 loop
		if n_cicli = 0 then
			raise notice ' ASSOCIATE % DISASSOCIATE % CAP %',n_associate ,n_disassociate, cap;
			stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''ASSEGNAZIONE ATTIVITA VETERINARI ASSOCIATI '')';
		    raise notice 'STMT %',stmt;
			perform dblink_exec(db_log,stmt);
		
		
			update agenda.attivita a set id_risorsa = sub.id_nominativo,dt=null -- AF 20240408 dt=param_periodo_da
				from
				(select a.id id_attivita, nl.id_nominativo , nl.id_nominativo_struttura
				from agenda.attivita a join cu_anag.linee l on l.id=a.id_linea join cu_anag.vw_stabilimenti s on l.id_stabilimento=s.id
				join agenda.vw_nominativo_linee nl on nl.id_linea=l.id
				where id_elab_cal=R_EC.id ) sub 
			where a.id=sub.id_attivita;
		
		
		
		
		/*
			update agenda.attivita a set id_risorsa = sub.id_nominativo,dt=param_periodo_da
				from
				(
				select distinct on (id_attivita) id_attivita,id_nominativo,a.id_nominativo_struttura from (				
				select a.id id_attivita, a.id_piano,s.id_comune , nl.id_nominativo_struttura,row_number() over(partition by id_piano,id_comune) n 
				from agenda.attivita a join cu_anag.linee l on l.id=a.id_linea join cu_anag.vw_stabilimenti s on l.id_stabilimento=s.id
				join agenda.nominativo_linee nl on nl.id_linea=l.id
				where id_elab_cal=R_EC.id and id_risorsa is null) a
				join
				(select id_piano,id_comune, id_nominativo,b.id_ns,row_number() over(partition by id_piano,id_comune order by rnd desc) n from (
				select np.id_nominativo,np.id_piano , nc.id_comune,
						(case when ns.cap_tot -ns.cap_ev> coalesce(ns.cap_used,0) then ns.cap_tot -ns.cap_ev -coalesce(ns.cap_used,0) else 0 end) * random() rnd,ns.id_ns
				from agenda.elab_cal_param_ns ns 
				join agenda.vw_nominativo_piani np on np.id_nominativo_struttura =ns.id_ns 
				join agenda.elab_cal_param_piani pp on pp.id_elab_cal =ns.id_elab_cal and pp.id_piano =np.id_piano 
				join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id_ns 
				--join matrix.vw_nominativi_struttura mns on mns.id=ns.id_ns
				join (SELECT generate_series as  contatore FROM generate_series(1,20)) c on 1=1
					where ns.id_elab_cal=R_EC.id and not ns.excluded 
					) b ) b on a.id_piano=b.id_piano and a.id_comune=b.id_comune and a.n=b.n and a.id_nominativo_struttura=b.id_ns limit 1000) sub 
			where a.id=sub.id_attivita ;*/
	
			GET DIAGNOSTICS n_associate = ROW_COUNT;
	    	raise notice 'ASSOCIAZIONE ATTIVITA RISORSE %',  n_associate;
			stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    ASSOCIAZIONE RISORSE-ATTIVITA ('||n_associate||')'')';
			perform dblink_exec(db_log,stmt);
		end if;
		n_cicli:= n_cicli+1;
	    raise notice ' ASSOCIATE % DISASSOCIATE % CAP %',n_associate ,n_disassociate, cap;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''START CICLO ('||n_cicli||')'')';
	    raise notice 'STMT %',stmt;
		perform dblink_exec(db_log,stmt);
		--commit;
/* START ASSOCIA RISORSE */
		raise notice 'START UPDATE agenda.attivita';

		update agenda.attivita a set id_risorsa = sub.id_nominativo,dt= null -- AF 2024-04-08 param_periodo_da
			from
			(
			select distinct on (id_attivita) id_attivita,id_nominativo from (
			/* AF 2024-02-19 select a.id id_attivita, a.id_piano,l.id_comune , row_number() over(partition by id_piano,id_comune) n 
			from agenda.attivita a join agenda.vw_linee l on l.id=a.id_linea
			where id_elab_cal=R_EC.id and id_risorsa is null*/
			
			select a.id id_attivita, a.id_piano,s.id_comune , row_number() over(partition by id_piano,id_comune) n 
			from agenda.attivita a join cu_anag.linee l on l.id=a.id_linea join cu_anag.vw_stabilimenti s on l.id_stabilimento=s.id
			--left join agenda.nominativo_linee nl on nl.id_linea=l.id
			where id_elab_cal=R_EC.id and id_risorsa is null and a.id_linea not in (select id_linea from agenda.nominativo_linee)) a
			join
			(select id_piano,id_comune, id_nominativo,row_number() over(partition by id_piano,id_comune order by rnd desc) n from (
			select np.id_nominativo,np.id_piano , nc.id_comune,
					(case when ns.cap_tot -ns.cap_ev> coalesce(ns.cap_used,0) then ns.cap_tot -ns.cap_ev -coalesce(ns.cap_used,0) else 0 end) * random() rnd 
			from agenda.elab_cal_param_ns ns 
			join agenda.vw_nominativo_piani np on np.id_nominativo_struttura =ns.id_ns 
			join agenda.elab_cal_param_piani pp on pp.id_elab_cal =ns.id_elab_cal and pp.id_piano =np.id_piano 
			join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id_ns 
			--join matrix.vw_nominativi_struttura mns on mns.id=ns.id_ns
			join (SELECT generate_series as  contatore FROM generate_series(1,20)) c on 1=1
				where ns.id_elab_cal=R_EC.id and not ns.excluded 
				) b ) b on a.id_piano=b.id_piano and a.id_comune=b.id_comune and a.n=b.n limit 1000) sub 
		where a.id=sub.id_attivita ;

		GET DIAGNOSTICS n_associate = ROW_COUNT;
    	raise notice 'ASSOCIAZIONE ATTIVITA RISORSE %',  n_associate;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    ASSOCIAZIONE RISORSE-ATTIVITA ('||n_associate||')'')';
		perform dblink_exec(db_log,stmt);
		/* END ASSOCIA RISORSE */
	 
	 	/*CANCELLA LE LINEE VISITATE PIU VOLTE RISPETTO ALLA FREQUENZA PREVISTA */
	    delete from agenda.attivita where id in 
	 		(select id from (
				select a.id,a.id_linea,a.id_piano,f.freq f,row_number() over(partition by a.id_linea,a.id_piano) n_seq
				from agenda.attivita a --join agenda.vw_piano_freq f on f.id_piano=a.id_piano --and f.livello =1
				join cu_anag.linee l on l.id=a.id_linea
				join cu_anag.stabilimenti s on s.id=l.id_stabilimento
				join agenda.vw_piano_freq f on f.id_piano=a.id_piano and f.livello =s.categoria_rischio
				where a.id_linea is not null and
				id_elab_cal=R_EC.id) a where n_seq>ceil(f));
		GET DIAGNOSTICS n_multiple = ROW_COUNT;
    	raise notice 'ELIMINAZIONE LINEE VISITATE TROPPO SPESSO %',  n_multiple;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    ELIMINAZIONI LINEE MULTIPLE ('||n_multiple||')'')';
		perform dblink_exec(db_log,stmt);
	 
	--	commit;
	 /* SELEZIONA LE RISORSE CHE HANNO ESAURITO LA CAPACITA' A TO-BE-EXLUDED */
		update agenda.elab_cal_param_ns set to_be_excluded= true where id_elab_cal =R_EC.id and id_ns in (
		select a.id_ns from (
			select ns.id_ns,sum(ups) tot,ns.cap_tot,ns.cap_used,ns.cap_ev
			from agenda.attivita a 
			join agenda.vw_elab_cal_param_ns ns on ns.id_elab_cal=a.id_elab_cal and  ns.id_nominativo =a.id_risorsa 
			where  a.id_elab_cal=R_EC.id group by 1,3,4,5) a
		where cap_tot-cap_ev < tot );
		GET DIAGNOSTICS n_disassociate = ROW_COUNT;	
		raise notice 'DISASSOCIATE STEP 1 %',n_disassociate;
	
	/* DISASSOCIA LE ATTIVITA' CHE NON POSSONO ESSERE EFFETTUATE PER RAGGIUNGIMENTO CAPACITA' DA PARTE DELLA RISORSA */
		update agenda.attivita set id_risorsa=null where id in (
		select id from (
			select a.id,id_risorsa,ups ,sum(ups) over (partition by id_risorsa order by prog rows between unbounded preceding and current row) over_b,
				ns.cap_tot,ns.cap_used,ns.cap_ev
			from agenda.attivita a 
			join agenda.vw_elab_cal_param_ns ns on ns.id_elab_cal=a.id_elab_cal and  ns.id_nominativo =a.id_risorsa 
			where  a.id_elab_cal=R_EC.id and a.id_risorsa is not null and ns.to_be_excluded) a
		where cap_tot-cap_ev < over_b);
		GET DIAGNOSTICS n_disassociate = ROW_COUNT;
    	raise notice 'ASSOCIAZIONE  RISORSE DISASSOCIATE %',  n_disassociate;
    	n_disassociate:= n_disassociate+n_multiple;
    	raise notice '	DISASSOCIAZIONE ATTIVITA RISORSE %',  n_disassociate;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    DISASSOCIAZIONE RISORSE-ATTIVITA ('||n_disassociate||') '')';
		perform dblink_exec(db_log,stmt);
		/* END ASSOCIA RISORSE */
		--commit;

		/* START CALCOLO CAPACITA */
		update agenda.elab_cal_param_ns p set cap_used=sub.prog_a from (
			select ns.id as id_ns,coalesce(sum(ups),0) prog_a from agenda.attivita a 
			join matrix.vw_nominativi_struttura ns on a.id_risorsa =ns.id_nominativo and a.id_struttura =ns.id_node_struttura
			where   a.id_elab_cal =R_EC.id  group  by 1
		) sub where p.id_elab_cal=R_EC.id and p.id_ns=sub.id_ns	and to_be_excluded;

		/* ESCLUDE LE RISORSE SEGNATE COME TO-BE-EXCLUDED */
		update agenda.elab_cal_param_ns set excluded=true ,to_be_excluded=false where to_be_excluded and id_elab_cal =R_EC.id ;
		GET DIAGNOSTICS cap = ROW_COUNT;
		raise notice 'RISORSE ESCLUSE %', cap;

		select count(*) into cap from agenda.elab_cal_param_ns where id_elab_cal=R_EC.id and not excluded;

    	raise notice 'CALCOLATA CAPACITA RESIDUA %', cap;
	--raise notice   'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    ASSOCIAZIONE RISORSE-ATTIVITA ('||n_associate||')'')';
	/* END CALCOLO CAPACITA */
	--commit;
	--raise notice 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),'||
			--'END CICLO ('||n||') AGGIUNTI '||n_associate-n_disassociate|| ' TEMPO='||'round(extract(second from clock_timestamp()-time_start))'||' secondi'')';
	/* END CALCOLO CAPACITA */
	--commit;
   		raise notice ' ASSOCIATE % DISASSOCIATE % CAP %',n_associate ,n_disassociate, cap;

	end loop;
	/* END WHILE */


   /* START ASSOCIAZIONE DATA */

/*
   
	update agenda.attivita set dt=sub.giorno/*,durata= (interval '4 hour')* sub.fattore_ups*/ from
	(select id_struttura,id_piano,contatore,dd as giorno/*,coalesce(p.fattore_ups,0.75) fattore_ups*/ from (
		/*(select id_risorsa,id_struttura,id_piano,contatore, row_number() over (partition by id_risorsa order by id_risorsa)  as giorni
		from agenda.attivita where id_elab_cal =R_EC.id and id_risorsa is not null) d*/
	      (select id_anagrafica,id_struttura,id_piano,contatore, row_number() over (partition by id_anagrafica order by id_anagrafica)  as giorni
		from agenda.attivita a join matrix.nominativi n on n.id =a.id_risorsa  where id_elab_cal =R_EC.id and id_risorsa is not null) d
		join 
			(select dd,row_number() over(order by extract (hour from dd),dd) prog from (
				select dd +ora_start   as dd FROM generate_series( param_periodo_da, param_periodo_a, '1 day'::interval) dd
				union 
				select dd +ora_start+'04:00:00'::interval  FROM generate_series     ( param_periodo_da, param_periodo_a, '1 day'::interval) dd) a
				where extract (dow from dd) between 1 and 5
				and dd::date not in (select dt from agenda.festivita)) g on d.giorni=g.prog) a	
	)sub	where attivita.id_struttura =sub.id_struttura and attivita.id_piano=sub.id_piano
				and attivita.contatore=sub.contatore and attivita.id_elab_cal=R_EC.id ;
   
	GET DIAGNOSTICS n = ROW_COUNT;
	raise notice 'ATTIVITA ASSOCIATE CON DATA %',  n;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''ATTIVITA ASSOCIATE CON DATA ('||n||') '')';
    raise notice 'STMT %',stmt;
		perform dblink_exec(db_log,stmt);

	select count(*) into cnt_day from (
	select dd dt,row_number() over(order by extract (hour from dd),dd) prog from (
				select dd +ora_start /*(interval '1 hour') * 9*/  as dd FROM generate_series( param_periodo_da, param_periodo_a, '1 day'::interval) dd
				union 
				select dd +ora_start+'04:00:00'::interval   FROM generate_series     ( param_periodo_da, param_periodo_a, '1 day'::interval) dd) a
				where extract (dow from dd) between 1 and 5
				and dd::date not in (select dt from agenda.festivita)) a;
			
			
	update agenda.attivita set dt=s.dt_new
	from 
	(select id id_attivita,dt dt_new from 
		(select id,row_number() over (order by id) prog from agenda.attivita a2
		where id_risorsa is null and extract(hour from dt)=0 and id_elab_cal =R_EC.id  ) a
		join 
		(select dd dt,row_number() over(order by extract (hour from dd),dd) prog from (
				select dd + ora_start /*(interval '1 hour') * 9 */ as dd from
				generate_series( param_periodo_da, param_periodo_a, '1 day'::interval) dd
				union 
				select dd + ora_start+ '04:00:00'::interval   FROM generate_series     ( param_periodo_da, param_periodo_a, '1 day'::interval) dd) a
				where extract (dow from dd) between 1 and 5
				and dd::date not in (select dt from agenda.festivita)) b
		on mod(a.prog,cnt_day)=b.prog) s
	where id=s.id_attivita;		
*/
	n:=agenda.genera_calendario_upd_date(	R_EC.id,	ora_start,	ora_end,	param_periodo_da,	param_periodo_a,ore_lavoro);
 	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''AGGIORNAMENTO DATE ('||n||') '')';
	
 	raise notice 'STMT %',stmt;
	perform dblink_exec(db_log,stmt);

	/*Richiesta di Poli
	 * update agenda.attivita a set dt=dt+ora_start
	 * where id_risorsa is null and extract(hour from dt)=0 and id_elab_cal =R_EC.id ;
	 */

	update agenda.attivita a set dt=null
	where id_risorsa is null and id_elab_cal =R_EC.id ;

	update agenda.attivita a set dt=null, id_risorsa=null
	where extract(hour from dt)=0 and extract(minutes from dt)=0 and id_elab_cal =R_EC.id ;
	GET DIAGNOSTICS n = ROW_COUNT;
	raise notice 'ATTIVITA ELIMINATE PER NON CAPIENZA IN AGENDA %',  n;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''ATTIVITA ELIMINATE PER NON CAPIENZA IN AGENDA ('||n||') '')';
    raise notice 'STMT %',stmt;
		perform dblink_exec(db_log,stmt);

	select json_agg(row_to_json(g.*)) into rt from (
	
		/*select 
		 a.id,l.denominazione_sede_operativa  linea,l.comune,sa.descrizione_breve uos,n.nominativo ,dt as giorno, 
		 sp.alias || ' - '||sp.descrizione_breve  attivita,
		 e.id is null as selezionabile
		 from		agenda.attivita a  join c.vw_linee l on a.id_linea =l.id_linea
		join matrix.struttura_asl sa  on sa.id =a.id_struttura
		join matrix.vw_tree_nodes_up_piani sp on sp.id_node=a.id_piano
		left join matrix.nominativi n on n.id=a.id_risorsa 
		left join agenda.eventi e on e.id_attivita =a.id
		where a.id_elab_cal=R_EC.id order by a.dt,n.nominativo,l.comune,l.denominazione_sede_operativa */
	
		select 
			 a.id,s.nome linea  ,i.comune,sa.descrizione_breve uos,n.nominativo ,dt as giorno, 
			 sp.alias || ' - '||sp.descrizione_breve attivita,
			 --e.id is null as selezionabile
			 true as selezionabile
			 from		agenda.attivita a
			 join cu_anag.linee l on a.id_linea =l.id join cu_anag.stabilimenti s on s.id=l.id_stabilimento 
			 join cu_anag.vw_indirizzi i on i.id=s.id_indirizzo
			join matrix.struttura_asl sa  on sa.id =a.id_struttura
			join matrix.struttura_piani sp on sp.id=a.id_piano
			left join matrix.nominativi n on n.id=a.id_risorsa 
			--left join agenda.eventi e on e.id_attivita =a.id
			where a.id_elab_cal=R_EC.id order by a.dt,n.nominativo,i.comune,s.nome
		) g;

	raise notice '%',json_array_length(rt);
 
    	update agenda.elab_cals set tm_last_elab =clock_timestamp() where id=R_EC.id;
		ret.esito:=true;
		ret.msg:=null;
 		ret.info:=rt;
	 	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''FINE GENERAZIONE CALENDARIO'')';
	raise notice 'STMT %',stmt;
	perform dblink_exec(db_log,stmt);
	return ret;
	--end if;
end;
$$;


ALTER FUNCTION agenda.genera_calendario_funct(dati json, idtransazione bigint) OWNER TO postgres;

--
-- Name: genera_calendario_proc(json, bigint); Type: PROCEDURE; Schema: agenda; Owner: postgres
--

CREATE PROCEDURE agenda.genera_calendario_proc(IN dati json, IN idtransazione bigint, OUT ret ag_types.result_type)
    LANGUAGE plpgsql
    AS $$
	declare
	id_op bigint;   
	idselected bigint;
	proc_name varchar;
	dt_da timestamp;
	dt_a timestamp;
	R_CAL agenda.vw_calendari%ROWTYPE;
	R_EC agenda.vw_elab_cals%ROWTYPE;
	REC Record;
	rt json;
	n integer;
	fract_time decimal;

	param_periodo_da timestamp;
	param_periodo_a timestamp;
	param_non_visitati_dal_valore decimal;
	param_non_visitati_dal timestamp;
	param_ultima_visita decimal;
	param_machine decimal;
	param_casuale decimal;
	param_linea boolean;
	param_ispettore boolean;
	time_start timestamp;
	n_cicli integer;
	n_associate integer;
	n_multiple integer;
	n_disassociate integer;
	cap integer;
	rid integer;
	db_log varchar;
	--anno_elab integer;
    stmt varchar;
   cnt_day integer;
  
  	def_freq_rischio_alta  decimal;
	def_freq_rischio_media decimal;
	def_freq_rischio_bassa decimal;
	def_ups                decimal;
	def_uba                decimal;
	def_min_start          decimal;
	def_ora_start          decimal;
	ora_start interval;
	def_min_end          decimal;
	def_ora_end          decimal;
	ora_end interval;
	ore_lavoro interval;

	begin
	proc_name:='agenda.genera_calendario_proc';
	time_start := clock_timestamp();
	n_cicli := 0;
	/* START ACQUISIZIONE PARAMETRI */
	R_EC.id:=dati->>'id_elab_cal';
	if R_EC.id is null then
		R_EC.id:=dati->>'id_gen_cal';
	end if;

	if R_EC.id is null then
		ret.esito:=false;
		return;
	end if;
    update agenda.elab_cals set tm_last_elab_start =clock_timestamp(),tm_last_elab=null where id=R_EC.id and tm_last_elab_start is null;
    GET DIAGNOSTICS n = ROW_COUNT;
    if n!= 1 then
    	ret.esito:=false;
		return;
    end if;
	select 'dbname='||valore into db_log  from config.config where nome='MDGM_DB' and validita @> current_timestamp::timestamp;
	/* Svuotamento LOG */
	stmt:='delete from agenda.elab_cal_logs where id_elab_cal='||R_EC.id;
	perform dblink_exec(db_log,stmt);
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''START ELABORAZIONE'')';
	perform dblink_exec(db_log,stmt);
	--COMMIT;

	--R_EC.id_user:= ((dati->>'user_info')::json)->>'id_utente';

	raise notice 'ID_ELAB_CAL ID=% ID_USER=%', R_EC.id,R_EC.id_user;

	select * into R_EC from agenda.vw_elab_cals ec where id =R_EC.id;
   
	delete from agenda.attivita where id_elab_cal=R_EC.id;

	select value::timestamp into param_periodo_da from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='periodo_da';
	select value::timestamp into param_periodo_a  from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='periodo_a';
	if param_periodo_da is null then
		param_periodo_da:=date_trunc('year',current_timestamp);
	end if;
	if param_periodo_a is null then
		param_periodo_a:=date_trunc('year',param_periodo_da)+ interval '1 year';
	end if;
	--anno_elab:=extract(year from param_periodo_da);
	fract_time= (extract(epoch from param_periodo_a) - extract(epoch from param_periodo_da)) /(365*24*3600);
	--param_periodo_da:=param_periodo_da+ interval '9 hours';

	select value::decimal   into param_non_visitati_dal_valore from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='non_visitati_dal_valore';
	select value::timestamp into param_non_visitati_dal        from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='non_visitati_dal';
	select value::decimal   into param_ultima_visita           from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='ultima_visita';
	select value::decimal   into param_machine                 from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='machine';
	select value::decimal   into param_casuale                 from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='casuale';
	select value::boolean   into param_linea                   from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='linea';
	select value::boolean   into param_ispettore               from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='ispettore';

	select value::decimal   into def_freq_rischio_alta  from ag_conf.ag_conf where cod='freq_rischio_alta';
	select value::decimal   into def_freq_rischio_media from ag_conf.ag_conf where cod='freq_rischio_media';
	select value::decimal   into def_freq_rischio_bassa from ag_conf.ag_conf where cod='freq_rischio_bassa';
	select value::decimal   into def_ups                from ag_conf.ag_conf where cod='ups' ;
	select value::decimal   into def_uba                from ag_conf.ag_conf where cod='uba';
	select value::decimal   into def_ora_start          from ag_conf.ag_conf where cod='cal_start_ora';
	select value::decimal   into def_min_start          from ag_conf.ag_conf where cod='cal_start_minuti';
	select value::decimal   into def_ora_end            from ag_conf.ag_conf where cod='cal_end_ora';
	select value::decimal   into def_min_end            from ag_conf.ag_conf where cod='cal_end_minuti';
	select value::decimal* (interval '1 hours')   into ore_lavoro            from ag_conf.ag_conf where cod='cal_ore_lavoro';
	ora_start:= (interval '1 hour')*def_ora_start + (interval '1 minute')*def_min_start;
	ora_end  := (interval '1 hour')*def_ora_end + (interval '1 minute')*def_min_end;
	if ora_start   is null then ora_start := interval '9 hours'; end if;
	if ora_end     is null then ora_end   := ora_start + (interval '9 hours'); end if;
	raise notice 'FRACT_TIME=%',fract_time;
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''INIZIALIZZAZIONE'')';
	perform dblink_exec(db_log,stmt);
	--COMMIT;
	/* END ACQUISIZIONE PARAMETRI */


	/* START SELEZIONE PIANI */

	select count(*) into n from agenda.linee_selezionate ls where id_elab_cal =R_EC.id;
	raise notice 'LINEE SELEZIONATE DEL COUNT %',  n;
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''LINEE SELEZIONATE  ('|| n||')'')';
    raise notice 'STMT %',stmt;
	perform dblink_exec(db_log,stmt);
  
	/* CREA LA LISTA DELLE ATTIVITA POSSIBILI tenendo condo di:
	 * associazioni risorse/piani
	 * associazioni strutture/piani
	 * attività già programmate e presenti in agenda.eventi
	 * programmzione in matrix pp.periodo
	 * come periodo temporale usa l'intero anno */
	insert into agenda.attivita (id,id_elab_cal,id_struttura,id_piano,id_linea,dt,id_risorsa,target,contatore,ups,durata,validita,prog)
	select nextval('agenda.attivita_id_seq'),
			R_EC.id  ,t.id_struttura as id_struttura_asl,t.id_piano as id_piano,
			null id_linea, null dt, null id_risorsa, t.target, n.contatore,coalesce(fattore_fin,def_ups) ups,
			interval '1 minutes' * 4 * 60 * coalesce(fattore_fin,def_ups),
			coalesce(periodo,tsrange(param_periodo_da,param_periodo_a,'[]'))*tsrange(param_periodo_da,param_periodo_a,'[]'),row_number () over(order by t.id_piano,t.id_struttura)
			from matrix.struttura_piano_target t	
			join (/*select distinct np.id_piano,mns.id_node_struttura id_struttura from agenda.nominativo_piani np
					join agenda.elab_cal_param_ns ns on ns.id_ns =np.id_nominativo_struttura
					join matrix.vw_nominativi_struttura mns on mns.id=ns.id_ns 
					where ns.id_elab_cal =R_EC.id */
			select distinct np.id_piano,mns.id_node_struttura id_struttura from agenda.nominativo_piani np
					join agenda.elab_cal_param_ns ns on ns.id_ns =np.id_nominativo_struttura
					join matrix.vw_nominativi_struttura mns on mns.id=ns.id_ns 
					join agenda.elab_cal_param_piani ep on ep.id_elab_cal =ns.id_elab_cal and ep.id_piano =np.id_piano 
					where ns.id_elab_cal =R_EC.id 
			) p on t.id_struttura=p.id_struttura and t.id_piano =p.id_piano 
			join matrix.struttura_piani sp on sp.id=t.id_piano 
			
			left join agenda.piano_periodo pp on pp.id_piano=t.id_piano 

			left join (select per_conto id_struttura,id_piano,count(*) pianificati from agenda.eventi where extract (year from eventi.inizio ) = R_EC.anno group by 1,2) a on t.id_struttura =a.id_struttura and t.id_piano =a.id_piano
			left join matrix.formule f on sp.id_formula_ups =f.id
			join (SELECT generate_series as  contatore FROM generate_series(1,10000)) n on n.contatore <= t.target-coalesce(a.pianificati,0)
			
			
			where coalesce(periodo,tsrange(param_periodo_da,param_periodo_a,'[]')) && tsrange(param_periodo_da,param_periodo_a,'[]');
	
	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'ATTIVITA GENERATE %',  n;
	stmt := 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),' ||R_EC.id|| ',clock_timestamp(),''CREAZIONE ATTIVITA ('||n||')'')';
    raise notice 'STMT %',stmt;
	perform dblink_exec(db_log,stmt);
	if n <=0 then
    	raise notice 'NESSUN ATTIVITA GENERATA';
		stmt := 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),' ||R_EC.id|| ',clock_timestamp(),''CREAZIONE NON POSSIBILE: 0 ATTIVITA'')';
		perform dblink_exec(db_log,stmt);
	    ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=null;
	 
	    update agenda.elab_cals set tm_last_elab =clock_timestamp() where id=R_EC.id;
		return;
	end if;
	--COMMIT;


	/* END SELEZIONE PIANI */


	/* START SELEZIONE LINEE */

	if param_linea then
	
		/* ASSOCIA LE LINEE SELEZIONATE IN BASE A:
		 * piano
		 * struttura
		 * numero progressivo piano-struttura
		 */
		update agenda.attivita a
		set id_linea = sub.id_linea
		from (
			select a.id_linea,a.id_piano,a.id_struttura_asl,row_number() over (partition by  id_piano,id_struttura_asl order by rnd) contatore from (
				select  ls.id_linea, ls.id_piano,lps.id_struttura_asl, /*,n.contatore,coalesce(pf.freq,1)*10,*/random() rnd from
	     				agenda.linee_selezionate ls
						--join agenda.vw_linee l on l.id_linea =ls.id_linea 
						left join agenda.vw_piano_freq pf on pf.id_piano = ls.id_piano and livello=1			
						left join agenda.vw_linea_piano_anno_assegnate a on a.id_piano=ls.id_piano and a.id_linea=ls.id_linea and a.anno=R_EC.anno
						join      (SELECT generate_series as  contatore FROM generate_series(1,100)) n on n.contatore <= (ceil(coalesce(pf.freq,1))
						-coalesce(a.assegnate,0) )
						join (select id_piano,l.id id_linea,sc.id_struttura AS id_struttura_asl 
   FROM cu_anag.linee l join cu_anag.vw_stabilimenti s on l.id_stabilimento =s.id join agenda.comuni c on c.istat_comune=s.istat_comune 
     JOIN agenda.vw_piano_tipo_linea ptl ON l.id_tipo_linea  = ptl.id_tipo_linea
     JOIN agenda.struttura_comuni sc ON sc.id_comune = c.id) lps on lps.id_piano=ls.id_piano and lps.id_linea =ls.id_linea 
						--join agenda.elab_cal_param_piani ep on ep.id_elab_cal =ls.id_elab_cal and ls.id_piano =ep.id_piano 
						join (select distinct id_node_struttura as id_struttura,id_elab_cal from agenda.vw_elab_cal_param_ns pa  ) pa on lps.id_struttura_asl =pa.id_struttura and ls.id_elab_cal =pa.id_elab_cal
				where ls.id_elab_cal =R_EC.id) a
		) as sub
		where a.id_piano=sub.id_piano and a.id_struttura =sub.id_struttura_asl and a.contatore =sub.contatore and a.id_elab_cal =R_EC.id;

		GET DIAGNOSTICS n = ROW_COUNT;
    	raise notice 'ATTIVITA ASSOCIATE A LINEE %',  n;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''ATTIVITA ASSOCIATE A LINEE ('||n||')'')';
		raise notice 'STMT=%',stmt;
		perform dblink_exec(db_log,stmt);
	
		/*
		insert into agenda.attivita (id,id_elab_cal,id_struttura,id_piano,id_linea,dt,id_risorsa,target,
				contatore,ups,durata,validita,prog)
		select nextval('agenda.attivita_id_seq'),a.id_elab_cal,a.id_struttura,a.id_piano,
			l.id_linea,	a.dt,a.id_risorsa,a.target,a.contatore,a.ups,a.durata,a.validita,a.prog
			from agenda.attivita a
			join agenda.linee_principali lp on a.id_linea =lp.id_linea
			join agenda.vw_linee l on l.id_az_sede =lp.id_az_sede 
			where id_elab_cal =R_EC.id --and id_risorsa is not null
			and a.id_linea!=l.id_linea
			order by a.prog	;
		GET DIAGNOSTICS n = ROW_COUNT;
    	raise notice 'ATTIVITA ASSOCIATE A LINEE SECONDARIE  %',  n;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''ATTIVITA ASSOCIATE A LINEE SECONDARIE ('||n||')'')';
		raise notice 'STMT=%',stmt;
		perform dblink_exec(db_log,stmt); */

	end if;	
	--COMMIT;
    	/*	ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
	 	return ;*/
	/* END SELEZIONE LINEE */



	/* START CALCOLO CAPACITA PER OGNI RISORSA */ 
	update agenda.elab_cal_param_ns p set
		cap_tot=sub.capacita,cap_ev=sub.prog_e,excluded=false,to_be_excluded=false,
		cap_used=0/*sub.prog_a*/ from (
			select ns.id id_ns,ns.id_node_struttura id_struttura,
				(m4.ups*(100.0-ms.sottr)/200) *fract_time capacita,coalesce(e.prog_e,0) prog_e--,coalesce(a.prog_a,0) prog_a
			from matrix.vw_nominativi_struttura ns
			join matrix.mod4_nominativi m4 on m4.id_nominativo_struttura =ns.id
			join matrix.vw_mod4_strutture ms on ms.id_struttura =ns.id_struttura 
			join agenda.vw_elab_cal_param_ns pns on  pns.id_ns =ns.id
			left join (
				select ns.id as id_ns,coalesce(sum(coalesce(fattore_ups,def_ups)),0) prog_e from agenda.eventi e 
				join matrix.vw_nominativi_struttura ns on e.id_nominativo =ns.id_nominativo and e.per_conto =ns.id_node_struttura
				join matrix.vw_struttura_piani p on p.id=e.id_piano
				where e.inizio between param_periodo_da and param_periodo_a group  by 1/* AF 2024-01-30
				select ns.id as id_ns,sum(durata) prog_e from (
						select inizio,fine-inizio as durata,id_nominativo,per_conto from agenda.eventi union
						select inizio,fine-inizio as durata,id_partner,partner_per_conto from agenda.eventi 
						) e
						join matrix.vw_nominativi_struttura ns on e.id_nominativo =ns.id_nominativo and e.per_conto =ns.id_node_struttura
						where e.inizio between param_periodo_da and param_periodo_a group  by 1*/
			) e on e.id_ns=ns.id
			/*left join (
				select ns.id as id_ns,coalesce(sum(coalesce(fattore_ups,0.75)),0) prog_a from agenda.attivita a 
				join matrix.vw_nominativi_struttura ns on a.id_risorsa =ns.id_nominativo and a.id_struttura =ns.id_node_struttura
				join matrix.vw_struttura_piani p on p.id=a.id_piano 
				where   a.id_elab_cal =R_EC.id and a.dt between param_periodo_da and param_periodo_a group  by 1
			)  a on a.id_ns=ns.id*/
			where  pns.id_elab_cal=R_EC.id
	) sub where p.id_elab_cal=R_EC.id and p.id_ns=sub.id_ns	;

	GET DIAGNOSTICS cap = ROW_COUNT;
    raise notice 'CALCOLATA CAPACITA %',  cap;
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''CALCOLATA CAPACITA ('||cap||')'')';
    raise notice 'STMT %',stmt;
	perform dblink_exec(db_log,stmt);
	
	
	/* RIDUZIONE PER DISPONIBILITA TEMPO */

	
	
	
	

	/*  */
	update agenda.elab_cal_param_ns p set fact_disponibilita=sub.fact,cap_tot=cap_tot*sub.fact from

		(
			select id_ns,disponibilita/richiesta_tot fact from
		(select ns.id_anagrafica,id_ns,coalesce(p.cap_tot,0) richiesta_ns, sum (coalesce(p.cap_tot,0)) over(partition by ns.id_anagrafica) richiesta_tot,
		sum(extract (epoch from o.disponibilita) * 2/ extract (epoch from (ore_lavoro/*ora_end-ora_start*/))) disponibilita
				from agenda.elab_cal_param_ns p
			join matrix.vw_nominativi_struttura ns on p.id_ns=ns.id and  id_elab_cal =R_EC.id
			join
		(
	select id_anagrafica,dd,ore_lavoro /*ora_end-ora_start*/ -sum(occupato) disponibilita
						 from (
				select e.id,r.id_anagrafica,dd ,tsrange(e.inizio,e.fine,'[)') ev ,tsrange(e.inizio,e.fine,'[)') * dd,
			case when e.inizio is null then interval '0 seconds' else
			coalesce(upper(tsrange(e.inizio,e.fine,'[)') * dd) -lower(tsrange(e.inizio,e.fine,'[)') * dd),interval '0 seconds') end occupato
 			from
 			
 			(select distinct id_anagrafica from agenda.elab_cal_param_ns  a
				join matrix.vw_nominativi_struttura ns on ns.id=a.id_ns
				where id_elab_cal =R_EC.id ) r
				
				
				/*(select distinct id_anagrafica from agenda.attivita a
				join matrix.vw_nominativi_struttura ns on ns.id_nominativo=a.id_risorsa
				where id_elab_cal =R_EC.id and id_risorsa is not null) r*/
				join
				(select tsrange(d::timestamp+ora_start,d::timestamp+ora_end,'[)') dd 
					FROM generate_series(param_periodo_da,param_periodo_a, '1 day'::interval) d
				 where d not in (select dt from agenda.festivita) and extract (dow from d) between 1 and 5) g
				on 1=1
				left join agenda.vw_eventi_occupazione e on e.id_anagrafica=r.id_anagrafica and (tsrange(e.inizio,e.fine,'[)') && dd)
		) o group by 1,2)
		o on o.id_anagrafica=ns.id_anagrafica
		group by 1,2,3) q where richiesta_tot > disponibilita
		
		) sub
		where p.id_elab_cal=R_EC.id and p.id_ns=sub.id_ns;
	
		
	GET DIAGNOSTICS rid = ROW_COUNT;
    raise notice 'RIDUZIONE CAPACITA %',  rid;
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''RIDUZIONE CAPACITA ('||rid||')'')';
    raise notice 'STMT %',stmt;
		perform dblink_exec(db_log,stmt);
	
	
	
	/* END CALCOLO CAPACITA */
	--commit;

    	/*ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
	 	return ;*/
	n_associate:=1000;
	n_disassociate:=0;
	select sum(cap_tot)-sum(cap_ev) into n from agenda.elab_cal_param_ns			where  id_elab_cal=R_EC.id;
	if n <=0 or n is null then
    	raise notice 'NESSUNA RISORSA DISPONIBILE';
		stmt := 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),' ||R_EC.id|| ',clock_timestamp(),''CREAZIONE NON POSSIBILE: 0 RISORSE'')';
		perform dblink_exec(db_log,stmt);
	    ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=null;
	 	update agenda.elab_cals set tm_last_elab =clock_timestamp() where id=R_EC.id;
		return;
	end if;

	while n_cicli < 100 and ( clock_timestamp() - time_start ) < interval '5 minutes' and n_associate >n_disassociate and cap >0 loop
		n_cicli:= n_cicli+1;
	    raise notice ' ASSOCIATE % DISASSOCIATE % CAP %',n_associate ,n_disassociate, cap;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''START CICLO ('||n_cicli||')'')';
	    raise notice 'STMT %',stmt;
		perform dblink_exec(db_log,stmt);
		--commit;
/* START ASSOCIA RISORSE */
		raise notice 'START UPDATE agenda.attivita';

		update agenda.attivita a set id_risorsa = sub.id_nominativo,dt=param_periodo_da
			from
			(
			select distinct on (id_attivita) id_attivita,id_nominativo from (
			/* AF 2024-02-19 select a.id id_attivita, a.id_piano,l.id_comune , row_number() over(partition by id_piano,id_comune) n 
			from agenda.attivita a join agenda.vw_linee l on l.id=a.id_linea
			where id_elab_cal=R_EC.id and id_risorsa is null*/
			
			select a.id id_attivita, a.id_piano,s.id_comune , row_number() over(partition by id_piano,id_comune) n 
			from agenda.attivita a join cu_anag.vw_linee l on l.id=a.id_linea join cu_anag.vw_stabilimenti s on l.id_stabilimento=s.id
			where id_elab_cal=R_EC.id and id_risorsa is null			
			
			
			
			) a
			join
			(select id_piano,id_comune, id_nominativo,id_struttura,row_number() over(partition by id_piano,id_comune order by rnd desc) n from (
			select mns.id_nominativo,mns.id_node_struttura id_struttura,np.id_piano , nc.id_comune,
					(case when ns.cap_tot -ns.cap_ev> coalesce(ns.cap_used,0) then ns.cap_tot -ns.cap_ev -coalesce(ns.cap_used,0) else 0 end) * random() rnd 
			from agenda.elab_cal_param_ns ns 
			join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id_ns 
			join agenda.elab_cal_param_piani pp on pp.id_elab_cal =ns.id_elab_cal and pp.id_piano =np.id_piano 
			join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id_ns 
			join matrix.vw_nominativi_struttura mns on mns.id=ns.id_ns
			join (SELECT generate_series as  contatore FROM generate_series(1,20)) c on 1=1
				where ns.id_elab_cal=R_EC.id and not ns.excluded 
				) b) b on a.id_piano=b.id_piano and a.id_comune=b.id_comune and a.n=b.n ) sub 
		where a.id=sub.id_attivita;

		GET DIAGNOSTICS n_associate = ROW_COUNT;
    	raise notice 'ASSOCIAZIONE ATTIVITA RISORSE %',  n_associate;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    ASSOCIAZIONE RISORSE-ATTIVITA ('||n_associate||')'')';
		perform dblink_exec(db_log,stmt);
		/* END ASSOCIA RISORSE */
	 
	 	/*CANCELLA LE LINEE VISITATE PIU VOLTE RISPETTO ALLA FREQUENZA PREVISTA */
	    delete from agenda.attivita where id in 
	 		(select id from (
				select a.id,a.id_linea,a.id_piano,f.freq f,row_number() over(partition by a.id_linea,a.id_piano) n_seq
				from agenda.attivita a join agenda.vw_piano_freq f on f.id_piano=a.id_piano and f.livello =1
				where a.id_linea is not null and
				id_elab_cal=R_EC.id) a where n_seq>ceil(f));
		GET DIAGNOSTICS n_multiple = ROW_COUNT;
    	raise notice 'ELIMINAZIONE LINEE VISITATE TROPPO SPESSO %',  n_multiple;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    ELIMINAZIONI LINEE MULTIPLE ('||n_multiple||')'')';
		perform dblink_exec(db_log,stmt);
	 
	--	commit;
	 /* SELEZIONA LE RISORSE CHE HANNO ESAURITO LA CAPACITA' A TO-BE-EXLUDED */
		update agenda.elab_cal_param_ns set to_be_excluded= true where id_elab_cal =R_EC.id and id_ns in (
		select a.id_ns from (
			select ns.id_ns,sum(ups) tot,ns.cap_tot,ns.cap_used,ns.cap_ev
			from agenda.attivita a 
			join agenda.vw_elab_cal_param_ns ns on ns.id_elab_cal=a.id_elab_cal and  ns.id_nominativo =a.id_risorsa 
			where  a.id_elab_cal=R_EC.id group by 1,3,4,5) a
		where cap_tot-cap_ev < tot);
		GET DIAGNOSTICS n_disassociate = ROW_COUNT;	
		raise notice 'DISASSOCIATE STEP 1 %',n_disassociate;
	
	/* DISASSOCIA LE ATTIVITA' CHE NON POSSONO ESSERE EFFETTUATE PER RAGGIUNGIMENTO CAPACITA' DA PARTE DELLA RISORSA */
		update agenda.attivita set id_risorsa=null where id in (
		select id from (
			select a.id,id_risorsa,ups ,sum(ups) over (partition by id_risorsa order by prog rows between unbounded preceding and current row) over_b,
				ns.cap_tot,ns.cap_used,ns.cap_ev
			from agenda.attivita a 
			join agenda.vw_elab_cal_param_ns ns on ns.id_elab_cal=a.id_elab_cal and  ns.id_nominativo =a.id_risorsa 
			where  a.id_elab_cal=R_EC.id and a.id_risorsa is not null and ns.to_be_excluded) a
		where cap_tot-cap_ev < over_b);
		GET DIAGNOSTICS n_disassociate = ROW_COUNT;
    	raise notice 'ASSOCIAZIONE  RISORSE DISASSOCIATE %',  n_disassociate;
    	n_disassociate:= n_disassociate+n_multiple;
    	raise notice '	DISASSOCIAZIONE ATTIVITA RISORSE %',  n_disassociate;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    DISASSOCIAZIONE RISORSE-ATTIVITA ('||n_disassociate||') '')';
		perform dblink_exec(db_log,stmt);
		/* END ASSOCIA RISORSE */
		--commit;

		/* START CALCOLO CAPACITA */
		update agenda.elab_cal_param_ns p set cap_used=sub.prog_a from (
			select ns.id as id_ns,coalesce(sum(ups),0) prog_a from agenda.attivita a 
			join matrix.vw_nominativi_struttura ns on a.id_risorsa =ns.id_nominativo and a.id_struttura =ns.id_node_struttura
			where   a.id_elab_cal =R_EC.id  group  by 1
		) sub where p.id_elab_cal=R_EC.id and p.id_ns=sub.id_ns	and to_be_excluded;

		/* ESCLUDE LE RISORSE SEGNATE COME TO-BE-EXCLUDED */
		update agenda.elab_cal_param_ns set excluded=true ,to_be_excluded=false where to_be_excluded and id_elab_cal =R_EC.id ;
		GET DIAGNOSTICS cap = ROW_COUNT;
		raise notice 'RISORSE ESCLUSE %', cap;

		select count(*) into cap from agenda.elab_cal_param_ns where id_elab_cal=R_EC.id and not excluded;

    	raise notice 'CALCOLATA CAPACITA RESIDUA %', cap;
	--raise notice   'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    ASSOCIAZIONE RISORSE-ATTIVITA ('||n_associate||')'')';
	/* END CALCOLO CAPACITA */
	--commit;
	--raise notice 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),'||
			--'END CICLO ('||n||') AGGIUNTI '||n_associate-n_disassociate|| ' TEMPO='||'round(extract(second from clock_timestamp()-time_start))'||' secondi'')';
	/* END CALCOLO CAPACITA */
	--commit;
   		raise notice ' ASSOCIATE % DISASSOCIATE % CAP %',n_associate ,n_disassociate, cap;

	end loop;
	/* END WHILE */


   /* START ASSOCIAZIONE DATA */

/*
   
	update agenda.attivita set dt=sub.giorno/*,durata= (interval '4 hour')* sub.fattore_ups*/ from
	(select id_struttura,id_piano,contatore,dd as giorno/*,coalesce(p.fattore_ups,0.75) fattore_ups*/ from (
		/*(select id_risorsa,id_struttura,id_piano,contatore, row_number() over (partition by id_risorsa order by id_risorsa)  as giorni
		from agenda.attivita where id_elab_cal =R_EC.id and id_risorsa is not null) d*/
	      (select id_anagrafica,id_struttura,id_piano,contatore, row_number() over (partition by id_anagrafica order by id_anagrafica)  as giorni
		from agenda.attivita a join matrix.nominativi n on n.id =a.id_risorsa  where id_elab_cal =R_EC.id and id_risorsa is not null) d
		join 
			(select dd,row_number() over(order by extract (hour from dd),dd) prog from (
				select dd +ora_start   as dd FROM generate_series( param_periodo_da, param_periodo_a, '1 day'::interval) dd
				union 
				select dd +ora_start+'04:00:00'::interval  FROM generate_series     ( param_periodo_da, param_periodo_a, '1 day'::interval) dd) a
				where extract (dow from dd) between 1 and 5
				and dd::date not in (select dt from agenda.festivita)) g on d.giorni=g.prog) a	
	)sub	where attivita.id_struttura =sub.id_struttura and attivita.id_piano=sub.id_piano
				and attivita.contatore=sub.contatore and attivita.id_elab_cal=R_EC.id ;
   
	GET DIAGNOSTICS n = ROW_COUNT;
	raise notice 'ATTIVITA ASSOCIATE CON DATA %',  n;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''ATTIVITA ASSOCIATE CON DATA ('||n||') '')';
    raise notice 'STMT %',stmt;
		perform dblink_exec(db_log,stmt);

	select count(*) into cnt_day from (
	select dd dt,row_number() over(order by extract (hour from dd),dd) prog from (
				select dd +ora_start /*(interval '1 hour') * 9*/  as dd FROM generate_series( param_periodo_da, param_periodo_a, '1 day'::interval) dd
				union 
				select dd +ora_start+'04:00:00'::interval   FROM generate_series     ( param_periodo_da, param_periodo_a, '1 day'::interval) dd) a
				where extract (dow from dd) between 1 and 5
				and dd::date not in (select dt from agenda.festivita)) a;
			
			
	update agenda.attivita set dt=s.dt_new
	from 
	(select id id_attivita,dt dt_new from 
		(select id,row_number() over (order by id) prog from agenda.attivita a2
		where id_risorsa is null and extract(hour from dt)=0 and id_elab_cal =R_EC.id  ) a
		join 
		(select dd dt,row_number() over(order by extract (hour from dd),dd) prog from (
				select dd + ora_start /*(interval '1 hour') * 9 */ as dd from
				generate_series( param_periodo_da, param_periodo_a, '1 day'::interval) dd
				union 
				select dd + ora_start+ '04:00:00'::interval   FROM generate_series     ( param_periodo_da, param_periodo_a, '1 day'::interval) dd) a
				where extract (dow from dd) between 1 and 5
				and dd::date not in (select dt from agenda.festivita)) b
		on mod(a.prog,cnt_day)=b.prog) s
	where id=s.id_attivita;		
*/
	n:=agenda.genera_calendario_upd_date(	R_EC.id,	ora_start,	ora_end,	param_periodo_da,	param_periodo_a,ore_lavoro);
 	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''AGGIORNAMENTO DATE ('||n||') '')';
	
 	raise notice 'STMT %',stmt;
	perform dblink_exec(db_log,stmt);

	/*Richiesta di Poli
	 * update agenda.attivita a set dt=dt+ora_start
	 * where id_risorsa is null and extract(hour from dt)=0 and id_elab_cal =R_EC.id ;
	 */

	update agenda.attivita a set dt=null
	where id_risorsa is null and id_elab_cal =R_EC.id ;

	update agenda.attivita a set dt=null, id_risorsa=null
	where extract(hour from dt)=0 and extract(minutes from dt)=0 and id_elab_cal =R_EC.id ;
	GET DIAGNOSTICS n = ROW_COUNT;
	raise notice 'ATTIVITA ELIMINATE PER NON CAPIENZA IN AGENDA %',  n;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''ATTIVITA ELIMINATE PER NON CAPIENZA IN AGENDA ('||n||') '')';
    raise notice 'STMT %',stmt;
		perform dblink_exec(db_log,stmt);

	select json_agg(row_to_json(g.*)) into rt from (
	
		/*select 
		 a.id,l.denominazione_sede_operativa  linea,l.comune,sa.descrizione_breve uos,n.nominativo ,dt as giorno, 
		 sp.alias || ' - '||sp.descrizione_breve  attivita,
		 e.id is null as selezionabile
		 from		agenda.attivita a  join c.vw_linee l on a.id_linea =l.id_linea
		join matrix.struttura_asl sa  on sa.id =a.id_struttura
		join matrix.vw_tree_nodes_up_piani sp on sp.id_node=a.id_piano
		left join matrix.nominativi n on n.id=a.id_risorsa 
		left join agenda.eventi e on e.id_attivita =a.id
		where a.id_elab_cal=R_EC.id order by a.dt,n.nominativo,l.comune,l.denominazione_sede_operativa */
	
	select 
		 a.id,s.nome linea  ,s.comune,sa.descrizione_breve uos,n.nominativo ,dt as giorno, 
		 sp.alias || ' - '||sp.descrizione_breve attivita,
		 e.id is null as selezionabile
		 from		agenda.attivita a
		 join cu_anag.vw_linee l on a.id_linea =l.id_linea join cu_anag.vw_stabilimenti s on s.id=l.id_stabilimento 
		join matrix.struttura_asl sa  on sa.id =a.id_struttura
		join matrix.vw_tree_nodes_up_piani sp on sp.id_node=a.id_piano
		left join matrix.nominativi n on n.id=a.id_risorsa 
		left join agenda.eventi e on e.id_attivita =a.id
		where a.id_elab_cal=R_EC.id order by a.dt,n.nominativo,s.comune,s.nome
		) g;
		

		raise notice '%',json_array_length(rt);
    		--update agenda.elab_cals set tm_last_elab =current_timestamp where id=R_EC.id;	

    	update agenda.elab_cals set tm_last_elab =clock_timestamp() where id=R_EC.id;
		ret.esito:=true;
		ret.msg:=null;
 		ret.info:=rt;
	 	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''FINE GENERAZIONE CALENDARIO'')';
   		raise notice 'STMT %',stmt;
		perform dblink_exec(db_log,stmt);
		--end if;
	end;

$$;


ALTER PROCEDURE agenda.genera_calendario_proc(IN dati json, IN idtransazione bigint, OUT ret ag_types.result_type) OWNER TO postgres;

--
-- Name: genera_calendario_proc_old(json, bigint); Type: PROCEDURE; Schema: agenda; Owner: postgres
--

CREATE PROCEDURE agenda.genera_calendario_proc_old(IN dati json, IN idtransazione bigint, OUT ret ag_types.result_type)
    LANGUAGE plpgsql
    AS $$
	declare
	id_op bigint;   
	idselected bigint;
	proc_name varchar;
	dt_da timestamp;
	dt_a timestamp;
	R_CAL agenda.vw_calendari%ROWTYPE;
	R_EC agenda.vw_elab_cals%ROWTYPE;
	REC Record;
	rt json;
	n integer;
	fract_time decimal;

	param_periodo_da timestamp;
	param_periodo_a timestamp;
	param_non_visitati_dal_valore decimal;
	param_non_visitati_dal timestamp;
	param_ultima_visita decimal;
	param_machine decimal;
	param_casuale decimal;
	param_linea boolean;
	param_ispettore boolean;
	time_start timestamp;
	n_cicli integer;
	n_associate integer;
	n_multiple integer;
	n_disassociate integer;
	cap integer;
	db_log varchar;
	--anno_elab integer;
    stmt varchar;
   cnt_day integer;
  
  	def_freq_rischio_alta  decimal;
	def_freq_rischio_media decimal;
	def_freq_rischio_bassa decimal;
	def_ups                decimal;
	def_uba                decimal;
	def_min_start          decimal;
	def_ora_start          decimal;
	ora_start interval;
	def_min_start_p          decimal;
	def_ora_start_p          decimal;
	ora_start_p interval;

	begin
	proc_name:='agenda.genera_calendario_proc';
	time_start := clock_timestamp();
	n_cicli := 0;
	/* START ACQUISIZIONE PARAMETRI */
	R_EC.id:=dati->>'id_elab_cal';
	if R_EC.id is null then
		R_EC.id:=dati->>'id_gen_cal';
	end if;

	if R_EC.id is null then
		ret.esito:=false;
		return;
	end if;
	select 'dbname='||valore into db_log  from config.config where nome='MDGM_DB' and validita @> current_timestamp::timestamp;
	/* Svuotamento LOG */
	stmt:='delete from agenda.elab_cal_logs where id_elab_cal='||R_EC.id;
	perform dblink_exec(db_log,stmt);
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''START ELABORAZIONE'')';
	perform dblink_exec(db_log,stmt);
	--COMMIT;

	--R_EC.id_user:= ((dati->>'user_info')::json)->>'id_utente';

	raise notice 'ID_ELAB_CAL ID=% ID_USER=%', R_EC.id,R_EC.id_user;

	select * into R_EC from agenda.vw_elab_cals ec where id =R_EC.id;
   
	delete from agenda.attivita where id_elab_cal=R_EC.id;

	select value::timestamp into param_periodo_da from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='periodo_da';
	select value::timestamp into param_periodo_a  from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='periodo_a';
	if param_periodo_da is null then
		param_periodo_da:=date_trunc('year',current_timestamp);
	end if;
	if param_periodo_a is null then
		param_periodo_a:=date_trunc('year',param_periodo_da)+ interval '1 year';
	end if;
	--anno_elab:=extract(year from param_periodo_da);
	fract_time= (extract(epoch from param_periodo_a) - extract(epoch from param_periodo_da)) /(365*24*3600);
	--param_periodo_da:=param_periodo_da+ interval '9 hours';

	select value::decimal   into param_non_visitati_dal_valore from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='non_visitati_dal_valore';
	select value::timestamp into param_non_visitati_dal        from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='non_visitati_dal';
	select value::decimal   into param_ultima_visita           from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='ultima_visita';
	select value::decimal   into param_machine                 from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='machine';
	select value::decimal   into param_casuale                 from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='casuale';
	select value::boolean   into param_linea                   from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='linea';
	select value::boolean   into param_ispettore               from agenda.elab_cal_params where id_elab_cal =R_EC.id and type_param='ispettore';

	select value::decimal   into def_freq_rischio_alta  from ag_conf.ag_conf where cod='freq_rischio_alta';
	select value::decimal   into def_freq_rischio_media from ag_conf.ag_conf where cod='freq_rischio_media';
	select value::decimal   into def_freq_rischio_bassa from ag_conf.ag_conf where cod='freq_rischio_bassa';
	select value::decimal   into def_ups                from ag_conf.ag_conf where cod='ups';
	select value::decimal   into def_uba                from ag_conf.ag_conf where cod='uba';
	select value::decimal   into def_ora_start          from ag_conf.ag_conf where cod='cal_start_ora';
	select value::decimal   into def_min_start          from ag_conf.ag_conf where cod='cal_start_minuti';
	select value::decimal   into def_ora_start_p        from ag_conf.ag_conf where cod='cal_start_ora_p';
	select value::decimal   into def_min_start_p        from ag_conf.ag_conf where cod='cal_start_minuti_p';
	ora_start:= (interval '1 hour')*def_ora_start + (interval '1 minute')*def_min_start;
	ora_start_p:= (interval '1 hour')*def_ora_start_p + (interval '1 minute')*def_min_start_p;
	if ora_start   is null then ora_start := interval '9 hours'; end if;
	if ora_start_p is null then ora_start_p := ora_start + (interval '5 hours'); end if;
	raise notice 'FRACT_TIME=%',fract_time;
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''INIZIALIZZAZIONE'')';
	perform dblink_exec(db_log,stmt);
	--COMMIT;
	/* END ACQUISIZIONE PARAMETRI */


	/* START SELEZIONE PIANI */

	select count(*) into n from agenda.linee_selezionate ls where id_elab_cal =R_EC.id;
	raise notice 'LINEE SELEZIONATE DEL COUNT %',  n;
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''LINEE SELEZIONATE  ('|| n||')'')';
    raise notice 'STMT %',stmt;
	perform dblink_exec(db_log,stmt);
  
	/* CREA LA LISTA DELLE ATTIVITA POSSIBILI tenendo condo di:
	 * associazioni risorse/piani
	 * associazioni strutture/piani
	 * attività già programmate e presenti in agenda.eventi
	 * programmzione in matrix pp.periodo
	 * come periodo temporale usa l'intero anno */
	insert into agenda.attivita (id,id_elab_cal,id_struttura,id_piano,id_linea,dt,id_risorsa,target,contatore,ups,durata,validita,prog)
	select nextval('agenda.attivita_id_seq'),
			R_EC.id  ,t.id_struttura as id_struttura_asl,t.id_piano as id_piano,
			null id_linea, null dt, null id_risorsa, t.target, n.contatore,coalesce(fattore_fin,def_ups) ups,
			interval '1 minutes' * 4 * 60 * coalesce(fattore_fin,def_ups),
			coalesce(periodo,tsrange(param_periodo_da,param_periodo_a,'[]'))*tsrange(param_periodo_da,param_periodo_a,'[]'),row_number () over(order by t.id_piano,t.id_struttura)
			from matrix.struttura_piano_target t	
			join (/*select distinct np.id_piano,mns.id_node_struttura id_struttura from agenda.nominativo_piani np
					join agenda.elab_cal_param_ns ns on ns.id_ns =np.id_nominativo_struttura
					join matrix.vw_nominativi_struttura mns on mns.id=ns.id_ns 
					where ns.id_elab_cal =R_EC.id */
			select distinct np.id_piano,mns.id_node_struttura id_struttura from agenda.nominativo_piani np
					join agenda.elab_cal_param_ns ns on ns.id_ns =np.id_nominativo_struttura
					join matrix.vw_nominativi_struttura mns on mns.id=ns.id_ns 
					join agenda.elab_cal_param_piani ep on ep.id_elab_cal =ns.id_elab_cal and ep.id_piano =np.id_piano 
					where ns.id_elab_cal =R_EC.id 
			) p on t.id_struttura=p.id_struttura and t.id_piano =p.id_piano 
			join matrix.struttura_piani sp on sp.id=t.id_piano 
			
			left join agenda.piano_periodo pp on pp.id_piano=t.id_piano 

			left join (select per_conto id_struttura,id_piano,count(*) pianificati from agenda.eventi where extract (year from eventi.inizio ) = R_EC.anno group by 1,2) a on t.id_struttura =a.id_struttura and t.id_piano =a.id_piano
			left join matrix.formule f on sp.id_formula_ups =f.id
			join (SELECT generate_series as  contatore FROM generate_series(1,10000)) n on n.contatore <= t.target-coalesce(a.pianificati,0)
			
			
			where coalesce(periodo,tsrange(param_periodo_da,param_periodo_a,'[]')) && tsrange(param_periodo_da,param_periodo_a,'[]');
	
	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'ATTIVITA GENERATE %',  n;
	stmt := 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),' ||R_EC.id|| ',clock_timestamp(),''CREAZIONE ATTIVITA ('||n||')'')';
    raise notice 'STMT %',stmt;
	perform dblink_exec(db_log,stmt);
	if n <=0 then
    	raise notice 'NESSUN ATTIVITA GENERATA';
		stmt := 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),' ||R_EC.id|| ',clock_timestamp(),''CREAZIONE NON POSSIBILE: 0 ATTIVITA'')';
		perform dblink_exec(db_log,stmt);
	    ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=null;
	 
	    update agenda.elab_cals set tm_last_elab =current_timestamp where id=R_EC.id;
		return;
	end if;
	--COMMIT;


	/* END SELEZIONE PIANI */


	/* START SELEZIONE LINEE */

	if param_linea then
	
		/* ASSOCIA LE LINEE SELEZIONATE IN BASE A:
		 * piano
		 * struttura
		 * numero progressivo piano-struttura
		 */
		update agenda.attivita a
		set id_linea = sub.id_linea
		from (
			select a.id_linea,a.id_piano,a.id_struttura_asl,row_number() over (partition by  id_piano,id_struttura_asl order by rnd) contatore from (
				select  ls.id_linea, ls.id_piano,lps.id_struttura_asl, /*,n.contatore,coalesce(pf.freq,1)*10,*/random() rnd from
	     				agenda.linee_selezionate ls
						join agenda.vw_linee l on l.id_linea =ls.id_linea 
						left join agenda.vw_piano_freq pf on pf.id_piano = ls.id_piano and livello=1
						/*left join (select ls.id_elab_cal,ls.id_linea,ls.id_piano,count(*) eseguite from agenda.attivita a 
										join agenda.linee_selezionate ls on a.id_piano =ls.id_piano and a.id_linea =ls.id_linea and ls.id_elab_cal=a.id_elab_cal
										where a.id_elab_cal =R_EC.id
					   				group by 1,2,3) e on e.id_elab_cal=ls.id_elab_cal and e.id_piano=ls.id_piano and e.id_linea=ls.id_linea*/
						
								    /*(select ls.id_linea,ls.id_piano,count(*) eseguite from agenda.eventi  a 
										join agenda.linee_selezionate ls on a.id_piano =ls.id_piano and a.id_linea =ls.id_linea --and ls.id_elab_cal=a.id_elab_cal
										where extract (year from a.inizio ) = anno_elab and ls.id_elab_cal =R_EC.id
					   				group by 1,2) e on  e.id_piano=ls.id_piano and e.id_linea=ls.id_linea*/
						
						left join agenda.vw_linea_piano_anno_assegnate a on a.id_piano=ls.id_piano and a.id_linea=ls.id_linea and a.anno=R_EC.anno
						join      (SELECT generate_series as  contatore FROM generate_series(1,100)) n on n.contatore <= (ceil(coalesce(pf.freq,1))
						-coalesce(a.assegnate,0) )
						join agenda.vw_linee_piano_struttura lps on lps.id_piano=ls.id_piano and lps.id_linea =ls.id_linea 
						join agenda.elab_cal_param_piani ep on ep.id_elab_cal =ls.id_elab_cal and ls.id_piano =ep.id_piano 
						join (select distinct id_node_struttura as id_struttura,id_elab_cal from agenda.vw_elab_cal_param_ns pa  ) pa on lps.id_struttura_asl =pa.id_struttura and ls.id_elab_cal =pa.id_elab_cal
				where ls.id_elab_cal =R_EC.id) a
		) as sub
		where a.id_piano=sub.id_piano and a.id_struttura =sub.id_struttura_asl and a.contatore =sub.contatore and a.id_elab_cal =R_EC.id;

		GET DIAGNOSTICS n = ROW_COUNT;
    	raise notice 'ATTIVITA ASSOCIATE A LINEE %',  n;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''ATTIVITA ASSOCIATE A LINEE ('||n||')'')';
		raise notice 'STMT=%',stmt;
		perform dblink_exec(db_log,stmt);
	
		insert into agenda.attivita (id,id_elab_cal,id_struttura,id_piano,id_linea,dt,id_risorsa,target,
				contatore,ups,durata,validita,prog)
		select nextval('agenda.attivita_id_seq'),a.id_elab_cal,a.id_struttura,a.id_piano,
			l.id_linea,	a.dt,a.id_risorsa,a.target,a.contatore,a.ups,a.durata,a.validita,a.prog
			from agenda.attivita a
			join agenda.linee_principali lp on a.id_linea =lp.id_linea
			join agenda.vw_linee l on l.id_az_sede =lp.id_az_sede 
			where id_elab_cal =R_EC.id --and id_risorsa is not null
			and a.id_linea!=l.id_linea
			order by a.prog	;
		GET DIAGNOSTICS n = ROW_COUNT;
    	raise notice 'ATTIVITA ASSOCIATE A LINEE SECONDARIE  %',  n;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''ATTIVITA ASSOCIATE A LINEE SECONDARIE ('||n||')'')';
		raise notice 'STMT=%',stmt;
		perform dblink_exec(db_log,stmt); 

	end if;	
	--COMMIT;
    	/*	ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
	 	return ;*/
	/* END SELEZIONE LINEE */



	/* START CALCOLO CAPACITA PER OGNI RISORSA */
	update agenda.elab_cal_param_ns p set
		cap_tot=sub.capacita,cap_ev=sub.prog_e,excluded=false,to_be_excluded=false,
		cap_used=0/*sub.prog_a*/ from (
			select ns.id id_ns,ns.id_node_struttura id_struttura,
				(m4.ups*(100.0-ms.sottr)/200) *fract_time capacita,coalesce(e.prog_e,0) prog_e--,coalesce(a.prog_a,0) prog_a
			from matrix.vw_nominativi_struttura ns
			join matrix.mod4_nominativi m4 on m4.id_nominativo_struttura =ns.id
			join matrix.vw_mod4_strutture ms on ms.id_struttura =ns.id_struttura 
			join agenda.vw_elab_cal_param_ns pns on  pns.id_ns =ns.id
			left join (
				select ns.id as id_ns,coalesce(sum(coalesce(fattore_ups,def_ups)),0) prog_e from agenda.eventi e 
				join matrix.vw_nominativi_struttura ns on e.id_nominativo =ns.id_nominativo and e.per_conto =ns.id_node_struttura
				join matrix.vw_struttura_piani p on p.id=e.id_piano
				where e.inizio between param_periodo_da and param_periodo_a group  by 1
			) e on e.id_ns=ns.id
			/*left join (
				select ns.id as id_ns,coalesce(sum(coalesce(fattore_ups,0.75)),0) prog_a from agenda.attivita a 
				join matrix.vw_nominativi_struttura ns on a.id_risorsa =ns.id_nominativo and a.id_struttura =ns.id_node_struttura
				join matrix.vw_struttura_piani p on p.id=a.id_piano 
				where   a.id_elab_cal =R_EC.id and a.dt between param_periodo_da and param_periodo_a group  by 1
			)  a on a.id_ns=ns.id*/
			where  pns.id_elab_cal=R_EC.id
	) sub where p.id_elab_cal=R_EC.id and p.id_ns=sub.id_ns	;
    
	GET DIAGNOSTICS cap = ROW_COUNT;
    raise notice 'CALCOLATA CAPACITA %',  cap;
	stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''CALCOLATA CAPACITA ('||cap||')'')';
    raise notice 'STMT %',stmt;
		perform dblink_exec(db_log,stmt);
	/* END CALCOLO CAPACITA */
	--commit;

    	/*ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
	 	return ;*/
	n_associate:=1000;
	n_disassociate:=0;
	select sum(cap_tot)-sum(cap_ev) into n from agenda.elab_cal_param_ns			where  id_elab_cal=R_EC.id;
	if n <=0 or n is null then
    	raise notice 'NESSUNA RISORSA DISPONIBILE';
		stmt := 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),' ||R_EC.id|| ',clock_timestamp(),''CREAZIONE NON POSSIBILE: 0 RISORSE'')';
		perform dblink_exec(db_log,stmt);
	    ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=null;
	 	update agenda.elab_cals set tm_last_elab =current_timestamp where id=R_EC.id;
		return;
	end if;
	while n_cicli < 100 and ( clock_timestamp() - time_start ) < interval '5 minutes' and n_associate >n_disassociate and cap >0 loop
		n_cicli:= n_cicli+1;
	    raise notice ' ASSOCIATE % DISASSOCIATE % CAP %',n_associate ,n_disassociate, cap;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''START CICLO ('||n_cicli||')'')';
	    raise notice 'STMT %',stmt;
		perform dblink_exec(db_log,stmt);
		--commit;
/* START ASSOCIA RISORSE */
		update agenda.attivita a set id_risorsa = sub.id_nominativo,dt=param_periodo_da
			from
			(
			select id_attivita,id_nominativo from (
			select a.id id_attivita, a.id_piano,l.id_comune , row_number() over(partition by id_piano,id_comune) n 
			from agenda.attivita a join agenda.vw_linee l on l.id=a.id_linea
			where id_elab_cal=R_EC.id and id_risorsa is null) a
			join
			(select id_piano,id_comune, id_nominativo,id_struttura,row_number() over(partition by id_piano,id_comune order by rnd desc) n from (
			select mns.id_nominativo,mns.id_node_struttura id_struttura,np.id_piano , nc.id_comune,
					(case when ns.cap_tot -ns.cap_ev> coalesce(ns.cap_used,0) then ns.cap_tot -ns.cap_ev -coalesce(ns.cap_used,0) else 0 end) * random() rnd 
			from agenda.elab_cal_param_ns ns 
			join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id_ns 
			join agenda.elab_cal_param_piani pp on pp.id_elab_cal =ns.id_elab_cal and pp.id_piano =np.id_piano 
			join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id_ns 
			join matrix.vw_nominativi_struttura mns on mns.id=ns.id_ns
			join (SELECT generate_series as  contatore FROM generate_series(1,100)) c on 1=1
				where ns.id_elab_cal=R_EC.id and not ns.excluded 
				) b) b on a.id_piano=b.id_piano and a.id_comune=b.id_comune and a.n=b.n) sub 
		where a.id=sub.id_attivita;

		GET DIAGNOSTICS n_associate = ROW_COUNT;
    	raise notice 'ASSOCIAZIONE ATTIVITA RISORSE %',  n_associate;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    ASSOCIAZIONE RISORSE-ATTIVITA ('||n_associate||')'')';
		perform dblink_exec(db_log,stmt);
		/* END ASSOCIA RISORSE */
	 
	 	/*CANCELLA LE LINEE VISITATE PIU VOLTE RISPETTO ALLA FREQUENZA PREVISTA */
	    delete from agenda.attivita where id in 
	 		(select id from (
				select a.id,a.id_linea,a.id_piano,f.freq f,row_number() over(partition by a.id_linea,a.id_piano) n_seq
				from agenda.attivita a join agenda.vw_piano_freq f on f.id_piano=a.id_piano and f.livello =1
				where a.id_linea is not null and
				id_elab_cal=R_EC.id) a where n_seq>ceil(f));
		GET DIAGNOSTICS n_multiple = ROW_COUNT;
    	raise notice 'ELIMINAZIONE LINEE VISITATE TROPPO SPESSO %',  n_multiple;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    ELIMINAZIONI LINEE MULTIPLE ('||n_multiple||')'')';
		perform dblink_exec(db_log,stmt);
	 
	--	commit;
	 /* SELEZIONA LE RISORSE CHE HANNO ESAURITO LA CAPACITA' A TO-BE-EXLUDED */
		update agenda.elab_cal_param_ns set to_be_excluded= true where id_elab_cal =R_EC.id and id_ns in (
		select a.id_ns from (
			select ns.id_ns,sum(ups) tot,ns.cap_tot,ns.cap_used,ns.cap_ev
			from agenda.attivita a 
			join agenda.vw_elab_cal_param_ns ns on ns.id_elab_cal=a.id_elab_cal and  ns.id_nominativo =a.id_risorsa 
			where  a.id_elab_cal=R_EC.id group by 1,3,4,5) a
		where cap_tot-cap_ev < tot);
		GET DIAGNOSTICS n_disassociate = ROW_COUNT;	
		raise notice 'DISASSOCIATE STEP 1 %',n_disassociate;
	
	/* DISASSOCIA LE ATTIVITA' CHE NON POSSONO ESSERE EFFETTUATE PER RAGGIUNGIMENTO CAPACITA' DA PARTE DELLA RISORSA */
		update agenda.attivita set id_risorsa=null where id in (
		select id from (
			select a.id,id_risorsa,ups ,sum(ups) over (partition by id_risorsa order by prog rows between unbounded preceding and current row) over_b,
				ns.cap_tot,ns.cap_used,ns.cap_ev
			from agenda.attivita a 
			join agenda.vw_elab_cal_param_ns ns on ns.id_elab_cal=a.id_elab_cal and  ns.id_nominativo =a.id_risorsa 
			where  a.id_elab_cal=R_EC.id and a.id_risorsa is not null and ns.to_be_excluded) a
		where cap_tot-cap_ev < over_b);
		GET DIAGNOSTICS n_disassociate = ROW_COUNT;
    	raise notice 'ASSOCIAZIONE  RISORSE DISASSOCIATE %',  n_disassociate;
    	n_disassociate:= n_disassociate+n_multiple;
    	raise notice '	DISASSOCIAZIONE ATTIVITA RISORSE %',  n_disassociate;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    DISASSOCIAZIONE RISORSE-ATTIVITA ('||n_disassociate||') '')';
		perform dblink_exec(db_log,stmt);
		/* END ASSOCIA RISORSE */
		--commit;

		/* START CALCOLO CAPACITA */
		update agenda.elab_cal_param_ns p set cap_used=sub.prog_a from (
			select ns.id as id_ns,coalesce(sum(ups),0) prog_a from agenda.attivita a 
			join matrix.vw_nominativi_struttura ns on a.id_risorsa =ns.id_nominativo and a.id_struttura =ns.id_node_struttura
			where   a.id_elab_cal =R_EC.id  group  by 1
		) sub where p.id_elab_cal=R_EC.id and p.id_ns=sub.id_ns	and to_be_excluded;

		/* ESCLUDE LE RISORSE SEGNATE COME TO-BE-EXCLUDED */
		update agenda.elab_cal_param_ns set excluded=true ,to_be_excluded=false where to_be_excluded and id_elab_cal =R_EC.id ;
		GET DIAGNOSTICS cap = ROW_COUNT;
		raise notice 'RISORSE ESCLUSE %', cap;

		select count(*) into cap from agenda.elab_cal_param_ns where id_elab_cal=R_EC.id and not excluded;

    	raise notice 'CALCOLATA CAPACITA RESIDUA %', cap;
	--raise notice   'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''    ASSOCIAZIONE RISORSE-ATTIVITA ('||n_associate||')'')';
	/* END CALCOLO CAPACITA */
	--commit;
	--raise notice 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),'||
			--'END CICLO ('||n||') AGGIUNTI '||n_associate-n_disassociate|| ' TEMPO='||'round(extract(second from clock_timestamp()-time_start))'||' secondi'')';
	/* END CALCOLO CAPACITA */
	--commit;
   		raise notice ' ASSOCIATE % DISASSOCIATE % CAP %',n_associate ,n_disassociate, cap;

	end loop;
	/* END WHILE */


   /* START ASSOCIAZIONE DATA */
   
	update agenda.attivita set dt=sub.giorno/*,durata= (interval '4 hour')* sub.fattore_ups*/ from
	(select id_struttura,id_piano,contatore,dd as giorno/*,coalesce(p.fattore_ups,0.75) fattore_ups*/ from (
		/*(select id_risorsa,id_struttura,id_piano,contatore, row_number() over (partition by id_risorsa order by id_risorsa)  as giorni
		from agenda.attivita where id_elab_cal =R_EC.id and id_risorsa is not null) d*/
	      (select id_anagrafica,id_struttura,id_piano,contatore, row_number() over (partition by id_anagrafica order by id_anagrafica)  as giorni
		from agenda.attivita a join matrix.nominativi n on n.id =a.id_risorsa  where id_elab_cal =R_EC.id and id_risorsa is not null) d
		join 
			(select dd,row_number() over(order by extract (hour from dd),dd) prog from (
				select dd +ora_start /*(interval '1 hour') * 9*/  as dd FROM generate_series( param_periodo_da, param_periodo_a, '1 day'::interval) dd
				union 
				select dd +ora_start_p  FROM generate_series     ( param_periodo_da, param_periodo_a, '1 day'::interval) dd) a
				where extract (dow from dd) between 1 and 5
				and dd::date not in (select dt from agenda.festivita)) g on d.giorni=g.prog) a
	/* left join matrix.vw_struttura_piani p on p.id=a.id_piano */
	
	)sub	where attivita.id_struttura =sub.id_struttura and attivita.id_piano=sub.id_piano
				and attivita.contatore=sub.contatore and attivita.id_elab_cal=R_EC.id ;
   
	GET DIAGNOSTICS n = ROW_COUNT;
	raise notice 'ATTIVITA ASSOCIATE CON DATA %',  n;
		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''ATTIVITA ASSOCIATE CON DATA ('||n||') '')';
    raise notice 'STMT %',stmt;
		perform dblink_exec(db_log,stmt);

	select count(*) into cnt_day from (
	select dd dt,row_number() over(order by extract (hour from dd),dd) prog from (
				select dd +ora_start /*(interval '1 hour') * 9*/  as dd FROM generate_series( param_periodo_da, param_periodo_a, '1 day'::interval) dd
				union 
				select dd +ora_start_p  FROM generate_series     ( param_periodo_da, param_periodo_a, '1 day'::interval) dd) a
				where extract (dow from dd) between 1 and 5
				and dd::date not in (select dt from agenda.festivita)) a;
			
			
	update agenda.attivita set dt=s.dt_new
	from 
	(select id id_attivita,dt dt_new from 
		(select id,row_number() over (order by id) prog from agenda.attivita a2
		where id_risorsa is null and extract(hour from dt)=0 and id_elab_cal =R_EC.id  ) a
		join 
		(select dd dt,row_number() over(order by extract (hour from dd),dd) prog from (
				select dd + ora_start /*(interval '1 hour') * 9 */ as dd FROM generate_series( param_periodo_da, param_periodo_a, '1 day'::interval) dd
				union 
				select dd + ora_start_p  FROM generate_series     ( param_periodo_da, param_periodo_a, '1 day'::interval) dd) a
				where extract (dow from dd) between 1 and 5
				and dd::date not in (select dt from agenda.festivita)) b
		on mod(a.prog,cnt_day)=b.prog) s
	where id=s.id_attivita;
			
	
	update agenda.attivita a set dt=dt+ora_start
	where id_risorsa is null and extract(hour from dt)=0 and id_elab_cal =R_EC.id ;

	--COMMIT;
   /* END ASSOCIAZIONE DATA */

/*
select count(*) into n from agenda.linee_selezionate ls where id_elab_cal =R_EC.id;
raise notice 'LINEE SELEZIONATE PRE COUNT %',  n;

raise notice 'LINEE SELEZIONATE %',  n;

select count(*) into n from agenda.linee_selezionate ls where id_elab_cal =R_EC.id;
raise notice 'LINEE SELEZIONATE POST COUNT %',  n;


n:=0;
for REC in select ls.*,s.id_comune as id_comune from agenda.linee_selezionate ls
	join agenda.linee l on l.id=ls.id_linea --join agenda.vw_comuni_lookup cl on cl.id=l.id_comune
	join agenda.az_sedi s on s.id=l.id_az_sede 
	-- join agenda.comuni cl on cl.id =s.id_comune 
	where id_elab_cal = R_EC.id order by ordine loop
	select a.id into idselected  from agenda.attivita a join matrix.vw_nominativi_struttura ns on ns.id_nominativo=a.id_risorsa
	join agenda.nominativo_comuni n on ns.id  =n.id_nominativo_struttura join agenda.struttura_comuni sc on sc.id =n.id_struttura_comune  
	where id_piano=REC.id_piano and sc.id_comune=REC.id_comune and a.id_linea is null and id_elab_cal= R_EC.id order by dt limit 1;
	if idselected is not null then
		update agenda.attivita set id_linea = REC.id_linea where id=idselected ;
		n:=n+1;
	end if;
end loop;
raise notice 'LINEE ASSOCIATE POST FOR  %',  n;

*/




	select json_agg(row_to_json(g.*)) into rt from (select 
		 a.id,l.denominazione_sede_operativa  linea,c.comune,sa.descrizione_breve uos,n.nominativo ,dt as giorno, 
		 sp.alias || ' - '||sp.descrizione_breve  /*replace(sp.path_descr,'Totale/','')*/ attivita,
		 e.id is null as selezionabile
		 
		 from		agenda.attivita a  join agenda.vw_linee l on a.id_linea =l.id_linea
		--left join agenda.vw_comuni_lookup c on c.com_id =l.id_comune
		left join agenda.vw_az_sedi s on s.id=l.id_az_sede 
	 	join agenda.comuni c on c.id =s.id_comune 
		join matrix.struttura_asl sa  on sa.id =a.id_struttura
		join matrix.vw_tree_nodes_up_piani sp on sp.id_node=a.id_piano
		left join matrix.nominativi n on n.id=a.id_risorsa 
		left join agenda.eventi e on e.id_attivita =a.id
		where a.id_elab_cal=R_EC.id order by a.dt,n.nominativo,c.comune,l.denominazione_sede_operativa 
		) g;
		
		
	/*select json_agg(row_to_json(g.*)) into rt from (select 
		 l.denominazione_sede_operativa  linea,c.comune,sa.descrizione_breve uos,n.nominativo ,dt as giorno,replace(sp.path_descr,'Totale/','') attivita from
		agenda.attivita a  join agenda.vw_linee l on a.id_linea =l.id_linea
		--left join agenda.vw_comuni_lookup c on c.com_id =l.id_comune
		join agenda.az_sedi s on s.id=l.id_az_sede 
	 	join agenda.comuni c on c.id =s.id_comune 
		join matrix.struttura_asl sa  on sa.id =a.id_struttura
		join matrix.vw_tree_nodes_up_piani sp on sp.id_node=a.id_piano
		join matrix.nominativi n on n.id=a.id_risorsa 
		where a.id_elab_cal=R_EC.id
		
		) g;*/

		raise notice '%',json_array_length(rt);
    		--update agenda.elab_cals set tm_last_elab =current_timestamp where id=R_EC.id;	
		/*if json_array_length(rt) is null then
			ret.esito:=true;	
    		ret.msg:='calendario non generato';
    		ret.info:=null; 
    	else*/
    	update agenda.elab_cals set tm_last_elab =current_timestamp where id=R_EC.id;
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
	 	
	 		stmt:= 'insert into agenda.elab_cal_logs values(nextval(''agenda.elab_cal_log_id_seq''),'||R_EC.id||',clock_timestamp(),''FINE GENERAZIONE CALENDARIO'')';
   		raise notice 'STMT %',stmt;
		perform dblink_exec(db_log,stmt);
		--end if;
	end;

$$;


ALTER PROCEDURE agenda.genera_calendario_proc_old(IN dati json, IN idtransazione bigint, OUT ret ag_types.result_type) OWNER TO postgres;

--
-- Name: genera_calendario_prova(bigint, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.genera_calendario_prova(id_record bigint, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idselected bigint;
	proc_name varchar;
	R_CAL agenda.vw_calendari%ROWTYPE;
	REC Record;
	rt json;

	begin
		proc_name:='agenda.genera_calendario';
	
	
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
	delete from agenda.attivita where id_elab_cal=1;
	delete from linee_selezionate  where id_elab_cal=1;
	insert into attivita
	select nextval('attivita_id_seq'),1,sd.id_node as id_struttura_asl,p.id id_piano,null id_linea,null dt,null id_risorsa,
			target,n.contatore,target*fattore_fin ups--,sd.descrizione_breve as uos,p.descrizione 
	from matrix.struttura_piano_target t
			join matrix.vw_tree_nodes_down_asl_descr sd on sd.id_node=t.id_struttura 
			join matrix.vw_tree_nodes_down_piani pd on pd.id_node=t.id_piano
			join matrix.struttura_piani p on t.id_piano = p.id
			join matrix.formule f on p.id_formula_ups =f.id
			join (SELECT generate_series as  contatore FROM generate_series(1,10000)) n on n.contatore <= t.target
			where sd.id_node_ref=6019421  and pd.id_node_ref=19499 and sd.n_livello =3;
		
update attivita set id_risorsa=sub.id_nominativo FROM
(select id_struttura,id_piano,row_number() over (partition by id_struttura,id_piano order by id_struttura,id_piano,id_nominativo) contatore,
 id_nominativo from (
select id_nominativo,ns.id_struttura,m4.ups*(100.0-ms.sottr)/200/ms.ups frazione --,*
from matrix.vw_nominativi_struttura ns
			join matrix.vw_tree_nodes_down_asl_descr sd on sd.id_node=ns.id_struttura 
			join matrix.mod4_nominativi m4 on m4.id_nominativo_struttura =ns.id
			join matrix.mod4_strutture ms on ms.id_struttura =ns.id_struttura 
			--join (SELECT generate_series as  contatore FROM generate_series(1,10000)) n on n.contatore <= m4.ups /2
			where sd.id_node_ref=6019421) r join (
			select --nextval('attivita_id_seq'),
sd.id_node as id_struttura_asl,p.id id_piano,null id_linea,null dt,null id_risorsa,target,/*n.contatore,*/target*fattore_fin ups--,sd.descrizione_breve as uos,p.descrizione 
	from matrix.struttura_piano_target t
			join matrix.vw_tree_nodes_down_asl_descr sd on sd.id_node=t.id_struttura 
			join matrix.vw_tree_nodes_down_piani pd on pd.id_node=t.id_piano
			join matrix.struttura_piani p on t.id_piano = p.id
			join matrix.formule f on p.id_formula_ups =f.id
			where sd.id_node_ref=6019421  and pd.id_node_ref=19499 and sd.n_livello =3) s
			on r.id_struttura=s.id_struttura_asl 
			join (SELECT generate_series as  contatore FROM generate_series(1,10000)) n on n.contatore <= round(frazione*target)) as sub
where attivita.id_struttura =sub.id_struttura and attivita.id_piano=sub.id_piano and attivita.contatore=sub.contatore and attivita.id_elab_cal=1;

delete from attivita where id_risorsa is null;
update attivita set dt=sub.giorno from
(select id_risorsa,id_struttura,id_piano,contatore,
'2023-01-02 09:00:00'::timestamp + ((trunc(giorni/5))*7 + mod(giorni,5))* interval '1 days' as giorno
from (
select id_risorsa,id_struttura,id_piano,contatore, row_number() over (partition by id_risorsa) -1 as giorni
from attivita where id_elab_cal =1 and id_risorsa is not null) d) sub
where attivita.id_struttura =sub.id_struttura and attivita.id_piano=sub.id_piano
and attivita.contatore=sub.contatore and attivita.id_elab_cal=1 ;


insert into linee_selezionate 
--select nextval('linee_selezionate_id_seq'),1,id_linea ,id_piano from linea_piani lp order by id_linea+id_piano limit 3000;
select nextval('linee_selezionate_id_seq'),
1,id_linea ,id_piano,row_number() over () from linea_piani lp
join linea l on l.id=lp.id_linea 
join vw_comuni_lookup vcl on vcl.com_id =l.id_comune 
join matrix.vw_tree_nodes_down_piani p on lp.id_piano =p.id_node 
join matrix.vw_tree_nodes_down_asl sd 
join struttura_comuni sc on sc.id_struttura =sd.id_node
 on sc.id_comune=vcl.id
 where sd.id_node_ref=6019421 and p.id_node_ref=19499
order by id_linea+id_piano limit 5000;

for REC in select ls.*,cl.id as id_comune from linee_selezionate ls
	join linea l on l.id=ls.id_linea join agenda.vw_comuni_lookup cl on cl.com_id=l.id_comune
	where id_elab_cal = 1 order by ordine loop
	select a.id into idselected  from attivita a join matrix.nominativi_struttura ns on ns.id_nominativo=a.id_risorsa
	join nominativo_comuni n on ns.id  =n.id_nominativo_struttura join struttura_comuni sc on sc.id_struttura =ns.id_struttura 
	where id_piano=REC.id_piano and sc.id_comune=REC.id_comune and a.id_linea is null order by dt limit 1;
	if idselected is not null then
		update attivita set id_linea = REC.id_linea where id=idselected ;
	end if;
end loop;



	select json_agg(row_to_json(g.*)) into rt from (select 
		 l.denominazione,c.comune,sa.descrizione_breve,dt as giorno,/*replace(sp.path_descr,'Totale/','')*/ sp.descrizione_breve attivita from
		attivita a  join linea l on a.id_linea =l.id
		left join vw_comuni_lookup c on c.com_id =l.id_comune
		join matrix.struttura_asl sa  on sa.id =a.id_struttura
		join matrix.struttura_piani sp on sp.id=a.id_piano) g;

		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='calendario non generato';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'calendario_non_generato');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;

	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.genera_calendario_prova(id_record bigint, idtransazione bigint) OWNER TO postgres;

--
-- Name: genera_calendario_upd_date(bigint, interval, interval, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.genera_calendario_upd_date(idelabcal bigint, ora_start interval, ora_end interval, v_inizio timestamp without time zone, v_fine timestamp without time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
n_righe integer;
proc_name varchar;
	begin
	proc_name:='agenda.genera_calendario_upd_date';
	n_righe:=0;

	raise notice 'PAR % % % % %',idelabcal,ora_start,ora_end,v_inizio,v_fine;

	update agenda.attivita a
		set dt=sub.data_new from 
		(
	select id_attivita,a.id_anagrafica,data_new from (
	select a.id id_attivita,id_anagrafica,dt,row_number() over (partition by id_anagrafica order by dt) n from agenda.attivita a
	join matrix.vw_nominativi_struttura ns on ns.id_nominativo=a.id_risorsa
			where id_elab_cal=idelabcal) a join


	(select id_anagrafica,
	   case when n=0 then lower(dd) 
					   when disponibilita_p > (ora_end -ora_start) /2
					   then upper (dd) -(ora_end -ora_start) /2
					   else upper(dd)-disponibilita_p end data_new,
		row_number() over(partition by id_anagrafica order by n,dd) n
	from (
		select id_anagrafica,dd,ora_end -ora_start -sum(occupato) disponibilita,
				min(disponibilita_a) disponibilita_a,min(disponibilita_p) disponibilita_p from (
				
				
			select e.id,r.id_anagrafica,dd ,tsrange(e.inizio,e.fine,'[)') ev ,tsrange(e.inizio,e.fine,'[)') * dd,
				--coalesce((e.fine-e.inizio),interval '0 seconds') occupato,
			case when e.inizio is null then interval '0 seconds' else
			coalesce(upper(tsrange(e.inizio,e.fine,'[)') * dd) -lower(tsrange(e.inizio,e.fine,'[)') * dd),interval '0 seconds') end occupato,
				coalesce(e.inizio,upper(dd))-lower(dd) disponibilita_a,
				upper(dd)-coalesce(e.fine,lower(dd)) disponibilita_p
 			from
				(select distinct id_anagrafica from agenda.attivita a
				join matrix.vw_nominativi_struttura ns on ns.id_nominativo=a.id_risorsa
				where id_elab_cal =idelabcal and id_risorsa is not null) r
				join
				(select tsrange(d+ora_start,d+ora_end,'[)') dd 
					FROM generate_series(v_inizio,v_fine, '1 day'::interval) d
				 where d not in (select dt from agenda.festivita) and extract (dow from d) between 1 and 5) g
				on 1=1
				left join agenda.vw_eventi_occupazione e on e.id_anagrafica=r.id_anagrafica and (tsrange(e.inizio,e.fine,'[)') && dd)
				

				
				
		) o group by 1,2) a join (select n FROM generate_series( 0, 1) n) n on
			disponibilita > (ora_end -ora_start)*3/4 or (disponibilita > ((ora_end -ora_start)/4)
			and ((disponibilita_a>=disponibilita_p and n=0) or (disponibilita_a<disponibilita_p and n=1)))
		order by 1,2) b 
on a.id_anagrafica=b.id_anagrafica and b.n=a.n	
) sub

		where a.id=sub.id_attivita;
		
		
		/*

(select id_attivita,a.id_risorsa,data_new from (
	select id id_attivita,id_risorsa,dt,row_number() over (partition by id_risorsa order by dt) n from agenda.attivita a 
			where id_elab_cal=idelabcal) a join


	(select id_risorsa,
	   case when n=0 then lower(dd) 
					   when disponibilita_p > (ora_end -ora_start) /2 then upper (dd) -(ora_end -ora_start) /2
					   else upper(dd)-disponibilita_p end data_new,
		row_number() over(partition by id_risorsa order by n,dd) n
	from (
		select id_risorsa,dd,ora_end -ora_start -sum(occupato) disponibilita,
				min(disponibilita_a) disponibilita_a,min(disponibilita_p) disponibilita_p from (
			select id_risorsa,dd ,tsrange(e.inizio,e.fine,'[)'),tsrange(e.inizio,e.fine,'[)') * dd,
				--coalesce((e.fine-e.inizio),interval '0 seconds') occupato,
			case when e.inizio is null then interval '0 seconds' else
			coalesce(upper(tsrange(e.inizio,e.fine,'[)') * dd) -lower(tsrange(e.inizio,e.fine,'[)') * dd),interval '0 seconds') end occupato,
				coalesce(e.inizio,upper(dd))-lower(dd) disponibilita_a,
				upper(dd)-coalesce(e.fine,lower(dd)) disponibilita_p
 			from
				(select distinct id_risorsa from agenda.attivita a where id_elab_cal =idelabcal and id_risorsa is not null) r
				join
				(select tsrange(d+ora_start,d+ora_end,'[)') dd FROM generate_series(v_inizio,v_fine, '1 day'::interval) d
				 where d not in (select dt from agenda.festivita) and extract (dow from d) between 1 and 5) g
				on 1=1
				left join agenda.vw_eventi_occupazione e on e.id_nominativo=r.id_risorsa and (tsrange(e.inizio,e.fine,'[)') && dd)
		) o group by 1,2) a join (select n FROM generate_series( 0, 1) n) n on
			disponibilita > (ora_end-ora_start)*3/4 or (disponibilita > ((ora_end-ora_start)/4) and ((disponibilita_a>=disponibilita_p and n=0) or (disponibilita_a<disponibilita_p and n=1)))
		order by 1,2) b 
on a.id_risorsa=b.id_risorsa and b.n=a.n) sub

		where a.id=sub.id_attivita;*/
	
	

/*

	update agenda.attivita a
		set dt=sub.data_new from 
		(select id_attivita,id_risorsa,data_new from (
		select id id_attivita,id_risorsa,dt,row_number() over (partition by id_risorsa order by dt) n from agenda.attivita a 
		where id_elab_cal=idelabcal) a join
							
		(select id_nominativo,data_new,row_number() over (partition by id_nominativo order by data_new) n from (
			select id_nominativo,data + ora_start as data_new from (
				select id_nominativo,date_trunc('day',inizio) data,min(inizio) ini ,max(fine)fine,sum(durata) durata from agenda.vw_eventi_occupazione
				where inizio between v_inizio and v_fine and id_nominativo is not null
				group by 1,2
			) e where (e.ini - date_trunc('day',e.ini)) > ora_start_p or extract(epoch from durata) <3600	
			union	
			select id_nominativo,data + ora_start_p from (
				select id_nominativo,date_trunc('day',inizio) data,min(inizio) ini ,max(fine)fine,sum(durata) durata from agenda.vw_eventi_occupazione
				where inizio between v_inizio and v_fine and id_nominativo is not null
				group by 1,2
			) e where (e.fine - date_trunc('day',e.fine)) <= ora_start_p or extract(epoch from durata) <3600
		) x) b on a.id_risorsa=b.id_nominativo and b.n=a.n) sub
		where a.id=sub.id_attivita;*/
	
	GET DIAGNOSTICS n_righe = ROW_COUNT;
	return n_righe;
end;
$$;


ALTER FUNCTION agenda.genera_calendario_upd_date(idelabcal bigint, ora_start interval, ora_end interval, v_inizio timestamp without time zone, v_fine timestamp without time zone) OWNER TO postgres;

--
-- Name: genera_calendario_upd_date(bigint, interval, interval, timestamp without time zone, timestamp without time zone, interval); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.genera_calendario_upd_date(idelabcal bigint, ora_start interval, ora_end interval, v_inizio timestamp without time zone, v_fine timestamp without time zone, ore_lavoro interval) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
n_righe integer;
proc_name varchar;
intervallo tsrange;
	begin
	proc_name:='agenda.genera_calendario_upd_date';
	n_righe:=0;

	raise notice 'PAR % % % % %',idelabcal,ora_start,ora_end,v_inizio,v_fine;

for intervallo in select distinct validita from agenda.attivita where id_elab_cal= idelabcal loop

	update agenda.attivita a
		set dt=sub.data_new from 
		(
	select id_attivita,a.id_anagrafica,data_new,b.ap,inizio,fine ,durata,
	case when b.ap=0 then date_trunc('hour',coalesce(inizio-durata,data_new))
		else date_trunc('hour',coalesce(fine,data_new)+ interval '1 hour') end data_exactly
	
	from (
	select a.id id_attivita,id_anagrafica,dt,a.durata,row_number() over (partition by id_anagrafica order by dt) n from agenda.attivita a
	join matrix.vw_nominativi_struttura ns on ns.id_nominativo=a.id_risorsa
			where id_elab_cal=idelabcal and a.validita=intervallo) a join


	(select id_anagrafica,
	   case when n=0 then lower(dd) 
					   when disponibilita_p > (ore_lavoro) /2
					   then upper (dd) -(ore_lavoro) /2
					   else upper(dd)-disponibilita_p end data_new,
		row_number() over(partition by id_anagrafica order by n,dd) n,n ap,inizio,fine
	from (
		select id_anagrafica,dd,ore_lavoro -sum(occupato) disponibilita,
				min(disponibilita_a) disponibilita_a,min(disponibilita_p) disponibilita_p,min(o.inizio) inizio,max(o.fine) fine from (
				
				
			select e.id,r.id_anagrafica,dd ,tsrange(e.inizio,e.fine,'[)') ev ,tsrange(e.inizio,e.fine,'[)') * dd,
				--coalesce((e.fine-e.inizio),interval '0 seconds') occupato,
			case when e.inizio is null then interval '0 seconds' else
			coalesce(upper(tsrange(e.inizio,e.fine,'[)') * dd) -lower(tsrange(e.inizio,e.fine,'[)') * dd),interval '0 seconds') end occupato,
				coalesce(e.inizio,upper(dd))-lower(dd) disponibilita_a,
				upper(dd)-coalesce(e.fine,lower(dd)) disponibilita_p,e.inizio,e.fine
 			from
				(select distinct id_anagrafica from agenda.attivita a
				join matrix.vw_nominativi_struttura ns on ns.id_nominativo=a.id_risorsa
				where id_elab_cal =idelabcal and id_risorsa is not null) r
				join
				(select tsrange(d+ora_start,d+ora_end,'[)') dd 
					--FROM generate_series(v_inizio,v_fine, '1 day'::interval) d
					from generate_series(lower(intervallo),upper(intervallo), '1 day'::interval) d
				 where d not in (select dt from agenda.festivita) and extract (dow from d) between 1 and 5) g
				on 1=1
				left join (select eo.id,eo.id_anagrafica,eo.inizio,eo.fine from agenda.vw_eventi_occupazione eo union all
				           select  a.id,ns.id_anagrafica, a.dt, a.dt+a.durata from agenda.attivita a join matrix.vw_nominativi_struttura ns on ns.id_nominativo=a.id_risorsa
				           	where a.id_elab_cal=idelabcal and id_risorsa is not null
					) e on e.id_anagrafica=r.id_anagrafica and (tsrange(e.inizio,e.fine,'[)') && dd)
		) o group by 1,2) a join (select n FROM generate_series( 0, 1) n) n on
			disponibilita > (ore_lavoro)*2/3 or (disponibilita > ((ore_lavoro)/3)
			and ((disponibilita_a>=disponibilita_p and n=0) or (disponibilita_a<disponibilita_p and n=1)))
		order by 1,2) b 
on a.id_anagrafica=b.id_anagrafica and b.n=a.n
) sub

		where a.id=sub.id_attivita;
end loop;

	GET DIAGNOSTICS n_righe = ROW_COUNT;
	return n_righe;
end;
$$;


ALTER FUNCTION agenda.genera_calendario_upd_date(idelabcal bigint, ora_start interval, ora_end interval, v_inizio timestamp without time zone, v_fine timestamp without time zone, ore_lavoro interval) OWNER TO postgres;

--
-- Name: get_ag_conf(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_ag_conf(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	a varchar;
	begin
		proc_name:='agenda.get_ag_conf';
		a=v->>'area';
		raise notice 'v=%',v;
		raise notice 'area=%',a;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (
			select * from ag_conf.vw_ag_conf c where trim(upper(c.area))=trim(upper(a)) or a is null ) g;
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=ag_ui.build_ret(ret,proc_name, 'configurazione_non_trovata');
    	else
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_ag_conf(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ag_tipo_eventi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_ag_tipo_eventi(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
	flusso text;
 

	begin
	proc_name:='agenda.get_tipo_liste';
	
		select json_agg(row_to_json(c.*)) into rt  from (select * from  ag_types.vw_ag_tipo_eventi e ) c;

		raise notice '%',rt;	
		if rt is null then
			ret.esito:=false;	
    	    ret:=ag_ui.build_ret(ret,proc_name, 'Valori non trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null; 		 		
 			ret.info:='{"dati":' || rt;
			ret.info:=ret.info || '}';

		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_ag_tipo_eventi(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_agende(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_agende(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	idanagrafica bigint;
	R_EV agenda.vw_calendari%ROWTYPE;
	responsabile bool;
	rt json;
	info bool;

	begin
		proc_name:='agenda.get_agende';
		responsabile:=v->'user_info'->'responsabile';
		info:=v->'get_info';
		raise notice 'RESPONSABILE %',responsabile;
		if replace((v->'user_info'->'id_struttura_root')::varchar,'"','') = 'null' 
							or responsabile is null or not responsabile or (info and info is not null) then
			raise notice 'NON RESPONSABILE';
			idstrutturaasl:= null;
			idanagrafica:=v->'id';
			if idanagrafica is null then
				idanagrafica:=v->'id_anagrafica';
			end if;
			--select json_agg(row_to_json(c.*)) into rt  from 
			select row_to_json(c.*) into rt  from 
				(select *,to_char(round(eseguite::numeric,2)          ,'999G990D00') ||'/'||
						  to_char(round(pianificate::numeric,2)       ,'999G990D00')||' ('||
						  to_char(round(eseguite_ratio::numeric*100,2),'999G990D00')||' %)' as att from agenda.vw_agende a
			where a.id_anagrafica =idanagrafica order by pianificate desc, eseguite desc) c;

		else
			raise notice 'RESPONSABILE';
			idstrutturaasl=v->'user_info'->'id_struttura_root';
			select json_agg(row_to_json(c.*)) into rt  from 
				(select *,to_char(round(eseguite::numeric,2)          ,'999G990D00') ||'/'||
					      to_char(round(pianificate::numeric,2)       ,'999G990D00') ||' ('||
					      to_char(round(eseguite_ratio::numeric*100,2),'999G990D00')||' %)' as att from agenda.vw_agende a
			where a.id_anagrafica in (select distinct id_anagrafica from matrix.vw_nominativi_struttura where id_node_struttura
			in (select id_node from matrix.vw_tree_nodes_down_asl where id_node_ref =idstrutturaasl )) order by pianificate desc, eseguite desc) c;
			raise notice '%',json_array_length(rt);
		
			if json_array_length(rt) is null then
				ret.esito:=false;	
	    		--ret.msg:='calendari non trovati';
	    	    ret:=ag_ui.build_ret(ret,proc_name, 'calendari_non_trovati');
	    		ret.info:=null; 
	    		return ret;
	    	end if;
		end if;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;


		ret.esito:=true;
		ret.msg:=null;
 		ret.info:=rt;

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_agende(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_attivita(bigint, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_attivita(id_record bigint, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idselected bigint;
	proc_name varchar;
	R_CAL agenda.vw_calendari%ROWTYPE;
	REC Record;
	rt json;

	begin
		proc_name:='agenda.get_attivita';
	

	select json_agg(row_to_json(g.*)) into rt from (select 
		 l.denominazione linea,c.comune,sa.descrizione_breve uos,n.nominativo ,dt as giorno,replace(sp.path_descr,'Totale/','') attivita from
		agenda.attivita a  join agenda.vw_linee l on a.id_linea =l.id
		left join agenda.vw_comuni_lookup c on c.com_id =l.id_comune
		join matrix.struttura_asl sa  on sa.id =a.id_struttura
		join matrix.vw_tree_nodes_up_piani sp on sp.id_node=a.id_piano
		join matrix.nominativi n on n.id=a.id_risorsa 
		
		) g;

		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		ret.msg:='calendario non generato';
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;

	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_attivita(id_record bigint, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_avvisi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_avvisi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	responsabile bool;
	rt json;
	idAsl bigint;
	idNs bigint;

	begin
		proc_name:='agenda.get_avvisi';
		responsabile:=v->'user_info'->'responsabile';
		raise notice 'RESPONSABILE %',responsabile;
		if v->'user_info'->>'id_asl' is null or v->'user_info'->>'id_asl' = 'null' then
			idAsl = -1;
		else
			idAsl:=v->'user_info'->>'id_asl';
		end if;
		--idAsl:=v->'user_info'->'id_asl';
		idNs:=v->'user_info'->'id_utente';
			--select json_agg(row_to_json(c.*)) into rt  from 
			/*if idAsl = -1 then
				select json_agg(row_to_json(g.*)) into rt from (
				select va.*, 
				responsabile is true as aggiungi_avviso
				--var.id_asl 
				from agenda.vw_avvisi va
				--join agenda.vw_avviso_risorse var on var.id_avviso = va.id_avviso
				order by lower(va.validita) desc) g;
			else*/
				select json_agg(row_to_json(g.*)) into rt from (
				select va.*, 
				responsabile is true as aggiungi_avviso
				--var.id_asl 
				from agenda.vw_avvisi va
				--join agenda.vw_avviso_risorse var on var.id_avviso = va.id_avviso
				where va.id_user_create = idns
				or idAsl = -1--var.id_asl = idAsl
				order by lower(va.validita) desc) g;
			--end if;

			/*if json_array_length(rt) is null then
				ret.esito:=true;	
	    		--ret.msg:='calendari non trovati';
	    	    ret:=ag_ui.build_ret(ret,proc_name, 'avvisi_non_trovati');
	    		ret.info:=null; 
	    		return ret;
	    	end if;*/

		ret.esito:=true;
		ret.msg:=null;
 		ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_avvisi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_avvisi_for_risorsa(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_avvisi_for_risorsa(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;
	v_id_risorsa bigint;
	proc_name varchar;
	responsabile bool;
	rt json;
	v_id_anagrafica bigint;

	begin
		proc_name:='agenda.get_avvisi_for_risorsa';
		responsabile:=v->'user_info'->'responsabile';
		v_id_anagrafica:=v->'user_info'->'id_utente';
		raise notice 'id_anagrafica%',v_id_anagrafica;
		raise notice 'RESPONSABILE %',responsabile;
			--select json_agg(row_to_json(c.*)) into rt  from 
			select json_agg(row_to_json(g.*)) into rt from (
			select distinct on (ar.id_avviso) ar.id_avviso_risorsa , ar.descrizione, ar.descr_livello, ar.descr_tipo, 
			ar.id_avviso, ar.colore,
			ar.ordine,ar.icona, ar.dt_prima_visualizzazione,
			ar.visualizzabile 
			from agenda.vw_avviso_risorse ar 
			join agenda.vw_avvisi va on va.id_avviso = ar.id_avviso 
			join matrix.vw_nominativi_struttura_validi_operativi vns on vns.id = ar.id_risorsa 
			where vns.id_anagrafica = v_id_anagrafica 
			and va.validita @> CURRENT_TIMESTAMP::timestamp without time zone) g;

			if json_array_length(rt) is null then
				ret.esito:=false;	
	    		--ret.msg:='calendari non trovati';
	    	    --ret:=ag_ui.build_ret(ret,proc_name, 'avvisi_non_trovati');
	    		ret.info:=null; 
	    		return ret;
	    	end if;

		ret.esito:=true;
		ret.msg:=null;
 		ret.info:='{"dati":'||rt::varchar||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_avvisi_for_risorsa(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_avviso_singolo(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_avviso_singolo(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	responsabile bool;
	rt json;
	idavviso bigint;

	begin
		proc_name:='agenda.get_avviso_singolo';
		responsabile:=v->'user_info'->'responsabile';
		idavviso:=v->'id_avviso';
		raise notice 'RESPONSABILE %',responsabile;
			--select json_agg(row_to_json(c.*)) into rt  from 
			select json_agg(row_to_json(g.*)) into rt from (
			select * from agenda.vw_avvisi va where id_avviso = idavviso) g;

			if json_array_length(rt) is null then
				ret.esito:=false;	
	    		--ret.msg:='calendari non trovati';
	    	    ret:=ag_ui.build_ret(ret,proc_name, 'avviso_non_trovato');
	    		ret.info:=null; 
	    		return ret;
	    	end if;

		ret.esito:=true;
		ret.msg:=null;
 		ret.info:='{"dati":'||rt::varchar||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_avviso_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_az_sedi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_az_sedi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	idelabcal bigint;
	rt json;
	idstrutturaroot bigint;
	begin
		proc_name:='agenda.get_az_sedi';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (
			select   l.*
			from agenda.vw_az_sedi l 
			join agenda.vw_linee lin on l.id_az_sede= lin.id_az_sede where l.id_comune in
			(select distinct id_comune from  agenda.vw_struttura_comuni s 
				join matrix.vw_tree_nodes_down_asl a
				on s.id_struttura =a.id_node where a.id_node_ref=idstrutturaroot)
			order by l.comune  ,l.denominazione_sede_operativa
		)  g;

	
	
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=ag_ui.build_ret(ret,proc_name, 'az_sedi_non_trovate');
    	else
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_az_sedi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_azienda_indirizzi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_azienda_indirizzi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	idelabcal bigint;
	idazienda bigint;
	rt json;
	idstrutturaroot bigint;
	begin
		proc_name:='agenda.get_azienda_indirizzi';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		idazienda:=v->'id_azienda';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (
		select * from agenda.vw_azienda_indirizzi where id_azienda =idazienda
		) g;
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=ag_ui.build_ret(ret,proc_name, 'azienda_indirizzi_non_trovati');
    	else
	 		--ret.info:=rt;
    		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_azienda_indirizzi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_azienda_persone(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_azienda_persone(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	idelabcal bigint;
	idazienda bigint;
	rt json;
	idstrutturaroot bigint;
	begin
		proc_name:='agenda.get_azienda_persone';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		idazienda:=v->'id_azienda';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (
		select * from agenda.vw_azienda_persone l where l.id_azienda =idazienda
			--order by l.comune  ,l.denominazione_sede_operativa
		) g;
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=ag_ui.build_ret(ret,proc_name, 'azienda_persone_non_trovate');
    	else
	 		--ret.info:=rt;
    		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_azienda_persone(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_aziende(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_aziende(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	idelabcal bigint;
	rt json;
	idstrutturaroot bigint;
	begin
		proc_name:='agenda.get_aziende';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (
		select * from agenda.vw_aziende where id_azienda in (

			select   l.id_azienda 
			from agenda.vw_az_sedi l where id_comune in
			(select distinct id_comune from  agenda.vw_struttura_comuni s  join matrix.vw_tree_nodes_down_asl a
			on s.id_struttura =a.id_node where a.id_node_ref=idstrutturaroot)
			order by l.comune  ,l.denominazione_sede_operativa
		) ) g;

	
	
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=ag_ui.build_ret(ret,proc_name, 'aziende_non_trovate');
    	else
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_aziende(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_aziende_by_sel(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_aziende_by_sel(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	idelabcal bigint;
	rt json;
	idstrutturaroot bigint;
	v_rag_sociale varchar;
	v_p_iva varchar;
	v_comune varchar;
	begin
		proc_name:='agenda.get_aziende_by_sel';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		v_rag_sociale = v->'rag_sociale'||'%';
		v_p_iva = v->'p_iva'||'%';
		v_comune = v->'comune'||'%';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (
		select * from agenda.vw_aziende where (rag_soc is null || rag_soc ilike v_rag_sociale) 
		and (piva is null || piva ilike v_p_iva)
		and id_azienda in (

			select   l.id_azienda 
			from agenda.vw_az_sedi l where id_comune in
			(select distinct id_comune from  agenda.vw_struttura_comuni s  join matrix.vw_tree_nodes_down_asl a
			on s.id_struttura =a.id_node where a.id_node_ref=idstrutturaroot)
			order by l.comune  ,l.denominazione_sede_operativa
		) ) g;

	
	
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=ag_ui.build_ret(ret,proc_name, 'aziende_non_trovate');
    	else
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;

	END;
$$;


ALTER FUNCTION agenda.get_aziende_by_sel(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cal_riepiloghi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_cal_riepiloghi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	ret_1 ag_types.result_type; 
	ret_2 ag_types.result_type; 
	ret_3 ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	str_conf varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	rt json;
	j_user_info json;

	begin
		j_user_info:=v->'user_info';
		ret_1:=agenda.get_cal_riepilogo_uos(v,idtransazione);
		if ret_1.esito then
			str_conf:= ag_ui.get_ui_definition(''::varchar,'agenda.get_cal_riepilogo_uos',((j_user_info->'id_struttura_root')::varchar)::int8,idtransazione);
			ret_1.info:='{"uos":{'||str_conf||',"dati":' || coalesce(ret_1.info,'[]');
			ret_1.info:=ret_1.info || '}';
			raise notice 'ret.info 1 %',ret_1.info;
		end if;
		ret_2:=agenda.get_cal_riepilogo_risorse(v ,idtransazione);
		if ret_2.esito then
			str_conf:= ag_ui.get_ui_definition(''::varchar,'agenda.get_cal_riepilogo_risorse',((j_user_info->'id_struttura_root')::varchar)::int8,idtransazione);
			ret_2.info:='"risorse":{'||str_conf||',"dati":' || coalesce(ret_2.info,'[]');
			ret_2.info:=ret_2.info || '}';
			raise notice 'ret.info 2 %',ret_2.info;
		end if;
		ret_3:=agenda.get_cal_riepilogo_linee(v ,idtransazione);
		if ret_3.esito then
			str_conf:= ag_ui.get_ui_definition(''::varchar,'agenda.get_cal_riepilogo_linee',((j_user_info->'id_struttura_root')::varchar)::int8,idtransazione);
			ret_3.info:='"linee":{'||str_conf||',"dati":' || coalesce(ret_3.info,'[]');
			ret_3.info:=ret_3.info || '}';
			raise notice 'ret.info 3 %',ret_3.info;
		end if;
	    ret.esito:=true;
 		ret.msg:=null;
		ret.info:=ret_1.info||','||ret_2.info||','||ret_3.info||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_cal_riepiloghi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cal_riepiloghi_da_eliminare(bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_cal_riepiloghi_da_eliminare(idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	ret_2 ag_types.result_type; 
	ret_3 ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	str_conf varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	rt json;

	begin
		ret:=agenda.get_cal_riepilogo_uos(v::json,idtransazione);
		if ret.esito then
			str_conf:= ag_ui.get_ui_definition(''::varchar,'agenda.get_cal_riepilogo_uos',((j_user_info->'id_struttura_root')::varchar)::int8,idtransazione);
			ret.info:='{"uos":{'||str_conf||',"dati":' || ret.info::json;
			ret.info:=ret.info || '},';
			raise notice 'ret.info %',ret.info;
		end if;
		ret_2:=agenda.get_cal_riepilogo_risorse(v::json ,idtransazione);
		if ret2.esito then
			str_conf:= ag_ui.get_ui_definition(''::varchar,'agenda.get_cal_riepilogo_risorse',((j_user_info->'id_struttura_root')::varchar)::int8,idtransazione);
			ret.info:='{"risorse":{'||str_conf||',"dati":' || ret.info::json;
			ret.info:=ret2.info || '},';
			raise notice 'ret.info %',ret2.info;
		end if;
		ret_3:=agenda.get_cal_riepilogo_linee(v::json ,idtransazione);
		if ret3.esito then
			str_conf:= ag_ui.get_ui_definition(''::varchar,'agenda.get_cal_riepilogo_linee',((j_user_info->'id_struttura_root')::varchar)::int8,idtransazione);
			ret.info:='{"linee":{'||str_conf||',"dati":' || ret.info::json;
			ret.info:=ret3.info || '},';
			raise notice 'ret.info %','{'||ret3.info||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_cal_riepiloghi_da_eliminare(idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cal_riepilogo_linee(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_cal_riepilogo_linee(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	idelabcal bigint;
	rt json;

	begin
		proc_name:='agenda.get_cal_riepilogo_linee';
		raise notice 'v=%',v;
		idelabcal:=v->'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v->>'id_gen_cal';
		end if;
	raise notice 'idelabcal=%',idelabcal;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (select * from agenda.vw_cal_linee_piani_riep
		where id_elab_cal=idelabcal order by programmate desc /*asl_c,asl_d,piano_d*/) a;
	
		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		/*if json_array_length(rt) is null then
			ret.esito:=false;	
    		ret.msg:='riepilogo linee non trovato';
    		ret.info:=null; 
    	else*/
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		--end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_cal_riepilogo_linee(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cal_riepilogo_risorse(bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_cal_riepilogo_risorse(idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	rt json;

	begin
		proc_name:='agenda.get_cal_riepilogo_risorse';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (select * from agenda.vw_cal_risorse_riepilogo
		where id_elab_cal=2 order by nominativo) a;
	
		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		/*if json_array_length(rt) is null then
			ret.esito:=false;	
    		ret.msg:='riepilogo risorse non trovato';
    		ret.info:=null; 
    	else*/
	
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		--end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_cal_riepilogo_risorse(idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cal_riepilogo_risorse(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_cal_riepilogo_risorse(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	idelabcal bigint;
	rt json;

	begin
		proc_name:='agenda.get_cal_riepilogo_risorse';
		idelabcal:=v->'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v->>'id_gen_cal';
		end if;
		raise notice 'idelabcal=%',idelabcal;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (select * from agenda.vw_cal_risorse_riepilogo
		where id_elab_cal=idelabcal order by attivita desc) a;
	
		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		/*if json_array_length(rt) is null then
			ret.esito:=false;	
    		ret.msg:='riepilogo risorse non trovato';
    		ret.info:=null; 
    	else*/
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		--end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_cal_riepilogo_risorse(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cal_riepilogo_uos(bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_cal_riepilogo_uos(idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idelabcal bigint;
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	rt json;

	begin
		proc_name:='agenda.get_cal_riepilogo_uos';
		idelabcal:=v->'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v->>'id_gen_cal';
		end if;
		raise notice 'idelabcal=%',idelabcal;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (select * from agenda.vw_cal_uos_riepilogo
		where id_elab_cal=idelabcal order by descrizione_breve) a;
	
		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		/*if json_array_length(rt) is null then
			ret.esito:=false;	
    		ret.msg:='riepilogo risorse non trovato';
    		ret.info:=null; 
    	else*/
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		--end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_cal_riepilogo_uos(idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cal_riepilogo_uos(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_cal_riepilogo_uos(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	rt json;
idelabcal bigint;

	begin
		proc_name:='agenda.get_cal_riepilogo_uos';
		idelabcal:=v->'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v->>'id_gen_cal';
		end if;
		raise notice 'idelabcal=%',idelabcal;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (select * from agenda.vw_cal_uos_riepilogo
		where id_elab_cal=idelabcal order by programmati desc /*descrizione_breve*/) a;
	
		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		ret.msg:='riepilogo risorse non trovato';
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_cal_riepilogo_uos(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_calendari(bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_calendari(idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV agenda.vw_calendari%ROWTYPE;
	rt json;
	idelabcal bigint;

	begin
		proc_name:='agenda.get_calendari';
		idelabcal:=v->'id_elab_cal';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
	
		select json_agg(row_to_json(c.*)) into rt  from (select * from agenda.vw_calendari c where idelabcal is null or idelabcal=id_elab_cal order by pianificate desc, eseguite desc) c;

		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		ret.msg:='calendari non trovati';
    	    ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_calendari(idtransazione bigint) OWNER TO postgres;

--
-- Name: get_calendario(bigint, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_calendario(id_record bigint, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idselected bigint;
	proc_name varchar;
	R_CAL agenda.vw_calendari%ROWTYPE;
	REC Record;
	rt json;

	begin
		proc_name:='agenda.get_calendario';
	
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select row_to_json(c.*) into rt from agenda.vw_calendari c
	where id_anagrafica =id_record;
	
		--ret.valore:= id_record;
	
		raise notice '%',rt;
	
		if rt is null then
			ret.esito:=false;	
    		--ret.msg:='calendario non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'calendari_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	

	 	return ret;

	end;
end;
$$;


ALTER FUNCTION agenda.get_calendario(id_record bigint, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_calendario(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_calendario(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	idelabcal bigint;
	rt json;

	begin
		proc_name:='agenda.get_calendario';
	
			id_op:=ag_log.start_op(proc_name,idtransazione ,'');
		raise notice 'v=%',v;
		idelabcal:=v->'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v->>'id_gen_cal';
		end if;
	raise notice 'idelabcal=%',idelabcal;

	select json_agg(row_to_json(g.*)) into rt from (/*select 
		 a.id,l.denominazione_sede_operativa  linea,c.comune,sa.descrizione_breve uos,n.nominativo ,dt as giorno, 
		 to_char(dt, 'HH24:MI' ) as ora, sp.alias || ' - '||sp.descrizione_breve  /*replace(sp.path_descr,'Totale/','')*/ attivita,
		 e.id is null as selezionabile,np.nominativo nominativo_partner , l.cod_tipo_linea
		 
		 from		agenda.attivita a  join agenda.vw_linee l on a.id_linea =l.id_linea
		--left join agenda.vw_comuni_lookup c on c.com_id =l.id_comune
		left join agenda.vw_az_sedi s on s.id=l.id_az_sede 
	 	join agenda.comuni c on c.id =s.id_comune 
		join matrix.struttura_asl sa  on sa.id =a.id_struttura
		join matrix.vw_tree_nodes_up_piani sp on sp.id_node=a.id_piano
		left join matrix.nominativi n on n.id=a.id_risorsa 
		left join matrix.nominativi np on np.id=a.id_partner 
		left join agenda.eventi e on e.id_attivita =a.id
		where a.id_elab_cal=idelabcal order by a.dt,n.nominativo,c.comune,l.denominazione_sede_operativa */

		select 
		 a.id,s.nome  linea,s.comune,sa.descrizione_breve uos,n.nominativo ,dt as giorno, 
		 to_char(dt, 'HH24:MI' ) as ora, sp.alias || ' - '||sp.descrizione_breve  /*replace(sp.path_descr,'Totale/','')*/ attivita,
		 e.id is null as selezionabile,np.nominativo nominativo_partner , l.cod_tipo_linea,
		 s.cod_regionale 	--ISSUE #11570
		 
		 from		agenda.attivita a  join cu_anag.vw_linee l on a.id_linea =l.id_linea
		--left join agenda.vw_comuni_lookup c on c.com_id =l.id_comune
		 join cu_anag.vw_stabilimenti s on s.id=l.id_stabilimento 
	 	--join agenda.comuni c on c.id =s.id_comune 
		join matrix.struttura_asl sa  on sa.id =a.id_struttura
		join matrix.struttura_piani sp on sp.id=a.id_piano
		left join matrix.nominativi n on n.id=a.id_risorsa 
		left join matrix.nominativi np on np.id=a.id_partner 
		left join agenda.eventi e on e.id_attivita =a.id
		where a.id_elab_cal=idelabcal order by a.dt,n.nominativo,s.comune,s.nome 
		
		
		
		) g;
	
		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	    ret.esito:=true;
 		ret.msg:=null;
		if json_array_length(rt) is null then
    		ret.msg:='Nessuna attivita nel calendario';
    	end if;

	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||rt||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_calendario(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_calendario_info(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_calendario_info(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idelabcal bigint;
	proc_name varchar;
	n integer;
	rt json;

	begin
		proc_name:='agenda.get_calendario_info';
	
		idelabcal:=replace((v->'id_elab_cal')::varchar,'"','')::bigint;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');

		select row_to_json(c.*) into rt from agenda.vw_elab_cals c
		where id=idelabcal;
	
		raise notice '%',rt;
	
		if rt is null then
			ret.esito:=false;	
    		--ret.msg:='ealb_cal non trovata';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'ealb_cal_non_trovata');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_calendario_info(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cf_allevamenti(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_cf_allevamenti(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	j_user_info json;
	tipo integer;
	begin
		proc_name:='agenda.get_cf_allevamenti';
	    tipo:=v->'tipo';
		j_user_info:=v->'user_info';
	
  		if(tipo=2) then
		
	 	  	    select json_agg(row_to_json(a.*)) into rt from ( 
	 	  	    /*select * from agenda.vw_import_linea 
	 	  	    where id_lista = (v->>'id_lista')::bigint
				and id_linea is null
				order by id desc*/
	 	  	    select s.cod_allevamento cod_tipo_linea, s.attributo
	 	  		from
	 			agenda.file_xls_cf s
	 			inner join agenda.vw_import_linea l on l.id=s.id and  id_lista =(v->>'id_lista')::bigint
	 			where id_linea is null
	 			order by s.id  desc
	 	  	    
	 	  	    ) a; 	
	 	else 
	 	  -- 2 associati
	 		if(tipo=1) then
	 			select json_agg(row_to_json(a.*)) into rt from (
	 			/*select * from agenda.vw_import_linea  
	 	  	    where id_lista = (v->>'id_lista')::bigint
				and id_linea is not null
				order by id desc
				*/
	 			select s.cod_allevamento cod_tipo_linea, s.attributo
	 			from
	 			agenda.file_xls_cf s
	 			inner join agenda.vw_import_linea l on l.id=s.id and  id_lista =(v->>'id_lista')::bigint
	 			where id_linea is not null
	 			order by s.id  desc
				) a; 	
	 			end if;
	 	end if;
	 	
	
		raise notice '%',json_array_length(rt);
	    ret.esito:=true;
 		ret.msg:=null;
		ret.info:='{"dati":'||rt||'}';
		--end if;
	 	return ret;
	 
	 
	end;
end;
$$;


ALTER FUNCTION agenda.get_cf_allevamenti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cf_liste(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_cf_liste(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	j_user_info json;

	begin
		proc_name:='agenda.get_cf_liste';
		j_user_info:=v->'user_info';
		raise notice 'function: %', proc_name;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (select * from agenda.vw_cf_liste
		order by dt desc) a;
	
		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	    ret.esito:=true;
 		ret.msg:=null;
		ret.info:='{"dati":'||rt||'}';
		--end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_cf_liste(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_dati(character varying, character varying, bigint, json); Type: PROCEDURE; Schema: agenda; Owner: postgres
--

CREATE PROCEDURE agenda.get_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json)
    LANGUAGE plpgsql
    AS $$

declare 	
	idtransazione bigint;
	proc_name varchar;
	id_op bigint;  
	id_risorsa bigint;
	ret ag_types.result_type;
	ret_2 ag_types.result_type;
	ret_3 ag_types.result_type;

	ret_eventi ag_types.result_type;
	ret_calendari ag_types.result_type;
	retj json;
	text_msg1 varchar;	
	text_msg2 varchar;	
	text_msg3 varchar;	
	text_msg4 varchar;
	str_conf varchar;

		idstruttura bigint;
		responsabile bool;
		--idutente bigint;
	ts timestamp;
id bigint;
	fallito bool;
j_user_info json;
n integer;
v_j json;
begin 
	ts:=CLOCK_TIMESTAMP();
	proc_name:='agenda.get_dati';
	idtransazione:= ag_log.get_id_transazione(idutente,proc_name);
	id_op:=ag_log.op(proc_name,idtransazione,v,null,ts,-1,operazione);
	
	--idutente è rbac.id_utente_struttura_ruolo
	select row_to_json(a.*) into j_user_info from
	(	
		select *,id_struttura as id_struttura_root from public.get_utente_info_3(idutente)
	) a;

	if j_user_info is not null then
		if v is null or v='' or v='{}' then
			v:= '{"user_info":'||j_user_info||'}';
		else
			v:= substring(v,1,length(v)-1)||',"user_info":'||j_user_info||'}';
		end if;
	end if;
	raise notice 'USER_DATA %', v;
	id_op:=ag_log.op(proc_name,idtransazione,v,null,ts,-1,operazione);
   	--COMMIT;
 
	begin 
	fallito:=false;


	case operazione
		when 'get_user_info' then
			if v is not null then
				ret.esito = true;
				ret.info := v;
			end if;
		when 'get_ws_call' then
			ret:=trf.get_ws_call(v, idtransazione);
		when 'get_tariffario_per_attivita' then
			ret:=trf.get_tariffario_per_attivita(v::json, idtransazione);		
		when 'get_tariffario_per_regole' then
			ret:=trf.get_tariffario_per_regole(v::json, idtransazione);
		when 'get_master_list' then
			ret:=agenda.get_masterlist(v::json, idtransazione);
		when 'get_tariffa_ml' then
			ret:=trf.get_tariffa_ml(v::json, idtransazione);
		when 'get_trf_per_regole' then
			ret:=trf.get_trf_per_regole(v::json, idtransazione);
		when 'get_piano_periodo' then
			ret:=agenda.get_piano_periodo(v::json, idtransazione);
		when 'get_exp_dati' then
			ret:=agenda.get_exp_dati(v::json, idtransazione);
		when 'get_exp_conf' then
			ret:=agenda.get_exp_conf(v::json, idtransazione);
		when 'get_elab_log' then
			ret:=agenda.get_elab_log(v::json, idtransazione);
		when 'get_menu_old' then
			ret:=ag_ui.get_menu(v::json, idtransazione);
		when 'get_menu' then
			ret:=rbac_ui.get_menu(v::json, idtransazione);
		when 'get_portali' then
			ret:=rbac_ui.get_portali(v::json, idtransazione);
		when 'get_ns_az_sedi' then
			ret:=agenda.get_ns_az_sedi(v::json, idtransazione);
		when 'get_ns_linee' then
			ret:=agenda.get_ns_linee(v::json, idtransazione);
		when 'get_tariffario_per_piani' then
			ret:=trf.get_tariffario_per_piani(v::json, idtransazione);
		when 'get_piano_freq' then
			ret:=agenda.get_piano_freq(v::json, idtransazione);
		when 'get_tipo_linee_per_piani' then
			ret:=agenda.get_tipo_linee_per_piani(v::json, idtransazione);
		when 'get_piani' then
			ret:=agenda.get_piani(v::json,idtransazione);
		when 'get_piani_totali' then
			ret:=agenda.get_piani_totali(v::json,idtransazione);
		when 'get_piani_totali_spostamento' then
			ret:=agenda.get_piani_totali_spostamento(v::json,idtransazione);
		when 'get_piano_singolo' then
			ret:=agenda.get_piano_singolo(v::json,idtransazione);
		when 'get_elab_ns_piani' then
			ret:=agenda.get_elab_ns_piani(v::json,idtransazione);
		when 'get_tipologia_controllo_piani' then
			ret:=agenda.get_tipologia_controllo_piani(v::json,idtransazione);
	    when 'get_elab_asl_piani' then
	    	v:=replace(v,'"asl":','"ns":');
			ret:=agenda.get_elab_ns_piani(v::json,idtransazione);
		when 'get_attivita_fatturabili' then
			ret:=trf.get_attivita_fatturabili(v::json,idtransazione);
		when 'get_elab_cal_params' then
			ret:=agenda.get_elab_params(v::json,idtransazione);
		when 'get_tariffa_voci' then
			ret:=trf.get_tariffa_voci(v::json,idtransazione);
		when 'get_tariffa' then
			ret:=trf.get_tariffa(v::json,idtransazione);
		when 'get_trf_att_inviate' then
			ret:=trf.get_trf_att_inviate(v::json,idtransazione);
		when 'get_trf_att_inviate_ultimo_stato' then
			ret:=trf.get_trf_att_inviate_ultimo_stato(v::json,idtransazione);
		when 'get_trf_att_inviate_stati' then
			ret:=trf.get_trf_att_inviate_stati(v::json,idtransazione);
		when 'get_elab_az_sedi' then
			ret:=agenda.get_elab_az_sedi(v::json,idtransazione);
		when 'get_elab_linee' then
			ret:=agenda.get_elab_linee(v::json,idtransazione);
		when 'get_nominativi_calendario' then
			ret:=agenda.get_nominativi_calendario(v::json,idtransazione);
		when 'get_ag_conf' then
			ret:=ag_conf.get_ag_conf(v::json,idtransazione);
		when 'get_monitoraggio_flusso_import' then
			ret:=conf_ext.get_monitoraggio_flusso_import(v::json,idtransazione);
		when 'get_aziende' then
			ret:=agenda.get_aziende(v::json,idtransazione);	
		when 'get_azienda_persone' then
			ret:=agenda.get_azienda_persone(v::json,idtransazione);	
		when 'get_azienda_indirizzi' then
			ret:=agenda.get_azienda_indirizzi(v::json,idtransazione);
		when 'get_aziende_by_sel' then
			ret:=agenda.get_aziende_by_sel(v::json,idtransazione);	
		when 'get_dettaglio_scarto_aziende' then
			ret:=conf_ext.get_dettaglio_scarto_aziende(v::json,idtransazione);	
		when 'get_dettaglio_scarto_persone' then
			ret:=conf_ext.get_dettaglio_scarto_persone(v::json,idtransazione);		
		when 'get_dettaglio_scarto_persone' then
			ret:=conf_ext.get_dettaglio_scarto_persone(v::json,idtransazione);	
		when 'get_formato_import' then
			ret:=agenda.get_formato_import(v::json,idtransazione);
	    when 'get_import_formato_linea' then
			ret:=agenda.get_import_formato_linea(v::json,idtransazione);
		when 'get_import_formato_sicer' then
			ret:=agenda.get_import_formato_sicer(v::json,idtransazione);
		when 'get_import_formato_profilassi' then
			ret:=agenda.get_import_formato_profilassi(v::json,idtransazione);
		when 'get_tipo_liste' then
			ret:=agenda.get_tipo_liste(v::json,idtransazione);	
      when 'get_tipologia_controllo_piani' then
			ret:=agenda.get_tipologia_controllo_piani(v::json,idtransazione);
		when 'get_tipolista_piani' then
			ret:=agenda.get_tipolista_piani(v::json,idtransazione);	
		when 'get_dettaglio_lista' then
			ret:=agenda.get_dettaglio_lista(v::json,idtransazione);	
		when 'get_lista_calendari' then
			ret:=agenda.get_lista_calendari(v::json,idtransazione);
		when 'get_comuni_associati' then
			ret:=conf_ext.get_comuni_associati(v::json,idtransazione);
		when 'get_codici_nascita' then
			ret:=conf_ext.get_codici_nascita(v::json,idtransazione);
		when 'get_nazioni' then
			ret:=cu_anag.get_nazioni(v::json,idtransazione);
		when 'get_toponimi' then
			ret:=conf_ext.get_toponimi(v::json,idtransazione);
		when 'get_comuni' then
			ret:=conf_ext.get_comuni(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"calendari":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_indirizzi_per_comune' then
			ret:=conf_ext.get_indirizzi_per_comune(v::json,idtransazione);
		when 'get_uoc' then
			ret:=agenda.get_uoc(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"uoc":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_uos' then
		ret:=agenda.get_uos(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"uos":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_uoc_piani' then
			ret:=agenda.get_uoc_piani(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"uoc_piani":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_uos_comuni' then
			ret:=agenda.get_uos_comuni(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"uos_comuni":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_linee_piano' then
			ret:=agenda.get_linee_piano(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"linee_piano":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_nominativi_comuni' then
					ret:=agenda.get_nominativi_comuni(v::json,idtransazione);
		when 'get_ns_comuni' then
			ret:=agenda.get_nominativi_comuni(v::json,idtransazione);
		when 'get_nominativi_uos' then
			ret:=agenda.get_nominativi_uos(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"nominativi_uos":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_nominativi_uos_selezionabile' then
			ret:=agenda.get_nominativi_uos_selezionabile(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"nominativi_uos_selezionabili":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_ns_piani' then
			ret:=agenda.get_ns_piani(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"ns_piani":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_ns' then
			ret:=agenda.get_ns(v::json,idtransazione);
		when 'get_piani_by_ns' then
			ret:=agenda.get_piani_by_ns(v::json,idtransazione);
		when 'get_linee_by_ns_piano' then
			ret:=agenda.get_linee_by_ns_piano(v::json,idtransazione);
			raise notice 'RET=%',ret;
		when 'genera_calendario_prova' then
			ret:=agenda.genera_calendario_prova(-1,idtransazione);
			if ret.esito then
				ret.info:='{"eventi":' || ret.info::json;
				ret.info:=ret.info || '}';
			raise notice 'ret.info %',ret.info;
		end if;
		when 'genera_calendario_prova' then
		ret:=agenda.genera_calendario_prova(-1,idtransazione);
		if ret.esito then
			ret.info:='{"eventi":' || ret.info::json;
			ret.info:=ret.info || '}';
			raise notice 'ret.info %',ret.info;
		end if;
		when 'get_fattura' then
			ret:=trf.get_fattura(v,idtransazione);
			if ret.esito then
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_linee_calendario' then
		ret:=agenda.get_linee_calendario(v::json,idtransazione);
		if ret.esito then
			raise notice 'ret.info %',ret.info;
		end if;
		when 'get_lnominativi_calendario' then
		ret:=agenda.get_nominativi_calendario(v::json,idtransazione);
		if ret.esito then
			raise notice 'ret.info %',ret.info;
		end if;	
		when 'get_calendario' then
		ret:=agenda.get_calendario(v::json,idtransazione);
		if ret.esito then
			raise notice 'ret.info %',ret.info;
		end if;	
		when 'get_calendario_info' then
		ret:=agenda.get_calendario_info(v::json,idtransazione);
		if ret.esito then
			raise notice 'ret.info %',ret.info;
		end if;	
		when 'get_ag_tipo_eventi' then
		ret:=agenda.get_ag_tipo_eventi(v::json,idtransazione);
		if ret.esito then
			raise notice 'ret.info %',ret.info;
		end if;		
		when 'get_elab_cal' then
		ret:=agenda.get_elab_cal(v,idtransazione);
		if ret.esito then
			raise notice 'ret.info %',ret.info;
		end if;	

		when 'get_cal_riepilogo_linee' then
		raise notice 'GET V=%',v;
		ret:=agenda.get_cal_riepilogo_linee(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"linee":{"colonne":[{"name":"UOC","type":"text","field":"asl_c"},{"name":"UOS","type":"text","field":"asl_d"},
{"name":"Piano","type":"text","field":"piano_d"},{"name":"Target","type":"number","field":"target"},{"name":"n. linee","type":"number","field":"cnt"},
{"name":"n. att","type":"number","field":"a_cnt"}],"dati":' || ret.info::json;
			ret.info:=ret.info || '}}';
			raise notice 'ret.info %',ret.info;
		end if;
		when 'get_cal_riepilogo' then
		ret:=agenda.get_cal_riepilogo_uos(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"uos":{"colonne":[{"name":"UOS","type":"text","field":"descrizione_breve"},{"name":"Pianificati","type":"number","field":"pianificati"},{"name":"Programmati","type":"number","field":"programmati"}],"tipo_colonne":["text","number","number"],"dati":' || ret.info::json;
			ret.info:=ret.info || '},';
			raise notice 'ret.info %',ret.info;
		end if;
		ret_2:=agenda.get_cal_riepilogo_risorse(v::json ,idtransazione);
		if ret_2.esito then
			ret.info:=ret.info||'"risorse":{"colonne":[{"name":"Ispettore","type":"text","field":"nominativo"},{"name":"Pianificati","type":"number","field":"pianificati"},{"name":"Programmati","type":"number","field":"programmati"}],"tipo_colonne":["text","number","number"],"dati":' || ret_2.info::json;
			ret.info:=ret.info || '},';
			raise notice 'ret.info %',ret.info;
		end if;
		when 'get_cal_riepiloghi' then
			ret:=agenda.get_cal_riepiloghi(v::json,idtransazione);
		
		when 'get_tariffario' then
		ret:=trf.get_tariffario(v::json,idtransazione);
		if ret.esito then
			if (j_user_info->>'livello')::integer =0 then
				ret.info:='{"modificabile":true,"tariffario":' || ret.info::json|| '}';
			else
				ret.info:='{"modificabile":false,"tariffario":' || ret.info::json|| '}';
			end if;
			--ret.info:=ret.info||'"tariffario":' || ret.info::json;
			--ret.info:=ret.info || '}';
			raise notice 'ret.info %',ret.info;
		end if;
		when 'get_tariffe_export' then
			ret:=trf.get_tariffario_export(v::json, idtransazione);
		/*
		ret:=trf.get_tariffario(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"tariffe":' || ret.info::json;
			ret.info:=ret.info || '}';
			raise notice 'ret.info %',ret.info;
		end if;
		*/
		when 'get_fatture' then
		--id_risorsa:=(v::json->>'id')::bigint;
		ret:=trf.get_fatture(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"fatture":' || ret.info;
			ret.info:=ret.info || '}';
		
			raise notice 'ret.info %',ret.info;
		end if;
		when 'get_trf_ft_periodiche' then
		--id_risorsa:=(v::json->>'id')::bigint;
		ret:=trf.get_fatture_periodiche(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"fatture_periodiche":' || ret.info;
			ret.info:=ret.info || '}';
		
			raise notice 'ret.info %',ret.info;
		end if;
		when 'get_attivita' then
		--id_risorsa:=(v::json->>'id')::bigint;
		ret:=trf.get_attivita(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"attivita":' || ret.info;
			ret.info:=ret.info || '}';
		
			raise notice 'ret.info %',ret.info;
		end if;
	when 'get_attivita_by_sel' then
		ret:=trf.get_attivita_by_sel(v::json,idtransazione);
	when 'get_trf_att_inviate_by_sel' then
		ret:=trf.get_trf_att_inviate_by_sel(v::json,idtransazione);
	when 'get_rilevazione_attivita' then
		--id_risorsa:=(v::json->>'id')::bigint;
		--ret:=trf.get_attivita(idtransazione);
		--if ret.esito then
		ret:= trf.get_rilevazione_attivita(v,idtransazione);
		raise notice 'ret.info %',ret.info;

	--when 'get_calendari' then
	when 'get_agende' then
		--id_risorsa:=(v::json->>'id')::bigint;
		ret:=agenda.get_agende(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"calendari":' || ret.info;
			ret.info:=ret.info || '}';
		
			raise notice 'ret.info %',ret.info;
		end if;
	when 'get_att_dati_da_inviare' then
			ret:= agenda.get_att_dati_da_inviare(v::json,idtransazione);
			raise notice 'ret.info %',ret.info;
	when 'get_eventi_struttura' then
			ret:= agenda.get_eventi_struttura(v::json,idtransazione);
			raise notice 'ret.info %',ret.info;
	when 'get_linee' then
			ret:= agenda.get_linee(v::json,idtransazione);
	when 'get_veterinari_carico' then
			ret:= agenda.get_veterinari_carico(v::json,idtransazione);
			raise notice 'ret.info %',ret.info;
	when 'get_fatt_forf_riep' then
			ret:= trf.get_fatt_forf_riep(v::json,idtransazione);
			raise notice 'ret.info %',ret.info;	
	when 'get_att_forf_riep' then
			ret:= trf.get_att_forf_riep(v::json,idtransazione);
			raise notice 'ret.info %',ret.info;	
	when 'get_attivita_forfet' then
			ret:= trf.get_attivita_forfet(v::json,idtransazione);
			raise notice 'ret.info %',ret.info;
	when 'get_stati_forfet' then
			ret:= trf.get_stati_forfet(v::json,idtransazione);
			raise notice 'ret.info %',ret.info;
	when 'get_cf_liste' then
			ret:=agenda.get_cf_liste(v::json,idtransazione);
	when 'get_stato_eventi' then
			ret:=agenda.get_stato_eventi(v::json,idtransazione);		
	when 'get_cf_allevamenti' then
			ret:=agenda.get_cf_allevamenti(v::json,idtransazione);
	when 'get_az_sedi' then
			ret:=agenda.get_az_sedi(v::json,idtransazione);
	when 'get_ag_conf' then
			ret:=agenda.get_ag_conf(v::json,idtransazione);	
	when 'get_manuali' then
			ret:=ag_conf.get_manuali(v::json,idtransazione);				
	when 'get_nominativi_uos_by_asl' then
			ret:=agenda.get_nominativi_uos_by_asl(v::json,idtransazione);	
		
	when 'get_eventi' then
		v_j:=v::json;
		id_risorsa:=((v_j->>'id')::varchar)::int8;

		raise notice 'id_risorsa=%',id_risorsa;
		--ret:=agenda.get_calendario(id_risorsa, idtransazione);
		--if ret.esito then
		idstruttura:=((j_user_info->'id_struttura_root')::varchar)::int8;
		responsabile:=v_j->'user_info'->'responsabile';
		--idutente:=((v_j->'user_info')->'id_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		n:=0;
		if responsabile then
			select count(*) into n from
			(select distinct id_anagrafica from matrix.vw_nominativi_struttura where id_node_struttura
				in (select id_node from matrix.vw_tree_nodes_down_asl where id_node_ref =idstruttura ) and id_anagrafica=id_risorsa) x;
		end if;
		--n:=1;
		if (id_risorsa=(select id_utente from rbac.vw_utente_strutture_ruoli where id_utente_struttura_ruolo = idutente)) or n> 0 then
			ret_eventi:=agenda.get_eventi(id_risorsa, idtransazione);
		
			raise notice 'RET_EVENTI %',ret_eventi;
			--ret.info:='{"calendario":' || left(ret.info,length(ret.info)-1);
			
					
			if ret_eventi.esito then 
				ret.info:= '{"calendario":{"eventi":'||ret_eventi.info||'}';
			else
				ret.info:= '{"calendario":{"eventi":[]}';
			end if;
			raise notice 'JSON %',('{"id":'||id_risorsa||',"get_info":true}');
			ret_eventi:=agenda.get_agende (('{"id":'||id_risorsa||',"get_info":true}')::json ,idtransazione);
			ret.info:=ret.info||coalesce(',"valori":'||ret_eventi.info,'')||'}';
			--ret.info:=ret.info || '}}';
			ret.esito := true;
		else
			ret.esito:=false;
		end if;
		
			raise notice 'ret.info %',ret.info;
		--end if;
	when 'get_scontrino_xml' then
		ret:=trf.get_scontrino_xml(v::json, idtransazione);
	when 'get_nominativi_carico' then
		ret:=agenda.get_nominativi_carico(v::json,idtransazione);
	when 'get_unita_di_crisi_asu_gi' then
		ret:=agenda.get_unita_di_crisi_asu_gi(v::json,idtransazione);
	when 'get_unita_di_crisi_asu_fc' then
		ret:=agenda.get_unita_di_crisi_asu_fc(v::json,idtransazione);
	when 'get_unita_di_crisi_as_fo' then
		ret:=agenda.get_unita_di_crisi_as_fo(v::json,idtransazione);
	when 'get_unita_di_crisi_fvg' then
		ret:=agenda.get_unita_di_crisi_fvg(v::json,idtransazione);
	when 'get_unita_di_crisi_singolo' then
		ret:=agenda.get_unita_di_crisi_singolo(v::json,idtransazione);
	when 'get_unita_di_crisi' then
		ret:=agenda.get_unita_di_crisi(v::json,idtransazione);
	when 'get_strutture_asl' then
		ret:=agenda.get_strutture_asl(v::json,idtransazione);
	when 'get_strutture_asl_singolo' then
		ret:=agenda.get_strutture_asl_singolo(v::json,idtransazione);
	when 'get_risorse' then
		ret:=agenda.get_risorse(v::json,idtransazione);
	when 'get_risorsa_singolo' then
		ret:=agenda.get_risorsa_singolo(v::json,idtransazione);
	when 'get_cf_da_bonificare' then
		ret:=conf_ext.get_cf_da_bonificare(v::json,idtransazione);
	when 'get_piva_da_bonificare' then
		ret:=conf_ext.get_piva_da_bonificare(v::json,idtransazione);
	when 'get_avvisi' then
		ret:=agenda.get_avvisi(v::json,idtransazione);
	when 'get_tipi_avviso' then
		ret:=agenda.get_tipi_avviso(v::json,idtransazione);
	when 'get_livelli_avviso' then
		ret:=agenda.get_livelli_avviso(v::json,idtransazione);
	when 'get_nominativi_avvisi' then
		ret:=agenda.get_nominativi_avvisi(v::json,idtransazione);
	when 'get_avviso_singolo' then
		ret:=agenda.get_avviso_singolo(v::json,idtransazione);
	when 'get_avvisi_for_risorsa' then
		ret:=agenda.get_avvisi_for_risorsa(v::json,idtransazione);
 	else
 			ret.esito := false;
 			ret.info  := 'CASO NON PREVISTO';
 			raise notice 'ELSE CASE';
	end case;

	RAISE notice 'agenda.get_dati ret.esito: %', ret.esito;
	   
	if ret.esito=false then 
		RAISE notice 'agenda.get_dati if su ret.esito=false';
		fallito=true;
		RAISE notice 'agenda.get_dati ROLLBACK a seguito di ret.esito=false';
	end if;
raise notice 'ID_NS %',j_user_info->'id_struttura_root';
	str_conf:= ag_ui.get_ui_definition(''::varchar,'agenda.'||operazione,((j_user_info->'id_struttura_root')::varchar)::int8,idtransazione);
raise notice 'OPERAZIONE % STR_CONF=%',operazione,str_conf;
raise notice 'j_user_info=%',j_user_info;
	if str_conf is not null and str_conf != '' then
	 	 ret.info:='{'||str_conf||','||right(ret.info,length(ret.info)-1);
	end if;

	exception when others then
		fallito:=true;
		RAISE notice 'agenda.get_dati ROLLBACK a seguito di exception';
		GET STACKED DIAGNOSTICS text_msg1 = MESSAGE_TEXT,
		                  			text_msg2 = PG_EXCEPTION_DETAIL,
		                  			text_msg3 = PG_EXCEPTION_HINT,
		                 			text_msg4 = PG_EXCEPTION_CONTEXT;
		ret.esito:=false;
		ret.valore:= null;
	if replace(upper(j_user_info->>'ambiente'),'"','') ='local' then
		ret.err_msg:=coalesce(ret.err_msg,'')||coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');
	else
		ret.err_msg:=coalesce(ret.err_msg,'')||coalesce(text_msg1,'');
	end if;
   end;
  
  	/* AF 20240212
  	 * if fallito=true then 
		rollback;
	end if;*/

	joutput:=row_to_json(ret);
	id_op:=ag_log.op(proc_name,idtransazione,v,null,ts,-1,operazione);
--commit;
end;
$$;


ALTER PROCEDURE agenda.get_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json) OWNER TO postgres;

--
-- Name: get_dettaglio_lista(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_dettaglio_lista(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
	j_user_info json;
	idtipolista bigint;
	formato varchar;
	begin
		proc_name:='agenda.get_dettaglio_lista';
		j_user_info:=v->'user_info';
		idtipolista=(v->>'id_tipo_lista') ;
		formato=(v->>'formato') ;
		raise notice 'function: %', proc_name;
 
	/*    if(formato='1')then
		select json_agg(row_to_json(a.*)) into rt from (
	 
	
		  select imp.*, coalesce (imp_det.totali,0)totali,coalesce (imp_det.non_associati,0)non_associati,
		  coalesce (imp_det.associati,0) associati from 
		  agenda.vw_lista_import imp 
		  left join (
		    SELECT COUNT(1) AS totali,	
		         COUNT(1) FILTER (WHERE cf.id_linea is null) AS non_associati,
		         COUNT(1) FILTER (WHERE cf.id_linea is not null) AS associati,
		         id_tipo_lista,i.id_lista  
		    from agenda.vw_lista_import i  
		    inner  join  agenda.cf_allevamenti cf  on i.id=cf.id_lista 
   		  --  inner  join  agenda.import_linea cf  on i.id=cf.id_lista 
 			group by i.id_lista,id_tipo_lista,anno) 
  			imp_det on imp_det.id_tipo_lista=imp.id_tipo_lista and imp.id_lista =imp_det.id_lista
  			  where imp.id_tipo_lista=idtipolista
  			order by anno desc
		) a;
	 else 
	  select json_agg(row_to_json(a.*)) into rt from (


	
		  select imp.*, coalesce (imp_det.totali,0)totali,coalesce (imp_det.non_associati,0)non_associati,
		  coalesce (imp_det.associati,0) associati from 
		  agenda.vw_lista_import imp 
		  left join (
		    SELECT COUNT(1) AS totali,	
		         COUNT(1) FILTER (WHERE l.id_linea is null) AS non_associati,
		         COUNT(1) FILTER (WHERE l.id_linea is not null) AS associati,
		         id_tipo_lista,i.id_lista  
		  from agenda.vw_lista_import i  
		  inner  join  agenda.import_linea l  on i.id=l.id_lista 


 			 group by i.id_lista,id_tipo_lista,anno) 
  			imp_det on imp_det.id_tipo_lista=imp.id_tipo_lista and imp.id_lista =imp_det.id_lista
  			  where imp.id_tipo_lista=idtipolista
  			order by anno desc
		) a;
	end if; */
		  select json_agg(row_to_json(a.*)) into rt from (


	
		  select imp.*, coalesce (imp_det.totali,0)totali,coalesce (imp_det.non_associati,0)non_associati,
		  coalesce (imp_det.associati,0) associati from 
		  agenda.vw_lista_import imp 
		  left join (
		    SELECT COUNT(1) AS totali,	
		         COUNT(1) FILTER (WHERE l.id_linea is null) AS non_associati,
		         COUNT(1) FILTER (WHERE l.id_linea is not null) AS associati,
		         id_tipo_lista,i.id_lista  
		  from agenda.vw_lista_import i  
		  inner  join  agenda.import_linea l  on i.id=l.id_lista 


 			 group by i.id_lista,id_tipo_lista,anno) 
  			imp_det on imp_det.id_tipo_lista=imp.id_tipo_lista and imp.id_lista =imp_det.id_lista
  			  where imp.id_tipo_lista=idtipolista
  			order by anno desc
		) a;
	  
	
		raise notice '%',json_array_length(rt);

		if rt is null then
			ret.esito:=false;	
    	    ret:=ag_ui.build_ret(ret,proc_name, 'nessuna_lista_ancora_presente');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null; 		 		
 			ret.info:='{"dati":' || rt;
			ret.info:=ret.info || '}';

		end if;
		
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_dettaglio_lista(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_elab_asl_piani(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_elab_asl_piani(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	idelabcal bigint;
	rt json;

	begin
		proc_name:='agenda.get_uoc';
		
		idstrutturaasl=v->'user_info'->'id_struttura_root';
		idelabcal:=v->>'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v->>'id_gen_cal';
		end if;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
		--select json_agg(row_to_json(c.*)) into rt  from matrix.vw_tree_nodes_asl_descr c where  id_node_parent =idstrutturaasl;
	
	    select json_agg(row_to_json(a.*)) into rt  from (
	   			select id_node,case when id_node=idstrutturaasl then null else id_node_parent end id_node_parent,descrizione,descrizione_breve,pa.id is not null as selezionato from
					matrix.vw_tree_nodes_up_asl a left join agenda.elab_cal_param_asl pa on a.id=pa.id_asl and pa.id_elab_cal =idelabcal
					where id_node in (select id_node from matrix.vw_tree_nodes_down_asl_descr where id_node_ref=idstrutturaasl) order by descrizione_breve) a;
		ret.info:= '{"asl":'||rt::varchar;
		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		select json_agg(row_to_json(x.*)) into rt from (select vp.id_node,vp.id_node_parent,descrizione_breve,c.selezionato from matrix.vw_tree_nodes_up_piani vp join
			(select distinct p.id_node_ref,ep.id_piano is not null selezionato from  matrix.vw_tree_nodes_down_piani_descr p 
				left join agenda.elab_cal_param_piani ep on ep.id_piano =p.id_node_ref and ep.id_elab_cal =idelabcal
				 join 
				(select distinct id_piano as id_uoc_piano from agenda.asl_piani ap join matrix.vw_tree_nodes_down tn on ap.id_struttura=tn.id_node
				where tn.id_node_ref=idstrutturaasl) a
				on a.id_uoc_piano =p.id_node where anno=(select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int--(select max(anno) from matrix.tree_anno) 
			) c on vp.id_node=c.id_node_ref) x;
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		ret.msg:='strutture piani non trovate';
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
 			ret.info:= ret.info||',"piani":'||rt::varchar||'}';
	 		--ret.info:=rt;
		end if;
	

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_elab_asl_piani(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_elab_az_sedi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_elab_az_sedi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EC agenda.vw_elab_cals;
	idelabcal bigint;
	--anno_elab integer;
	rt json;

	begin
		proc_name:='agenda.get_elab_linee';
		raise notice 'v=%',v;
		idelabcal:=v->'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v->>'id_gen_cal';
		end if;
		raise notice 'idelabcal=%',idelabcal;
		R_EC.id:=idelabcal;
		select * into R_EC from agenda.vw_elab_cals ec where id =R_EC.id;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (

		select  l.id_az_sede as id, l.id_az_sede,l.denominazione_sede_operativa ,l.indirizzo ,
						l.comune , descrizione_breve,l.id_piano ,
						ls.id is not null selezionata from (
		select  distinct l.id_az_sede,np.id_piano,l.denominazione_sede_operativa ,l.indirizzo ,
		l.comune, sp.alias || ' - ' || sp.descrizione  descrizione_breve 
		from
			matrix.nominativi_struttura ns
			join  agenda.elab_cal_param_ns a on ns.id =a.id_ns and a.id_elab_cal=idelabcal
			join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			join  agenda.elab_cal_param_piani p on np.id_piano=p.id_piano and p.id_elab_cal=idelabcal
			join matrix.vw_struttura_piani sp on sp.id=p.id_piano
			join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
			join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune  
			left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=1
			left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno
			where  coalesce(assegnate,0)<coalesce(pf.freq,1) and (not sp.flag_cf or 
				(sp.flag_cf and l.id_linea in (select id_linea from agenda.vw_cf_allevamenti vca where anno=R_EC.anno) ))									
			) l
			left join agenda.az_sedi_selezionate ls on ls.id_az_sede=l.id_az_sede and ls.id_piano =l.id_piano and ls.id_elab_cal =idelabcal
	
		) g;

		raise notice '%',json_array_length(rt);
		ret.esito:=true;	
		if json_array_length(rt) is null then
    		--ret.msg:='linee per calendario non trovate per le impostazioni attuali';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'stabilimenti_per_calendario_non_trovati_per_le_impostazioni_attuali');
    		ret.info:=null; 
    	else
 			ret.msg:=null;
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_elab_az_sedi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_elab_cal(bigint, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_elab_cal(id_record bigint, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idelabcal bigint;
	proc_name varchar;
	R_CAL agenda.vw_calendari%ROWTYPE;
	R_EC agenda.vw_elab_cals%ROWTYPE;
	REC Record;
	rt json;

	begin
		proc_name:='agenda.get_elab_cal';
	
		--idelabcal:=v->'id_elab_cal';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		/*select row_to_json(c.*) into rt from agenda.vw_elab_cals c
		where id_elab_cal=idelabcal;*/
	
	select json_agg(row_to_json(a.*)) into rt from
		(select  row_to_json(c.*) cal,
			(select json_agg(row_to_json(ec.*)) elabs from agenda.vw_elab_cals ec where id_calendario = c.id  )  
			from agenda.vw_calendari c) a ;

		raise notice '%',rt;
	
		if rt is null then
			ret.esito:=false;	
    		--ret.msg:='calendari non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'calendari_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	

	 	return ret;

	end;
end;
$$;


ALTER FUNCTION agenda.get_elab_cal(id_record bigint, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_elab_linee(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_elab_linee(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EC agenda.vw_elab_cals;
	idelabcal bigint;
	--anno_elab integer;
	rt json;
	j_piani json;
	j_ns json;
	v_piani varchar;
	v_ns varchar;
	v_data varchar;

	begin
		proc_name:='agenda.get_elab_linee';
		raise notice 'v=%',v;
		idelabcal:=v->'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v->>'id_gen_cal';
		end if;
		raise notice 'idelabcal=%',idelabcal;
		R_EC.id:=idelabcal;
		select * into R_EC from agenda.vw_elab_cals ec where id =R_EC.id;

		select replace(replace(array_agg(id_piano)::varchar,'{','['),'}',']') into v_piani from agenda.elab_cal_param_piani 
		where id_elab_cal=R_EC.id;
			
		select replace(replace(array_agg(id_ns)::varchar,'{','['),'}',']')  into v_ns from agenda.elab_cal_param_ns 
		where id_elab_cal=R_EC.id;
	
		select trim(value)  into v_data from agenda.elab_cal_params
		where id_elab_cal=R_EC.id  and type_param='non_visitati_dal';
		if v_data='' then v_data = null; end if;
	
		raise notice 'PIANI % NS %',j_piani,j_ns;
	
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (			
						
	
		select  l.id_linea as id, l.id_linea,l.denominazione_sede_operativa ,l.indirizzo_completo ,l.piva , descrizione_breve,l.id_piano, 
		l.cod_tipo_linea ,ls_id is not null as selezionata, l.sd_cod_regionale
		from (

		
		select  /*distinct AF 20240928 performance */ l.id_linea,np.id_piano,l.denominazione_sede_operativa ,--l.indirizzo ,l.comune, 
		sp.alias || ' - ' || sp.descrizione  descrizione_breve , l.cod_tipo_linea,l.piva,l.indirizzo_completo,
		l.sd_cod_regionale,ls.id ls_id --ISSUE #11570
		from
		--select distinct l.id_linea from 
			matrix.nominativi_struttura ns
			join (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
			join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			join (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
			join matrix.vw_struttura_piani sp on sp.id=p.id_piano
			join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
			join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune
			and ( linea_principale or l.fonte ilike '%853%' or l.desc_tipo_linea ilike '%svet%'
				or l.cod_tipologia_struttura in ('BDN', 'ALL'))
				left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
			left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
			left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
			left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea
			left join agenda.linee_selezionate ls on ls.id_linea=l.id and R_EC.id=ls.id_elab_cal
			where  coalesce(assegnate,0)<coalesce(pf.freq,1)
				and	 (tlp.id_piano is null or (tlp.id_piano is not null and lp.id_linea is not null))
				and ( (l.data_ultima_visita <=v_data::date or v_data is null) or l.data_ultima_visita is null or coalesce(pf.freq,1)>=1)
				and l.id not in (select id_linea from agenda.nominativo_linee nl)
		union
		select  distinct l.id_linea,np.id_piano,l.denominazione_sede_operativa ,--l.indirizzo ,l.comune, 
		sp.alias || ' - ' || sp.descrizione  descrizione_breve , l.cod_tipo_linea,l.piva,l.indirizzo_completo,
		l.sd_cod_regionale,ls.id --ISSUE #11570 
		from
		--select distinct l.id_linea from 
			matrix.nominativi_struttura ns
			join (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
			join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			join (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
			join matrix.vw_struttura_piani sp on sp.id=p.id_piano
			join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
			join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune
			join agenda.nominativo_linee nl on nl.id_linea=l.id and 	a.id_ns=nl.id_nominativo_struttura 	
			and ( linea_principale or l.fonte ilike '%853%' or l.desc_tipo_linea ilike '%svet%'
				or l.cod_tipologia_struttura in ('BDN', 'ALL')) 
			left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
			left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
			left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
			left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea
			left join agenda.linee_selezionate ls on ls.id_linea=l.id and R_EC.id=ls.id_elab_cal
			where  coalesce(assegnate,0)<coalesce(pf.freq,1)
				and	 (tlp.id_piano is null or (tlp.id_piano is not null and lp.id_linea is not null))
				and ( (l.data_ultima_visita <=v_data::date or v_data is null) or l.data_ultima_visita is null or coalesce(pf.freq,1)>=1)
							
					) l
		) g;

		raise notice '%',json_array_length(rt);
		ret.esito:=true;	
		if json_array_length(rt) is null then
    		--ret.msg:='linee per calendario non trovate per le impostazioni attuali';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'linee_per_calendario_non_trovate_per_le_impostazioni_attuali');
    		ret.info:=null; 
    	else
 			ret.msg:=null;
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_elab_linee(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_elab_linee_check(bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_elab_linee_check(idelabcal bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare

	id_op bigint;   
	proc_name varchar;
	R_EC agenda.vw_elab_cals;

	--anno_elab integer;
	rt json;
	j_piani json;
	j_ns json;
	v_piani varchar;
	v_ns varchar;
	v_data varchar;
	str varchar;

	begin
		raise notice 'idelabcal=%',idelabcal;
		R_EC.id:=idelabcal;
		select * into R_EC from agenda.vw_elab_cals ec where id =R_EC.id;

		select replace(replace(array_agg(id_piano)::varchar,'{','['),'}',']') into v_piani from agenda.elab_cal_param_piani 
		where id_elab_cal=R_EC.id;
			
		select replace(replace(array_agg(id_ns)::varchar,'{','['),'}',']')  into v_ns from agenda.elab_cal_param_ns 
		where id_elab_cal=R_EC.id;
	
		select trim(value)  into v_data from agenda.elab_cal_params
		where id_elab_cal=R_EC.id  and type_param='non_visitati_dal';
		if v_data='' then v_data = null; end if;
	

select string_agg(rpad(descr,25,' ')||coalesce(lpad(cnt::varchar,10,' '),''),'
') into str from 	(
select 1 id,'nominativi' descr,count(*) cnt from matrix.nominativi_struttura ns
		                                                        join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
union   select 2,'comuni',count(*)  from matrix.nominativi_struttura ns			
																join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
																join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
union   select 3,'piani',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
union   select 4,' struttura',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
union   select 5,'tipo linea',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano

union   select 6,'linee',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 

			

union   select 8,'left',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea
			
			
union select 9,'assegnate < frequenza',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea			
																where  coalesce(assegnate,0)<coalesce(pf.freq,1)
union select 10,'liste-precaricate',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea			
																where  coalesce(assegnate,0)<coalesce(pf.freq,1)						
																	and	 (tlp.id_piano is null or (tlp.id_piano is not null and lp.id_linea is not null))
						
						
union select 11,'data ultima visita',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea			
																where  coalesce(assegnate,0)<coalesce(pf.freq,1)						
																	and	 (tlp.id_piano is null or (tlp.id_piano is not null and lp.id_linea is not null))						
																	and ( (l.data_ultima_visita <=v_data::date or v_data is null) or l.data_ultima_visita is null or coalesce(pf.freq,1)>=1)						
union select 12,'linee non associate',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea			
																where  coalesce(assegnate,0)<coalesce(pf.freq,1)						
																	and	 (tlp.id_piano is null or (tlp.id_piano is not null and lp.id_linea is not null))						
																	and ( (l.data_ultima_visita <=v_data::date or v_data is null) or l.data_ultima_visita is null or coalesce(pf.freq,1)>=1)
																	and l.id not in (select id_linea from agenda.nominativo_linee nl)
union select 100,'-----------------------------------',null

union		select 101,'nominativi',count(*)  from matrix.nominativi_struttura ns
		                                                        join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
union   select 102,'comuni',count(*)  from matrix.nominativi_struttura ns			
																join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
																join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
union   select 103,'piani',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
union   select 104,' struttura',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
union   select 105,'tipo linea',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano

union   select 106,'linee',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 

union   select 107,'nominativi-linee',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																join agenda.nominativo_linee nl on nl.id_linea=l.id and 	a.id_ns=nl.id_nominativo_struttura 	
			

union   select 108,'left',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																join agenda.nominativo_linee nl on nl.id_linea=l.id and 	a.id_ns=nl.id_nominativo_struttura 	
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea
			
			
union select 109,'assegnate < frequenza',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																join agenda.nominativo_linee nl on nl.id_linea=l.id and 	a.id_ns=nl.id_nominativo_struttura 	
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea			
																where  coalesce(assegnate,0)<coalesce(pf.freq,1)
union select 110,'liste associate',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																join agenda.nominativo_linee nl on nl.id_linea=l.id and 	a.id_ns=nl.id_nominativo_struttura 	
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea			
																where  coalesce(assegnate,0)<coalesce(pf.freq,1)						
																	and	 (tlp.id_piano is null or (tlp.id_piano is not null and lp.id_linea is not null))
						
						
union select 111,'data ultima visita',count(*)  from matrix.nominativi_struttura ns			
                                                                join (select id_ns from agenda.elab_cal_param_ns where id_elab_cal=idelabcal) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select id_piano from agenda.elab_cal_param_piani ecpp where id_elab_cal=idelabcal)  p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																join agenda.nominativo_linee nl on nl.id_linea=l.id and 	a.id_ns=nl.id_nominativo_struttura 	
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea			
																where  coalesce(assegnate,0)<coalesce(pf.freq,1)						
																	and	 (tlp.id_piano is null or (tlp.id_piano is not null and lp.id_linea is not null))						
																	and ( (l.data_ultima_visita <=v_data::date or v_data is null) or l.data_ultima_visita is null or coalesce(pf.freq,1)>=1)
order by 1
) a;
	
	 	return str;
	end;
end;
$$;


ALTER FUNCTION agenda.get_elab_linee_check(idelabcal bigint) OWNER TO postgres;

--
-- Name: get_elab_linee_check_fast(bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_elab_linee_check_fast(idelabcal bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare

	id_op bigint;   
	proc_name varchar;
	R_EC agenda.vw_elab_cals;

	--anno_elab integer;
	rt json;
	j_piani json;
	j_ns json;
	v_piani varchar;
	v_ns varchar;
	v_data varchar;
	str varchar;
R record;

	begin
		raise notice 'idelabcal=%',idelabcal;
		R_EC.id:=idelabcal;
		select * into R_EC from agenda.vw_elab_cals ec where id =R_EC.id;

		select replace(replace(array_agg(id_piano)::varchar,'{','['),'}',']') into v_piani from agenda.elab_cal_param_piani 
		where id_elab_cal=R_EC.id;
			
		select replace(replace(array_agg(id_ns)::varchar,'{','['),'}',']')  into v_ns from agenda.elab_cal_param_ns 
		where id_elab_cal=R_EC.id;
	
		select trim(value)  into v_data from agenda.elab_cal_params
		where id_elab_cal=R_EC.id  and type_param='non_visitati_dal';
		if v_data='' then v_data = null; end if;
	

--select string_agg(rpad(descr,25,' ')||coalesce(lpad(cnt::varchar,10,' '),''),'
--') into str from 	(
select 1 id,'nominativi' descr,count(*) cnt into R from matrix.nominativi_struttura ns
		                                                        join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns; raise notice 'R=%',R;
   select 2,'comuni',count(*)  into R from matrix.nominativi_struttura ns			
																join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
																join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id ; raise notice 'R=%',R;
   select 3,'piani',count(*)  into R from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano ; raise notice 'R=%',R;
   select 4,' struttura',count(*)  into R from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano ; raise notice 'R=%',R;
   select 5,'tipo linea',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano ; raise notice 'R=%',R;

   select 6,'linee',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) ; raise notice 'R=%',R;

			

   select 8,'left',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea; raise notice 'R=%',R;
			
			
 select 9,'assegnate < frequenza',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a  on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea			
																where  coalesce(assegnate,0)<coalesce(pf.freq,1); raise notice 'R=%',R;
 select 10,'liste-precaricate',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea			
																where  coalesce(assegnate,0)<coalesce(pf.freq,1)						
																	and	 (tlp.id_piano is null or (tlp.id_piano is not null and lp.id_linea is not null)); raise notice 'R=%',R;
						
						
 select 11,'data ultima visita',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea			
																where  coalesce(assegnate,0)<coalesce(pf.freq,1)						
																	and	 (tlp.id_piano is null or (tlp.id_piano is not null and lp.id_linea is not null))						
																	and ( (l.data_ultima_visita <=v_data::date or v_data is null) or l.data_ultima_visita is null or coalesce(pf.freq,1)>=1); raise notice 'R=%',R;						
 select 12,'linee non associate',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea			
																where  coalesce(assegnate,0)<coalesce(pf.freq,1)						
																	and	 (tlp.id_piano is null or (tlp.id_piano is not null and lp.id_linea is not null))						
																	and ( (l.data_ultima_visita <=v_data::date or v_data is null) or l.data_ultima_visita is null or coalesce(pf.freq,1)>=1)
																	and l.id not in (select id_linea from agenda.nominativo_linee nl); raise notice 'R=%',R;
 select 100,'-----------------------------------',null into R ; raise notice 'R=%',R;

		select 101,'nominativi',count(*)  into R  from matrix.nominativi_struttura ns
		                                                        join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns; raise notice 'R=%',R;
   select 102,'comuni',count(*) into R  from matrix.nominativi_struttura ns			
																join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
																join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id ; raise notice 'R=%',R;
   select 103,'piani',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano ; raise notice 'R=%',R;
   select 104,' struttura',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano; raise notice 'R=%',R;
   select 105,'tipo linea',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano; raise notice 'R=%',R;

   select 106,'linee',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) ; raise notice 'R=%',R;

   select 107,'nominativi-linee',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																join agenda.nominativo_linee nl on nl.id_linea=l.id and 	a.id_ns=nl.id_nominativo_struttura 	; raise notice 'R=%',R;
			

   select 108,'left',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																join agenda.nominativo_linee nl on nl.id_linea=l.id and 	a.id_ns=nl.id_nominativo_struttura 	
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea; raise notice 'R=%',R;
			
			
 select 109,'assegnate < frequenza',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																join agenda.nominativo_linee nl on nl.id_linea=l.id and 	a.id_ns=nl.id_nominativo_struttura 	
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea			
																where  coalesce(assegnate,0)<coalesce(pf.freq,1); raise notice 'R=%',R;
 select 110,'liste associate',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																join agenda.nominativo_linee nl on nl.id_linea=l.id and 	a.id_ns=nl.id_nominativo_struttura 	
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea			
																where  coalesce(assegnate,0)<coalesce(pf.freq,1)						
																	and	 (tlp.id_piano is null or (tlp.id_piano is not null and lp.id_linea is not null)); raise notice 'R=%',R;
						
						
 select 111,'data ultima visita',count(*) into R  from matrix.nominativi_struttura ns			
                                                                join  (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements(v_ns::json) a) a on ns.id =a.id_ns
                                                                join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			                                                    join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			                                                    join  (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements (v_piani::json) p) p on np.id_piano=p.id_piano 
																join matrix.vw_struttura_piani sp on sp.id=p.id_piano
																join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
																join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and ( linea_principale or l.fonte='853' or l.desc_tipo_linea ilike '%svet%'				) 
																join agenda.nominativo_linee nl on nl.id_linea=l.id and 	a.id_ns=nl.id_nominativo_struttura 	
																left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=l.categoria_rischio
																left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno		
																left join agenda.tipo_lista_piano tlp on tlp.id_piano=p.id_piano
																left join agenda.vw_liste_precaricate lp on lp.id_piano=p.id_piano and lp.anno=R_EC.anno and lp.id_linea=l.id_linea			
																where  coalesce(assegnate,0)<coalesce(pf.freq,1)						
																	and	 (tlp.id_piano is null or (tlp.id_piano is not null and lp.id_linea is not null))						
																	and ( (l.data_ultima_visita <=v_data::date or v_data is null) or l.data_ultima_visita is null or coalesce(pf.freq,1)>=1); raise notice 'R=%',R;

																return '';
	end;
end;
$$;


ALTER FUNCTION agenda.get_elab_linee_check_fast(idelabcal bigint) OWNER TO postgres;

--
-- Name: get_elab_log(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_elab_log(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	idelabcal bigint;
	R_EC agenda.elab_cals%ROWTYPE;
	rt json;
R record;
RSLEEP record;

	begin
		proc_name:='agenda.get_cal_riepilogo_linee';
	   -- select pg_sleep(5) into R;
		raise notice 'v=%',v;
		idelabcal:=v->'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v->>'id_gen_cal';
		end if;
	
		R_EC.id:=idelabcal;
		if R_EC.id is null then
			ret.esito:=false;
			ret.msg:='parametro id_elab_cal non specificato';
			ret.info:=rt;
			return ret;
		end if;

		select * into R_EC from agenda.elab_cals ec where id =R_EC.id;
 		if R_EC.id is null then
			ret.esito:=false;
			ret.msg:=' id_elab_cal '||R_EC.id||'non trovato';
			ret.info:=rt;
			return ret;
		end if;  
	
	
		raise notice 'idelabcal=%',idelabcal;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (
			select l.*,e.elaborato  from agenda.elab_cal_logs l
			join agenda.vw_elab_cals e on l.id_elab_cal =e.id_elab_cal
			where l.id_elab_cal=R_EC.id order by dt) a;
	   if json_array_length(rt) <=0  or rt is null then
	   	ret.info:='[{"id":-1,"id_elab_cal":'||idelabcal||',"dt":"'||current_timestamp||'","value":"ATTESA START ELABORAZIONE","elaborato":false}]';
	   else
	   	 	ret.info:=rt;
	   end if;
		--ret.valore:= id_record;
	
		raise notice 'LENGTH %',json_array_length(rt);

    	ret.esito:=true;
 		ret.msg:=null;
 	    
		--select pg_sleep(60) into RSLEEP;

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_elab_log(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_elab_ns_piani(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_elab_ns_piani(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	idelabcal bigint;
	rt json;

	begin
		proc_name:='agenda.get_elab_ns_piani';
		
		idstrutturaasl=v->'user_info'->'id_struttura_root';
		idelabcal:=v->>'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v->>'id_gen_cal';
		end if;
				
	    select json_agg(row_to_json(a.*)) into rt  from (
			select null id,id_node*10+1 id_node,case when id_node=idstrutturaasl then null else id_node_parent*10+1 end id_node_parent ,
			descrizione ,descrizione_breve  ,descrizione_breve descrizione_composta,false selezionato
			from matrix.vw_tree_nodes_down_asl_descr tn where tn.id_node_ref =idstrutturaasl
			union 
			select	ns.id id,ns.id*10+2,ns.id_node_struttura*10+1,
			ns.nominativo descrizione,ns.nominativo descrizione_breve,
			ns.descrizione_breve || ' - ' ||ns.nominativo descrizione_composta,pns.id is not null
	     	from matrix.vw_nominativi_struttura ns join matrix.vw_tree_nodes_down  tn on tn.id_node =ns.id_node_struttura 
	     	left join agenda.vw_elab_cal_param_ns pns on ns.id=pns.id_ns and pns.id_elab_cal=idelabcal
	    	where tn.id_node_ref =idstrutturaasl
				order by descrizione_breve) a;
		ret.info:= '{"ns":'||rt::varchar;
	
		raise notice '%',json_array_length(rt);
	
		select json_agg(row_to_json(x.*)) into rt from (select vp.id_node as id,vp.id_node,vp.id_node_parent,
		coalesce(alias||' ','')||descrizione_breve descrizione_breve,coalesce(alias||' ','')||descrizione descrizione,c.selezionato from matrix.vw_tree_nodes_up_piani vp join
			(select distinct p.id_node_ref,ep.id_piano is not null selezionato from  matrix.vw_tree_nodes_down_piani_descr p 
				left join agenda.elab_cal_param_piani ep on ep.id_piano =p.id_node_ref and ep.id_elab_cal =idelabcal
				 join 
				(select distinct id_piano as id_uoc_piano from agenda.asl_piani ap join matrix.vw_tree_nodes_down tn on ap.id_struttura=tn.id_node
				where tn.id_node_ref=idstrutturaasl) a
				on a.id_uoc_piano =p.id_node where anno=(select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int--(select max(anno) from matrix.tree_anno) 
			) c on vp.id_node=c.id_node_ref order by path_ord) x;
	    ret.esito:=true;
 		ret.msg:=null;
 	 	ret.info:= ret.info||',"piani":'||rt::varchar||'}';
		if json_array_length(rt) is null then
	
    		--ret.msg:='strutture piani non trovate';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'strutture_piani_non_trovate');

    	else

 			--ret.info:= ret.info||',"piani":'||rt::varchar||'}';
	 		--ret.info:=rt;
		end if;
	

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_elab_ns_piani(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_elab_params(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_elab_params(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idelabcal bigint;
	proc_name varchar;
	R_CAL agenda.vw_calendari%ROWTYPE;
	R_EC agenda.vw_elab_cals%ROWTYPE;
	REC Record;
	rt json;

	begin
		proc_name:='agenda.get_elab_cal_params';
	
		idelabcal:=v_j->'id_elab_cal';
		if idelabcal is null then
			idelabcal:=dati->>'id_gen_cal';
		end if;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(c.*)) into rt from agenda.vw_elab_cals_params c
		where id_elab_cal=idelabcal;

		raise notice '%',rt;
	
		if rt is null then
			ret.esito:=false;	
    		--ret.msg:='ealb_cal_params non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'ealb_cal_params_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	

	 	return ret;

	end;
end;
$$;


ALTER FUNCTION agenda.get_elab_params(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_even(character varying, character varying, bigint, json); Type: PROCEDURE; Schema: agenda; Owner: postgres
--

CREATE PROCEDURE agenda.get_even(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json)
    LANGUAGE plpgsql
    AS $$

declare 	
	idtransazione bigint;
	proc_name varchar;
	id_op bigint;  
	id_risorsa bigint;
	ret ag_types.result_type;
	ret_2 ag_types.result_type;
	ret_3 ag_types.result_type;

	ret_eventi ag_types.result_type;
	ret_calendari ag_types.result_type;
	retj json;
	text_msg1 varchar;	
	text_msg2 varchar;	
	text_msg3 varchar;	
	text_msg4 varchar;
	str_conf varchar;
	ts timestamp;
id bigint;
	fallito bool;
j_user_info json;
begin 
	ts:=CLOCK_TIMESTAMP();
	proc_name:='agenda.get_dati';
	idtransazione:= ag_log.get_id_transazione(idutente,proc_name);
	id_op:=ag_log.op(proc_name,idtransazione,v,null,ts,-1,operazione);
	--select row_to_json(public.get_utente_info_from_gisa(idutente)) into j_user_info;
	select row_to_json(a.*) into j_user_info from
		(
			select u.* , sa.descrizione_breve as descr_struttura_root
			from public.get_utente_info_from_gisa_ext(idutente) u
			left join matrix.struttura_asl sa on sa.id = u.id_struttura_root
		) a;
 

	if j_user_info is not null then
		if v is null or v='' or v='{}' then
			v:= '{"user_info":'||j_user_info||'}';
		else
			v:= substring(v,1,length(v)-1)||',"user_info":'||j_user_info||'}';
		end if;
	end if;
	raise notice 'USER_DATA %', v;
	id_op:=ag_log.op(proc_name,idtransazione,v,null,ts,-1,operazione);
   	--COMMIT;
 
	begin 
	fallito:=false;


	case operazione
		when 'get_user_info' then
			if v is not null then
				ret.esito = true;
				ret.info := v;
			end if;
		when 'get_ws_call' then
			ret:=trf.get_ws_call(v, idtransazione);
		when 'get_tariffario_per_attivita' then
			ret:=trf.get_tariffario_per_attivita(v::json, idtransazione);		
		when 'get_tariffario_per_regole' then
			ret:=trf.get_tariffario_per_regole(v::json, idtransazione);
		when 'get_master_list' then
			ret:=agenda.get_masterlist(v::json, idtransazione);
		when 'get_tariffa_ml' then
			ret:=trf.get_tariffa_ml(v::json, idtransazione);
		when 'get_trf_per_regole' then
			ret:=trf.get_trf_per_regole(v::json, idtransazione);
		when 'get_piano_periodo' then
			ret:=agenda.get_piano_periodo(v::json, idtransazione);
		when 'get_exp_dati' then
			ret:=agenda.get_exp_dati(v::json, idtransazione);
		when 'get_exp_conf' then
			ret:=agenda.get_exp_conf(v::json, idtransazione);
		when 'get_elab_log' then
			ret:=agenda.get_elab_log(v::json, idtransazione);
		when 'get_menu' then
			ret:=ag_ui.get_menu(v::json, idtransazione);
		when 'get_ns_az_sedi' then
			ret:=agenda.get_ns_az_sedi(v::json, idtransazione);
		when 'get_ns_linee' then
			ret:=agenda.get_ns_linee(v::json, idtransazione);
		when 'get_tariffario_per_piani' then
			ret:=trf.get_tariffario_per_piani(v::json, idtransazione);
		when 'get_piano_freq' then
			ret:=agenda.get_piano_freq(v::json, idtransazione);
		when 'get_tipo_linee_per_piani' then
			ret:=agenda.get_tipo_linee_per_piani(v::json, idtransazione);
		when 'get_piani' then
			ret:=agenda.get_piani(v::json,idtransazione);
		when 'get_elab_ns_piani' then
			ret:=agenda.get_elab_ns_piani(v::json,idtransazione);
	    when 'get_elab_asl_piani' then
	    	v:=replace(v,'"asl":','"ns":');
			ret:=agenda.get_elab_ns_piani(v::json,idtransazione);
		when 'get_attivita_fatturabili' then
			ret:=trf.get_attivita_fatturabili(v::json,idtransazione);
		when 'get_elab_cal_params' then
			ret:=agenda.get_elab_params(v::json,idtransazione);
		when 'get_tariffa_voci' then
			ret:=trf.get_tariffa_voci(v::json,idtransazione);
		when 'get_tariffa' then
			ret:=trf.get_tariffa(v::json,idtransazione);
		when 'get_trf_att_inviate' then
			ret:=trf.get_trf_att_inviate(v::json,idtransazione);
		when 'get_trf_att_inviate_ultimo_stato' then
			ret:=trf.get_trf_att_inviate_ultimo_stato(v::json,idtransazione);
		when 'get_trf_att_inviate_stati' then
			ret:=trf.get_trf_att_inviate_stati(v::json,idtransazione);
		when 'get_elab_az_sedi' then
			ret:=agenda.get_elab_az_sedi(v::json,idtransazione);
		when 'get_elab_linee' then
			ret:=agenda.get_elab_linee(v::json,idtransazione);
		when 'get_nominativi_calendario' then
			ret:=agenda.get_nominativi_calendario(v::json,idtransazione);
		when 'get_ag_conf' then
			ret:=ag_conf.get_ag_conf(v::json,idtransazione);
		when 'get_monitoraggio_flusso_import' then
			ret:=conf_ext.get_monitoraggio_flusso_import(v::json,idtransazione);
		when 'get_aziende' then
			ret:=agenda.get_aziende(v::json,idtransazione);	
		when 'get_azienda_persone' then
			ret:=agenda.get_azienda_persone(v::json,idtransazione);	
		when 'get_azienda_indirizzi' then
			ret:=agenda.get_azienda_indirizzi(v::json,idtransazione);
		when 'get_aziende_by_sel' then
			ret:=agenda.get_aziende_by_sel(v::json,idtransazione);	
		when 'get_dettaglio_scarto_aziende' then
			ret:=conf_ext.get_dettaglio_scarto_aziende(v::json,idtransazione);	
		when 'get_dettaglio_scarto_persone' then
			ret:=conf_ext.get_dettaglio_scarto_persone(v::json,idtransazione);		
		when 'get_dettaglio_scarto_persone' then
			ret:=conf_ext.get_dettaglio_scarto_persone(v::json,idtransazione);	
		when 'get_formato_import' then
			ret:=agenda.get_formato_import(v::json,idtransazione);
	    when 'get_import_formato_linea' then
			ret:=agenda.get_import_formato_linea(v::json,idtransazione);
		when 'get_tipo_liste' then
			ret:=agenda.get_tipo_liste(v::json,idtransazione);	
       when 'get_tipolista_piani' then
			ret:=agenda.get_tipolista_piani(v::json,idtransazione);	
		when 'get_dettaglio_lista' then
			ret:=agenda.get_dettaglio_lista(v::json,idtransazione);	
		when 'get_lista_calendari' then
			ret:=agenda.get_lista_calendari(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"calendari":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_uoc' then
			ret:=agenda.get_uoc(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"uoc":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_uos' then
		ret:=agenda.get_uos(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"uos":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_uoc_piani' then
			ret:=agenda.get_uoc_piani(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"uoc_piani":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_uos_comuni' then
			ret:=agenda.get_uos_comuni(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"uos_comuni":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_linee_piano' then
			ret:=agenda.get_linee_piano(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"linee_piano":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_nominativi_comuni' then
					ret:=agenda.get_nominativi_comuni(v::json,idtransazione);
		when 'get_ns_comuni' then
			ret:=agenda.get_nominativi_comuni(v::json,idtransazione);
		when 'get_nominativi_uos' then
			ret:=agenda.get_nominativi_uos(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"nominativi_uos":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_nominativi_uos_selezionabile' then
			ret:=agenda.get_nominativi_uos_selezionabile(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"nominativi_uos_selezionabili":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_ns_piani' then
			ret:=agenda.get_ns_piani(v::json,idtransazione);
			if ret.esito then
				ret.info:='{"ns_piani":' || ret.info::json;
				ret.info:=ret.info || '}';
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_ns' then
			ret:=agenda.get_ns(v::json,idtransazione);
		when 'get_piani_by_ns' then
			ret:=agenda.get_piani_by_ns(v::json,idtransazione);
		when 'get_linee_by_ns_piano' then
			ret:=agenda.get_linee_by_ns_piano(v::json,idtransazione);
			raise notice 'RET=%',ret;
		when 'genera_calendario_prova' then
			ret:=agenda.genera_calendario_prova(-1,idtransazione);
			if ret.esito then
				ret.info:='{"eventi":' || ret.info::json;
				ret.info:=ret.info || '}';
			raise notice 'ret.info %',ret.info;
		end if;
		when 'genera_calendario_prova' then
		ret:=agenda.genera_calendario_prova(-1,idtransazione);
		if ret.esito then
			ret.info:='{"eventi":' || ret.info::json;
			ret.info:=ret.info || '}';
			raise notice 'ret.info %',ret.info;
		end if;
		when 'get_fattura' then
			ret:=trf.get_fattura(v,idtransazione);
			if ret.esito then
				raise notice 'ret.info %',ret.info;
			end if;
		when 'get_linee_calendario' then
		ret:=agenda.get_linee_calendario(v::json,idtransazione);
		if ret.esito then
			raise notice 'ret.info %',ret.info;
		end if;
		when 'get_lnominativi_calendario' then
		ret:=agenda.get_nominativi_calendario(v::json,idtransazione);
		if ret.esito then
			raise notice 'ret.info %',ret.info;
		end if;	
		when 'get_calendario' then
		ret:=agenda.get_calendario(v::json,idtransazione);
		if ret.esito then
			raise notice 'ret.info %',ret.info;
		end if;	
		when 'get_calendario_info' then
		ret:=agenda.get_calendario_info(v::json,idtransazione);
		if ret.esito then
			raise notice 'ret.info %',ret.info;
		end if;	
		when 'get_ag_tipo_eventi' then
		ret:=agenda.get_ag_tipo_eventi(v::json,idtransazione);
		if ret.esito then
			raise notice 'ret.info %',ret.info;
		end if;		
		when 'get_elab_cal' then
		ret:=agenda.get_elab_cal(v,idtransazione);
		if ret.esito then
			raise notice 'ret.info %',ret.info;
		end if;	

		when 'get_cal_riepilogo_linee' then
		raise notice 'GET V=%',v;
		ret:=agenda.get_cal_riepilogo_linee(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"linee":{"colonne":[{"name":"UOC","type":"text","field":"asl_c"},{"name":"UOS","type":"text","field":"asl_d"},
{"name":"Piano","type":"text","field":"piano_d"},{"name":"Target","type":"number","field":"target"},{"name":"n. linee","type":"number","field":"cnt"},
{"name":"n. att","type":"number","field":"a_cnt"}],"dati":' || ret.info::json;
			ret.info:=ret.info || '}}';
			raise notice 'ret.info %',ret.info;
		end if;
		when 'get_cal_riepilogo' then
		ret:=agenda.get_cal_riepilogo_uos(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"uos":{"colonne":[{"name":"UOS","type":"text","field":"descrizione_breve"},{"name":"Pianificati","type":"number","field":"pianificati"},{"name":"Programmati","type":"number","field":"programmati"}],"tipo_colonne":["text","number","number"],"dati":' || ret.info::json;
			ret.info:=ret.info || '},';
			raise notice 'ret.info %',ret.info;
		end if;
		ret_2:=agenda.get_cal_riepilogo_risorse(v::json ,idtransazione);
		if ret_2.esito then
			ret.info:=ret.info||'"risorse":{"colonne":[{"name":"Ispettore","type":"text","field":"nominativo"},{"name":"Pianificati","type":"number","field":"pianificati"},{"name":"Programmati","type":"number","field":"programmati"}],"tipo_colonne":["text","number","number"],"dati":' || ret_2.info::json;
			ret.info:=ret.info || '},';
			raise notice 'ret.info %',ret.info;
		end if;
		when 'get_cal_riepiloghi' then
			ret:=agenda.get_cal_riepiloghi(v::json,idtransazione);
		
		when 'get_tariffario' then
		ret:=trf.get_tariffario(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"tariffario":' || ret.info::json;
			ret.info:=ret.info || '}';
			raise notice 'ret.info %',ret.info;
		end if;
		when 'get_tariffe_export' then
			ret:=trf.get_tariffario_export(v::json, idtransazione);
		/*
		ret:=trf.get_tariffario(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"tariffe":' || ret.info::json;
			ret.info:=ret.info || '}';
			raise notice 'ret.info %',ret.info;
		end if;
		*/
		when 'get_fatture' then
		--id_risorsa:=(v::json->>'id')::bigint;
		ret:=trf.get_fatture(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"fatture":' || ret.info;
			ret.info:=ret.info || '}';
		
			raise notice 'ret.info %',ret.info;
		end if;
		when 'get_trf_ft_periodiche' then
		--id_risorsa:=(v::json->>'id')::bigint;
		ret:=trf.get_fatture_periodiche(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"fatture_periodiche":' || ret.info;
			ret.info:=ret.info || '}';
		
			raise notice 'ret.info %',ret.info;
		end if;
		when 'get_attivita' then
		--id_risorsa:=(v::json->>'id')::bigint;
		ret:=trf.get_attivita(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"attivita":' || ret.info;
			ret.info:=ret.info || '}';
		
			raise notice 'ret.info %',ret.info;
		end if;
	when 'get_rilevazione_attivita' then
		--id_risorsa:=(v::json->>'id')::bigint;
		--ret:=trf.get_attivita(idtransazione);
		--if ret.esito then
		ret:= trf.get_rilevazione_attivita(v);
		raise notice 'ret.info %',ret.info;

	--when 'get_calendari' then
	when 'get_agende' then
		--id_risorsa:=(v::json->>'id')::bigint;
		ret:=agenda.get_agende(v::json,idtransazione);
		if ret.esito then
			ret.info:='{"calendari":' || ret.info;
			ret.info:=ret.info || '}';
		
			raise notice 'ret.info %',ret.info;
		end if;
	when 'get_att_dati_da_inviare' then
			ret:= agenda.get_att_dati_da_inviare(v::json,idtransazione);
			raise notice 'ret.info %',ret.info;
	when 'get_eventi_struttura' then
			ret:= agenda.get_eventi_struttura(v::json,idtransazione);
			raise notice 'ret.info %',ret.info;
	when 'get_linee' then
			ret:= agenda.get_linee(v::json,idtransazione);
	when 'get_veterinari_carico' then
			ret:= agenda.get_veterinari_carico(v::json,idtransazione);
			raise notice 'ret.info %',ret.info;
	when 'get_fatt_forf_riep' then
			ret:= trf.get_fatt_forf_riep(v::json,idtransazione);
			raise notice 'ret.info %',ret.info;	
	when 'get_att_forf_riep' then
			ret:= trf.get_att_forf_riep(v::json,idtransazione);
			raise notice 'ret.info %',ret.info;	
	when 'get_attivita_forfet' then
			ret:= trf.get_attivita_forfet(v::json,idtransazione);
			raise notice 'ret.info %',ret.info;
	when 'get_stati_forfet' then
			ret:= trf.get_stati_forfet(v::json,idtransazione);
			raise notice 'ret.info %',ret.info;
	when 'get_cf_liste' then
			ret:=agenda.get_cf_liste(v::json,idtransazione);
	when 'get_cf_allevamenti' then
			ret:=agenda.get_cf_allevamenti(v::json,idtransazione);
	when 'get_az_sedi' then
			ret:=agenda.get_az_sedi(v::json,idtransazione);		
	when 'get_nominativi_uos_by_asl' then
			ret:=agenda.get_nominativi_uos_by_asl(v::json,idtransazione);	
		
	when 'get_eventi' then
		id_risorsa:=(v::json->>'id')::bigint;
		raise notice 'id_risorsa=%',id_risorsa;
		--ret:=agenda.get_calendario(id_risorsa, idtransazione);
		--if ret.esito then
			ret_eventi:=agenda.get_eventi(id_risorsa, idtransazione);
		
			raise notice 'RET_EVENTI %',ret_eventi;
			--ret.info:='{"calendario":' || left(ret.info,length(ret.info)-1);
			
					
			if ret_eventi.esito then 
				ret.info:= '{"calendario":{"eventi":'||ret_eventi.info||'}}';
			else
				ret.info:= '{"calendario":{"eventi":[]}}';
			end if;
			--ret.info:=ret.info || '}}';
		
			raise notice 'ret.info %',ret.info;
		--end if;
	when 'get_scontrino_xml' then
		ret:=trf.get_scontrino_xml(v::json, idtransazione);
 	else
 			ret.esito := false;
 			ret.info  := 'CASO NON PREVISTO';
 			raise notice 'ELSE CASE';
	end case;

	RAISE notice 'agenda.get_dati ret.esito: %', ret.esito;
	   
	if ret.esito=false then 
		RAISE notice 'agenda.get_dati if su ret.esito=false';
		fallito=true;
		RAISE notice 'agenda.get_dati ROLLBACK a seguito di ret.esito=false';
	end if;
raise notice 'ID_NS %',j_user_info->'id_struttura_root';
	str_conf:= ag_ui.get_ui_definition(''::varchar,'agenda.'||operazione,((j_user_info->'id_struttura_root')::varchar)::int8,idtransazione);
raise notice 'OPERAZIONE % STR_CONF=%',operazione,str_conf;
raise notice 'j_user_info=%',j_user_info;
	if str_conf is not null and str_conf != '' then
	 	 ret.info:='{'||str_conf||','||right(ret.info,length(ret.info)-1);
	end if;

	exception when others then
		fallito:=true;
		RAISE notice 'agenda.get_dati ROLLBACK a seguito di exception';
		GET STACKED DIAGNOSTICS text_msg1 = MESSAGE_TEXT,
		                  			text_msg2 = PG_EXCEPTION_DETAIL,
		                  			text_msg3 = PG_EXCEPTION_HINT,
		                 			text_msg4 = PG_EXCEPTION_CONTEXT;
		ret.esito:=false;
		ret.valore:= null;
	if replace(upper(j_user_info->>'ambiente'),'"','') ='local' then
		ret.err_msg:=coalesce(ret.err_msg,'')||coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');
	else
		ret.err_msg:=coalesce(ret.err_msg,'')||coalesce(text_msg1,'');
	end if;
   end;
  
  	if fallito=true then 
		rollback;
	end if;

	joutput:=row_to_json(ret);
	id_op:=ag_log.op(proc_name,idtransazione,v,joutput,ts,-1,operazione);
--commit;
end;
$$;


ALTER PROCEDURE agenda.get_even(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json) OWNER TO postgres;

--
-- Name: get_eventi(bigint, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_eventi(id_record bigint, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
BEGIN
DECLARE
    ret ag_types.result_type;
    id_op bigint;
    proc_name varchar;
    R_EV agenda.vw_eventi%ROWTYPE;
    rt json;
   
      dt_inizio timestamp;
  dt_fine timestamp;
BEGIN
    proc_name := 'agenda.get_eventi';
    
   	-- id_op:=gds_log.start_op(proc_name,idtransazione ,'');
    
	select (value||'-01-01')::timestamp into dt_inizio from "Analisi_dev".config where descr='ANNO CORRENTE';  
	   dt_fine := dt_inizio + interval '2 year';
  	--select * into R_C from cu_confconfig where cod=;
  	dt_inizio:= dt_inizio - interval '4 months';
   
   	SELECT json_agg(row_to_json(e.*)) INTO rt
    
    FROM (
        SELECT
            *  --,
            /*(sigla_tipo_evento in ('CU', 'FU', 'PL') AND id_cu IS NULL) crea_cu,
            (sigla_tipo_evento in ('CU', 'FU', 'PL') AND id_cu IS NOT NULL) apri_cu*/
            --crea_controllo AND id_cu IS NULL     crea_cu,
            --crea_controllo AND id_cu IS NOT NULL apri_cu
        FROM agenda.vw_eventi e
        WHERE id_anagrafica = id_record and inizio between dt_inizio and dt_fine
        --extract (year from inizio) =
        		--(select value::integer from "Analisi_dev".config where descr='ANNO CORRENTE')
	) e;

    -- ret.valore:= id_record;
	if rt is null then
		rt:='[]'::json;
	end if;

    
	RAISE NOTICE 'NUMERO EVENTI TROVATI %', json_array_length(rt);

    /*if json_array_length(rt) is null then
     ret.esito:=false;	
     ret.msg:='id risorsa non trovato';
     ret.info:=null; 
     else*/
    ret.esito := TRUE;
    ret.msg := NULL;
    ret.info := rt;
    --end if;
    RETURN ret;
    END;
END;
$$;


ALTER FUNCTION agenda.get_eventi(id_record bigint, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_eventi_struttura(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_eventi_struttura(j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idstruttura bigint;
	proc_name varchar;
	R_EV agenda.vw_eventi%ROWTYPE;
	responsabile bool;
	idutente bigint;
	rt json;

	begin
		proc_name:='agenda.get_eventi_struttura';
		idstruttura:=j->'user_info'->'id_struttura_root';
		responsabile:=j->'user_info'->'responsabile';
		idutente:=j->'user_info'->'id_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
	raise notice 'idstruttura %',idstruttura;
	raise notice 'idtrnsazione %, j %,',idtransazione,j;
		if responsabile then
		raise notice 'responsabile sì';
			select json_agg(row_to_json(a.*)) into rt from (
			select e.id,e.inizio,e.risorsa,e.sigla_tipo_evento,e.comune,e.presso, e.id_partner,e.partner,
				operativa and id_cu is null and not effettuata modificabile,
				operativa and (not effettuata) and id_cu is null eliminabile,
				id_cu is null and stato_attivita = 'Aperta' and not effettuata and operativa selezionabile, stato_attivita,
				e.cod_regionale
			from agenda.vw_eventi_singoli e 
			where e.id_anagrafica in (select distinct id_anagrafica from matrix.vw_nominativi_struttura where id_node_struttura
				in (select id_node from matrix.vw_tree_nodes_down_asl where id_node_ref =idstruttura ) )order by e.inizio,e.risorsa) a;
		else
				raise notice 'responsabile no';
			select json_agg(row_to_json(a.*)) into rt from (
			select e.id,e.inizio,e.risorsa,e.sigla_tipo_evento,e.comune,e.presso, e.id_partner,e.partner,
				operativa and id_user_create= idutente and not effettuata and id_cu is null modificabile, 
				((not operativa or id_user_create= idutente) and not effettuata)  and id_cu is null eliminabile,
				--(not operativa) and 
				id_cu is null and stato_attivita = 'Aperta' and not effettuata and operativa selezionabile, stato_attivita,
				e.cod_regionale 
			from agenda.vw_eventi e 
			where e.id_anagrafica =idutente  order by e.inizio,e.risorsa) a;
		end if;
		ret.valore:= idstruttura;	
		raise notice 'NUMERO RECORD %',json_array_length(rt);	
    	ret.esito:=true;
 		ret.msg:=null;
 		ret.info:='{"dati":'||rt||'}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_eventi_struttura(j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_exp_conf(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_exp_conf(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	lev integer;
	rt json;

	begin
		proc_name:='agenda.get_exp_conf';
		idstruttura=v->'user_info'->'id_struttura_root';
		lev:=v->'user_info'->'livello';
	
		raise notice 'idstruttura: %', idstruttura;
		raise notice 'lev: %', lev;
	
		select json_agg(row_to_json(c.*)) into rt from (select id, cod, descr, true selezionabile from agenda.vw_config_exp_imp where livello >= lev order by ordine) c ;

		raise notice '%',json_array_length(rt);
		ret.esito:=true;	
		if json_array_length(rt) is null then
    		--ret.msg:='configurazioni non trovate';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'configurazioni_non_trovate');
    	else
 			ret.msg:=null;
		end if;
		ret.info:='{"dati":'||rt||'}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_exp_conf(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_exp_dati(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_exp_dati(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	ret_dati varchar;
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	rt json;
	R_C agenda.config_exp_imp;
	dati varchar;
	stmt varchar;
	fstmt varchar;

	begin
		proc_name:='agenda.get_exp_dati';
		idstruttura=v->'user_info'->'id_struttura_root';

		ret.info:='';
		ret.esito:=true;
		for R_C in select c.* from agenda.vw_config_exp_imp c 
			join  json_array_elements(v->'id') v on v.value::varchar::int8=c.id 
			order by c.ordine  loop
			raise notice 'ID=%',R_C.id;
			stmt:= 'select ' ||R_C.f_exp||'(%L::json,%L::bigint)';
			raise notice 'STMT=%',stmt;
			fstmt:= format(stmt,v,idtransazione);
			execute fstmt into ret_dati;
			raise notice 'DATI %',ret_dati;
			if ret.info='' then ret.info:='[';
			else ret.info:=ret.info||',';
			end if;
			ret.info:=ret.info||
				'{"nome_foglio":"'||R_C.intestazione||
			    '","intestazione_colonne":'||R_C.intestazione_campi||
			    ',"dati":'|| coalesce(ret_dati,'[]') ||'}';
			raise notice 'RET_INFO %',ret.info;
		end loop;
		if ret.info!='' then ret.info:=ret.info||']'; end if;
 		   ret.msg:=null;
 	    -- AF 20230807 ret:=ag_ui.build_ret(ret,proc_name, '');
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_exp_dati(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_exp_uos_comuni(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_exp_uos_comuni(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	rt json;

	begin
		proc_name:='agenda.get_exp_uos_comuni';
		idstruttura=v->'user_info'->'id_struttura_root';
		select json_agg(row_to_json(c.*)) into rt from (select descrizione_breve,comune from agenda.vw_struttura_comuni vsc) c ;

		raise notice '%',json_array_length(rt);
		ret.esito:=true;	
		if json_array_length(rt) is null then
    		ret.msg:='configurazioni non trovate';
    	else
 			ret.msg:=null;
		end if;
		ret.info:=rt;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_exp_uos_comuni(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_formato_import(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_formato_import(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
 

	begin
		proc_name:='agenda.get_formato_import';
	
		select json_agg(row_to_json(c.*)) into rt  from (select * from  agenda.formato_import  ) c;

		raise notice '%',rt;	
		if rt is null then
			ret.esito:=false;	
    	    ret:=ag_ui.build_ret(ret,proc_name, 'valori_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null; 		 		
 			ret.info:='{"dati":' || rt;
			ret.info:=ret.info || '}';

		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_formato_import(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_import_formato_linea(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_import_formato_linea(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	j_user_info json;
	tipo integer;
	tipo_p varchar;

	begin
		proc_name:='agenda.get_import_formato_linea';
	    tipo:=v->'tipo';
		j_user_info:=v->'user_info';
		 
		 raise notice '%',tipo;
	 	if(tipo=2) then
	 			raise notice '%','non_associati';
	 	  		select json_agg(row_to_json(a.*)) into rt from (
	 	  		
				/*select * from agenda.vw_import_linea where id_lista = (v->>'id_lista')::bigint
				and id_linea is null
				order by id desc*/
	 	  		select s.denominazione_sede_operativa, s.piva, s.cod_tipo_linea
	 	  		from
	 			agenda.file_xls_linea s
	 			inner join agenda.vw_import_linea l on l.id=s.id and  id_lista =(v->>'id_lista')::bigint
	 			where id_linea is null
	 			order by s.id  desc
			
				) a; 	
	 	else 
	 	  -- 2 associati
	 		if(tipo=1) then
	 		   raise notice '%','associati';
	 			 select json_agg(row_to_json(a.*)) into rt from (
				/*select * from agenda.vw_import_linea where id_lista = (v->>'id_lista')::bigint
				and id_linea is not null
				order by id desc*/
	 			select s.denominazione_sede_operativa, s.piva, s.cod_tipo_linea
	 	  		from
	 			agenda.file_xls_linea s
	 			inner join agenda.vw_import_linea l on l.id=s.id and  id_lista =(v->>'id_lista')::bigint
	 			where id_linea is not null
	 			order by s.id  desc
	 			 ) a; 	
			end if;
	 	end if;
	 	
	   raise notice '%',rt;
 
	
		raise notice '%',json_array_length(rt);
	    ret.esito:=true;
 		ret.msg:=null;
		ret.info:='{"dati":'||rt||'}';
		--end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_import_formato_linea(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_import_formato_profilassi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_import_formato_profilassi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	j_user_info json;
	tipo integer;
	begin
		proc_name:='agenda.get_import_formato_profilassi';
	    tipo:=v->'tipo';
		j_user_info:=v->'user_info';
	
  		if(tipo=2) then
		
	 	  	    select json_agg(row_to_json(a.*)) into rt from ( 
	 	  	  
	 	  		select cod_azienda ,cod_grp_specie 
	 	  		from
	 			agenda.file_xls_profilassi  p
	 			inner join agenda.vw_import_linea l on l.id=p.id::int and  id_lista=(v->>'id_lista')::bigint
	 			where id_linea is null
	 			order by p.id  desc
		
	 	  	    
	 	  	    ) a; 	
	 	else 
	 	  -- 2 associati
	 		if(tipo=1) then
	 			select json_agg(row_to_json(a.*)) into rt from (
	 		 
	 			select cod_azienda ,cod_grp_specie 
	 	  		from
	 			agenda.file_xls_profilassi  p
	 			inner join agenda.vw_import_linea l on l.id=p.id::int and  id_lista =(v->>'id_lista')::bigint
	 			where id_linea is not null
	 			order by p.id  desc
				) a; 	
	 			end if;
	 	end if;
	 	
	
		raise notice '%',json_array_length(rt);
	    ret.esito:=true;
 		ret.msg:=null;
		ret.info:='{"dati":'||rt||'}';
		--end if;
	 	return ret;
	 
	 
	end;
end;
$$;


ALTER FUNCTION agenda.get_import_formato_profilassi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_import_formato_sicer(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_import_formato_sicer(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	j_user_info json;
	tipo integer;
	tipo_p varchar;

	begin
		proc_name:='agenda.get_import_formato_sicer';
	    tipo:=v->'tipo';
		j_user_info:=v->'user_info';
		 
		 raise notice '%',tipo;
	 	if(tipo=2) then
	 			raise notice '%','non_associati';
	 	  		select json_agg(row_to_json(a.*)) into rt from (
			/*	select * from agenda.vw_import_linea where id_lista = (v->>'id_lista')::bigint
				and id_linea is null
				order by id desc */	  		 	 			
	 			 			
	 	  		select s.idua ,s.nome  ,s.codregionale ,s.comune   ,s.attivitacontrollate  
	 	  		from
	 			agenda.file_xls_sicer s
	 			inner join agenda.vw_import_linea l on l.id=s.id and  id_lista =(v->>'id_lista')::bigint
	 			where id_linea is null
	 			order by s.idua  desc
			  
				) a; 	
	 	else 
	 	  -- 2 associati
	 		if(tipo=1) then
	 		   raise notice '%','associati';
	 			 select json_agg(row_to_json(a.*)) into rt from (
			/*	select * from agenda.vw_import_linea where id_lista = (v->>'id_lista')::bigint
				and id_linea is not null
				order by s.idua desc*/
 			   select s.idua ,s.nome  ,s.codregionale ,s.comune   ,s.attivitacontrollate  
 			 	from
	 			agenda.file_xls_sicer s
	 			inner join agenda.vw_import_linea l on l.id=s.id and  id_lista =(v->>'id_lista')::bigint
	 			where id_linea is not null
	 			order by s.idua  desc
			
				) a; 	
			end if;
	 	end if;
	 	
	   raise notice '%',rt;
 
	
		raise notice '%',json_array_length(rt);
	    ret.esito:=true;
 		ret.msg:=null;
		ret.info:='{"dati":'||rt||'}';
		--end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_import_formato_sicer(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_import_formato_sicer_old(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_import_formato_sicer_old(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	j_user_info json;
	tipo integer;
	tipo_p varchar;

	begin
		proc_name:='agenda.get_import_formato_sicer';
	    tipo:=v->'tipo';
		j_user_info:=v->'user_info';
		 
		 raise notice '%',tipo;
	 	if(tipo=2) then
	 			raise notice '%','non_associati';
	 	  		select json_agg(row_to_json(a.*)) into rt from (
				select * from agenda.vw_import_linea where id_lista = (v->>'id_lista')::bigint
				and id_linea is null
				order by id desc) a; 	
	 	else 
	 	  -- 2 associati
	 		if(tipo=1) then
	 		   raise notice '%','associati';
	 			 select json_agg(row_to_json(a.*)) into rt from (
				select * from agenda.vw_import_linea where id_lista = (v->>'id_lista')::bigint
				and id_linea is not null
				order by id desc) a; 	
			end if;
	 	end if;
	 	
	   raise notice '%',rt;
 
	
		raise notice '%',json_array_length(rt);
	    ret.esito:=true;
 		ret.msg:=null;
		ret.info:='{"dati":'||rt||'}';
		--end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_import_formato_sicer_old(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_linee(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_linee(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	idelabcal bigint;
	rt json;
	idstrutturaroot bigint;
	begin
		proc_name:='agenda.get_linee';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (

			select   l.id_linea,l.denominazione_sede_operativa ,l.indirizzo ,
			l.comune--, p.alias || ' - ' || p.descrizione_breve descrizione_breve 
			from agenda.vw_linee l where id_comune in
			(select distinct id_comune from  agenda.vw_struttura_comuni s  join matrix.vw_tree_nodes_down_asl a
			on s.id_struttura =a.id_node where a.id_node_ref=idstrutturaroot)
			order by l.comune  ,l.denominazione_sede_operativa
		) g;

	
	
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=ag_ui.build_ret(ret,proc_name, 'linee_per_struttura_non_trovate');
    	else
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_linee(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_linee_by_ns_piano(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_linee_by_ns_piano(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idns bigint;
	idpiano bigint;
	idasl bigint;
	rt json;

	begin
		proc_name:='agenda.get_linee_by_ns_piano';
		raise notice 'v=%',v;
		idns:=v->'id_ns';
		idpiano:=v->'id_piano';
		idasl:=v->'user_info'->'id_asl';

		raise notice 'idns=% idpiano=%',idns,idpiano;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (
		select  l.id_linea as id, l.id_linea, s.nome denominazione_sede_operativa, s.indirizzo_completo, s.comune ,
							l.cod_tipo_linea, l.desc_tipo_linea, s.cod_regionale
			from cu_anag.vw_linee l join cu_anag.vw_stabilimenti s on l.id_stabilimento=s.id_stabilimento
			join agenda.vw_piano_tipo_linea tp on l.id_tipo_linea=tp.id_tipo_linea and tp.id_piano=idpiano
			where s.id_asl=idasl or idasl=-1

			/*select  l.id_linea as id, l.id_linea,l.denominazione_sede_operativa ,l.indirizzo ,
							l.comune,l.cod_tipo_linea  from (
				select distinct lps.id_linea,lps.denominazione_sede_operativa ,lps.indirizzo ,lps.comune,lps.cod_tipo_linea
				from agenda.vw_nominativo_comuni nc
				join agenda.vw_linee_piano_struttura lps on lps.id_comune =nc.id_comune
				where lps.id_piano =idpiano and nc.id_nominativo_struttura =idns) l */
		) g;

		raise notice 'json_length = %,id_piano = %, id_asl = %',json_array_length(rt), idpiano, idasl;
		ret.esito:=true;	
		ret.info:='{"dati":'||rt||'}';
	
		ret.valore = coalesce(json_array_length(rt),0);
		if coalesce(json_array_length(rt),0) <= 0 then
    		--ret.msg:='linee per calendario non trovate per le impostazioni attuali';
			ret.esito:=false;
    	    ret:=ag_ui.build_ret(ret,proc_name, 'linee_non_trovate');
    		--ret.info:=null; 
    	else
 			ret.msg:=null;
	 		--ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_linee_by_ns_piano(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_linee_calendario(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_linee_calendario(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	R_EC agenda.vw_elab_cals;
	idelabcal bigint;
	dal timestamp;
	rt json;

	begin
		proc_name:='agenda.get_linee_calendario';
		raise notice 'v=%',v;
		idelabcal:=v->'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v->>'id_gen_cal';
		end if;
		if idelabcal is null then
			ret.esito:=false;	
    		--ret.msg:='linee per calendario non trovate per le impostazioni attuali';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'id_elab_cal non fornito');
    		ret.info:=null; 
    		return ret;
    	end if;
		raise notice 'idelabcal=%',idelabcal;
		select * into R_EC from agenda.vw_elab_cals vec where id_elab_cal=idelabcal;
		select value::timestamp into dal
			from agenda.elab_cal_params where type_param='non_visitati_dal' and id_elab_cal=idelabcal;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		
		/*select json_agg(row_to_json(g.*)) into rt from (
			select   ls.id_linea,ls.id_piano,l.denominazione_sede_operativa ,l.indirizzo ,
			l.comune, p.alias || ' - ' || p.descrizione_breve descrizione_breve 
			from agenda.vw_linee l 
			join agenda.linee_selezionate ls on l.id_linea=ls.id_linea 
			join matrix.struttura_piani p on p.id=ls.id_piano 
			where ls.id_elab_cal =idelabcal and (dal is null or l.data_ultima_visita<dal)
		) g;*/
		select json_agg(row_to_json(g.*)) into rt from (
			select   ls.id_linea,ls.id_piano,l.denominazione_sede_operativa ,l.indirizzo , --2978
				l.comune, p.alias || ' - ' || p.descrizione_breve descrizione_breve 
				from agenda.vw_linee l 
				join agenda.linee_selezionate ls on l.id_linea=ls.id_linea 
				join matrix.struttura_piani p on p.id=ls.id_piano 
				left join agenda.vw_tipo_lista_piani lp on lp.id_piano =p.id
				left join agenda.vw_lista_import li on li.id_tipo_lista =lp.id_tipo_lista and li.anno=R_EC.anno
				left join agenda.vw_import_linea il on il.id_lista=li.id_lista and il.id_linea=l.id
				where ls.id_elab_cal =idelabcal and (dal is null or  l.data_ultima_visita<dal)
				and (li.id is null or(li.id is not null and il.id is not null)) and l.linea_principale
		) g;

		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=true;	
    		--ret.msg:='linee per calendario non trovate per le impostazioni attuali';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'linee_per_calendario_non_trovate_per_le_impostazioni_attuali');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_linee_calendario(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_linee_piano(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_linee_piano(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	
	declare
	ret ag_types.result_type; 
	idsroot bigint;   
	proc_name varchar;
	idpiano bigint;
	rt json;
u json;
	begin
		proc_name:='agenda.get_linee_piano';

	
		idpiano:= (v->>'id_piano')::bigint;
		u:=v->>'user_info';	
		idsroot:= (u->>'id_struttura_root')::bigint;

		raise notice 'V=%',v;
		raise notice 'IDPIANO=%',idpiano;
		raise notice 'IDSROOT=%',idsroot;
	
		select json_agg(row_to_json(c.*)) into rt
		from (	
	    	select distinct l.id_linea,l.id_comune,id_az_sede,id_azienda,stato_sede_operativa stato,rag_soc,piva,denominazione_sede_operativa denominazione,l.comune,indirizzo, stato_sede_operativa descrizione_breve,
	    				case when id_linea_piani is null then false else true end selezionato
			from agenda.vw_linee l join agenda.vw_struttura_comuni sc on l.id_comune=sc.id_comune join matrix.vw_tree_nodes_down_asl a on sc.id_struttura = a.id_node
							join agenda.vw_asl_piani ap on ap.id_struttura =sc.id_struttura left join agenda.vw_linea_piani lp on lp.id_linea =l.id_linea and ap.id_piano =lp.id_piano
			where id_node_ref=idsroot and ap.id_piano=idpiano
		) c;

		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='linee per piano non trovate';
    		ret:=ag_ui.build_ret(ret,proc_name, 'linee_per_piano_non_trovate');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:='{"id_linea_piani":'||rt||'}';
		end if;
	 	return ret;
	end;

	/*declare
	ret ag_types.result_type; 
	idsroot bigint;   
	proc_name varchar;
	idpiano bigint;
	rt json;

	begin
		proc_name:='agenda.get_linee_piano';

		idsroot:= v->"user_info"->"id_struttura_root";
		idpiano:=v->"id_piano";
		select json_agg(row_to_json(c.*)) into rt  from
	    	(	
	    	select l.id_linea,l.id_comune,id_az_sede,id_azienda,stato_sede_operativa stato,rag_soc,piva,denominazione_sede_operativa denominazione,l.comune,indirizzo, descrizione_breve,
	    				case when id_linea_piani is null then false else true end selezionato
			from vw_linee l join vw_struttura_comuni sc on l.id_comune=sc.id_comune join matrix.vw_tree_nodes_down_asl a on sc.id_struttura = a.id_node
							join vw_asl_piani ap on ap.id_struttura =sc.id_struttura left join vw_linea_piani lp on lp.id_linea =l.id_linea and ap.id_piano =lp.id_piano
			where id_node_ref=idsroot  and ap.id_piano=idpiano) c;

		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		ret.msg:='linee per piano non trovati';
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end; */
end;
$$;


ALTER FUNCTION agenda.get_linee_piano(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_lista_calendari(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_lista_calendari(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	iduser bigint;
	rt json;

	begin
		proc_name:='agenda.get_lista_calendari';
		iduser=v->'user_info'->'id_utente';



		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
		/*select json_agg(row_to_json(c.*)) into rt  from (
	select * from agenda.vw_elab_cals c where  id_user =iduser order by c.id_calendario ,c.tm) c;*/


	
	select json_agg(row_to_json(a.*)) into rt from
		(select  row_to_json(c.*) cal,
			(select json_agg(row_to_json(ec.*)) elabs from agenda.vw_elab_cals ec where id_calendario = c.id  )  
			from agenda.calendari c where id_user=iduser order by c.tm desc) a  ;

		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=true;	
    		--ret.msg:='calendari non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'calendari_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_lista_calendari(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_livelli_avviso(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_livelli_avviso(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	responsabile bool;
	rt json;

	begin
		proc_name:='agenda.get_livelli_avviso';
		responsabile:=v->'user_info'->'responsabile';
		raise notice 'RESPONSABILE %',responsabile;
			--select json_agg(row_to_json(c.*)) into rt  from 
			select json_agg(row_to_json(g.*)) into rt from (
			select * from ag_types.vw_ag_livelli_avviso vala) g;

			if json_array_length(rt) is null then
				ret.esito:=false;	
	    		--ret.msg:='calendari non trovati';
	    	    ret:=ag_ui.build_ret(ret,proc_name, 'avvisi_non_trovati');
	    		ret.info:=null; 
	    		return ret;
	    	end if;

		ret.esito:=true;
		ret.msg:=null;
 		ret.info:='{"dati":'||rt::varchar||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_livelli_avviso(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_masterlist(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_masterlist(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	idelabcal bigint;
	rt json;

	begin
		proc_name:='agenda.get_masterlist';
		
		idstrutturaasl=v->'user_info'->'id_struttura_root';
	
		raise notice 'idstrutturaasl: %', idstrutturaasl;
	
		/*select json_agg(row_to_json(x.*)) into rt from (
		SELECT 
    t.livello,t.id_node,t.id_node_parent,t.id,t.sigla descrizione_breve ,t.descrizione,t.sigla
   FROM dblink('dbname=gisa_fvg user=postgres'::text, 
          'select 0 livello, -1::bigint as id_node,null::bigint id_node_parent,           -1::bigint id, ''MASTER LIST'' as sigla,''MASTER LIST'' descrizione from public.master_list_macroarea
				union
		   select 1 livello, id*10+1    as id_node,-1 id_node_parent,                     id, codice_sezione as sigla,macroarea descrizione from public.master_list_macroarea
				union
		   select 2 livello, id*10+2    as id_node,id_macroarea*10+1 as id_node_parent,   id, aggregazione codice_attivita,codice_attivita || '' - ''||aggregazione aggregazione from public.master_list_aggregazione
				union
		   select 3 livello, id*10+3    as id_node,id_aggregazione*10+2 as id_node_parent,id,linea_attivita codice_prodotto_specie, linea_attivita from master_list_linea_attivita
'::text) t(livello integer,id_node bigint,id_node_parent bigint,id bigint,sigla character varying,descrizione character varying)

		) x; */
	select json_agg(row_to_json(x.*)) into rt from (
	select 
	t.livello,t.id_node,t.id_node_parent,/*t.id,t.cod descrizione_breve ,case when t.cod = t.descr then t.cod
else t.cod ||' - '||t.descr end as descrizione,t.cod sigla */


t.id,
t.descr cod,
t.descr descrizione_breve,
case when t.cod = t.descr then t.cod
else t.cod ||' - '||t.descr end as descrizione,t.cod sigla
			
			



from
	agenda.vw_ag_tree_nodes_up_tipo_linee t order by t.path_ord collate "POSIX") x;
	
	
	
		if json_array_length(rt) is null then
			ret.esito:=true;	
    		--ret.msg:='master_list non trovata';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'master_list_non_trovata');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
 			ret.info:= rt;
	 		--ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_masterlist(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_nominativi_avvisi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_nominativi_avvisi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	n integer;
	rt json;
	struct varchar;
	responsabile bool;
	idutente bigint;
	idavviso bigint;

	begin
		proc_name:='agenda.get_nominativi_avvisi';
		--idstrutturaasl=v->'id_struttura_asl';
		idstrutturaasl=v->'user_info'->'id_struttura_root';
			responsabile:=v->'user_info'->'responsabile';
		idutente:=v->'user_info'->'id_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
		struct=v->'struct';
		idavviso:=v->'id_avviso';
raise notice 'STRUCT =%',struct;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
		if struct is not null and lower(replace(struct,'"',''))='tree' then
		raise notice 'IF STRUCT =>%<',struct;
			select json_agg(row_to_json(c.*)) into rt
			from (
			/*select id_node id,id_node*10+1 id_node,case when id_node=idstrutturaasl then null else id_node_parent*10+1 end id_node_parent ,
			descrizione ,descrizione_breve  ,descrizione_breve descrizione_composta,null id_nominativo , null id_struttura, false selezionato 
			from matrix.vw_tree_nodes_down_asl_descr tn where tn.id_node_ref =idstrutturaasl
			union 
			select	ns.id id,ns.id*10+2,id_node_struttura*10+1,
			nominativo descrizione,nominativo descrizione_breve,
			ns.descrizione_breve || ' - ' ||nominativo descrizione_composta,ns.id_nominativo ,ns.id_struttura,
			ar.id_avviso is not null selezionato
	     	from matrix.vw_nominativi_struttura ns join matrix.vw_tree_nodes_down  tn on tn.id_node =ns.id_node_struttura 
	     	left join agenda.avviso_risorse ar on ns.id = ar.id_risorsa and ar.id_avviso = idavviso
	    	where tn.id_node_ref =idstrutturaasl and (responsabile or (id_anagrafica=idutente))
	    	order by descrizione_breve*/
			select id_node id,id_node*10+1 id_node,case when id_node=idstrutturaasl then null else id_node_parent*10+1 end id_node_parent ,
			descrizione ,descrizione_breve  ,descrizione_breve descrizione_composta,null id_nominativo , null id_struttura, false selezionato  
			from matrix.vw_tree_nodes_down_asl_descr tn 
			where tn.id_node_ref =idstrutturaasl
				and  tn.id_node in (select id_node_ref  from matrix.vw_nominativi_struttura_validi_operativi ns
									join matrix.vw_tree_nodes_down  tn on tn.id_node =ns.id_node_struttura 
		    					)

			union 
			select	ns.id id,ns.id*10+2,id_node_struttura*10+1,
			nominativo descrizione,nominativo descrizione_breve,
			ns.descrizione_breve || ' - ' ||nominativo descrizione_composta,ns.id_nominativo ,ns.id_struttura,
			ar.id_avviso is not null selezionato
	     	from matrix.vw_nominativi_struttura_validi_operativi ns join matrix.vw_tree_nodes_down  tn on tn.id_node =ns.id_node_struttura
	     	left join agenda.avviso_risorse ar on ns.id = ar.id_risorsa and ar.id_avviso = idavviso
	    	where tn.id_node_ref =idstrutturaasl and (responsabile or (id_anagrafica=idutente))
	    	order by descrizione_breve
	    	) c ;
	    end if;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='nominativi non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'nominativi_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_nominativi_avvisi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_nominativi_calendario(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_nominativi_calendario(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	idelabcal bigint;
	rt json;

	begin
		proc_name:='agenda.get_nominativi_calendario';
		raise notice 'v=%',v;
		idelabcal:=v->'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v->>'id_gen_cal';
		end if;
		raise notice 'idelabcal=%',idelabcal;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
	select json_agg(row_to_json(g.*)) into rt from (
	select distinct id_nominativo ,nominativo,ns.id,ns.id as id_ns  from    matrix.vw_nominativi_struttura ns
			join agenda.elab_cal_param_ns pns on ns.id=pns.id_ns
			where pns.id_elab_cal=idelabcal
			order by nominativo
		) g;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='nominativi per calendario non trovato';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'nominativi_per_calendario_non_trovato');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_nominativi_calendario(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_nominativi_carico(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_nominativi_carico(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	idanagrafica bigint;
	idutente bigint;
	R_EV agenda.vw_calendari%ROWTYPE;
	responsabile bool;
	rt json;
	info bool;
	y integer;

	begin
		proc_name:='agenda.get_nominativi_carico';
		responsabile:=v->'user_info'->'responsabile';
		info:=v->'get_info';
		idutente:=v->'user_info'->'id_utente';
	
		raise notice 'RESPONSABILE %',responsabile;
		select value::integer into y from "Analisi_dev".config where descr='ANNO CORRENTE';
raise notice 'Y %',y;
		if replace((v->'user_info'->'id_struttura_root')::varchar,'"','') = 'null' 
							or responsabile is null or not responsabile or (info and info is not null) then
			raise notice 'NON RESPONSABILE';
			idstrutturaasl:= null;
			idanagrafica:=v->'id';
			if idanagrafica is null then
				idanagrafica:=v->'id_anagrafica';
			end if;
			select json_agg(row_to_json(c.*)) into rt  from (
			select row_to_json(c.*) from 
				(select * from agenda.vw_nominativi_carico a
			--where anno=y and a.id_anagrafica =idanagrafica order by nominativo,descrizione_breve) c;
				where (anno = y or anno is null) and a.id_nominativo in (select distinct id_nominativo from matrix.vw_nominativi_struttura where id_node_struttura
				in (select id_node from matrix.vw_tree_nodes_down_asl where id_node_ref =idstruttura ) )order by e.inizio,e.risorsa) c) c;

		else
			raise notice 'RESPONSABILE';
			idstrutturaasl=v->'user_info'->'id_struttura_root';
			select json_agg(row_to_json(c.*)) into rt  from (
			select --row_to_json
			(c.*) from 
				(select * from agenda.vw_nominativi_carico a where (anno = y or anno is null) and a.id_nominativo in
					(select distinct id_nominativo from matrix.vw_nominativi_struttura where anno=y and id_node_struttura
						in (select id_node from matrix.vw_tree_nodes_down_asl where id_node_ref =idstrutturaasl )) 
					order by nominativo) c) c;
		end if;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;

raise notice '%',json_array_length(rt);
		ret.esito:=true;
		ret.msg:=null;
 		--ret.info:=rt;
		ret.info:='{"dati":'||rt::varchar||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_nominativi_carico(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_nominativi_comuni(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_nominativi_comuni(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	responsabile bool;
	idutente bigint;
	idns bigint;
N Record;
	rt json;
str varchar;
R Record;

	begin
		proc_name:='agenda.get_nominativi_comuni';
		idstrutturaasl=v->'id_struttura_asl';
		responsabile:=v->'user_info'->'responsabile';
		idutente:=v->'user_info'->'id_utente';
		idns:=null;
		idns:=v->'id';

		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
		raise notice 'IDNS %', idns;
		--if idns is null then
			str:='{"nominativi":[';

			for N in select * from matrix.vw_nominativi_struttura ns where (idns is null and (ns.id_node_struttura=idstrutturaasl) and (responsabile or (id_anagrafica=idutente)))
			or (idns is not null and ns.id=idns)
			order by ns.nominativo  loop
				select json_agg(row_to_json(c.*)) into rt  from
	     			(select sc.*,case when nc.id is null then false else true end selezionato from agenda.vw_struttura_comuni sc 
left join agenda.vw_nominativo_comuni nc on nc.id_struttura =sc.id_struttura and nc.id_nominativo_struttura =N.id and sc.id_comune =nc.id_comune 
where  sc.id_struttura =N.id_node_struttura order by sc.comune) c;
				str:=str||row_to_json(N);
				str := left(str,length(str)-1);
				str:=str||',"comuni":'||rt||'},';
			raise notice 'STR=%',str;
			end loop;
			str := left(str,length(str)-1);
			str:= str||']}';
			raise notice 'STR=%',str;
		/*select json_agg(row_to_json(c.*)) into rt  from
	     (select * from agenda.vw_nominativo_comuni nc where  id_struttura =idstrutturaasl order by nc.nominativo ,nc.comune) c;*/
		
		--ret.valore:= id_record;
	
			raise notice '%',json_array_length(rt);
		/*else
			select * into N from matrix.vw_nominativi_struttura ns where (ns.id_node_struttura=idstrutturaasl) and (responsabile or (id_anagrafica=idutente))
			select json_agg(row_to_json(c.*)) into rt  from
	     			(select sc.*,case when nc.id is null then false else true end selezionato from agenda.vw_struttura_comuni sc 
					left join agenda.vw_nominativo_comuni nc on nc.id_struttura =sc.id_struttura and nc.id_nominativo_struttura =idns and sc.id_comune =nc.id_comune 
					where  sc.id_struttura =N.id_node_struttura
 						order by sc.comune) c;
			str:='{"comuni":'||rt||'}';
			raise notice 'ARRAY %',json_array_length(rt);
		raise notice 'STR %',str;
		end if;*/
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='comuni non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'comuni_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=str;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_nominativi_comuni(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_nominativi_uos(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_nominativi_uos(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	n integer;
	rt json;
	struct varchar;
	responsabile bool;
	idutente bigint;

	begin
		proc_name:='agenda.get_nominativi_uos';
		--idstrutturaasl=v->'id_struttura_asl';
		idstrutturaasl=v->'user_info'->'id_struttura_root';
			responsabile:=v->'user_info'->'responsabile';
		idutente:=v->'user_info'->'id_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
		struct=v->'struct';
raise notice 'STRUCT =%',struct;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
		if struct is not null and lower(replace(struct,'"',''))='tree' then
		raise notice 'IF STRUCT =>%<',struct;
			select json_agg(row_to_json(c.*)) into rt
			from (
			select id_node id,id_node*10+1 id_node,case when id_node=idstrutturaasl then null else id_node_parent*10+1 end id_node_parent ,
			descrizione ,descrizione_breve  ,descrizione_breve descrizione_composta,null id_nominativo , null id_struttura 
			from matrix.vw_tree_nodes_down_asl_descr tn 
			where tn.id_node_ref =idstrutturaasl
				and  tn.id_node in (select id_node_ref  from matrix.vw_nominativi_struttura_validi_operativi ns
									join matrix.vw_tree_nodes_down  tn on tn.id_node =ns.id_node_struttura 
		    					)

			union 
			select	ns.id id,ns.id*10+2,id_node_struttura*10+1,
			nominativo descrizione,nominativo descrizione_breve,
			ns.descrizione_breve || ' - ' ||nominativo descrizione_composta,ns.id_nominativo ,ns.id_struttura 
	     	from matrix.vw_nominativi_struttura_validi_operativi ns join matrix.vw_tree_nodes_down  tn on tn.id_node =ns.id_node_struttura 
	    	where tn.id_node_ref =idstrutturaasl and (responsabile or (id_anagrafica=idutente))
	    	order by descrizione_breve
	    	) c ;
		else
		raise notice 'ELSE STRUCT =%',struct;
			select count(*) into n 
	   		from  matrix.vw_tree_nodes_down tn
	    	where tn.id_node_ref =idstrutturaasl ;
	
			select json_agg(row_to_json(c.*)) into rt
			from (
				select	id,
					id_nominativo,
					id_struttura,
					case when n > 1 then nominativo ||' @ '||descrizione_breve else nominativo end as
					nominativo,
					descrizione_breve,
					id_node_struttura,
					ns.id id_nominativo_struttura
	     		from matrix.vw_nominativi_struttura_validi_operativi ns join matrix.vw_tree_nodes_down tn on tn.id_node =ns.id_node_struttura 
	    		where tn.id_node_ref =idstrutturaasl order by ns.descrizione_breve,ns.nominativo
	    	) c;
	    end if;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='nominativi non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'nominativi_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_nominativi_uos(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_nominativi_uos_by_asl(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_nominativi_uos_by_asl(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	n integer;
	rt json;
	struct varchar;
	responsabile bool;
	idutente bigint;
	v_idasl bigint;

	begin
		proc_name:='agenda.get_nominativi_uos';
		--idstrutturaasl=v->'id_struttura_asl';
		idstrutturaasl=v->'user_info'->'id_struttura_root';
		v_idasl=v->'user_info'->'id_asl';
			responsabile:=v->'user_info'->'responsabile';
		idutente:=v->'user_info'->'id_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
		struct=v->'struct';
raise notice 'STRUCT =%',struct;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
		if struct is not null and lower(replace(struct,'"',''))='tree' then
		raise notice 'IF STRUCT =>%<',struct;
			select json_agg(row_to_json(c.*)) into rt
			from (
			select id_node id,id_node*10+1 id_node,case when tn.n_livello=1 then null else id_node_parent*10+1 end id_node_parent ,
			descrizione ,descrizione_breve  ,descrizione_breve descrizione_composta,null id_nominativo , null id_struttura 
			from matrix.vw_tree_nodes_up_asl tn where tn.id_asl =v_idasl and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int
			union 
			select	ns.id id,ns.id*10+2,id_node_struttura*10+1,
			nominativo descrizione,nominativo descrizione_breve,
			ns.descrizione_breve || ' - ' ||nominativo descrizione_composta,ns.id_nominativo ,ns.id_struttura 
	     	from matrix.vw_nominativi_struttura ns join matrix.vw_tree_nodes_up_asl  tn on tn.id_node =ns.id_node_struttura 
	    	where tn.id_asl=v_idasl and tn.anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int
	    	order by descrizione_breve
	    	) c ;
		else
		raise notice 'ELSE STRUCT =%',struct;
			select count(*) into n 
	   		from  matrix.vw_tree_nodes_down tn
	    	where tn.id_node_ref =idstrutturaasl ;
	
			select json_agg(row_to_json(c.*)) into rt
			from (
				select	ns.id,
					id_nominativo,
					id_struttura,
					case when n > 1 then nominativo ||' @ '||ns.descrizione_breve else nominativo end as
					nominativo,
					ns.descrizione_breve,
					id_node_struttura,
					ns.id id_nominativo_struttura
	     		from matrix.vw_nominativi_struttura ns join matrix.vw_tree_nodes_up_asl tn on tn.id_node =ns.id_node_struttura 
	    		where tn.id_asl =v_idasl and tn.anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int order by ns.descrizione_breve,ns.nominativo
	    	) c;
	    end if;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='nominativi non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'nominativi_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_nominativi_uos_by_asl(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_nominativi_uos_selezionabile(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_nominativi_uos_selezionabile(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	n integer;
	rt json;
	struct varchar;
	responsabile bool;
	idutente bigint;

	begin
		proc_name:='agenda.get_nominativi_uos_selectable';
		--idstrutturaasl=v->'id_struttura_asl';
		idstrutturaasl=v->'user_info'->'id_struttura_root';
			responsabile:=v->'user_info'->'responsabile';
		idutente:=v->'user_info'->'id_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
		struct=v->'struct';
raise notice 'STRUCT =%',struct;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
		if struct is not null and lower(replace(struct,'"',''))='tree' then
		raise notice 'IF STRUCT =>%<',struct;
			select json_agg(row_to_json(c.*)) into rt
			from (
			select id_node id,id_node*10+1 id_node,case when id_node=idstrutturaasl then null else id_node_parent*10+1 end id_node_parent ,
			descrizione ,descrizione_breve  ,descrizione_breve descrizione_composta, true selezionabile
			from matrix.vw_tree_nodes_down_asl_descr tn where tn.id_node_ref =idstrutturaasl
			union 
			select	ns.id id,ns.id*10+2,id_node_struttura*10+1,
			nominativo descrizione,nominativo descrizione_breve,
			ns.descrizione_breve || ' - ' ||nominativo descrizione_composta, true selezionabile
	     	from matrix.vw_nominativi_struttura ns join matrix.vw_tree_nodes_down  tn on tn.id_node =ns.id_node_struttura 
	    	where tn.id_node_ref =idstrutturaasl and (responsabile or (id_anagrafica=idutente))
	    	order by descrizione_breve
	    	) c ;
		else
		raise notice 'ELSE STRUCT =%',struct;
			select count(*) into n 
	   		from  matrix.vw_tree_nodes_down tn
	    	where tn.id_node_ref =idstrutturaasl ;
	
			select json_agg(row_to_json(c.*)) into rt
			from (
				select	id,
					id_nominativo,
					id_struttura,
					case when n > 1 then nominativo ||' @ '||descrizione_breve else nominativo end as
					nominativo,
					descrizione_breve,
					id_node_struttura,
					ns.id id_nominativo_struttura, true selezionabile
	     		from matrix.vw_nominativi_struttura ns join matrix.vw_tree_nodes_down tn on tn.id_node =ns.id_node_struttura 
	    		where tn.id_node_ref =idstrutturaasl order by ns.descrizione_breve,ns.nominativo
	    	) c;
	    end if;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='nominativi non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'nominativi_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_nominativi_uos_selezionabile(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ns(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_ns(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	rt json;

	begin
		proc_name:='agenda.get_ns';
		idstrutturaasl=v->'user_info'->'id_struttura_root';
		if v->'user_info'->'responsabile' then
		
	    select json_agg(row_to_json(a.*)) into rt  from (
			/*select null id,id_node*10+1 id_node,case when id_node=idstrutturaasl then null else id_node_parent*10+1 end id_node_parent ,
			descrizione ,descrizione_breve  ,descrizione_breve descrizione_composta
			from matrix.vw_tree_nodes_down_asl_descr tn where tn.id_node_ref =idstrutturaasl
			union */
			select	ns.id_nominativo id,--ns.id*10+2,ns.id_node_struttura*10+1
			ns.nominativo descrizione,ns.nominativo descrizione_breve,ns.id id_ns,
			ns.descrizione_breve || ' - ' ||ns.nominativo descrizione_composta,ns.id_anagrafica
	     	from matrix.vw_nominativi_struttura ns join matrix.vw_tree_nodes_down  tn on tn.id_node =ns.id_node_struttura 
	    	where tn.id_node_ref =idstrutturaasl
				order by descrizione_breve) a;
		else
			    select json_agg(row_to_json(a.*)) into rt  from (
			/*select null id,id_node*10+1 id_node,case when id_node=idstrutturaasl then null else id_node_parent*10+1 end id_node_parent ,
			descrizione ,descrizione_breve  ,descrizione_breve descrizione_composta
			from matrix.vw_tree_nodes_down_asl_descr tn where tn.id_node_ref =idstrutturaasl
			union */
			select	ns.id_nominativo id,--ns.id*10+2,ns.id_node_struttura*10+1
			ns.nominativo descrizione,ns.nominativo descrizione_breve,ns.id id_ns,
			ns.descrizione_breve || ' - ' ||ns.nominativo descrizione_composta,ns.id_anagrafica
	     	from matrix.vw_nominativi_struttura ns 
	    	where ns.id_anagrafica=(v->'user_info'->'id_utente')::varchar::bigint and ns.id_struttura=idstrutturaasl
				order by descrizione_breve) a;
		end if;
		if json_array_length(rt) is null then
    		--ret.msg:='strutture piani non trovate';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'risorse_non_trovate');
    	else
    	 	ret.msg:=null;
    	end if;
    	ret.esito:=true;
    	ret.info:= rt; --'{"ns":'||rt::varchar;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_ns(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ns_az_sedi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_ns_az_sedi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idnominativostruttura bigint;
	idstrutturaasl bigint;
	rt json;
	R_NS matrix.vw_nominativi_struttura;
	--R_GD ag_ui.grid_definition;
	begin
		proc_name:='agenda.get_ns_az_sedi';
		idnominativostruttura=v->'id_nominativo_struttura';
	raise notice 'idnominativostruttura %', idnominativostruttura;
	select * into R_NS from matrix.vw_nominativi_struttura ns where id=idnominativostruttura;
	idstrutturaasl=v->'user_info'->'id_struttura_root';
	raise notice 'idstrutturaasl %',idstrutturaasl;

	--R_GD.str_conf:= ag_ui.get_ui_definition('grid',proc_name,idstrutturaasl,idtransazione);
	--raise notice 'R_GD.str_conf %',R_GD.str_conf;
	select json_agg(row_to_json(c.*)) into rt  from
    	(select distinct l.id_az_sede,id_azienda,l.denominazione_sede_operativa,l.indirizzo,l.id_comune,
    	l.rag_soc,l.piva,l.codfis,l.comune,l.cap,
    	nas.id is not null selezionato from agenda.vw_linee l
    		join agenda.piano_tipo_linea ptl on ptl.id_tipo_linea =l.id_attivita
			join agenda.vw_nominativo_comuni nc  on nc.id_comune =l.id_comune and nc.id_nominativo_struttura =83728
			join agenda.nominativo_piani np on np.id_nominativo_struttura =83728
							and ptl.id_piano =np.id_piano 
			left join agenda.nominativo_az_sedi nas on nas.id_nominativo_struttura =83728
						and nas.id_az_sede =l.id_az_sede
			--where nc.id_nominativo_struttura =idnominativostruttura
			 order by l.comune ,l.denominazione_sede_operativa 
		) c;

	--ret.valore:= id_record;

	raise notice '%',json_array_length(rt);

	if json_array_length(rt) is null then
		ret.esito:=true;	
		--ret.msg:='linee non trovate';
	    ret:=ag_ui.build_ret(ret,proc_name, 'stabilimenti_non_trovate');
		ret.info:=null; 
	else
		ret.esito:=true;
		ret.msg:=null;
 		ret.info:=rt;
 	 	--if R_GD.str_conf is not null then
 	 	ret.info:='{"dati":'||rt::varchar||'}';
 	 	--else
 	 		 --ret.info:=rt;
 	 	--end if;
	end if;
 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_ns_az_sedi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ns_linee(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_ns_linee(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idnominativostruttura bigint;
	idstrutturaasl bigint;
	rt json;
	R_NS matrix.vw_nominativi_struttura;
	--R_GD ag_ui.grid_definition;
	begin
		proc_name:='agenda.get_ns_linee';
		idnominativostruttura=v->'id_nominativo_struttura';
	raise notice 'idnominativostruttura %', idnominativostruttura;
	select * into R_NS from matrix.vw_nominativi_struttura ns where id=idnominativostruttura;

	--select * from agenda.grid_definition gd join matrix.matrix.vw_tree_nodes_down t on t.id_node=gd.id_user
	--where t.id_node=R_NS.id_node_struttura;

	/*
	select * into R_GD from ag_ui.grid_definition gd join matrix.vw_tree_nodes_down t on t.id_node_ref=gd.id_user
	where t.id_node=R_NS.id_node_struttura order by dist_node limit 1;*/

	--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
	--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
	idstrutturaasl=v->'user_info'->'id_struttura_root';
	raise notice 'idstrutturaasl %',idstrutturaasl;

	--R_GD.str_conf:= ag_ui.get_ui_definition('grid',proc_name,idstrutturaasl,idtransazione);
	--raise notice 'R_GD.str_conf %',R_GD.str_conf;
	select json_agg(row_to_json(c.*)) into rt  from
    	(/* AF 20240325 select distinct l.*,nl.id is not null selezionato from agenda.vw_linee l
    		join agenda.piano_tipo_linea ptl on ptl.id_tipo_linea =l.id_attivita
			join agenda.vw_nominativo_comuni nc  on nc.id_comune =l.id_comune and nc.id_nominativo_struttura =idnominativostruttura
			join agenda.nominativo_piani np on np.id_nominativo_struttura =idnominativostruttura
							and ptl.id_piano =np.id_piano 
			left join agenda.nominativo_linee nl on nl.id_nominativo_struttura =idnominativostruttura
						and nl.id_linea =l.id_linea
						where l.linea_principale or l.fonte='853'
			--where nc.id_nominativo_struttura =idnominativostruttura
			 order by l.comune ,l.denominazione_sede_operativa*/
    	select distinct l.*,nl.id is not null selezionato from agenda.vw_linee l
    		join agenda.piano_tipo_linea ptl on ptl.id_tipo_linea =l.id_attivita
			join agenda.vw_nominativo_comuni nc  on nc.id_comune =l.id_comune and nc.id_nominativo_struttura =idnominativostruttura
			join agenda.nominativo_piani np on np.id_nominativo_struttura =idnominativostruttura
							and ptl.id_piano =np.id_piano 
			left join agenda.nominativo_linee nl on --nl.id_nominativo_struttura =83645
						 nl.id_linea =l.id_linea
						where (l.linea_principale or l.fonte='853') and ( nl.id is null or nl.id_nominativo_struttura =idnominativostruttura)
			--where nc.id_nominativo_struttura =idnominativostruttura
			 order by nl.id is not null desc,l.comune ,l.denominazione_sede_operativa 
		) c;

	--ret.valore:= id_record;

	raise notice '%',json_array_length(rt);

	if json_array_length(rt) is null then
		ret.esito:=true;	
		--ret.msg:='linee non trovate';
	    ret:=ag_ui.build_ret(ret,proc_name, 'linee_non_trovate');
		ret.info:=null; 
	else
		ret.esito:=true;
		ret.msg:=null;
 		ret.info:=rt;
 	 	--if R_GD.str_conf is not null then
 	 	ret.info:='{"dati":'||rt::varchar||'}';
 	 	--else
 	 		 --ret.info:=rt;
 	 	--end if;
	end if;
 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_ns_linee(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ns_piani(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_ns_piani(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idnominativostruttura bigint;
	rt json;

	begin
		proc_name:='agenda.get_ns_piani';
		idnominativostruttura=v->'id_nominativo_struttura';

		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
		select json_agg(row_to_json(c.*)) into rt  from
	    	(			/*select distinct tn.*,case when np.id is null then false else true end selezionato, t.path_ord  from agenda.vw_asl_piani ap join matrix.vw_nominativi_struttura ns on ns.id_node_struttura =ap.id_struttura 
			join matrix.vw_tree_nodes_down_piani_descr t on t.id_node =ap.id_piano
			join matrix.tree_nodes tn on t.id_node_ref =tn.id
			left join agenda.nominativo_piani np on np.id_piano =tn.id and np.id_nominativo_struttura =ns.id
			where ns.id=idnominativostruttura
			order by t.path_ord*/
	    	select tp.id_node id,tp.id_node,tp.id_node_parent, 
	    	coalesce(tp.alias,'')||' '||tp.descrizione_breve descrizione_breve,coalesce(tp.alias,'')||' '||tp.descrizione descrizione,
		np.id is not null selezionato
from matrix.vw_tree_nodes_up_piani tp join
(select distinct id_node_ref id_node from matrix.vw_tree_nodes_down pd join
(select distinct id_piano from agenda.vw_asl_piani ap
join matrix.vw_nominativi_struttura ns on ns.id_node_struttura =ap.id_struttura 
--join  (select distinct id_node_ref matrix.vw_tree_nodes_down_piani_descr t on t.id_node =ap.id_piano
where ns.id=idnominativostruttura) p on p.id_piano=pd.id_node) p on tp.id_node =p.id_node
left join agenda.nominativo_piani np on np.id_piano =p.id_node and np.id_nominativo_struttura =idnominativostruttura
order by tp.path_ord 
	    	
	    	
	    	
	    	) c;

		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='piani non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'piani_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_ns_piani(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_piani(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_piani(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	idelabcal bigint;
	rt json;

	begin
		proc_name:='agenda.get_piani';
		
		idstrutturaasl=v->'user_info'->'id_struttura_root';
	
		raise notice 'idstrutturaasl: %', idstrutturaasl;
	
		select json_agg(row_to_json(x.*)) into rt from (
			select vp.id_node id,vp.id_node,vp.id_node_parent,
			coalesce(alias||' ','')||descrizione_breve descrizione_breve,
			coalesce(alias||' ','')||descrizione       descrizione
			from matrix.vw_tree_nodes_up_piani vp join
			(select distinct id_node_ref id_piano from 
					(select  distinct id_piano   
					from agenda.asl_piani ap 
					join matrix.vw_tree_nodes_down tn on ap.id_struttura=tn.id_node
					where tn.id_node_ref=idstrutturaasl) p 
				join matrix.vw_tree_nodes_down d on p.id_piano=d.id_node) a		
				on vp.id_node =a.id_piano 
				where vp.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text)
				-- #12230	-- vp.data_scadenza is null	
				order by vp.path_ord	) x;
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='piani non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'piani_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
 			ret.info:= rt;
	 		--ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_piani(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_piani_by_ns(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_piani_by_ns(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	idns bigint;
	rt json;

	begin
		proc_name:='agenda.get_piani_by_ns';
		
		--idns=v->'user_info'->'id_struttura_root';
		idns:=v->>'id_ns';
	
		select json_agg(row_to_json(x.*)) into rt from (
			select vp.id_node as id,vp.id_node,vp.id_node_parent,coalesce(alias||' ','')||descrizione_breve descrizione_breve,
			coalesce(alias||' ','')||descrizione descrizione 
				from matrix.vw_tree_nodes_up_piani vp /*join
				(select distinct p.id_node_ref id_ns_piano from  matrix.vw_tree_nodes_down_piani_descr p 
				 join  agenda.vw_nominativo_piani np 
					on np.id_nominativo_struttura=idns and np.id_piano=p.id_node) a
				on a.id_ns_piano =vp.id_node */
				where anno=(select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int--(select max(anno) from matrix.tree_anno) 
				order by path_ord) x;
	    ret.esito:=true;
 		ret.msg:=null;
 	 	ret.info:= rt; --ret.info||',"piani":'||rt::varchar||'}';
 	 	ret.valore :=coalesce(json_array_length(rt),0);
		if coalesce(json_array_length(rt),0) <= 0 then
			ret.esito:=false;
    	    ret:=ag_ui.build_ret(ret,proc_name, 'piani_non_trovati');
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_piani_by_ns(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_piani_totali(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_piani_totali(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	idelabcal bigint;
	rt json;

	begin
		proc_name:='agenda.get_piani_totali';
		
		idstrutturaasl=v->'user_info'->'id_struttura_root';
	
		raise notice 'idstrutturaasl: %', idstrutturaasl;
	
		select json_agg(row_to_json(x.*)) into rt from (
			select  n.mn::bigint=vp.ordinamento as primo, n.mx::bigint=vp.ordinamento as ultimo, n.mn, n.mx, vp.ordinamento, vp.id_node id,vp.id_node,vp.id_node_parent,vp.path_ord,
			coalesce(alias||' ','')||descrizione_breve descrizione_breve,
			coalesce(alias||' ','')||descrizione       descrizione,
			vp.ordinamento, vp.inizio_validita, vp.fine_validita 
			from matrix.vw_tree_nodes_up_piani vp
			left join (select id_parent, min(sp.ordinamento) as mn, max(sp.ordinamento) as mx
					from matrix.tree_nodes tn
					join matrix.struttura_piani sp on tn.id = sp.id 
					group by 1) n on n.id_parent = vp.id_node_parent 
			where --vp.data_scadenza is null and
			 anno = 2024 --and vp.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text)
			order by vp.path_ord
				) x;
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='piani non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'piani_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
 			ret.info:= rt;
	 		--ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_piani_totali(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_piani_totali_spostamento(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_piani_totali_spostamento(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	idelabcal bigint;
	rt json;
	v_id_node bigint;
	--R_P matrix.vw_tree_nodes_up_piani;

	begin
		proc_name:='agenda.get_piani_totali';
		
		idstrutturaasl=v->'user_info'->'id_struttura_root';
	
		v_id_node:=v->'id_node';
	
		/*select * into R_P from matrix.vw_tree_nodes_up_piani vp
		where id_node_parent = v_id_node;*/
	
		raise notice 'idstrutturaasl: %', idstrutturaasl;
	
		select json_agg(row_to_json(x.*)) into rt from (
			select vp.id_node id,vp.id_node,vp.id_node_parent,vp.path_ord,
			coalesce(alias||' ','')||descrizione_breve descrizione_breve,
			coalesce(alias||' ','')||descrizione       descrizione,
			vp.ordinamento 
			from matrix.vw_tree_nodes_up_piani vp
			where vp.data_scadenza is null and anno = 2024 and vp.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text)
			and vp.id_node not in (select id_node from matrix.vw_tree_nodes_down_piani where id_node_ref=v_id_node)
		
			--<> v_id_node_parent and vp.id_node_parent <> v_id_node_parent
			order by vp.path_ord	) x;
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='piani non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'piani_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
 			ret.info:= rt;
	 		--ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_piani_totali_spostamento(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_piano_freq(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_piano_freq(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idpiano bigint;
	idelabcal bigint;
	rt json;
	str varchar;

	begin
		proc_name:='agenda.get_piani_freq';
		
		idpiano=v->'id_piano';
	 	select json_agg(descr_livello_rischio) into str from 
			(select descr_livello_rischio from public.vw_livelli_rischio order by ord_livello_rischio) a	;
		select json_agg(row_to_json(x.*)) into rt from (
			select * from agenda.vw_piano_freq where id_piano=idpiano
		) x;
    	ret.esito:=true;
 		ret.msg:=null;

 		ret.info:= '{"livelli":'||str ||',"piano_freq":'||coalesce(rt,'""')||'}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_piano_freq(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_piano_periodo(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_piano_periodo(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idpiano bigint;
	idelabcal bigint;
	rt json;

	begin
		proc_name:='agenda.get_piani_periodo';
		
		idpiano=v->'id_piano';
		select json_agg(row_to_json(x.*)) into rt from (
			select * from agenda.vw_piani_periodo where id_piano=idpiano
		) x;
    	ret.esito:=true;
 		ret.msg:=null;
 		ret.info:= rt;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_piano_periodo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_piano_singolo(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_piano_singolo(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	v_idpiano bigint;
	idelabcal bigint;
	rt json;

	begin
		proc_name:='agenda.get_piano_singolo';
		
		idstrutturaasl=v->'user_info'->'id_struttura_root';
	
		v_idpiano = v->'id_piano';
		raise notice 'id_piano: %',v_idpiano;
	
		raise notice 'idstrutturaasl: %', idstrutturaasl;
	
		select json_agg(row_to_json(x.*)) into rt from (
			select vp.id_node id,vp.id_node,vp.id_node_parent,vp.path_ord, 
			coalesce(alias||' ','')||descrizione_breve descrizione_breve,
			coalesce(alias||' ','')||descrizione       descrizione,
			vp.alias, vp.ordinamento, vp.inizio_validita, vp.fine_validita 
			from matrix.vw_tree_nodes_up_piani vp
			where --vp.data_scadenza is null and 
			anno = 2024
			--and vp.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text) 
			and vp.id = v_idpiano	order by vp.path_ord	) x;
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='piani non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'piani_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
 			ret.info:= rt;
	 		--ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_piano_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_rilevazione_quantita(bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_rilevazione_quantita(idtrfattivita bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
begin
	declare
	id_op bigint;
	R_ATT trf.trf_attivita%ROWTYPE;
	idtariffa bigint;
	rt json;
	j_tree json;
    max_lev integer;
    struttura varchar;
    ui_default varchar;
	begin 

	ui_default:='{"colonne":[{"campo":"descrizione","intestazione":"Descrizione","tipo":"text","editabile": false},{"campo":"valore","intestazione":"Valore","tipo":"text","editabile": true}]}';
	select * into R_ATT from trf.trf_attivita where id=idtrfattivita;
	idtariffa:=R_ATT.id_tariffa;

WITH RECURSIVE c AS (
    SELECT id_node, id_node_parent, sigla_tariffa, --descr_tariffa, --#10409
    descr_con_u_mis as descr_tariffa, 0 as livello 
    FROM matrix.vw_tree_nodes_tariffario_descr t 
    -- use parameters here, to select the root first
    WHERE id_node=idtariffa and visibile_trf --2174 --AND id_parent IS NULL
  UNION ALL
    SELECT t.id_node,t.id_node_parent,t.sigla_tariffa,--t.descr_tariffa, --#10409
    descr_con_u_mis as descr_tariffa, c.livello + 1 as livello
    FROM matrix.vw_tree_nodes_tariffario_descr t
    JOIN c ON t.id_node_parent = c.id_node and visibile_trf 
) select max(livello) into max_lev from c;
	struttura:= CASE WHEN MAX_LEV=3 THEN '[{"nome":"RADICE"},{"nome":"SEZIONI"},{"nome":"RIGHE"},{"nome":"COLONNE"}]' 
			         WHEN MAX_LEV=2 THEN '[{"nome":"RADICE"},{"nome":"SEZIONI"},{"nome":"RIGHE"}]'
			         WHEN MAX_LEV=1 THEN '[{"nome":"RADICE"},{"nome":"RIGHE"}]'
			         WHEN MAX_LEV=0 THEN '[{"nome":"RADICE"}]' end;
-- calculate node levels select array_to_json('{"prova","1"}'::varchar[])
WITH RECURSIVE c AS (
    SELECT path_ord,id_node,id_node_parent ,sigla_tariffa sigla,--descr_tariffa descrizione, --#10409
    descr_con_u_mis as descrizione, 0 as livello,d.valore ,coalesce(u.ui_info,ui_default) ui_info
    ,array_to_json(array_append(array_append(null,/*descr_tariffa #10409*/descr_con_u_mis::varchar),coalesce(d.valore,'')::varchar))::varchar lista_valori,t.limite_inf,t.limite_sup
    FROM matrix.vw_tree_nodes_tariffario_descr t left join trf.trf_attivita_dettagli d on d.id_tariffa= t.id_node and d.id_trf_attivita=idtrfattivita
    	left join trf_ui.trf_ui u on u.id_tariffa=t.id_node and visibile_trf 
    -- use parameters here, to select the root first
    WHERE id_node=idtariffa --2174 --AND id_parent IS NULL
  UNION ALL
    SELECT t.path_ord,t.id_node,t.id_node_parent,t.sigla_tariffa sigla ,--descr_tariffa descrizione, --#10409
    descr_con_u_mis as descrizione, c.livello + 1 as livello,d.valore,coalesce(u.ui_info,ui_default) ui_info
    ,array_to_json(array_append(array_append(null,t./*descr_tariffa #10409*/descr_con_u_mis::varchar),coalesce(d.valore,'')::varchar))::varchar lista_valori,t.limite_inf,t.limite_sup
    FROM matrix.vw_tree_nodes_tariffario_descr t left join trf.trf_attivita_dettagli d on d.id_tariffa= t.id_node and d.id_trf_attivita=idtrfattivita
    left join trf_ui.trf_ui u on u.id_tariffa=t.id_node
    JOIN c ON t.id_node_parent = c.id_node
    where visibile_trf 
),
-- select max level
max_livello AS (
  SELECT max(livello) max_livello FROM c
),
-- accumulate children
j AS (
    SELECT c.*, json '[]' sezioni -- at max level, there are only leaves
    FROM c, max_livello
    WHERE livello = max_livello
  UNION ALL
    -- a little hack, because PostgreSQL doesn't like aggregated recursive terms
    SELECT (c).*, array_to_json(array_agg(j  order by path_ord)) sezioni
    FROM (
      SELECT c, j,j.path_ord
      FROM j
      JOIN c ON j.id_node_parent = c.id_node order by path_ord
    ) v
    GROUP BY v.c
)
-- select only root
SELECT row_to_json(j) json_tree into j_tree
FROM j
WHERE livello = 0;

	struttura:= '{"struttura":'||struttura||',"dati":'||j_tree||'}';
raise notice 'STRUTTURA %',struttura;
	rt:= struttura::json;

	return rt;
	end;
end;
$$;


ALTER FUNCTION agenda.get_rilevazione_quantita(idtrfattivita bigint) OWNER TO postgres;

--
-- Name: get_risorsa_singolo(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_risorsa_singolo(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	n integer;
	rt json;
	struct varchar;
	responsabile bool;
	idutente bigint;
	v_id_risorsa bigint;
	v_id_nominativo bigint;

	begin
		proc_name:='agenda.get_risorsa_singolo';
		--idstrutturaasl=v->'id_struttura_asl';
		idstrutturaasl=v->'user_info'->'id_struttura_root';
		responsabile:=v->'user_info'->'responsabile';
		idutente:=v->'user_info'->'id_utente';
		if v->'id_risorsa' is not null then
			v_id_risorsa:=v->'id_risorsa';
			raise notice 'id_risorsa%',v_id_risorsa;
			select json_agg(row_to_json(c.*)) into rt
			from (
			select id_node id,id_node*10+1 id_node,case when id_node=idstrutturaasl then null else id_node_parent*10+1 end id_node_parent ,
			descrizione ,descrizione_breve  ,descrizione_breve descrizione_composta,null id_nominativo , null id_struttura 
			from matrix.vw_tree_nodes_down_asl_descr tn where tn.id_node_ref = idstrutturaasl and tn.id_node = v_id_risorsa limit 1
			) c ;
		else
			v_id_nominativo:=v->'id_nominativo';
			raise notice 'id_nominativo%',v_id_nominativo;
			select json_agg(row_to_json(c.*)) into rt
			from (
			select	ns.id id,ns.id*10+2 id_nominativo_struttura,id_node_struttura*10+1 id_node,
			nominativo descrizione,nominativo descrizione_breve,
			ns.descrizione_breve || ' - ' ||nominativo descrizione_composta,ns.id_nominativo ,ns.id_struttura 
	     	from matrix.vw_nominativi_struttura ns join matrix.vw_tree_nodes_down  tn on tn.id_node =ns.id_node_struttura 
	    	where tn.id_node_ref =idstrutturaasl and (responsabile or (id_anagrafica=idutente)) and ns.id = v_id_nominativo
	    	order by descrizione_breve
	    	) c ;
		end if;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='nominativi non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, null);
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_risorsa_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_risorse(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_risorse(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	n integer;
	rt json;
	struct varchar;
	responsabile bool;
	idutente bigint;

	begin
		proc_name:='agenda.get_risorse';
		--idstrutturaasl=v->'id_struttura_asl';
		idstrutturaasl=v->'user_info'->'id_struttura_root';
			responsabile:=v->'user_info'->'responsabile';
		idutente:=v->'user_info'->'id_utente';
			select json_agg(row_to_json(c.*)) into rt
			from (
			select id_node id,id_node*10+1 id_node,case when id_node=idstrutturaasl then null else id_node_parent*10+1 end id_node_parent ,
			descrizione ,descrizione_breve  ,descrizione_breve descrizione_composta,null id_nominativo , null id_struttura ,
			tn.inizio_validita, tn.fine_validita 
			from matrix.vw_tree_nodes_down_asl_descr tn where tn.id_node_ref =idstrutturaasl
			--and tn.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text)
			and tn.validita @> current_timestamp::timestamp
			/*union 
			select	ns.id id,ns.id*10+2,id_node_struttura*10+1,
			nominativo descrizione,nominativo descrizione_breve,
			ns.descrizione_breve || ' - ' ||nominativo descrizione_composta,ns.id_nominativo ,ns.id_struttura 
	     	from matrix.vw_nominativi_struttura ns join matrix.vw_tree_nodes_down  tn on tn.id_node =ns.id_node_struttura 
	    	where tn.id_node_ref =idstrutturaasl and (responsabile or (id_anagrafica=idutente))
	    	order by descrizione_breve */
	    	) c ;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='nominativi non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'organigramma_risorse_non_trovate');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_risorse(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_stato_eventi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_stato_eventi(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
	flusso text;
 

	begin
	proc_name:='agenda.get_stato_eventi';
	
		select json_agg(row_to_json(c.*)) into rt  from (
		  select * from ag_types.vw_ag_stato_eventi order by sigla_tipo,effettuata,scaduta) c;

		raise notice '%',rt;	
		if rt is null then
			ret.esito:=false;	
    	    ret:=ag_ui.build_ret(ret,proc_name, 'Valori non trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null; 		 		
 			ret.info:='{"dati":' || rt;
			ret.info:=ret.info || '}';

		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_stato_eventi(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_strutture_asl(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_strutture_asl(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	rt json;
	

	begin
		set search_path to agenda, matrix,public, "$user";
		proc_name:='agenda.get_strutture_asl';
		--idstrutturaasl=v->'id_struttura_asl';
		idstrutturaasl=v->'user_info'->'id_struttura_root';
		raise notice 'idstrutturaasl%',idstrutturaasl;

			select json_agg(row_to_json(a.*)) into rt  from (
				select n.mn::bigint=c.ordinamento::bigint as primo, n.mx::bigint=c.ordinamento::bigint as ultimo,
				n.mn, n.mx, c.name_tree,c.id_node,c.id_tree,
				case when c.id_node=idstrutturaasl then null else c.id_node_parent end id_node_parent,
				c.id_node_ref,c.id,c.id_gisa,c.id_asl,c.codice_interno_fk, c.ordinamento, 
				    c.descrizione descrizione,c.n_livello,c.anno,c.descrizione_breve,c.ups,c.uba,
				    c.inizio_validita, c.fine_validita 
				from matrix.vw_tree_nodes_down_asl_descr c 
				left join (select id_parent, min(sa.ordinamento) as mn, max(sa.ordinamento) as mx
					from matrix.tree_nodes tn
					join matrix.vw_tree_nodes_down_asl_descr sa on tn.id = sa.id 
					join matrix.struttura_asl sa2 on tn.id = sa2.id
					--where sa.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text) 
					group by 1) n on n.id_parent = c.id_node_parent 
				where  c.id_node_ref =idstrutturaasl --and c.data_Scadenza is null and c.trashed_date is null 
				--and c.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text) 
				order by c.ordinamento, c.descrizione_breve) a;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='strutture non trovate';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'strutture_non_trovate');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	

	 	return ret;
	end;
end;
$_$;


ALTER FUNCTION agenda.get_strutture_asl(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_strutture_asl_singolo(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_strutture_asl_singolo(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	rt json;
	v_id_node bigint;

	begin
		set search_path to agenda, matrix,public, "$user";
		proc_name:='agenda.get_strutture_asl_singolo';
		--idstrutturaasl=v->'id_struttura_asl';
		idstrutturaasl=v->'user_info'->'id_struttura_root';
		v_id_node:=v->'id_node';

			select json_agg(row_to_json(a.*)) into rt  from (
				select c.name_tree,c.id_node,c.id_tree,case when c.id_node=idstrutturaasl then null else c.id_node_parent end id_node_parent,
				c.id_node_ref,c.id,c.id_gisa,c.id_asl,c.codice_interno_fk, c.ordinamento,
				    c.descrizione descrizione,c.n_livello,c.anno,c.descrizione_breve,c.ups,c.uba,
				c.inizio_validita, c.fine_validita 
				from matrix.vw_tree_nodes_down_asl_descr c 
				where  c.id_node_ref =idstrutturaasl --and c.data_Scadenza is null 
				--and c.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text)
				--and c.trashed_date is null 
				and c.id = v_id_node order by c.descrizione_breve) a;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='strutture non trovate';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'struttura_singolo_non_trovata');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	

	 	return ret;
	end;
end;
$_$;


ALTER FUNCTION agenda.get_strutture_asl_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_strutture_by_asl(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_strutture_by_asl(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	v_idasl bigint;

	begin
		proc_name:='agenda.get_strutture_by_asl';
		v_idasl=v->>'id_asl';
	
		if v_idasl != -1 then
			select json_agg(row_to_json(a.*)) into rt  from (	
	    		select id_node id
				,id_node*10+1 id_node
				,case when tn.n_livello=1 then null else id_node_parent*10+1 end id_node_parent
				,n_livello,id_asl,descrizione,descrizione_breve
				from matrix.vw_tree_nodes_up_asl tn where tn.id_asl = v_idasl and 
				n_livello >= 0 and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int
				order by descrizione_breve
			) a;
		else
			select json_agg(row_to_json(a.*)) into rt  from (
				select id_node id
				,id_node*10+1 id_node
				,case when tn.n_livello=0 then null else id_node_parent*10+1 end id_node_parent
				,n_livello,id_asl,descrizione,descrizione_breve
				from matrix.vw_tree_nodes_up_asl tn where --tn.id_asl = 205 and 
				n_livello = 0 /*between 0 and 2*/ and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int
				order by descrizione_breve
			) a;
		end if;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='nominativi non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'strutture_non_trovate');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_strutture_by_asl(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tipi_avviso(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_tipi_avviso(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	responsabile bool;
	rt json;

	begin
		proc_name:='agenda.get_tipi_avviso';
		responsabile:=v->'user_info'->'responsabile';
		raise notice 'RESPONSABILE %',responsabile;
			--select json_agg(row_to_json(c.*)) into rt  from 
			select json_agg(row_to_json(g.*)) into rt from (
			select * from ag_types.vw_ag_tipo_avvisi vala) g;

			if json_array_length(rt) is null then
				ret.esito:=false;	
	    		--ret.msg:='calendari non trovati';
	    	    ret:=ag_ui.build_ret(ret,proc_name, 'avvisi_non_trovati');
	    		ret.info:=null; 
	    		return ret;
	    	end if;

		ret.esito:=true;
		ret.msg:=null;
 		ret.info:='{"dati":'||rt::varchar||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_tipi_avviso(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tipo_linee_per_piani(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_tipo_linee_per_piani(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idpiano bigint;
	idelabcal bigint;
	rt json;

	begin
		proc_name:='agenda.get_tipo_linee_per_piani';
		
		idpiano=v->'id_piano';
		select json_agg(row_to_json(x.*)) into rt from (
			select tl.name_tree,
tl.id_node,
tl.id_tree,
tl.id_node_parent,
tl.descr path ,
tl.path_ord,
tl.descr path_descr,
tl.id,
tl.descr cod,
tl.descr descrizione_breve,
case when tl.cod = tl.descr then tl.cod
else tl.cod ||' - '||tl.descr end as descrizione
			
			, ptl.id is not null selezionato from agenda.vw_ag_tree_nodes_up_tipo_linee tl
			left join agenda.piano_tipo_linea ptl on tl.id = ptl.id_tipo_linea and ptl.id_piano = idpiano
			order by tl.path_ord collate "POSIX"
		) x;

		if json_array_length(rt) is null then
			ret.esito:=true;	
    		--ret.msg:='piani non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'piani_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
 			ret.info:= rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_tipo_linee_per_piani(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tipo_liste(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_tipo_liste(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
	flusso text;
 

	begin
	proc_name:='agenda.get_tipo_liste';
	
		select json_agg(row_to_json(c.*)) into rt  from (	  
				select 
		 		case when cc.num is null or cc.num =0 then false
                else true end liste_associate,  tl.*,
                tlp.lista_piani
		  from  agenda.vw_tipo_liste tl 
		  left join  (
		  select count(*) num ,l.id_tipo_lista  
			from  agenda.vw_tipo_liste l
			inner join  agenda.lista_import i on i.id_tipo_lista =l.id
			
			where dt is not null  
			group by l.id_tipo_lista
	   ) cc on cc.id_tipo_lista= tl.id
	   left join (select id_tipo_lista, string_agg(alias,', ') lista_piani	--2024-03-11
	   from agenda.vw_tipo_lista_piani group by 1 ) tlp on tl.id_tipo_lista = tlp.id_tipo_lista
	  ORDER BY descr ) c;

		raise notice '%',rt;	
		if rt is null then
			ret.esito:=false;	
    	    ret:=ag_ui.build_ret(ret,proc_name, 'Valori non trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null; 		 		
 			ret.info:='{"dati":' || rt;
			ret.info:=ret.info || '}';

		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_tipo_liste(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tipolista_piani(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_tipolista_piani(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idtipolistaP bigint;
	rt json;

	begin
		proc_name:='agenda.get_tipolista_piani';
		idtipolistaP=v->'id_tipo_lista';
	

 
		select json_agg(row_to_json(c.*)) into rt  from
	    	(
		/*	select  
			tp.id_node id,tp.id_node,tp.id_node_parent, 
			coalesce(tp.alias,'')||' '||tp.descrizione_breve descrizione_breve,coalesce(tp.alias,'')||' '||tp.descrizione descrizione,
			tlp.id is not null selezionato ,
			case when tlp2.id is not null    then true
      	    else false end disabled
			from matrix.vw_tree_nodes_up_piani tp 
			left join agenda.tipo_lista_piano tlp on tp.id = tlp.id_piano  and tlp.id_tipo_lista  = idtipolistaP
		    left join agenda.tipo_lista_piano tlp2 on tp.id = tlp2.id_piano and tlp2.id_tipo_lista!= idtipolistaP
			WHERE tp.anno=extract( year from current_timestamp)
			--and tp.id not in (select id_piano  from agenda.vw_tipo_lista_piani  where id_tipo_lista!=idtipolista)	--2024-03-11
		
			order by tp.path_ord collate "POSIX"
		*/	
		/*
	    	select  
			tp.id_node id,tp.id_node,tp.id_node_parent, 
			coalesce(tp.alias,'')||' '||tp.descrizione_breve descrizione_breve,coalesce(tp.alias,'')||' '||tp.descrizione descrizione,
			tlp.id is not null selezionato 
			from matrix.vw_tree_nodes_up_piani tp 
			left join agenda.tipo_lista_piano tlp on tp.id = tlp.id_piano  and tlp.id_tipo_lista  = idtipolista
		    left join agenda.tipo_lista_piano tlp2 on tp.id = tlp2.id_piano and tlp2.id_tipo_lista!= idtipolista
			WHERE tp.anno=extract( year from current_timestamp)
			 and tp.id not in (select id_piano  from agenda.vw_tipo_lista_piani  where id_tipo_lista!=idtipolista)	--2024-03-11
		
			order by tp.path_ord collate "POSIX"
		*/
		   	
	    	
	    	/* AF 20240316
 	       select  
			tp.id_node id,tp.id_node,tp.id_node_parent, 
			coalesce(tp.alias,'')||' '||tp.descrizione_breve descrizione_breve,coalesce(tp.alias,'')||' '||tp.descrizione descrizione,
			tlp.id is not null selezionato ,dis.disabled			
			from matrix.vw_tree_nodes_up_piani tp 
			left join agenda.tipo_lista_piano tlp on tp.id = tlp.id_piano  and tlp.id_tipo_lista  = idtipolistaP
			left join 
				(
				select 
				      case when coalescE(countPianiAltri,0) = countTotale then  true
				      else   false end disabled,	a.id_node_parent 
				from (
				
				 	SELECT 	 count(*)countTotale ,id_node_parent
					FROM 
					matrix.vw_tree_nodes_up_piani tp 
				    WHERE anno = extract( year from current_timestamp) and livello =3   
			 		group by tp.id_node_parent
			 	)a 
		 		left join (
			 		SELECT 	count(*)countPianiAltri ,id_node_parent
					FROM 
					matrix.vw_tree_nodes_up_piani tp 
					left join agenda.tipo_lista_piano tlp2 on tp.id = tlp2.id_piano and tlp2.id_tipo_lista!=  idtipolistaP
				    WHERE anno = extract( year from current_timestamp) and livello =3--   and   (id_node_parent=6656706 OR id_node=6656706)
				    and tlp2.id is not  null
			 		group by id_node_parent
		 		) b on b.id_node_parent=a.id_node_parent
			 	 
		 	)		dis on dis.id_node_parent=tp.id_node_parent  or tp.id_node=dis.id_node_parent
			WHERE tp.anno=extract( year from current_timestamp)
			order by tp.path_ord collate "POSIX"
 
        	) c; */
	    	
	    	select 
			p.id,p.id_node,p.id_node_parent, 
			coalesce(p.alias,'')||' '||p.descrizione_breve descrizione_breve,coalesce(p.alias,'')||' '||p.descrizione descrizione,
			lp.id is not null selezionato,dis.disabled from			
				matrix.vw_tree_nodes_up_piani p
				left join agenda.tipo_lista_piano lp on lp.id_piano =p.id and lp.id_tipo_lista = idtipolistaP
				join (
					select id_node_ref,sum(case when lp.id_piano is null then 1 else 0 end) = 0 disabled 
					from matrix.vw_tree_nodes_down_piani_descr p
					left join agenda.tipo_lista_piano lp on lp.id_piano =p.id_node and lp.id_tipo_lista != idtipolistaP
					where p.id_node not in (select distinct id_node_parent from matrix.vw_tree_nodes_piani where id_node_parent is not null) and
						  p.anno=extract( year from current_timestamp)
					group by id_node_ref
				) dis on dis.id_node_ref=p.id_node
			where p.anno=extract( year from current_timestamp)
			) c;
 
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	 
    	    ret:=ag_ui.build_ret(ret,proc_name, 'tipo_lista_piani_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_tipolista_piani(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tipologia_controllo_piani(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_tipologia_controllo_piani(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idpiano bigint;
	rt json;
	isp record;
	ret2 cu_types.result_type;
	begin
		proc_name:='agenda.get_tipologia_controllo_piani';
		idpiano=v->'id_piano';
		raise notice 'v=%',v;
	
		select json_agg(row_to_json(a.*)) into rt from (
		SELECT aute.id,aute.sigla,aute.descr, tcp.id is not null selezionato
   			FROM ag_types.vw_ag_tipo_eventi aute
			--FROM ag_ui.ag_ui_tipo_eventi aute 
   			JOIN matrix.struttura_piani p on 1=1
     		left JOIN agenda.tipologia_controllo_piani tcp ON tcp.id_tipologia_controllo  = aute.id and p.id=tcp.id_piano 
			where p.id=idpiano
			order by aute.descr asc
     		)a;
		raise notice '%',json_array_length(rt);
    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:='{"dati":'||rt||'}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_tipologia_controllo_piani(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_unita_di_crisi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_unita_di_crisi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	v_responsabile bool;
	idasl bigint;
	begin
		proc_name:='agenda.get_unita_di_crisi_fvg';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_responsabile:=v->'user_info'->'responsabile';
		--idasl:=v->'user_info'->'id_asl';
		if v->'user_info'->>'id_asl' is null or v->'user_info'->>'id_asl' = 'null' then
			idasl = -1;
		else
			idasl:=v->'user_info'->>'id_asl';
		end if;
		if idasl = -1 then
			select json_agg(row_to_json(g.*)) into rt from (
				select *, (idasl=-1 or idasl=id_asl) and v_responsabile is true as aggiungi_unita_di_crisi
				from agenda.vw_unita_di_crisi 
				) g;
		else
			select json_agg(row_to_json(g.*)) into rt from (
				select *, (idasl=-1 or idasl=id_asl) and v_responsabile is true as aggiungi_unita_di_crisi
				from agenda.vw_unita_di_crisi 
				where id_asl = idasl) g;
		end if;
	
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=ag_ui.build_ret(ret,proc_name, 'unita_di_crisi_non_trovata');
    	else
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_unita_di_crisi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_unita_di_crisi_as_fo(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_unita_di_crisi_as_fo(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	v_responsabile bool;
	idasl bigint;
	begin
		proc_name:='agenda.get_unita_di_crisi_as_fo';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_responsabile:=v->'user_info'->'responsabile';
		idasl:=v->'user_info'->'id_asl';
		select json_agg(row_to_json(g.*)) into rt from (
			select *, (idasl=-1 or idasl=id_asl) and v_responsabile is true as aggiungi_as_fo 
		from agenda.vw_unita_di_crisi_as_fo) g;
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=ag_ui.build_ret(ret,proc_name, 'unita_di_crisi_as_fo_non_trovata');
    	else
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_unita_di_crisi_as_fo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_unita_di_crisi_asu_fc(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_unita_di_crisi_asu_fc(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	v_responsabile bool;
	idasl bigint;
	begin
		proc_name:='agenda.get_ag_conf';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_responsabile:=v->'user_info'->'responsabile';
		idasl:=v->'user_info'->'id_asl';
		select json_agg(row_to_json(g.*)) into rt from (
			select *, (idasl=-1 or idasl=id_asl) and v_responsabile is true as aggiungi_asu_fc
			from agenda.vw_unita_di_crisi_asu_fc) g;
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=ag_ui.build_ret(ret,proc_name, 'unita_di_crisi_as_fo_non_trovata');
    	else
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_unita_di_crisi_asu_fc(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_unita_di_crisi_asu_gi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_unita_di_crisi_asu_gi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	v_responsabile bool;
	idasl bigint;
	begin
		proc_name:='agenda.get_ag_conf';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_responsabile:=v->'user_info'->'responsabile';
		idasl:=v->'user_info'->'id_asl';
		select json_agg(row_to_json(g.*)) into rt from (
			select *, (idasl=-1 or idasl=id_asl) and v_responsabile is true as aggiungi_asu_gi 
		from agenda.vw_unita_di_crisi_asu_gi) g;
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=ag_ui.build_ret(ret,proc_name, 'unita_di_crisi_as_fo_non_trovata');
    	else
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_unita_di_crisi_asu_gi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_unita_di_crisi_fvg(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_unita_di_crisi_fvg(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	v_responsabile bool;
	idasl bigint;
	begin
		proc_name:='agenda.get_unita_di_crisi_fvg';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_responsabile:=v->'user_info'->'responsabile';
		idasl:=v->'user_info'->'id_asl';
		select json_agg(row_to_json(g.*)) into rt from (
			select *, (idasl=-1 or idasl=id_asl) and v_responsabile is true as aggiungi_fvg
		from agenda.vw_unita_di_crisi_fvg) g;
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=ag_ui.build_ret(ret,proc_name, 'unita_di_crisi_fvg_non_trovata');
    	else
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_unita_di_crisi_fvg(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_unita_di_crisi_singolo(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_unita_di_crisi_singolo(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	tipo varchar;
	id_unita bigint;
	begin
		proc_name:='agenda.get_unita_di_crisi_singolo';
		tipo:=v->>'tipo';
		id_unita:=v->>'id_unita';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		if tipo ilike 'fvg' then
			select json_agg(row_to_json(g.*)) into rt from (
				select * from agenda.vw_unita_di_crisi where id = id_unita) g;
			raise notice '%',json_array_length(rt);
			ret.info:=null;
			ret.esito:=true;	
			if json_array_length(rt) is null then
				ret.esito:=false;
	    	    ret:=ag_ui.build_ret(ret,proc_name, 'unita_di_crisi_fvg_non_trovata');
	    	else
		 		ret.info:='{"dati":'||rt||'}';
			end if;
		 	return ret;
		elsif tipo ilike 'asu_fc' then
			select json_agg(row_to_json(g.*)) into rt from (
				select * from agenda.vw_unita_di_crisi where id = id_unita) g;
			raise notice '%',json_array_length(rt);
			ret.info:=null;
			ret.esito:=true;	
			if json_array_length(rt) is null then
				ret.esito:=false;
	    	    ret:=ag_ui.build_ret(ret,proc_name, 'unita_di_crisi_asu_fc_non_trovata');
	    	else
		 		ret.info:='{"dati":'||rt||'}';
			end if;
		 	return ret;
		elsif tipo ilike 'asu_gi' then
			select json_agg(row_to_json(g.*)) into rt from (
				select * from agenda.vw_unita_di_crisi where id = id_unita) g;
			raise notice '%',json_array_length(rt);
			ret.info:=null;
			ret.esito:=true;	
			if json_array_length(rt) is null then
				ret.esito:=false;
	    	    ret:=ag_ui.build_ret(ret,proc_name, 'unita_di_crisi_asu_gi_non_trovata');
	    	else
		 		ret.info:='{"dati":'||rt||'}';
			end if;
		 	return ret;
		else
			select json_agg(row_to_json(g.*)) into rt from (
				select * from agenda.vw_unita_di_crisi where id = id_unita) g;
			raise notice '%',json_array_length(rt);
			ret.info:=null;
			ret.esito:=true;	
			if json_array_length(rt) is null then
				ret.esito:=false;
	    	    ret:=ag_ui.build_ret(ret,proc_name, 'unita_di_crisi_as_fo_non_trovata');
	    	else
		 		ret.info:='{"dati":'||rt||'}';
			end if;
		 	return ret;
		end if;
	end;
end;
$$;


ALTER FUNCTION agenda.get_unita_di_crisi_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_uoc(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_uoc(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	rt json;
	struct varchar;
	R_STRUCT record;
	begin
		proc_name:='agenda.get_uoc';
		idstrutturaasl=v->'user_info'->'id_struttura_root';
		select * into R_STRUCT from matrix.vw_tree_nodes_up_asl vtnua where id_node=idstrutturaasl;
		if R_STRUCT.n_livello > 2 then
			idstrutturaasl:=R_STRUCT.id_node_parent;
		end if;
		struct=v->'struct';
		if struct is not null and lower(replace(struct,'"',''))='tree' then	
	    	select json_agg(row_to_json(a.*)) into rt  from (	
	    		select name_tree,id_node,id_tree,case when id_node=idstrutturaasl then null else id_node_parent end id_node_parent,
	    		id_node_ref,id,id_gisa,id_asl,codice_interno_fk,descrizione,
					n_livello,anno,descrizione_breve,ups,uba
					from matrix.vw_tree_nodes_down_asl_descr 
					where  id_node_ref =idstrutturaasl and n_livello<=2 
					and validita @> current_timestamp::timestamp
				order by descrizione_breve) a;
		else
	    	select json_agg(row_to_json(a.*)) into rt  from (
	   				select c.* from matrix.vw_tree_nodes_down_asl_descr c where  id_node_ref =idstrutturaasl and n_livello=2 order by descrizione_breve) a;
	   	end if;

		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='strutture UOC non trovate';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'strutture_UOC_non_trovate');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_uoc(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_uoc_piani(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_uoc_piani(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura_uoc bigint;
	idstruttura_asl bigint;
	rt json;

	begin
		proc_name:='agenda.get_uoc_piani';
		idstruttura_uoc=v->'id_struttura_asl';
		select json_agg(row_to_json(c.*)) into rt from
			(select p.id,p.id_node,p.id_node_parent,
				coalesce(p.alias,'')||' '||descrizione as descrizione,coalesce(p.alias,'')||' '||descrizione_breve as descrizione_breve,case when id_uoc_piano is null then false else true end selezionato 
			from matrix.vw_tree_nodes_up_piani p 
				left join 
				(select distinct id_piano as id_uoc_piano from agenda.asl_piani ap join matrix.tree_nodes tn on ap.id_struttura=tn.id where tn.id_parent=idstruttura_uoc) a
				on a.id_uoc_piano =p.id_node 
				where anno=(select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int--(select max(anno) from matrix.tree_anno)
				and (p.data_scadenza > current_timestamp or p.data_scadenza is null) and p.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text)
			order by p.path_ord) c;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='piani non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'piani_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_uoc_piani(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_uos(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_uos(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	rt json;
	struct varchar;

	begin
		set search_path to agenda, matrix,public, "$user";
		proc_name:='agenda.get_uos';
		--idstrutturaasl=v->'id_struttura_asl';
		idstrutturaasl=v->'user_info'->'id_struttura_root';
		struct=v->'struct';

		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
		if struct is not null and lower(replace(struct,'"',''))='tree' then
			select json_agg(row_to_json(a.*)) into rt  from (
				select c.name_tree, c.id_node, c.id_tree,
				case when c.id_node=idstrutturaasl then null else c.id_node_parent end id_node_parent,
				c.id_node_ref, c.id, c.id_gisa, c.id_asl, c.codice_interno_fk,
				c.descrizione descrizione, c.n_livello, c.anno, c.descrizione_breve, c.ups, c.uba
				from matrix.vw_tree_nodes_down_asl_descr c 
				where  c.id_node_ref =idstrutturaasl 
				--and c.data_Scadenza is null and c.trashed_date is null order by c.descrizione_breve		-- #12230
				and c.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text)
				order by c.descrizione_breve
			) a;
		else
			select json_agg(row_to_json(a.*)) into rt  from (
				select name_tree,id_node,id_tree,id_node_parent,id_node_ref,id,id_gisa,id_asl,codice_interno_fk,
			       	descrizione descrizione,n_livello,anno,descrizione_breve,ups,uba
	   			from matrix.vw_tree_nodes_down_asl_descr c where  id_node_ref =idstrutturaasl and n_livello=3
	   		--and c.data_Scadenza is null and c.trashed_date is null
				and c.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text)
	   			order by descrizione) a;
	   	end if;


 
		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='strutture non trovate';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'strutture_non_trovate');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	

	 	return ret;
	end;
end;
$_$;


ALTER FUNCTION agenda.get_uos(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_uos_comuni(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_uos_comuni(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura_uos bigint;
	idstruttura_uoc bigint;
	idstruttura_asl bigint;
	rt json;

	begin
		set search_path to agenda, matrix,public, "$user";
		proc_name:='agenda.get_uos_comuni';
		idstruttura_uos=v->'id_struttura_asl';
		select id_node_parent into idstruttura_uoc from matrix.vw_tree_nodes vtn where id_node =idstruttura_uos;
		select id_node_parent into idstruttura_asl from matrix.vw_tree_nodes vtn where id_node =idstruttura_uoc;
	raise notice 'UOS %',idstruttura_uos;
	raise notice 'UOC %',idstruttura_uoc;
	raise notice 'ASL %',idstruttura_asl;

		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(c.*)) into rt from agenda.vw_calendari c order by pianificate,eseguite;
		/*select json_agg(row_to_json(c.*)) into rt  
	    from (select *,case when id_comune is null then false else true end selezionato from agenda.comuni c left join 
(select n.id_node,sc.id_comune,n.node_descr from matrix.vw_tree_nodes n    left join agenda.struttura_comuni sc on sc.id_struttura =n.id_node where id_node_parent=idstruttura_uoc) a on a.id_comune=c.id
 where c.id_asl =idstruttura_asl and (id_node=idstruttura_uos or id_node is null) order by c.comune) c;
*/
	
	select  json_agg(row_to_json(c.*)) into rt from (
select c.*,case when nc.cnt=0 or nc.cnt is null then true else false end modificabile,case when id_comune is null then false else true end selezionato,coalesce(nc.cnt,0) cnt from agenda.comuni c
left join (select n.id_node,sc.id_comune,n.node_descr,sc.id from matrix.vw_tree_nodes n    
			left join agenda.struttura_comuni sc on sc.id_struttura =n.id_node where id_node_parent=idstruttura_uoc) a on a.id_comune=c.id
			--left join agenda.struttura_comuni sc on sc.id_struttura =n.id_node where id_node=idstruttura_uos) a on a.id_comune=c.id
left join (select id_struttura_comune ,count(*) cnt from agenda.nominativo_comuni group by 1) nc on a.id=nc.id_struttura_comune
join matrix.vw_tree_nodes_up_asl ta on ta.id_asl =c.id_asl and ta.n_livello =1
 where ta.id_node =idstruttura_asl and (a.id_node=idstruttura_uos or a.id_node is null) order by c.comune) c;
	
	
/*
select json_agg(row_to_json(c.*)) into rt  
	    from (
select c.*,case when id_comune is null then false else true end selezionato from agenda.comuni c left join 
(select n.id_node,sc.id_comune,n.node_descr from matrix.vw_tree_nodes n    left join agenda.struttura_comuni sc on sc.id_struttura =n.id_node where id_node_parent=idstruttura_uoc) a on a.id_comune=c.id
join matrix.vw_tree_nodes_up_asl ta on ta.id_asl =c.id_asl and ta.n_livello =1
 where ta.id_node =idstruttura_asl and (a.id_node=idstruttura_uos or a.id_node is null) order by c.comune) c;*/
		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='comuni non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'comuni_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$_$;


ALTER FUNCTION agenda.get_uos_comuni(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_veterinari_carico(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.get_veterinari_carico(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	rt json;
	data_da date;
	data_a date;

	begin
		proc_name:='agenda.get_veterinari_carico';
		idstrutturaasl=v->'user_info'->'id_struttura_root';
		data_da:=v->'data_inizio';
		raise notice '%', v;
		if v->>'id_struttura_root' is not null null then
				idstrutturaasl=v->>'id_struttura_root';
		end if;
		raise notice '%', idstrutturaasl;
		--data_a:=data_da + (interval '1 day') * 6;
		/*if extract(dow from data_a) <= 0 or extract(dow from data_a) >=6 then
			data_a:= data_a + (interval '1 day') * 2;
		end if;*/
		
	    select json_agg(row_to_json(a.*)) into rt  from (
	    	select distinct ns.id id,
			ns.nominativo descrizione,ns.descrizione_breve descrizione_breve, d.d dt,nc.durata_perc,
			case when extract(dow from dt) between 1 and 5 then '#fa3737' else '#51f751' end as colore,
			ns.id_nominativo 
	     	from matrix.vw_nominativi_struttura ns
	     	join (select data_da + generate_series(0,6) d) d on 1=1
	     	join matrix.vw_tree_nodes_down  tn on tn.id_node =ns.id_node_struttura 
	     	left join agenda.vw_nominativo_carico nc on nc.id_anagrafica =ns.id_anagrafica and nc.dt=d.d
	    	where tn.id_node_ref =idstrutturaasl
			order by ns.nominativo,d.d
		) a;
				
	    /*
			select	ns.id id,
			ns.nominativo descrizione,ns.nominativo descrizione_breve,
			ns.descrizione_breve descrizione_composta,ns.id,nc.dt,nc.durata_perc,
			case when extract(dow from dt) between 1 and 5 then '#008000' else '#800000' end as colore
	     	from matrix.vw_nominativi_struttura ns join matrix.vw_tree_nodes_down  tn on tn.id_node =ns.id_node_struttura 
	     	join agenda.vw_nominativo_carico nc on nc.id_risorsa =ns.id_nominativo
	    	where tn.id_node_ref =idstrutturaasl/*6029255*/ and nc.dt between data_da and data_a
	    	--and extract(dow from dt) between 1 and 5
				order by ns.descrizione_breve,ns.nominativo,dt*/
	    	
	    /*select	distinct ns.id_nominativo  id,
			ns.nominativo descrizione,ns.nominativo descrizione_breve,
			/*ns.id,*/d.d dt,nc.durata_perc,
			case when extract(dow from dt) between 1 and 5 then '#008000' else '#800000' end as colore
	     	from agenda.vw_nominativi_struttura ns
	     	join (select data_da + generate_series(0,6) d) d on 1=1
	     	join matrix.vw_tree_nodes_down  tn on tn.id_node =ns.id_node_struttura 
	     	left join agenda.vw_nominativo_carico nc on nc.id_anagrafica =ns.id_anagrafica and nc.dt=d.d*/
	     	
	    	--and extract(dow from dt) between 1 and 5
				/*
						select	distinct ns.id_nominativo  id,
			ns.nominativo descrizione,ns.nominativo descrizione_breve,
			d.d dt,coalesce(nc.durata_perc,0),
			case when extract(dow from dt) between 1 and 5 then '#008000' else '#800000' end as colore
	     	from agenda.vw_nominativi_struttura ns
	     	join (select data_dat + generate_series(0,6) d) d on 1=1
	     	join matrix.vw_tree_nodes_down  tn on tn.id_node =ns.id_node_struttura 
	     	left join agenda.vw_nominativo_carico nc on nc.id_risorsa =ns.id_nominativo and nc.dt=d.d
	    	where tn.id_node_ref =idstrutturaasl --and nc.dt -- between '2023-01-17' and '2023-01-24'
	    	--and extract(dow from dt) between 1 and 5
				order by ns.nominativo,d.d	*/

		if json_array_length(rt) is null then
    		ret.esito:=false;	
    	    ret:=ag_ui.build_ret(ret,proc_name,'risorse_non_trovate');
		   	ret.info = null;
    	--else
    	 	-- ret.msg:=null;
    	 	--ret := ag_ui.build_ret(ret, proc_name, 'veterinari_caricati_con_successo');
    	end if;
    	ret.esito:=true;
    	ret.info:= rt; --'{"ns":'||rt::varchar;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.get_veterinari_carico(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: ins_asl(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.ins_asl(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret ag_types.result_type;
		v_j json;
		R_SP matrix.struttura_asl;
		R_T matrix.tree_nodes;
		v_id_parent bigint;
		v_inizio_validita timestamp;
		n integer;
		proc_name varchar;
		ord varchar;
		begin
		proc_name:='agenda.ins_asl';
		v_j:=v::json;
		v_id_parent:=v_j->'id_node_parent';
		if v_j->>'inizio_validita' != '' and v_j->>'inizio_validita' is not null then
			v_inizio_validita:=v_j->>'inizio_validita';
		end if;
		R_SP.descrizione:=cu_anag.string_normalize_upper(v_j->>'descrizione');
		R_SP.descrizione_breve:=cu_anag.string_normalize_upper(v_j->>'descrizione_breve');
		R_SP.ordinamento:= (select count(*) + 1 from matrix.tree_nodes where id_parent = v_id_parent and validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));
	
		if v_j->>'inizio_validita' = '' then 
			v_inizio_validita:= null;
		end if;		
		
		select count(*) into n from matrix.struttura_asl sa 
		join matrix.tree_nodes tn on sa.id = tn.id
		where descrizione =  R_SP.descrizione
		and descrizione_breve = R_SP.descrizione_breve
		and validita && tsrange(v_inizio_validita,null,'[)');
	
		if n > 0 then
		    ret:=ag_ui.build_ret(ret,proc_name, 'struttura_asl_esistente');
		   	ret.esito:=false;
	   		return ret;
		end if;
	
	
		R_SP.n_livello = (select n_livello from matrix.struttura_asl sa where sa.id = v_id_parent) + 1;
		R_SP.anno = (select anno from matrix.struttura_asl sa where sa.id = v_id_parent);
		R_SP.id_asl = (select id_asl from matrix.struttura_asl sa where sa.id = v_id_parent);
		
		R_SP.id=nextval('agenda.agenda_id_seq');
		insert into matrix.struttura_asl values(R_SP.*);
		n:=ag_log.upd_record('agenda.struttura_asl',idtransazione,R_SP,'I');
	
		R_T.id = R_SP.id;
		select t.id into R_T.id_tree from matrix.trees t where t.name='Struttura ASL';
		R_T.id_parent = v_id_parent;
		R_T.node_descr = R_SP.descrizione_breve;
		R_T.ordinamento = LPAD(R_SP.ordinamento::varchar,4,'0');
		R_T.validita = tsrange(v_inizio_validita,NULL::timestamp without time zone,'[)'::text);
		
		insert into matrix.tree_nodes values(R_T.*);
		n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_T,'I');
		
	    GET DIAGNOSTICS n = ROW_COUNT;
		 if n < 1 then
			ret.esito:=false;
			ret:=ag_ui.build_ret(ret,proc_name, 'errore_inserimento_asl');
			return ret;
		 end if;
	  	
	  	ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info = '0';
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
		return ret;
		end;
	END;
$$;


ALTER FUNCTION agenda.ins_asl(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: ins_avviso(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.ins_avviso(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
       	v_sigla varchar;
       	v_descrizione varchar;
       	v_id_tipo_avviso bigint;
       	v_id_livello_avviso bigint;
     	v_periodo json;
     	v_data_inizio timestamp;
		v_data_fine timestamp;
		n integer;
		idavviso bigint;
		idNs bigint;
        proc_name varchar; -- END
        v_j json;
       	R_A agenda.avvisi;
        begin
		proc_name:='agenda.ins_avviso';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		v_sigla:=v_j->>'sigla';
		v_descrizione:=v_j->>'descrizione';
		v_id_tipo_avviso:=v_j->>'id_tipo_avviso';
		v_id_livello_avviso:=v_j->>'id_livello_avviso';
		idNs:=v->'user_info'->'id_utente';
		if v->>'periodo' != '' then
			v_periodo:=v->>'periodo';
			raise notice 'fine v_periodo%', v_periodo->>'end';
			if v_periodo->>'start' != '' then
				v_data_inizio:=to_timestamp(v_periodo->>'start'::varchar, 'YYYY-MM-DD"T"HH24:MI:SS');
			end if;
			if v_periodo->>'end' != '' then
				v_data_fine:=to_timestamp(v_periodo->>'end'::varchar, 'YYYY-MM-DD"T"HH24:MI:SS');
					if length(v_periodo->>'end')<=10 then
						v_data_fine:= v_data_fine + interval '1 day';
					end if;
			end if;

		end if;
		
		if v_data_inizio = v_data_fine then
			v_data_fine:= v_data_fine + interval '1 day';
		end if;
	
		raise notice 'v_j:%',v_j;
	
		insert into agenda.avvisi 
			select nextval('agenda.avvisi_id_seq'), v_sigla, v_sigla,v_descrizione, v_id_tipo_avviso, v_id_livello_avviso,
			tsrange(v_data_inizio::timestamp without time zone,v_data_fine::timestamp without time zone,'[)'), idNs, current_timestamp::timestamp without time zone
			returning * into R_A;
		n:=ag_log.upd_record('agenda.avvisi',idtransazione,R_A,'I');
		idavviso:=R_A.id;

		 GET DIAGNOSTICS n = ROW_COUNT;
		 if n < 1 then
			ret.esito:=false;
			ret:=ag_ui.build_ret(ret,proc_name, 'errore_aggiornamento_avviso');
			return ret;
		 end if;
	  	

    	ret.esito:=true;
		ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info=idavviso;
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.ins_avviso(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: ins_calendario(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.ins_calendario(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; -- START
	id_op bigint;   
	proc_name varchar; -- END
	R agenda.calendari%ROWTYPE; 
	v_j json;
	n integer;
	begin
	proc_name:='agenda.ins_calendario';

	raise notice '%', v;
	--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
	v_j:=v::json;
	R.id             := nextval('agenda.calendario_id_seq');
	R.descr  := v_j->>'descrizione';
	R.id_user :=  v_j->'user_info'->'id_utente';
	R.tm := current_timestamp;
	R.nota  := v_j->>'nota';
R.anno:=extract (year from current_timestamp);
raise notice 'ANNO=%',R.anno;

    
    insert into agenda.calendari  values (R.*);
	--DA IMPLEMENTARE n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'I');

    ret.esito:=true;	
	--ret:=ag_ui.build_ret(ret,proc_name,R.id);
     ret:=ag_ui.build_ret(ret,proc_name,'calendario_creato_con_successo');
     ret.info='0';
	return ret;
	end;
END
$$;


ALTER FUNCTION agenda.ins_calendario(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: ins_calendario_elab(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.ins_calendario_elab(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; -- START
	id_op bigint;   
	proc_name varchar; -- END
	R agenda.elab_cals%ROWTYPE; 
	R_CAL agenda.calendari%ROWTYPE; 


	v_j json;
	n integer;
	anno_elab integer;
	begin
	proc_name:='agenda.ins_calendario_elab';

	raise notice '%', v;
	--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
	v_j:=v::json;
	R.id             := nextval('agenda.elab_cals_id_seq');
	R.descr  := v_j->>'descrizione';
	R.id_user :=  v_j->'user_info'->'id_utente';
	R.tm := current_timestamp;
	R.nota  := v_j->>'nota';
	R.id_calendario  := v_j->'id_calendario';
	select * into R_CAL from agenda.calendari where id=R.id_calendario ;


    
    insert into agenda.elab_cals values (R.*);
    
    insert into agenda.elab_cal_params values(nextval('agenda.elab_cals_id_seq'),R.id  ,'periodo_a',R_CAL.anno||'-12-31');
    insert into agenda.elab_cal_params values(nextval('agenda.elab_cals_id_seq'),R.id  ,'periodo_da',R_CAL.anno||'-01-01');
    insert into agenda.elab_cal_params values(nextval('agenda.elab_cals_id_seq'),R.id  ,'non_visitati_dal',(R_CAL.anno-3)::varchar ||'-12-31 23:59:59');
	insert into agenda.elab_cal_params values(nextval('agenda.elab_cals_id_seq'),R.id  ,'non_visitati_dal_valore','25');
	insert into agenda.elab_cal_params values(nextval('agenda.elab_cals_id_seq'),R.id  ,'ultima_visita','25');
	insert into agenda.elab_cal_params values(nextval('agenda.elab_cals_id_seq'),R.id  ,'machine','25');
	insert into agenda.elab_cal_params values(nextval('agenda.elab_cals_id_seq'),R.id  ,'casuale','25');
	insert into agenda.elab_cal_params values(nextval('agenda.elab_cals_id_seq'),R.id  ,'linea','true');
	insert into agenda.elab_cal_params values(nextval('agenda.elab_cals_id_seq'),R.id  ,'ispettore','true');
	--DA IMPLEMENTARE n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'I');

    ret.esito:=true;	
	--ret:=ag_ui.build_ret(ret,proc_name,R.id);
     ret:=ag_ui.build_ret(ret,proc_name,'elaborazione_creata_con_successo');
     ret.info='0';
	return ret;
	end;
END
$$;


ALTER FUNCTION agenda.ins_calendario_elab(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: ins_cf_lista(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.ins_cf_lista(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; -- START
	id_op bigint;   
	proc_name varchar; -- END
	R agenda.cf_liste%ROWTYPE; 
	n integer;
	begin
	proc_name:='agenda.ins_cf_lista';
	raise notice '%', v_j;
	R.id             := nextval('agenda.agenda_id_seq');
	R.anno  := v_j->>'anno';
	R.id_cf_tipo_lista:=v_j->>'idTipoLista';
	raise notice 'ANNO=%',R.anno;

    insert into agenda.cf_liste  values (R.*);
   	n:=ag_log.upd_record('agenda.cf_liste',idtransazione,R,'I');
	--DA IMPLEMENTARE n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'I');
    ret.esito:=true;	
   	ret.msg := null;
   	ret.info := null;
	--ret:=ag_ui.build_ret(ret,proc_name,R.id);
        ret:=ag_ui.build_ret(ret,proc_name,'inserimento_avvenuto_con_successo');
		ret.info='0';
	return ret;
	end;
END
$$;


ALTER FUNCTION agenda.ins_cf_lista(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: ins_evento(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.ins_evento(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
BEGIN
DECLARE
    ret ag_types.result_type;
    -- START
    id_op bigint;
    proc_name varchar;
    -- END
    R_EV agenda.eventi%ROWTYPE;
   idstabilimento bigint;
    v_j json;
    n integer;
    t integer;
   R_TE  ag_types.vw_ag_tipo_eventi%ROWTYPE;
  
BEGIN
    proc_name := 'agenda.ins_evento';
    -- id_op:=gds_log.start_op(proc_name,idtransazione ,'');
    v_j := v::json;
    t := v_j -> 'id_tipo_evento';
	
    IF t IS NULL THEN
        t := 1;
    END IF;
    
	R_EV.id_nominativo := v_j -> 'id_ns';
    
	SELECT
        id_nominativo,
        id_node_struttura INTO R_EV.id_nominativo,
        R_EV.per_conto
    FROM matrix.vw_nominativi_struttura
    WHERE id = R_EV.id_nominativo;
    
	R_EV.id_tipo_evento := t;
    R_EV.inizio := v_j -> 'inizio';
    R_EV.fine := v_j -> 'fine';
    R_EV.id_partner := v_j -> 'id_partner';
    if R_EV.inizio > current_timestamp + interval '2 years' or
       R_EV.inizio < current_timestamp - interval '1 years' then
       	ret.esito := false;
    	ret := ag_ui.build_ret (ret, proc_name, 'data_inizio_non_ammissibile');
    	ret.info = R_EV.id::varchar;
    	return ret;
	end if;



    if R_EV.fine - R_EV.inizio > R_TE.durata_max	-- interval '1 week' 
    then
       	ret.esito := false;
    	ret := ag_ui.build_ret (ret, proc_name, 'durata_non_ammissibile');
    	ret.info = R_EV.id::varchar;
    	return ret;
	end if;
    if R_EV.id_partner is not null then
    	SELECT
	        id_nominativo,
	        id_node_struttura INTO R_EV.id_partner,
	        R_EV.partner_per_conto
	    FROM matrix.vw_nominativi_struttura
	    WHERE id = R_EV.id_partner;
    end if;
    
	/*IF extract(hour FROM R_EV.inizio) = 0 THEN
        R_EV.inizio := R_EV.inizio + interval '9 hours';
        R_EV.fine := R_EV.fine + interval '9 hours';
    END IF;*/
    IF v_j -> 'durata' IS NULL THEN
        IF R_EV.fine IS NULL THEN
            R_EV.fine := R_EV.inizio + interval '3 hours';
        END IF;
    ELSE
        R_EV.fine := R_EV.inizio + interval '1 minutes' * v_j -> 'durata';
    END IF;
    IF R_EV.fine <= R_EV.inizio THEN
        R_EV.fine := R_EV.inizio + interval '3 hours';
    END IF;
    IF v_j -> 'per_conto_di' IS NOT NULL THEN
        R_EV.per_conto := v_j -> 'per_conto_di';
    END IF;
    -- R_EV.per_conto:=v_j->'user_info'->'id_asl';
    IF v_j -> 'id_linea' IS NOT NULL THEN
        R_EV.id_linea := v_j -> 'id_linea';
    else
        IF v_j -> 'id_stabilimento' IS NOT NULL then
        	idstabilimento:=v_j->'id_stabilimento';
        	select id_linea into R_EV.id_linea from agenda.vw_linee where id_az_sede=idstabilimento order by id limit 1;
        	--R_EV.id_linea := v_j -> 'id_linea';
   		END IF;
    END IF;

    IF v_j -> 'id_piano' IS NOT NULL THEN
        R_EV.id_piano := v_j -> 'id_piano';
    else
    	select * into R_TE from ag_types.vw_ag_tipo_eventi where id=t;
    	if R_TE.sigla ='FU' then
				select id_piano into R_EV.id_piano from cu_conf.vw_cu_piani_speciali vcps 
				where sigla='FU_PIANO_DEF';
		end if;
    END IF;
  	IF v_j -> 'id_cu' IS NOT NULL THEN
        R_EV.id_cu := v_j -> 'id_cu';
    END IF;
    
	-- R_EV.id_calendario  := v_j->'id_calendario';
    R_EV.effettuata := FALSE;
    R_EV.id := nextval('agenda.agenda_id_seq');
    R_EV.validita_interna := TRUE;
    R_EV.quantita:=1;
    R_EV.id_user_create :=v_j->'user_info'->'id_utente';
   	R_EV.ts_create:=current_timestamp;
   
   	RAISE NOTICE 'R_EV: %', R_EV;
   
	INSERT INTO agenda.eventi VALUES (R_EV.*) returning * into R_EV;
    
	n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'I');
    
	ret.esito := TRUE;
    ret := ag_ui.build_ret (ret, proc_name, 'evento_inserito_con_successo');
    ret.info = R_EV.id::varchar;
    RETURN ret;
    END;
END
$$;


ALTER FUNCTION agenda.ins_evento(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: ins_lista_import(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.ins_lista_import(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; -- START
	id_op bigint;   
	proc_name varchar; -- END
	R agenda.lista_import%ROWTYPE; 
	n integer;
	rt integer;
	begin
	proc_name:='agenda.ins_lista_import';
	raise notice '%', v_j;
	R.id             := nextval('agenda.lista_import_id_seq');
	R.anno  := v_j->>'anno';
	R.id_tipo_lista:=v_j->>'idTipoLista';
	raise notice 'ANNO=%',R.anno;
   --  select count(*) into rt from agenda.lista_import where id_tipo_lista::text=v_j->>'idTipoLista';
   --	raise notice 'rt=%',rt;
    insert into agenda.lista_import  values (R.*);
   	n:=ag_log.upd_record('agenda.lista_import',idtransazione,R,'I');
    GET DIAGNOSTICS n = ROW_COUNT;
		if  n <=0 then
			ret.esito:=false;
			ret.valore:= null;
			ret.msg:=proc_name || ': valori non inseriti';
			RAISE notice '%', ret;
			return ret;
		end if;
    	ret.esito:=true;	
		ret:=ag_ui.build_ret(ret,proc_name,'inserimento_anno_avvenuto_con_successo');
	    ret.info ='0';

		return ret;
	end;
  END
 $$;


ALTER FUNCTION agenda.ins_lista_import(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: ins_piano(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.ins_piano(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret ag_types.result_type;
		v_j json;
		R_SP matrix.struttura_piani;
		R_T matrix.tree_nodes;
		v_id_parent bigint;
		v_inizio_validita timestamp;
		n integer;
		proc_name varchar;
		begin
		proc_name:='agenda.ins_piano';
		v_j:=v::json;
		v_id_parent:=v_j->'id_node_parent';
		R_SP.alias:=cu_anag.string_normalize_upper(v_j->>'alias');
		R_SP.descrizione:=cu_anag.string_normalize_upper(v_j->>'descrizione');
		R_SP.descrizione_breve:=cu_anag.string_normalize_upper(v_j->>'descrizione_breve');
		R_SP.ordinamento:= (select count(*) + 1 from matrix.tree_nodes where id_parent = v_id_parent and validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));
		if v_j->>'inizio_validita' != '' and v_j->>'inizio_validita' is not null then
			v_inizio_validita:=v_j->>'inizio_validita';
		end if;
	
		if v_j->>'inizio_validita' = '' then 
			v_inizio_validita:= null;
		end if;
	
		R_T.validita = tsrange(v_inizio_validita,NULL::timestamp without time zone,'[)'::text);
	
		select count(*) into n from matrix.struttura_piani sa 
		join matrix.tree_nodes tn on sa.id = tn.id
		where alias = R_SP.alias
		and validita && tsrange(v_inizio_validita,null,'[)');
	
		if n > 0 then
		    ret:=ag_ui.build_ret(ret,proc_name, 'struttura_piano_esistente');
		   	ret.esito:=false;
	   		return ret;
		end if;
	
		R_SP.color = (select color from matrix.struttura_piani where id = v_id_parent);
		--R_SP.livello = (select livello from matrix.struttura_piani sp where sp.id = v_id_parent) + 1;
		R_SP.anno = (select anno from matrix.struttura_piani sp where sp.id = v_id_parent);
		
		R_SP.id=nextval('agenda.agenda_id_seq');
		insert into matrix.struttura_piani values(R_SP.*);
		n:=ag_log.upd_record('agenda.struttura_piani',idtransazione,R_SP,'I');

		R_T.id = R_SP.id;
		select t.id into R_T.id_tree from matrix.trees t where t.name='Struttura Piani';
		R_T.id_parent = v_id_parent;
		R_T.node_descr = R_SP.alias;
		R_T.ordinamento = LPAD(R_SP.ordinamento::varchar,4,'0');
		
	
		insert into matrix.tree_nodes values(R_T.*);
		n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_T,'I');
	  
	    GET DIAGNOSTICS n = ROW_COUNT;
		 if n < 1 then
			ret.esito:=false;
			ret:=ag_ui.build_ret(ret,proc_name, 'errore_inserimento_piano');
			return ret;
		 end if;
	  	
	  	ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info = '0';
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
		return ret;
		end;
	END;
$$;


ALTER FUNCTION agenda.ins_piano(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: ins_risorsa(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.ins_risorsa(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret ag_types.result_type;
		v_j json;
		R_US rbac.utente_strutture;
		v_id_node bigint;
		v_id_utente bigint;
		n integer;
		proc_name varchar;
		descr_nodo varchar;
		begin
		proc_name:='agenda.ins_risorsa';
		v_j:=v::json;
		v_id_node:=v_j->'id_node';
		v_id_utente:=v_j->'id_utente';
		R_US.id=nextval('rbac.utente_strutture_id_seq');
	
		R_US.id_struttura = (select id from matrix.struttura_asl sa where sa.id = v_id_node);
		R_US.id_utente = v_id_utente;
		R_US.validita = (tsrange(current_timestamp::timestamp without time zone,null,'[)'));
		
		select count(*) into n from rbac.utente_strutture us  
		where us.id_utente = R_US.id_utente and us.id_struttura = R_US.id_struttura and validita && R_US.validita;
		if n > 0 then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'utente_già_presente_per_struttura');
				ret.info='0';
				return ret;
		end if;
		
		insert into rbac.utente_strutture values(R_US.*);
		raise notice 'R_US%',R_US;
		n:=ag_log.upd_record('agenda.utente_strutture',idtransazione,R_US,'I');
		
		
	    GET DIAGNOSTICS n = ROW_COUNT;
		 if n < 1 then
			ret.esito:=false;
			ret:=ag_ui.build_ret(ret,proc_name, 'errore_aggiornamento_risorsa');
			return ret;
		 end if;
	  	
	  	ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info = '0';
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
		return ret;
		end;
	END;
$$;


ALTER FUNCTION agenda.ins_risorsa(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: ins_tipo_lista(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.ins_tipo_lista(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R agenda.tipo_liste%ROWTYPE; 
	v_j json;
	n integer;
	begin
	proc_name:='agenda.ins_tipo_lista';

	raise notice '%', v;

	v_j:=v::json;
	R.id             := nextval('agenda.tipo_lista_id_seq');
	R.descr  := v_j->>'descr';
	R.cod  := v_j->>'cod';
	R.id_user :=  v_j->'user_info'->'id_utente';
	R.tm := current_timestamp;
	R.validita:=tsrange(current_timestamp::timestamp,null::timestamp,'[)');
	
	R.formato:= v_j->>'formato';
	
    

    
    insert into agenda.tipo_liste  values (R.*);
   	n:=ag_log.upd_record('agenda.tipo_liste',idtransazione,R,'I');

    ret.esito:=true;	
    ret:=ag_ui.build_ret(ret,proc_name,'tipologia_lista_creata_con_successo');
    ret.info='0';
	return ret;
	end;
END
$$;


ALTER FUNCTION agenda.ins_tipo_lista(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: ins_unita_di_crisi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.ins_unita_di_crisi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	n integer;
	tipo varchar;
	v_ruolo varchar;
	v_nome varchar;
	v_cognome varchar;
	v_email varchar;
	v_telefono varchar;
	v_cellulare varchar;
	R_U agenda.unita_di_crisi;
	begin
		proc_name:='agenda.ins_unita_di_crisi';
		tipo:=v->>'tipo';
		v_ruolo:=cu_anag.string_normalize_upper(v->>'ruolo');
		v_nome:=cu_anag.string_normalize_upper(v->>'nome');
		v_cognome:=cu_anag.string_normalize_upper(v->>'cognome');
		v_email:=v->>'email';	
		v_telefono:=v->>'telefono';
		v_cellulare:=v->>'cellulare';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		if tipo ilike 'fvg' then
			insert into agenda.unita_di_crisi (ruolo, responsabile_nome, responsabile_cognome, email, telefono, cellulare, validita, id_asl)
			values (v_ruolo, v_nome, v_cognome, v_email, v_telefono, v_cellulare, (tsrange(current_timestamp::timestamp without time zone,null,'[)')), -1) returning * into R_U;
			n:=ag_log.upd_record('agenda.unita_di_crisi',idtransazione,R_U,'I');
			ret.esito:=true;	
        	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		elsif tipo ilike 'asu_fc' then
			insert into agenda.unita_di_crisi (ruolo, responsabile_nome, responsabile_cognome, email, telefono, cellulare, validita, id_asl)
			values (v_ruolo, v_nome, v_cognome, v_email, v_telefono, v_cellulare, (tsrange(current_timestamp::timestamp without time zone,null,'[)')), 206) returning * into R_U;
			n:=ag_log.upd_record('agenda.unita_di_crisi',idtransazione,R_U,'I');
		
			ret.esito:=true;	
        	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		elsif tipo ilike 'asu_gi' then
			insert into agenda.unita_di_crisi (ruolo, responsabile_nome, responsabile_cognome, email, telefono, cellulare, validita, id_asl)
			values (v_ruolo, v_nome, v_cognome, v_email, v_telefono, v_cellulare, (tsrange(current_timestamp::timestamp without time zone,null,'[)')), 207) returning * into R_U;
			n:=ag_log.upd_record('agenda.unita_di_crisi',idtransazione,R_U,'I');
		
			ret.esito:=true;	
        	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		else
			insert into agenda.unita_di_crisi (ruolo, responsabile_nome, responsabile_cognome, email, telefono, cellulare, validita, id_asl)
			values (v_ruolo, v_nome, v_cognome, v_email, v_telefono, v_cellulare, (tsrange(current_timestamp::timestamp without time zone,null,'[)')), 205) returning * into R_U;
			n:=ag_log.upd_record('agenda.unita_di_crisi',idtransazione,R_U,'I');
		
			ret.esito:=true;	
        	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		end if;
	end;
end;
$$;


ALTER FUNCTION agenda.ins_unita_di_crisi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: load_cf_allevamenti(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.load_cf_allevamenti(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	proc_name varchar;
	ret ag_types.result_type; 
	idlista bigint;
	begin
		proc_name:='agenda.load_cf_allevamenti';
		idlista:=v->'id_lista';
		delete from agenda.cf_allevamenti where id_lista=idlista;
	
		insert into agenda.cf_allevamenti
			select nextval('agenda.agenda_id_seq'),idlista ,attributo,cod_allevamento from 
			
			(select attributo,cod_allevamento,l.id_linea from 
			  (select * from json_populate_recordset(null::record,v->'lista_cf') as (attributo varchar,cod_allevamento varchar)) cf 
				left join agenda.vw_linee l on
					l.piva                                   = trim(split_part(cod_allevamento,'-',3)) and
					case when trim(split_part(l.cod_tipo_linea,'-',1)) ~ '^[0-9]+$' then lpad(trim(split_part(l.cod_tipo_linea,'-',1)),4,'0') else trim(split_part(l.cod_tipo_linea,'-',1)) end
								                             = trim(split_part(cod_allevamento,'-',2)) and
					l.num_riconoscimento					 = trim(split_part(cod_allevamento,'-',1))
			) lp;
		update agenda.cf_liste set dt=current_timestamp where id=idlista;
		ret.esito:=true;
	 	return ret;
	end;
end;
$_$;


ALTER FUNCTION agenda.load_cf_allevamenti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: load_import_formato_cf(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.load_import_formato_cf(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	proc_name varchar;
	ret ag_types.result_type; 
	idlistaP bigint;
	begin
		proc_name:='agenda.load_import_formato_cf';
		idlistaP:=v->'id_lista';
	
		/*delete from agenda.cf_allevamenti where id_lista=idlista;
		insert into agenda.cf_allevamenti
			select nextval('agenda.agenda_id_seq'),idlista ,attributo,cod_allevamento ,id_linea from 
			
			(select attributo,cod_allevamento,l.id_linea from 
			  (select * from json_populate_recordset(null::record,v->'lista') as (attributo varchar,cod_allevamento varchar)) cf 
				left join agenda.vw_linee l on 
				 coalesce (l.piva,l.codfis) = trim(split_part(cf.cod_allevamento,'*',3)) and
				case when trim(split_part(l.cod_tipo_linea,'*',1)) ~ '^[0-9]+$' then 
				          regexp_replace(lpad(trim(split_part(l.cod_tipo_linea,'*',1)),4,'0') , '[- chr(32)]','','g')
				else regexp_replace((split_part(l.cod_tipo_linea,'*',1)) , '[- chr(32)]','','g') end
				   = regexp_replace(split_part(cf.cod_allevamento,'*',2),'[- chr(32)]','','g') and
				l.cod_registrazione = trim(split_part(cf.cod_allevamento,'*',1))
			) lp;
		
		*/
	
		  delete from agenda.file_xls_cf where file_xls_cf.idlista=idlistaP;

          insert into agenda.file_xls_cf
          (cod_allevamento, attributo, idlista,id)
		  select cod_allevamento  ,attributo, idlistaP, nextval('agenda.import_linea_id_seq')
		  from (
		 
		   select * from 
		  json_populate_recordset(null::record,v->'lista') as 
		  (cod_allevamento varchar,attributo varchar )
		   
	 	  )b;
 
		   delete from agenda.import_linea where id_lista=idlistaP;

	
	       insert into agenda.import_linea
	       (id, id_lista, attributo,cod_tipo_linea,id_linea)
			select lp.id,idlistaP ,attributo,cod_allevamento ,id_linea from 
			
			(select cf.id,attributo,cod_allevamento,l.id_linea from 
			    agenda.file_xls_cf cf 
				left join agenda.vw_linee l on 
				 coalesce (l.piva,l.codfis) = trim(split_part(cf.cod_allevamento,'*',3)) and
				case when trim(split_part(l.cod_tipo_linea,'*',1)) ~ '^[0-9]+$' then 
				          regexp_replace(lpad(trim(split_part(l.cod_tipo_linea,'*',1)),4,'0') , '[- chr(32)]','','g')
				else regexp_replace((split_part(l.cod_tipo_linea,'*',1)) , '[- chr(32)]','','g') end
				   = regexp_replace(split_part(cf.cod_allevamento,'*',2),'[- chr(32)]','','g') and
				--l.cod_registrazione = trim(split_part(cf.cod_allevamento,'*',1))
				   l.cod_nazionale = trim(split_part(cf.cod_allevamento,'*',1))
			   WHERE cf.idlista=idlistaP
			) lp;
		   
		update agenda.lista_import set dt=current_timestamp where id=idlistaP;
		ret.esito:=true;
	 	return ret;
	end;
end;
$_$;


ALTER FUNCTION agenda.load_import_formato_cf(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: load_import_formato_linea(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.load_import_formato_linea(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	proc_name varchar;
	ret ag_types.result_type; 
	idlistaP bigint;
	begin
		proc_name:='agenda.load_import_formato_linea';
		idlistaP:=v->'id_lista';
	
	    delete from agenda.file_xls_linea where file_xls_linea.idlista=idlistaP;

        insert into agenda.file_xls_linea
         (denominazione_sede_operativa, piva, cod_tipo_linea, idlista,id)
		 select denominazione_sede_operativa  ,piva  ,cod_tipo_linea, idlistaP, nextval('agenda.import_linea_id_seq')
		 from (
		 
		   select * from 
		  json_populate_recordset(null::record,v->'lista') as 
		  (denominazione_sede_operativa varchar,piva varchar,cod_tipo_linea varchar )
		   
		)b;
 
	
		delete from agenda.import_linea where id_lista=idlistaP;
	    insert into agenda.import_linea
		 select b.id,idlistaP ,piva,denominazione_sede_operativa,cod_tipo_linea,id_linea from 
			
			(select a.id,			
			  a.piva,  a.denominazione_sede_operativa,
			  case when  l.cod_tipo_linea_mod is not null then l.cod_tipo_linea
			  else a.cod_tipo_linea end as  cod_tipo_linea,
			  l.id_linea from 
			  agenda.file_xls_linea a  
			  left join agenda.vw_linee l on 
				    l.piva =  trim(a.piva) and
				    l.denominazione_sede_operativa =trim(a.denominazione_sede_operativa) and 
				  --  l.cod_tipo_linea= trim(a.cod_tipo_linea)
				   split_part(a.cod_tipo_linea,' ',2) =l.cod_tipo_linea_mod
 		    WHERE a.idlista=idlistaP	   
		    ) b;
		
		update agenda.lista_import set dt=current_timestamp where id=idlistaP;
		ret.esito:=true;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.load_import_formato_linea(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: load_import_formato_profilassi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.load_import_formato_profilassi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	proc_name varchar;
	ret ag_types.result_type; 
	idlistaP bigint;
	begin
			 proc_name:='agenda.load_import_formato_profilassi';
			 idlistaP:=v->'id_lista';
	
	
			 delete from agenda.file_xls_profilassi where idlista=idlistaP;

        	 insert into agenda.file_xls_profilassi       
		  	 select distinct    trim(cod_azienda) ,trim(cod_grp_specie)  , idlistaP, nextval('agenda.import_linea_id_seq')
		 	 from (
		 	  select *  from 
		  	  json_populate_recordset(null::record,v->'lista') as 
		  	  (cod_azienda varchar,cod_grp_specie varchar )		   
		     )b;
		    
	raise info 'prima insert';
	 		 delete from agenda.import_linea where id_lista=idlistaP;

	 	     insert into agenda.import_linea
	 	    (id, id_lista, cod_tipo_linea,id_linea,cod_regionale)
		     select b.id::bigint,idlistaP ,	b.cod_grp_specie	,id_linea, b.cod_azienda from 
		     (select cf.id,cod_azienda,cod_grp_specie ,l.id_linea from 
			    agenda.file_xls_profilassi cf 
				left join agenda.vw_linee l on   l.cod_tipo_linea= 'GS-'|| LTRIM( cf.cod_grp_specie,'0')  and  l.cod_nazionale =trim( cf.cod_azienda)
			   WHERE cf.idlista=idlistaP
			) b;
		   
	raise info 'seconda insert';
		update agenda.lista_import set dt=current_timestamp where id=idlistaP;
		ret.esito:=true;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.load_import_formato_profilassi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: load_import_formato_sicer(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.load_import_formato_sicer(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	proc_name varchar;
	ret ag_types.result_type; 
	idlistaP bigint;
	begin
		proc_name:='agenda.load_import_formato_sicer';
		idlistaP:=v->'id_lista';
	 raise notice '%',v->'lista';
	
	     delete from agenda.file_xls_sicer where file_xls_sicer.idlista=idlistaP;

         insert into agenda.file_xls_sicer
         (idua, nome, codregionale,attivitacontrollate,comune,idlista,id)
		 select idua  ,nome  ,cod_regionale  ,attivita_controllate  ,comune  , idlistaP, nextval('agenda.import_linea_id_seq')
		 from (
		 
		   select * from 
		  json_populate_recordset(null::record,v->'lista') as 
		  (idua varchar,nome varchar,cod_regionale varchar,comune varchar,attivita_controllate varchar)
		   
		 )b;
	 
	   
		delete from agenda.import_linea where id_lista=idlistaP;
	
	    insert into agenda.import_linea
		 select b.id,idlistaP ,piva,denominazione_sede_operativa,cod_tipo_linea_mod,id_linea,sd_id ,comune,codregionale from 
			
			(select a.id,
			     l.piva, 
			     case when l.denominazione_sede_operativa is not null then l.denominazione_sede_operativa 
			     else a.nome end as denominazione_sede_operativa,
			     case when  l.cod_tipo_linea_mod is not null then l.cod_tipo_linea
			     else attivitacontrollate end as  cod_tipo_linea_mod,
			     l.id_linea , 
			     a.idua::int as sd_id,
			     a.comune,
			     a.codregionale
			     from 
			     agenda.file_xls_sicer a 
			     left join  agenda.vw_linee l  on    (l.sd_id::int =a.idua::int

			--    and replace(replace(substring(l.cod_tipo_linea,1,strpos(l.cod_tipo_linea,' ')),'[',''),']','')=
		      --  replace(replace(substring(a.attivita_controllate,1,strpos(a.attivita_controllate,' ')),'[',''),']','')
		    --    AND 	 split_part(a.attivitacontrollate,' ',1) =l.cod_tipo_linea_mod )ANTONIO
			       and  l.linea_principale is true  )
		     --   or (     l.sd_id::int =a.idua::int and l.linea_principale is true)
		   --     AND 	 regexp_replace(upper(TRIM(a.nome   )),         '[ 	]+', ' ', 'g') =
		     --   		 regexp_replace(upper(trim(l.denominazione_sede_operativa)),'[ 	]+', ' ', 'g')
		       -- AND 	 regexp_replace(upper(TRIM(a.comune )),         '[ 	]+', ' ', 'g') =
		        --		 regexp_replace(upper(trim(l.comune)),          '[ 	]+', ' ', 'g')
		       --and      regexp_replace(upper(TRIM(a.cod_regionale)),   '[ 	]+', ' ', 'g') =
		        --		 regexp_replace(upper(trim(l.app_number)),      '[ 	]+', ' ', 'g')
		        WHERE a.idlista=idlistaP
		    ) b;
		
		 update agenda.import_linea impL
		 set cod_tipo_linea= subquery.cod_tipo_linea,id_linea= subquery.id_linea
		 from (
			select l.cod_tipo_linea ,l.id_linea,il.id  from
			agenda.import_linea il
			inner join agenda.vw_linee l on l.sd_id =il.sd_id and l.linea_principale is true 
			where il.id_linea  is null and il.id_lista =idlistaP  
		
	 	) as subquery
		 where 
		 subquery.id=impL.id;

  
		   
		   
		update agenda.lista_import set dt=current_timestamp where id=idlistaP;
	 
		ret.esito:=true;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.load_import_formato_sicer(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: load_import_formato_sicer_old(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.load_import_formato_sicer_old(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	proc_name varchar;
	ret ag_types.result_type; 
	idlista bigint;
	begin
		proc_name:='agenda.load_import_formato_sicer';
		idlista:=v->'id_lista';
	 raise notice '%',v->'lista';
		delete from agenda.import_linea where id_lista=idlista;
	
		raise notice 'dopo delete';
	    insert into agenda.import_linea
		 select nextval('agenda.import_linea_id_seq'),idlista ,piva,denominazione_sede_operativa,cod_tipo_linea_mod,id_linea,sd_id ,comune,cod_regionale from 
			
			(select 
			     l.piva, 
			     case when l.denominazione_sede_operativa is not null then l.denominazione_sede_operativa 
			     else a.nome end as denominazione_sede_operativa,
			     case when  l.cod_tipo_linea_mod is not null then l.cod_tipo_linea
			     else attivita_controllate end as  cod_tipo_linea_mod,
			     l.id_linea , 
			     a.idua::int as sd_id,
			     a.comune,
			     a.cod_regionale
			     from 
			    (select * from 
			    json_populate_recordset(null::record,v->'lista') as 
			    (idua varchar,nome varchar,cod_regionale varchar,comune varchar,attivita_controllate varchar)
			    ) a 
			    left join  agenda.vw_linee l  on    (l.sd_id::int =a.idua::int

			--    and replace(replace(substring(l.cod_tipo_linea,1,strpos(l.cod_tipo_linea,' ')),'[',''),']','')=
		      --  replace(replace(substring(a.attivita_controllate,1,strpos(a.attivita_controllate,' ')),'[',''),']','')
		       -- AND 	 split_part(a.attivita_controllate,' ',1) =l.cod_tipo_linea_mod ) --ANTONIO
			    and  l.linea_principale is true  )
		     --   or (     l.sd_id::int =a.idua::int and l.linea_principale is true)
		   --     AND 	 regexp_replace(upper(TRIM(a.nome   )),         '[ 	]+', ' ', 'g') =
		     --   		 regexp_replace(upper(trim(l.denominazione_sede_operativa)),'[ 	]+', ' ', 'g')
		       -- AND 	 regexp_replace(upper(TRIM(a.comune )),         '[ 	]+', ' ', 'g') =
		        --		 regexp_replace(upper(trim(l.comune)),          '[ 	]+', ' ', 'g')
		       --and      regexp_replace(upper(TRIM(a.cod_regionale)),   '[ 	]+', ' ', 'g') =
		        --		 regexp_replace(upper(trim(l.app_number)),      '[ 	]+', ' ', 'g')
		        
		    ) b;
		   
		raise notice 'dopo select';
		 update agenda.import_linea impL
		 set cod_tipo_linea= subquery.cod_tipo_linea,id_linea= subquery.id_linea
		 from (
			select l.cod_tipo_linea ,l.id_linea,il.id  from
			agenda.import_linea il
			inner join agenda.vw_linee l on l.sd_id =il.sd_id and l.linea_principale is true  
			where il.id_linea  is null and il.id_lista =idlista  
		
	 	) as subquery
		 where 
		 subquery.id=impL.id;

  		raise notice 'dopo update';
		   
		   
		update agenda.lista_import set dt=current_timestamp where id=idlista;
		ret.esito:=true;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.load_import_formato_sicer_old(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: load_linee_xls(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.load_linee_xls(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	proc_name varchar;
	ret ag_types.result_type; 
	idelabcal bigint;
	begin
		proc_name:='agenda.load_linee_xls';
		idelabcal:=v->'id_elab_cal';
		delete from agenda.linee_selezionate where id_elab_cal=idelabcal;
	
		insert into agenda.linee_selezionate
			select nextval('agenda.agenda_id_seq'),R_EC.id, lp.id_linea ,lp.id_piano,row_number () over() from 
			
			(select id_linea ,id_piano,row_number () over() from 
			json_populate_recordset(null::record,v_j->'id_linea_piani') as (id_linea int8,id_piano int8) 
			) lp;

		ret.esito:=true;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.load_linee_xls(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: load_lista_cf(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.load_lista_cf(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	proc_name varchar;
	ret ag_types.result_type; 
	idlista bigint;
	begin
		proc_name:='agenda.load_lista_cl';
		idlista:=v->'id_lista';
		delete from agenda.allevamenti_cf where id_lista=idlista;
	
		insert into agenda.allevamenti_cf
			select nextval('agenda.agenda_id_seq'),idlista,id_linea ,attributo,cod_allevamento from 
			
			(select id_linea ,attributo,cod_allevamento from 
			json_populate_recordset(null::record,v_j->'lista_cf') as (id_linea int8,attributo varchar,cod_allevamento varchar) 
			) lp;

		ret.esito:=true;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.load_lista_cf(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: move_asl_ordinamento(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.move_asl_ordinamento(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret ag_types.result_type;
		v_j json;
		R_SA matrix.struttura_asl;
		R_T matrix.vw_tree_nodes_down_asl_descr;
		R_T2 matrix.vw_tree_nodes_down_asl_descr;
		v_id_node bigint;
		v_id_node_parent bigint;
		n integer;
		proc_name varchar;
		--ord bigint[];
		spostamento varchar;
		R_TT matrix.tree_nodes;
		begin
		proc_name:='agenda.move_asl_ordinamento';
		v_j:=v::json;
		v_id_node:=v_j->'id_node';
		v_id_node_parent:=v_j->'id_node_parent';
		spostamento:=v_j->>'spostamento';
		
		
		--Prendo le informazioni del nodo che voglio spostare
		select * into R_T from matrix.vw_tree_nodes_down_asl_descr vp 
		where id_node = v_id_node
		and name_tree ilike 'Struttura ASL'
		--and vp.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text)
		;
	
		raise notice 'R_T%',R_T;
	
		
		/*ord:= ARRAY(select ordinamento from matrix.vw_tree_nodes_down_asl_descr vp
		where id_node_parent = R_T.id_node_parent and id_tree = R_T.id_tree 
		and vp.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));
		raise notice 'ord%',ord;
*/
		
		if spostamento ilike 'up' then
			
			--Prendo informazioni del piano con ordinamento maggiore rispetto agli altri
			select * into R_T2 from matrix.vw_tree_nodes_down_asl_descr vp
			where id_node_parent = v_id_node_parent and id_tree = R_T.id_tree
			and ordinamento < R_T.ordinamento 
			--and vp.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text)
			order by ordinamento desc limit 1;
			
			raise notice 'R_T2%',R_T2;
		
			--Sposto il piano che voglio muovere di 1 posto verso sopra
			update matrix.tree_nodes set 
			ordinamento = LPAD(R_T.ordinamento::varchar,4,'0')
			--node_descr = R_T.descrizione
			where id_tree = R_T2.id_tree and id = R_T2.id_node returning * into R_TT;
			n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_TT,'U');
		
		
			/*update matrix.struttura_asl set 
			ordinamento = R_T2.ordinamento::bigint,
			descrizione = R_T.descrizione,
			descrizione_breve = R_T.descrizione_breve,
			id_asl = R_T.id_asl,
			n_livello = R_T.n_livello,
			id_gisa = R_T.id_gisa,
			codice_interno_fk = R_T.codice_interno_fk,
			--codice_interno_univoco = R_T.codice_interno_univoco,
			anno = R_T.anno,
			ups = R_T.ups,
			uba = R_T.uba
			where id = R_T2.id_node; */
			
			--Sposto il piano che ho ricavato sotto
			update matrix.tree_nodes set 
			ordinamento = LPAD(R_T2.ordinamento::varchar,4,'0')
			--node_descr = R_T2.descrizione
			where id_tree = R_T.id_tree and id = R_T.id_node returning * into R_TT;
			n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_TT,'U');
		

		/*	update matrix.struttura_asl set 
			ordinamento = R_T.ordinamento::bigint,
			descrizione = R_T2.descrizione,
			descrizione_breve = R_T2.descrizione_breve,
			id_asl = R_T2.id_asl,
			n_livello = R_T2.n_livello,
			id_gisa = R_T2.id_gisa,
			codice_interno_fk = R_T2.codice_interno_fk,
			--codice_interno_univoco = R_T2.codice_interno_univoco,
			anno = R_T2.anno,
			ups = R_T2.ups,
			uba = R_T2.uba
			where id = R_T.id_node;  */
		
		else
			--Prendo informazioni del piano con ordinamento minore rispetto agli altri
			select * into R_T2 from matrix.vw_tree_nodes_down_asl_descr vp
			where id_node_parent = v_id_node_parent and id_tree = R_T.id_tree
			and ordinamento > R_T.ordinamento
			--and vp.validita && tsrange(CURRENT_TIMESTAMP::timestamp without time zone, NULL::timestamp without time zone, '[)'::text)
			order by ordinamento limit 1;
			
			raise notice 'R_T2%',R_T2;
		
			--Sposto il piano che voglio muovere di 1 posto verso sopra
			update matrix.tree_nodes set 
			ordinamento = LPAD(R_T.ordinamento::varchar,4,'0')
			-- node_descr = R_T.descrizione
			where id_tree = R_T2.id_tree and id = R_T2.id_node returning * into R_TT;
			n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_TT,'U');
		
		
		/*	update matrix.struttura_asl set 
			ordinamento = R_T2.ordinamento::bigint,
			descrizione = R_T.descrizione,
			descrizione_breve = R_T.descrizione_breve,
			id_asl = R_T.id_asl,
			n_livello = R_T.n_livello,
			id_gisa = R_T.id_gisa,
			codice_interno_fk = R_T.codice_interno_fk,
			--codice_interno_univoco = R_T.codice_interno_univoco,
			anno = R_T.anno,
			ups = R_T.ups,
			uba = R_T.uba
			where id = R_T2.id_node; */
			
			--Sposto il piano che ho ricavato sotto
			update matrix.tree_nodes set 
			ordinamento = LPAD(R_T2.ordinamento::varchar,4,'0')
			--node_descr = R_T2.descrizione
			where id_tree = R_T.id_tree and id = R_T.id_node returning * into R_TT;
			n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_TT,'U');
		

	/*		update matrix.struttura_asl set 
			ordinamento = R_T.ordinamento::bigint,
			descrizione = R_T2.descrizione,
			descrizione_breve = R_T2.descrizione_breve,
			id_asl = R_T2.id_asl,
			n_livello = R_T2.n_livello,
			id_gisa = R_T2.id_gisa,
			codice_interno_fk = R_T2.codice_interno_fk,
			--codice_interno_univoco = R_T2.codice_interno_univoco,
			anno = R_T2.anno,
			ups = R_T2.ups,
			uba = R_T2.uba
			where id = R_T.id_node;  */
	
		end if;	
		
	
	    GET DIAGNOSTICS n = ROW_COUNT;
		 if n < 1 then
			ret.esito:=false;
			ret:=ag_ui.build_ret(ret,proc_name, 'errore_aggiornamento_spostamento_piano');
			return ret;
		 end if;
	  	
	  	ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info = '0';
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
		return ret;
		end;
	END;
$$;


ALTER FUNCTION agenda.move_asl_ordinamento(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: move_piano(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.move_piano(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret ag_types.result_type;
		v_j json;
		R_SP matrix.struttura_piani;
		R_T matrix.vw_tree_nodes_up_piani;
		v_id_node bigint;
		v_id_node_parent bigint;
		n integer;
		proc_name varchar;
		ord bigint;
		R_TT matrix.tree_nodes;
		begin
		proc_name:='agenda.upd_piano';
		v_j:=v::json;
		v_id_node:=v_j->'id_node';
		v_id_node_parent:=v_j->'id_node_parent';
	

		select coalesce(max(ordinamento::bigint),0) + 1 into ord from matrix.tree_nodes tn 
		where id_parent = v_id_node_parent;
		
		update matrix.tree_nodes 
		set ordinamento = ord,
			id_parent = v_id_node_parent
		where id = v_id_node returning * into R_TT;
		n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_TT,'U');
		
		--Prendo le informazioni del nodo che voglio spostare
		/*select * into R_T from matrix.vw_tree_nodes_up_piani vp 
		where id_node = v_id_node
		and name_tree ilike 'Struttura Piani';
	
		raise notice 'R_T%',R_T;
		
		-- Sposto il nodo sotto a quello che voglio spostare
		update matrix.tree_nodes 
		set ordinamento = LPAD((ordinamento::bigint + 1)::varchar,4,'0')
		where id_tree = R_T.id_tree and id_parent = v_id_node_parent; 
	
		select ordinamento into ord from matrix.tree_nodes
		where id_tree = R_T.id_tree and id_parent = v_id_node_parent
		order by ordinamento desc;
		
		raise notice 'ord%',ord;
	
		if ord is null then
			ord = 0;
		end if;
	
		update matrix.tree_nodes
		set ordinamento = LPAD((ord + 1)::varchar,4,'0'),
			id_parent = v_id_node_parent
		where id = v_id_node and id_tree = R_T.id_tree;
	
		update matrix.struttura_piani 
		set ordinamento = ord + 1
		where id = v_id_node;
		*/
	
		/* update matrix.struttura_piani 
		set alias = R_SP.alias,
			descrizione = R_SP.descrizione,
			descrizione_breve = R_SP.descrizione_breve
		where id = v_id_node; */
		
		
	
	
	    GET DIAGNOSTICS n = ROW_COUNT;
		 if n < 1 then
			ret.esito:=false;
			ret:=ag_ui.build_ret(ret,proc_name, 'errore_aggiornamento_piano');
			return ret;
		 end if;
	  	
	  	ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info = '0';
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
		return ret;
		end;
	END;
$$;


ALTER FUNCTION agenda.move_piano(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: move_piano_ordinamento(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.move_piano_ordinamento(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret ag_types.result_type;
		v_j json;
		R_SP matrix.struttura_piani;
		R_T matrix.tree_nodes;
		R_T2 matrix.tree_nodes;
		R_TT matrix.tree_nodes;
		v_id_node bigint;
		n integer;
		proc_name varchar;
		ord bigint[];
		spostamento varchar;
		begin
		proc_name:='agenda.move_piano_ordinamento';
		v_j:=v::json;
		v_id_node:=v_j->'id_node';
		--v_id_node_parent:=v_j->'id_node_parent';
		spostamento:=v_j->>'spostamento';
		
		
		--Prendo le informazioni del nodo che voglio spostare
		select * into R_T from matrix.tree_nodes vp 
		where id = v_id_node;
	
		raise notice 'R_T%',R_T;
		
		if spostamento ilike 'up' then
			
			--Prendo informazioni del piano con ordinamento maggiore rispetto agli altri
			select * into R_T2 from matrix.tree_nodes vp
			where id_parent = R_T.id_parent and id_tree = R_T.id_tree
			and ordinamento < R_T.ordinamento
			order by ordinamento desc limit 1;
			
			raise notice 'R_T2%',R_T2;
		
			--Sposto il piano che voglio muovere di 1 posto verso sopra
			update matrix.tree_nodes set 
			ordinamento = LPAD(R_T.ordinamento::varchar,4,'0')
			--node_descr = R_T.descrizione
			where id_tree = R_T2.id_tree and id = R_T2.id returning * into R_TT;
			n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_TT,'U');

			update matrix.tree_nodes set 
			ordinamento = LPAD(R_T2.ordinamento::varchar,4,'0')
			--node_descr = R_T.descrizione
			where id_tree = R_T.id_tree and id = R_T.id returning * into R_TT;
			n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_TT,'U');
		
		else
			--Prendo informazioni del piano con ordinamento maggiore rispetto agli altri
			select * into R_T2 from matrix.tree_nodes vp
			where id_parent = R_T.id_parent and id_tree = R_T.id_tree
			and ordinamento > R_T.ordinamento
			order by ordinamento  limit 1;
			
			raise notice 'R_T2%',R_T2;
		
			--Sposto il piano che voglio muovere di 1 posto verso sopra
			update matrix.tree_nodes set 
			ordinamento = LPAD(R_T2.ordinamento::varchar,4,'0')
			--node_descr = R_T.descrizione
			where id_tree = R_T.id_tree and id = R_T.id returning * into R_TT;
			n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_TT,'U');

			update matrix.tree_nodes set 
			ordinamento = LPAD(R_T.ordinamento::varchar,4,'0')
			--node_descr = R_T.descrizione
			where id_tree = R_T.id_tree and id = R_T2.id returning * into R_TT;
			n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_TT,'U');
	
		end if;	
		
	
	    GET DIAGNOSTICS n = ROW_COUNT;
		 if n < 1 then
			ret.esito:=false;
			ret:=ag_ui.build_ret(ret,proc_name, 'errore_aggiornamento_spostamento_piano');
			return ret;
		 end if;
	  	
	  	ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info = '0';
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
		return ret;
		end;
	END;
$$;


ALTER FUNCTION agenda.move_piano_ordinamento(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: nuovo_anno(integer, integer); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.nuovo_anno(anno_old integer, anno_new integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
	declare
	n integer;
	begin
		insert into agenda.struttura_comuni 
select nextval('agenda.agenda_id_seq'),id_comune,sn.id from agenda.struttura_comuni sc 
join matrix.struttura_asl so on sc.id_struttura  =so.id and so.anno =2022
join matrix.struttura_asl sn on so.descrizione_breve  =sn.descrizione_breve  and sn.anno =2023;

insert into agenda.nominativo_comuni 
select nextval('agenda.agenda_id_seq'), nsn.id,scn.id from agenda.nominativo_comuni nc
join matrix.vw_nominativi_struttura ns on nc.id_nominativo_struttura =ns.id and ns.anno=2022
join agenda.vw_struttura_comuni sc on nc.id_struttura_comune =sc.id_struttura_comune and sc.anno=2022
join matrix.vw_nominativi_struttura nsn on ns.id_anagrafica=nsn.id_anagrafica and nsn.descrizione =ns.descrizione and nsn.anno=2023
join agenda.vw_struttura_comuni scn on scn.id_comune  =sc.id_comune  and scn.descrizione=sc.descrizione and scn.anno =2023;

insert into agenda.asl_piani 
select nextval('agenda.agenda_id_seq'), an.id,pn.id from agenda.vw_asl_piani ap
join matrix.struttura_piani pn on ap.cod_raggruppamento =pn.cod_raggruppamento and pn.anno=2023 and ap.anno_piano =2022
join matrix.struttura_asl   an on ap.descrizione_asl    =an.descrizione        and an.anno=2023 and ap.anno_asl   =2022;


insert into agenda.nominativo_piani 
select --distinct np.id_nominativo_struttura  
nextval('agenda.agenda_id_seq'), nsn.id,npn.id
from agenda.vw_nominativo_piani np
join matrix.struttura_piani npn on np.cod_raggruppamento =npn.cod_raggruppamento and npn.anno=2023 and np.anno_piano =2022
join matrix.vw_nominativi_struttura nsn on np.id_anagrafica=nsn.id_anagrafica and np.descrizione_breve_asl  =nsn.descrizione_breve  and nsn.anno=2023 and np.anno_asl=2022;

insert into agenda.linea_piani 
select nextval('agenda.agenda_id_seq'), lp.id_linea,pn.id from agenda.linea_piani lp 
join matrix.struttura_piani p on p.id=lp.id_piano 
join matrix.struttura_piani pn on p.cod_raggruppamento =pn.cod_raggruppamento and pn.anno=2023 and p.anno =2022;

insert into agenda.piani_ateco  
select  pn.id,id_tipo_linea from agenda.piani_ateco pa
join matrix.struttura_piani p on p.id=pa.id_piano 
join matrix.struttura_piani pn on p.cod_raggruppamento =pn.cod_raggruppamento and pn.anno=2023 and p.anno =2022;


update matrix.struttura_asl set descrizione_breve = trim(
replace(replace(
replace(replace(replace(replace(
replace(replace (replace (replace (descrizione,'Azienda Sanitaria Universitaria','ASU'),'Azienda Sanitaria','AS'),
'FRIULI CENTRALE','FC'),'Distretto di ',''),'TDP ',''),' - ',' '),'-',''),'VET ','VET'),
'CAMPANIA','Friuli Venezia Giulia'),'SVET','SVET '))
 where anno=2023;

insert into matrix.struttura_piano_target
select nextval('matrix.oid_matrix'),an.id,pn.id,target from matrix.struttura_piano_target t join matrix.struttura_piani p on p.id=t.id_piano 
join matrix.struttura_piani pn on pn.cod_raggruppamento =p.cod_raggruppamento and pn.anno=2023
join matrix.struttura_asl a on a.id=t.id_struttura
join matrix.struttura_asl an on a.descrizione =an.descrizione and an.anno =2023;


insert into  matrix.mod4_nominativi
select m.id,nsn.id,livello_formativo,carico_annuale,perc_sottr,perc_sottr2,
fattore1,fattore2,fattore3,uba_ora,fattori_text,ups,uba,entered,perc_dest_uba
from matrix.mod4_nominativi m
join matrix.vw_nominativi_struttura ns on m.id_nominativo_struttura =ns.id and ns.anno=2022
join matrix.vw_nominativi_struttura nsn on ns.id_anagrafica=nsn.id_anagrafica and nsn.descrizione =ns.descrizione and nsn.anno=2023;

insert into  matrix.mod4_nominativi
select m.id,nsn.id,id_fattore,valore
from matrix.mod4_nominativi_fattori  m
join matrix.vw_nominativi_struttura ns on m.id_nominativo_struttura =ns.id and ns.anno=2022
join matrix.vw_nominativi_struttura nsn on ns.id_anagrafica=nsn.id_anagrafica and nsn.descrizione =ns.descrizione and nsn.anno=2023;

insert into matrix.mod4_strutture
select m.id,an.id,sottr,fattore1,fattore2,m.ups,m.uba  from matrix.mod4_strutture m
--where id_struttura in (select id from matrix.struttura_asl sa )
join matrix.struttura_asl a on a.id=m.id_struttura and a.anno=2022
join matrix.struttura_asl an on a.descrizione =an.descrizione and an.anno =2023;

		return n;
	end;
END
$$;


ALTER FUNCTION agenda.nuovo_anno(anno_old integer, anno_new integer) OWNER TO postgres;

--
-- Name: result_type; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.result_type (
    esito boolean,
    valore text,
    msg character varying,
    info character varying,
    err_msg character varying
);


ALTER TABLE cu_types.result_type OWNER TO postgres;

--
-- Name: remap_config(integer, integer); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.remap_config(anno_old integer, anno_new integer) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	begin
		drop table if exists tmp.asl_remap;
		create table tmp.asl_remap as
		select a.id idold,b.id as idnew from matrix.struttura_asl a
		join matrix.struttura_asl b on a.descrizione_breve=b.descrizione_breve
		where a.anno=anno_old and b.anno=anno_new ;
		
		drop table if exists tmp.piani_remap;
		create table tmp.piani_remap as
		select a.id idold,b.id as idnew from matrix.struttura_piani a
		join matrix.struttura_piani b on (a.alias is not null and a.alias != '' and a.alias=b.alias) or 
		((a.alias is null or a.alias = '') and a.descrizione=b.descrizione)
		where a.anno=anno_old and b.anno=anno_new;
		
		drop table if exists tmp.ns_remap;
		create table tmp.ns_remap as
		select a.id idold,b.id as idnew from matrix.vw_nominativi_struttura a
		join matrix.vw_nominativi_struttura  b on a.nominativo=b.nominativo and a.descrizione_breve=b.descrizione_breve 
		where a.anno=anno_old and b.anno=anno_new;
	
		return ret;
	end;
	END;
$$;


ALTER FUNCTION agenda.remap_config(anno_old integer, anno_new integer) OWNER TO postgres;

--
-- Name: riversa_calendario(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.riversa_calendario(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint; 
        idelabcal bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
       	r_pl ag_types.ag_tipo_eventi;
      	r_cu ag_types.ag_tipo_eventi;
      	n integer;
        begin
		proc_name:='agenda.riversa_calendario';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'v=%',v;

		idelabcal:=v->'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v->>'id_gen_cal';
		end if;
		select * into r_cu from ag_types.ag_tipo_eventi where sigla='CU';
		select * into r_pl from ag_types.ag_tipo_eventi where sigla='PL';
	
		raise notice 'IDGENCAL %',idelabcal;
		if idelabcal is not null then
			raise notice 'IDGENCAL NOT NULL';
			--insert into agenda.eventi
			for R_EV in
				select nextval('agenda.agenda_id_seq'),id_risorsa,case when bd.id_piano is null then r_cu.id else r_pl.id end,
				dt,dt+durata,id_linea,id,a.id_piano,
				false,id_partner,null,null,id_struttura,id_elab_cal,null,id_struttura_partner,true validita_interna,1 quantita
				from agenda.attivita a
				left join
					(select id_piano from dblink('bdn_fvg','select distinct id_piano from bdn_prof.piano_profilassi')
						as T(id_piano bigint)) bd on  bd.id_piano=a.id_piano
				where id_elab_cal=idelabcal 
					and id not in (select id_attivita from agenda.eventi where id_elab_cal=idelabcal)
		 			and id_risorsa is not null and dt is not null loop
			 	R_EV.id_user_create :=v->'user_info'->'id_utente';
			 	R_EV.ts_create:=current_timestamp;
		 		insert into agenda.eventi values(R_EV.*) returning * into R_EV;
		 		n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'I');
		 	
		 	end loop;
		 			
			--delete from agenda.attivita where id_elab_cal=idelabcal;
			--update agenda.attivita set riversata=true  where id_elab_cal=idelabcal  and id_risorsa is not null;
		else
			raise notice 'IDGENCAL NULL';
			--insert into agenda.eventi
			for R_EV in
				select nextval('agenda.agenda_id_seq'),id_risorsa,case when bd.id_piano is null then r_cu.id else r_pl.id end,
				dt,dt+durata,id_linea,id,a.id_piano,
				false,id_partner,null,null,id_struttura,id_elab_cal,null,id_struttura_partner,true validita_interna,1 quantita
				from agenda.attivita a
				
				left join
					(select id_piano from dblink('bdn_fvg','select distinct id_piano from bdn_prof.piano_profilassi')
						as T(id_piano bigint)) bd on  bd.id_piano=a.id_piano
				
				where id in (select (value::varchar)::bigint id from json_array_elements(v->'id_attivita')) 
					and id not in (select id_attivita from agenda.eventi where id_attivita is not null)/*and (riversata = false or riversata is null) */
					and id_risorsa is not null and dt is not null loop
				R_EV.id_user_create :=v->'user_info'->'id_utente';
			   	R_EV.ts_create:=current_timestamp;
				insert into agenda.eventi values(R_EV.*) returning * into R_EV;
				n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'I');
												
			end loop;
											
			--update agenda.attivita set riversata=true  
			--where id in (select (value::varchar)::bigint id from 
			--										json_array_elements(v->'id_attivita')) and (riversata = false or riversata is null) and id_risorsa is not null;
		end if;

    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,R_EV.id);
		ret:=ag_ui.build_ret(ret,proc_name, 'riversamento_effettuato');
         ret.info = '0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.riversa_calendario(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: riversa_calendario(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.riversa_calendario(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint; 
        idcalendario bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
        v_j json;
        begin
		proc_name:='agenda.riversa_calendario';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		idcalendario:=replace((v_j->'id')::text,'"','')::int8;
		delete from agenda.eventi where id_nominativo in (select distinct id_risorsa from agenda.attivita);
		insert into agenda.eventi select nextval('agenda.agenda_id_seq'),id_risorsa,1,dt,dt+durata,id_linea,id,id_piano,false,null,null,null,id_struttura
		from agenda.attivita where id_elab_cal=1 and id_linea is not null;

    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,R_EV.id);
    	
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.riversa_calendario(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_asl(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_asl(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret ag_types.result_type;
		v_j json;
		R_SP matrix.struttura_asl;
		R_T matrix.tree_nodes;
		v_id_node bigint;
		v_id bigint; --id del nodo dell'albero specifico, visto che id e id_node possono essere diversi
		v_inizio_validita timestamp;
		v_fine_validita timestamp;
		n integer;
		proc_name varchar;
		begin
		proc_name:='agenda.upd_asl';
		v_j:=v::json;
		--v_inizio_validita:=v_j->>'inizio_validita';
		--v_fine_validita:=v_j->>'fine_validita';
		v_id_node:=v_j->'id_node';
		v_id:=v_j->'id';
		R_SP.descrizione:=cu_anag.string_normalize_upper(v_j->>'descrizione');
		R_SP.descrizione_breve:=cu_anag.string_normalize_upper(v_j->>'descrizione_breve');
	
		if v_j->>'fine_validita' != '' and v_j->>'fine_validita' is not null then
				v_fine_validita:=(v_j->>'fine_validita');
				--v_fine_validita:=(v_j->>'fine_validita')::date + interval '1 day';
		end if;
		
		if v_j->>'inizio_validita' != '' and v_j->>'inizio_validita' is not null then
			v_inizio_validita:=v_j->>'inizio_validita';
		end if;
	
		if v_inizio_validita is not null and  v_fine_validita is not null
				and v_inizio_validita >= v_fine_validita then
			ret.esito:=false;	
			ret:=ag_ui.build_ret(ret,proc_name,'inizio_e_fine_validita_non_compatibli');
			ret.info='0';
			return ret;
		end if;
	
		if v_j->>'inizio_validita' = '' then 
			v_inizio_validita:= null;
		end if;
	
		R_T.validita = tsrange(v_inizio_validita, v_fine_validita, '[)');
	
		select count(*) into n from matrix.struttura_asl sa 
		join matrix.tree_nodes tn on sa.id = tn.id
		where descrizione =  R_SP.descrizione
		and descrizione_breve = R_SP.descrizione_breve and v_id_node!=sa.id
		and validita && tsrange(v_inizio_validita,null,'[)');
		
		if n > 0 then
		    ret:=ag_ui.build_ret(ret,proc_name, 'struttura_asl_esistente');
		   	ret.esito:=false;
	   		return ret;
		end if;
	
		
		update matrix.struttura_asl 
		set descrizione = R_SP.descrizione,
			descrizione_breve = R_SP.descrizione_breve
		where id = v_id_node returning * into R_SP;
		n:=ag_log.upd_record('agenda.struttura_asl',idtransazione,R_SP,'U');
	
		update matrix.tree_nodes 
		set validita = R_T.validita
		where id = v_id returning * into R_T;
		n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_T,'U');
		
	    GET DIAGNOSTICS n = ROW_COUNT;
		 if n < 1 then
			ret.esito:=false;
			ret:=ag_ui.build_ret(ret,proc_name, 'errore_aggiornamento_asl');
			return ret;
		 end if;
	  	
	  	ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info = '0';
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
		return ret;
		end;
	END;
$$;


ALTER FUNCTION agenda.upd_asl(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_att_associa_linea(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_att_associa_linea(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idlinea bigint;
        proc_name varchar; -- END
        idevento bigint;
       	R_A agenda.attivita;
       	n integer;
       	rc record;
        begin
		proc_name:='agenda.upd_att_associa_linea';
		idlinea:=v_j->'id_linea';
			
		for rc in select  (value::varchar)::bigint id from 
			json_array_elements(v_j->'id_attivita') loop
				update agenda.attivita set id_linea = idlinea where id = rc.id returning * into R_A;
				n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U');
			end loop;
	
		/*update agenda.attivita set id_linea =idlinea where id in (
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'id_attivita') ) returning * into R_A;
		n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U'); */
    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idlinea);
    	ret:=ag_ui.build_ret(ret,proc_name,'associazione_effettuata_con_successo');
		ret.info='0';
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_att_associa_linea(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_att_associa_nominativo(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_att_associa_nominativo(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idnominativo bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        R_NS matrix.vw_nominativi_struttura;
       	R_A agenda.attivita;
        idevento bigint;
       	idstruttura bigint;
        tot bigint;
       	t bigint;
        eff bigint;
       	n integer;
       	rc record;
        begin
		proc_name:='agenda.upd_att_associa_nominativo';
		idnominativo:=v_j->'id_nominativo';
		--idstruttura:=v_j->'id_struttura';
		if idnominativo is null then
			idnominativo:=v_j->'id_ns';
		end if;
		if idnominativo is null then
		    ret.esito:=false;	
    		ret:=ag_ui.build_ret(ret,proc_name,'nominativo_non_specificato');
			return ret;
		end if;
		select * into R_NS
		from matrix.vw_nominativi_struttura where id=idnominativo;
		raise notice 'NOMINATIVO % STRUTTURA %',R_NS.id_nominativo,R_NS.id_struttura;
			if R_NS.id_nominativo is null or R_NS.id_struttura is null then
			    ret.esito:=false;	
	    		ret:=ag_ui.build_ret(ret,proc_name,'nominativo_errato');
				return ret;
			end if;
		tot:=coalesce(json_array_length(v_j->'id_attivita'),0);
		
		for rc in select  (value::varchar)::bigint id from 
			json_array_elements(v_j->'id_attivita') 
					where not exists 
			(select id from agenda.eventi where id_attivita is not null and id_attivita=(value::varchar)::bigint) 
		loop
			update agenda.attivita set 
			id_risorsa  =R_NS.id_nominativo,
			id_struttura=R_NS.id_struttura,
		
			id_partner          = case when id_partner is not null and id_partner=R_NS.id_nominativo then null else id_partner end,
			id_struttura_partner= case when id_struttura_partner is not null and id_partner=R_NS.id_nominativo then null else id_struttura_partner end
			where id = rc.id returning * into R_A;
			n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U');
		end loop;
		
			
	
	
	
		/*update agenda.attivita set 
		id_risorsa  =R_NS.id_nominativo,
		id_struttura=R_NS.id_struttura,
		
		id_partner          = case when id_partner is not null and id_partner=R_NS.id_nominativo then null else id_partner end,
		id_struttura_partner= case when id_struttura_partner is not null and id_partner=R_NS.id_nominativo then null else id_struttura_partner end

		
		where id in (
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'id_attivita') 
					where not exists 
			(select id from agenda.eventi where id_attivita is not null and id_attivita=(value::varchar)::bigint) 
			) returning * into R_A;
		n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U'); */
		GET DIAGNOSTICS eff := ROW_COUNT;
    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativo);
    	ret:=ag_ui.build_ret(ret,proc_name,'associazione_effettuata_con_successo');
		ret.info='0';
	    ret.msg:='Associate '|| eff ||' attività di '||tot||' selezionate';
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_att_associa_nominativo(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_att_associa_partner(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_att_associa_partner(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idpartner bigint;
        idstrutturapartner bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        R_NS matrix.vw_nominativi_struttura;
        idevento bigint;
        tot bigint;
       	t bigint;
        eff bigint;
       	R_A agenda.attivita;
       	n integer;
       	rc record;
        begin
		proc_name:='agenda.upd_att_associa_partner';
		idpartner:=v_j->'id_partner';
	
		if idpartner is null then
		    ret.esito:=false;	
			ret:=ag_ui.build_ret(ret,proc_name,'partner_non_specificato');
			return ret;
		end if;
		select * into R_NS
		from matrix.vw_nominativi_struttura where id=idpartner;
		--idstrutturapartner:=v_j->'id_struttura';
		tot:=coalesce(json_array_length(v_j->'id_attivita'),0);
	
		for rc in select  (value::varchar)::bigint id from 
			json_array_elements(v_j->'id_attivita')
			where not exists 
			(select id from agenda.eventi where id_attivita is not null and id_attivita=(value::varchar)::bigint)
		loop
			update agenda.attivita set
			id_partner          =case when id_risorsa is  null or  id_risorsa!=R_NS.id_nominativo then R_NS.id_nominativo else null end,
			id_struttura_partner=case when id_risorsa is  null or  id_risorsa!=R_NS.id_nominativo then R_NS.id_struttura  else null end
			--id_partner =idpartner,id_struttura_partner=idstrutturapartner
			where id = rc.id returning * into R_A;
			n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U');
		end loop;
			
		/*update agenda.attivita set
			id_partner          =case when id_risorsa is  null or  id_risorsa!=R_NS.id_nominativo then R_NS.id_nominativo else null end,
			id_struttura_partner=case when id_risorsa is  null or  id_risorsa!=R_NS.id_nominativo then R_NS.id_struttura  else null end
			--id_partner =idpartner,id_struttura_partner=idstrutturapartner
		where id in (
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'id_attivita')
			where not exists 
			(select id from agenda.eventi where id_attivita is not null and id_attivita=(value::varchar)::bigint) )
		
			and id_risorsa not in (select id from matrix.nominativi n where id_anagrafica = R_NS.id_anagrafica) -- ISSUE #11560 
			returning * into R_A;
		n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U'); */
    	GET DIAGNOSTICS eff := ROW_COUNT;
		ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativo);
    	ret:=ag_ui.build_ret(ret,proc_name,'associazione_effettuata_con_successo');
		ret.info='0';
		ret.msg:='Associate '|| eff ||' attività di '||tot||' selezionate';
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_att_associa_partner(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_att_associa_validita(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_att_associa_validita(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idnominativo bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
       valido_da timestamp;
       valido_a timestamp;
      	R_A agenda.attivita;
      	n integer;
      	rc record;
        begin
		proc_name:='agenda.upd_att_associa_validita';
		valido_da:=v_j->'valido_da';
		valido_a :=v_j->'valido_a';
			
		for rc in select  (value::varchar)::bigint id from 
			json_array_elements(v_j->'id_attivita') 
		loop
			update agenda.attivita set validita =tsrange(valido_da,valido_a,'[]') where id = rc.id;
			n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U');
		end loop;
		
	
		/*update agenda.attivita set validita =tsrange(valido_da,valido_a,'[]') where id in (
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'id_attivita') ) returning * into R_A;
		n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U'); */
    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativo);
        ret:=ag_ui.build_ret(ret,proc_name,'associazione_effettuata_con_successo');
		ret.info='0';
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_att_associa_validita(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_att_cambia_data(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_att_cambia_data(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idnominativo bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
        dt_att timestamp;
        dt_shift integer;
      	dt_shift_type varchar;
		def_min_start          decimal;
		def_ora_start          decimal;
		ora_start interval;
  		R_A agenda.attivita;
  		n integer;
  		rc record;
        begin
		proc_name:='agenda.upd_att_cambia_data';
	
		select value::decimal   into def_ora_start          from ag_conf.ag_conf where cod='cal_start_ora';
		select value::decimal   into def_min_start          from ag_conf.ag_conf where cod='cal_start_minuti';
		ora_start:= (interval '1 hour')*def_ora_start + (interval '1 minute')*def_min_start;
		dt_att:=v_j->'data';
		    ret.esito:=true;	
		   raise notice 'DT_ATT=%',coalesce(dt_att::varchar,'NULL');
		 
		 dt_shift:=v_j->'shift';
		 raise notice 'shift=%',coalesce(dt_shift::varchar,'NULL');
		 dt_shift_type:=v_j->'shift_type';
		 dt_shift_type:=replace(dt_shift_type,'"','');
		 raise notice 'shift_type=%',coalesce(dt_shift_type,'NULL');
		
		 for rc in select  (value::varchar)::bigint id from 
				json_array_elements(v_j->'id_attivita')
		 loop
			if dt_att is not null then		
		
			--update agenda.attivita set dt =coalesce(dt,dt_att) + (date_trunc('day',dt_att )- date_trunc('day',coalesce(dt,dt_att)))
			update agenda.attivita set dt = dt_att
			where id = rc.id;

			else
				if dt_shift_type='mesi'      then
					raise notice 'MESI';
					update agenda.attivita set dt =dt + (interval '1 month')*dt_shift /* + ora_start(interval '9 hour')*/ where id = rc.id returning * into R_A;
					n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U');
				end if;
				if dt_shift_type='giorni'    then
					raise notice 'GIORNI';
					update agenda.attivita set dt =dt + (interval '1 day')  *dt_shift /* ora_start (interval '9 hour')*/ where id = rc.id returning * into R_A;
					n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U');
				end if;
				if dt_shift_type='settimane' then
					raise notice 'SETTIMANE';	
					update agenda.attivita set dt =dt + (interval '1 week') *dt_shift /*+ ora_start (interval '9 hour')*/ where id = rc.id returning * into R_A;
					n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U');
				end if;
			
			end if;
			update agenda.attivita set dt = dt + (date_trunc('day',upper(validita)) - date_trunc('day',dt) - interval '1 day')
			where id = rc.id and (not upper_inf(validita)) and dt > (upper(validita) - interval '1 day') returning * into R_A;
			n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U');
		
			update agenda.attivita set dt = dt + (date_trunc('day',lower(validita)) - date_trunc('day',dt))
			where id = rc.id and (not lower_inf(validita)) and dt < (lower(validita)) returning * into R_A;
			n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U');
		end loop;
		 
		  
		  
		/*if dt_att is not null then		
		
			--update agenda.attivita set dt =coalesce(dt,dt_att) + (date_trunc('day',dt_att )- date_trunc('day',coalesce(dt,dt_att)))
			update agenda.attivita set dt = dt_att
			where id in (
				select  (value::varchar)::bigint from 
				json_array_elements(v_j->'id_attivita') );

		else
			dt_shift:=v_j->'shift';
			raise notice 'shift=%',coalesce(dt_shift::varchar,'NULL');
			dt_shift_type:=v_j->'shift_type';
			dt_shift_type:=replace(dt_shift_type,'"','');
			raise notice 'shift_type=%',coalesce(dt_shift_type,'NULL');
			if dt_shift_type='mesi'      then
				raise notice 'MESI';
				update agenda.attivita set dt =dt + (interval '1 month')*dt_shift /* + ora_start(interval '9 hour')*/ where id in (select  (value::varchar)::bigint from json_array_elements(v_j->'id_attivita') );
			end if;
			if dt_shift_type='giorni'    then
				raise notice 'GIORNI';
				update agenda.attivita set dt =dt + (interval '1 day')  *dt_shift /* ora_start (interval '9 hour')*/ where id in (select  (value::varchar)::bigint from json_array_elements(v_j->'id_attivita') );
			end if;
			if dt_shift_type='settimane' then
				raise notice 'SETTIMANE';	
				update agenda.attivita set dt =dt + (interval '1 week') *dt_shift /*+ ora_start (interval '9 hour')*/ where id in (select  (value::varchar)::bigint from json_array_elements(v_j->'id_attivita') );
			end if;
		
		end if;
		update agenda.attivita set dt = dt + (date_trunc('day',upper(validita)) - date_trunc('day',dt) - interval '1 day')
		where id in (select  (value::varchar)::bigint from json_array_elements(v_j->'id_attivita') )
			and (not upper_inf(validita)) and dt > (upper(validita) - interval '1 day') returning * into R_A;
		n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U');
		
		update agenda.attivita set dt = dt + (date_trunc('day',lower(validita)) - date_trunc('day',dt))
		where id in (select  (value::varchar)::bigint from json_array_elements(v_j->'id_attivita') )
			and (not lower_inf(validita)) and dt < (lower(validita)) returning * into R_A;
		n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U');*/
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativo);
	     ret:=ag_ui.build_ret(ret,proc_name,'associazione_effettuata_con_successo');
		ret.info='0';
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_att_cambia_data(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_att_close(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_att_close(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idlinea bigint;
        proc_name varchar; -- END
        idevento bigint;
       	R_T trf.trf_attivita;
       	n integer;
       	rc record;
        begin
		proc_name:='agenda.upd_att_close';
	
		for rc in select  (value::varchar)::bigint id from 
			json_array_elements(v_j->'id_attivita') 
		loop
			update trf.trf_attivita set closed=true,data_closed=current_timestamp where not closed and id = rc.id returning * into R_T;
			n:=ag_log.upd_record('trf.trf_attivita',idtransazione,R_T,'U');
		end loop;
		
	
		/*update trf.trf_attivita set closed=true,data_closed=current_timestamp where not closed and id in (
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'id_attivita') ) returning * into R_T;
		n:=ag_log.upd_record('trf.trf_attivita',idtransazione,R_T,'U'); */
    	ret.esito:=true;
		ret:=ag_ui.build_ret(ret,proc_name,idlinea);
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_att_close(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_att_elimina_partner(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_att_elimina_partner(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
	n bigint;
        proc_name varchar; -- END
       	R_ATT agenda.attivita%ROWTYPE; 
        idevento bigint;
       valido_da timestamp;
       valido_a timestamp;
        begin
		proc_name:='agenda.upd_att_elimina_partner';

			
		for R_ATT in select * from agenda.attivita where id in (
		
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'id_attivita') )  loop
			update agenda.attivita set id_partner  =null,id_struttura_partner=null where id =R_ATT.id 
				and not exists 
				(select id from agenda.eventi where id_attivita is not null and id_attivita=R_ATT.id )
				returning * into R_ATT;
			n:=ag_log.upd_record('agenda.attivita',idtransazione,R_ATT,'U');
		end loop;
		
    	ret.esito:=true;	
    	GET DIAGNOSTICS n = ROW_COUNT;
		ret:=ag_ui.build_ret(ret,proc_name,null);
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_att_elimina_partner(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_att_elimina_validita(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_att_elimina_validita(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
	n bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
       valido_da timestamp;
       valido_a timestamp;
      	R_A agenda.attivita;
      	rc record;
        begin
		proc_name:='agenda.upd_att_elimina_validita';

		for rc in select  (value::varchar)::bigint id from 
			json_array_elements(v_j->'id_attivita')
		loop
			update agenda.attivita set validita =null where id = rc.id returning * into R_A;
			n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U');
		end loop;
		
			
		/*update agenda.attivita set validita =null where id in (
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'id_attivita') ) returning * into R_A;
		n:=ag_log.upd_record('agenda.attivita',idtransazione,R_A,'U'); */
    	ret.esito:=true;	
    	GET DIAGNOSTICS n = ROW_COUNT;
		--ret:=ag_ui.build_ret(ret,proc_name,n);
        ret:=ag_ui.build_ret(ret,proc_name,'eliminazione_effettuata_con_successo');
		ret.info='0';
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_att_elimina_validita(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_avviso(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_avviso(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
       	v_sigla varchar;
       	v_descrizione varchar;
       	v_id_tipo_avviso bigint;
       	v_id_livello_avviso bigint;
     	v_periodo json;
     	v_data_inizio timestamp;
		v_data_fine timestamp;
		idavviso bigint;
		n integer;
        proc_name varchar; -- END
        v_j json;
		idNs bigint;
		R_A agenda.avvisi;
        begin
		proc_name:='agenda.upd_avviso';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		v_sigla:=v_j->>'sigla';
		v_descrizione:=v_j->>'descrizione';
		v_id_tipo_avviso:=v_j->>'id_tipo_avviso';
		v_id_livello_avviso:=v_j->>'id_livello_avviso';
		idavviso:=v_j->'id_avviso';
		idNs:=v->'user_info'->'id_utente';

		if v->>'periodo' != '' then
			v_periodo:=v->>'periodo';
			raise notice 'fine v_periodo%', v_periodo->>'end';
			if v_periodo->>'start' != '' then
				v_data_inizio:=to_timestamp(v_periodo->>'start'::varchar, 'YYYY-MM-DD"T"HH24:MI:SS');
			end if;
			if v_periodo->>'end' != '' then
				v_data_fine:=to_timestamp(v_periodo->>'end'::varchar, 'YYYY-MM-DD"T"HH24:MI:SS');
					if length(v_periodo->>'end')<=10 then
						v_data_fine:= v_data_fine + interval '1 day';
					end if;
			end if;

		end if;
	
		if v_data_inizio = v_data_fine then
			v_data_fine:= v_data_fine + interval '1 day';
		end if;
	
		raise notice 'v_j:%',v_j;
	
		update agenda.avvisi 
		set codice = v_sigla,
			sigla = v_sigla,
			descrizione = v_descrizione,
			id_tipo_avviso = v_id_tipo_avviso,
			id_livello_avviso = v_id_livello_avviso,
			validita = (tsrange(v_data_inizio::timestamp without time zone,v_data_fine::timestamp without time zone,'[)'))
		where id = idavviso and id_user_create = idNs returning * into R_A;
		n:=ag_log.upd_record('agenda.avvisi',idtransazione,R_A,'U');
	
		/*delete from agenda.nominativo_comuni where id_nominativo_struttura=idns;
		
		insert into agenda.nominativo_comuni 
			select nextval('agenda.agenda_id_seq'), idns,(value::varchar)::bigint from json_array_elements(v_j->'id_struttura_comune');*/

		 GET DIAGNOSTICS n = ROW_COUNT;
		 if n < 1 then
			ret.esito:=false;
			ret:=ag_ui.build_ret(ret,proc_name, 'errore_aggiornamento_avviso');
			return ret;
		 end if;
	  	

    	ret.esito:=true;
		ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_avviso(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_clona_ns_piani(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_clona_ns_piani(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idns bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
        v_j json;
       	R_NP agenda.nominativo_piani;
       	n integer;
       	rc record;
        begin
		proc_name:='agenda.upd_clona_ns_piani';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		idns:=v_j->'id_ns';
	
		for rc in select id from agenda.nominativo_piani np where id_nominativo_struttura in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'clone')) and 
			NOT EXISTS   (select 1 from agenda.nominativo_piani a
									where a.id_nominativo_struttura=idns and 
											a.id_piano = np.id_piano)
		loop
			delete  from agenda.nominativo_piani np where id=rc.id returning * into R_NP;
			n:=ag_log.upd_record('agenda.nominativo_piani',idtransazione,R_NP,'D');
		end loop;
		
		for rc in select nextval('agenda.agenda_id_seq'),
			nw.id_ns_new,np.id_piano from agenda.nominativo_piani np
			join (select (value::varchar)::bigint as id_ns_new from 
			json_array_elements(v_j->'clone')) nw on np.id_nominativo_struttura =idns
			where  NOT EXISTS   (select 1 from agenda.nominativo_piani a
									where a.id_nominativo_struttura=nw.id_ns_new and 
											a.id_piano = np.id_piano)
			loop
				insert into agenda.nominativo_piani
						values(nextval('agenda.agenda_id_seq'),rc.id_ns_new,rc.id_piano) returning * into R_NP;
				n:=ag_log.upd_record('agenda.nominativo_piani',idtransazione,R_NP,'I');
				
			end loop;
			
		
		
		/*delete  from agenda.nominativo_piani np where id_nominativo_struttura in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'clone')) and 
			
			NOT EXISTS   (select 1 from agenda.nominativo_piani a
									where a.id_nominativo_struttura=idns and 
											a.id_piano = np.id_piano) returning * into R_NP;
		n:=ag_log.upd_record('agenda.nominativo_piani',idtransazione,R_NP,'D');

		insert into agenda.nominativo_piani
					select nextval('agenda.agenda_id_seq'),
			nw.id_ns_new,np.id_piano from agenda.nominativo_piani np
			join (select (value::varchar)::bigint as id_ns_new from 
			json_array_elements(v_j->'clone')) nw
			on np.id_nominativo_struttura =idns
			where  NOT EXISTS   (select 1 from agenda.nominativo_piani a
									where a.id_nominativo_struttura=nw.id_ns_new and 
											a.id_piano = np.id_piano) returning * into R_NP;
		n:=ag_log.upd_record('agenda.nominativo_piani',idtransazione,R_NP,'I'); */

    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,R_EV.id);
	    ret:=ag_ui.build_ret(ret,proc_name,'duplicazione_effettuata_con_successo');
        ret.info='0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_clona_ns_piani(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_clona_tipo_linee_per_piano(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_clona_tipo_linee_per_piano(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idpiano bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
        v_j json;
       	R_P agenda.piano_tipo_linea;
       	n integer;
       	rc record;
        begin
		proc_name:='agenda.upd_clona_tipo_linee_per_piano';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		idpiano:=v_j->'id_piano';
	
		for rc in select id from agenda.piano_tipo_linea np where np.id_piano in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'clone') ) and np.id_piano!= idpiano
		loop 
			delete  from agenda.piano_tipo_linea np where id = rc.id;
			n:=ag_log.upd_record('agenda.piano_tipo_linea',idtransazione,R_P,'D');
		
		end loop;
	
		for rc in select 
			nw.id_piano_new,np.id_tipo_linea,nextval('agenda.agenda_id_seq') from agenda.piano_tipo_linea np
			join (select (value::varchar)::bigint as id_piano_new from 
			json_array_elements(v_j->'clone')) nw
			on np.id_piano = idpiano and nw.id_piano_new !=idpiano
		loop
			insert into agenda.piano_tipo_linea values(rc.id_piano_new,rc.id_tipo_linea,nextval('agenda.agenda_id_seq')) returning * into R_P;
			n:=ag_log.upd_record('agenda.piano_tipo_linea',idtransazione,R_P,'I');			
		end loop;
		
		
		
		/*delete  from agenda.piano_tipo_linea np where id_piano in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'clone') )and id_piano!= idpiano returning * into R_P;
		n:=ag_log.upd_record('agenda.piano_tipo_linea',idtransazione,R_P,'D');
			
			/*and 
			
			NOT EXISTS   (select 1 from agenda.piano_tipo_linea a
									where a.id_piano=idpiano and 
											a.id_tipo_linea = np.id_tipo_linea) */

		insert into agenda.piano_tipo_linea
					select 
			nw.id_piano_new,np.id_tipo_linea,nextval('agenda.agenda_id_seq') from agenda.piano_tipo_linea np
			join (select (value::varchar)::bigint as id_piano_new from 
			json_array_elements(v_j->'clone')) nw
			on np.id_piano  =idpiano and nw.id_piano_new !=idpiano
			/*where  NOT EXISTS   (select 1 from agenda.piano_tipo_linea a
									where a.id_piano=idpiano and 
											a.id_tipo_linea = np.id_tipo_linea) */ returning * into R_P;
		n:=ag_log.upd_record('agenda.piano_tipo_linea',idtransazione,R_P,'I'); */

    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,R_EV.id);
	    ret:=ag_ui.build_ret(ret,proc_name,'duplicazione_effettuata_con_successo');
        ret.info='0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_clona_tipo_linee_per_piano(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_dati(character varying, character varying, bigint, json); Type: PROCEDURE; Schema: agenda; Owner: postgres
--

CREATE PROCEDURE agenda.upd_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json)
    LANGUAGE plpgsql
    AS $$
declare 
	idtransazione bigint;
	proc_name varchar;
	id_op bigint;  
	ret ag_types.result_type;
	text_msg1 varchar;	
	text_msg2 varchar;	
	text_msg3 varchar;	
	text_msg4 varchar;
	ts timestamp;
	fallito bool;
	j_user_info json;
	n integer;
begin
	ts:=CLOCK_TIMESTAMP();
	proc_name:='agenda.upd_dati';
	idtransazione:= ag_log.get_id_transazione(idutente,proc_name);
	--select row_to_json(public.get_utente_info_from_gisa(idutente)) into j_user_info;
	--select row_to_json(a.*) into j_user_info from (select u.*,a.n_livello  from public.get_utente_info_from_gisa_ext(idutente) u left join matrix.vw_tree_nodes_up_asl a on a.id_node=u.id_struttura_root) a;

	--idutente è rbac.id_utente_struttura_ruolo
	select row_to_json(a.*) into j_user_info from
	(	
		select *,id_struttura as id_struttura_root from public.get_utente_info_3(idutente)
	) a;
 

	if j_user_info is not null then
		if v is null or v='' or v='{}' then
			v:= '{"user_info":'||j_user_info||'}';
		else
			v:= substring(v,1,length(v)-1)||',"user_info":'||j_user_info||'}';
		end if;
	end if;
	id_op:=ag_log.start_op(proc_name,idtransazione ,v);


--commit; 2024-04-15
 
   	begin
	   	fallito:=false;
	   	case operazione
	   		when 'upd_ag_conf' then
	   			ret:=ag_conf.upd_ag_conf(v::json, idtransazione);
	   		when 'build_att_forfet' then
	   			ret:=trf.build_att_forfet(v::json, idtransazione);
	   		when 'upd_ws_call' then
	   			ret:=trf.upd_ws_call(v::json, idtransazione);
	   		when 'del_tariffa_struttura' then
	   			ret:=trf.del_tariffa_struttura(v::json, idtransazione);
	   		when 'del_tariffa_ml' then
	   			ret:=trf.del_tariffa_ml(v::json, idtransazione);
	   		when 'upd_tariffa_ml' then
	   			ret:=trf.upd_tariffa_ml(v::json, idtransazione);
	   		when 'upd_trf_per_regole' then
	   			ret:=trf.upd_trf_per_regole(v::json, idtransazione);
	   		when 'upd_imp_dati' then
	   			ret:=agenda.upd_imp_dati(v::json, idtransazione);
	   		when 'upd_piano_periodo' then
	   			ret:=trf.upd_piano_periodo(v::json, idtransazione);
	   		when 'upd_tariffa_piano' then
	   			ret:=trf.upd_tariffa_piano(v::json, idtransazione);
	   		when 'annulla_elab_cal' then
	   			ret:=agenda.annulla_elab_cal(v::json, idtransazione);
	   		when 'upd_tipo_linee_per_piano' then
	   			ret:=agenda.upd_tipo_linee_per_piano(v, idtransazione);
	   		when 'upd_piano_freq' then
	   			ret:=agenda.upd_piano_freq(v::json, idtransazione);
	   		when 'upd_ns_linee' then
	   			ret:=agenda.upd_ns_linee(v::json, idtransazione);
	   		when 'upd_ns_az_sedi' then
	   			ret:=agenda.upd_ns_az_sedi(v::json, idtransazione);
	   		when 'upd_linee_piano' then
	   			ret:=agenda.upd_linee_piano(v, idtransazione);
	   		when 'upd_genera_fatture' then
	   			ret:=trf.upd_genera_fatture(v::json, idtransazione);
	   		when 'upd_genera_ft_periodiche' then
	   			ret:=trf.upd_genera_ft_periodiche(v::json, idtransazione);	   		
	   		when 'upd_elab_linee' then
	   			ret:=agenda.upd_elab_linee(v::json, idtransazione);
	   		when 'upd_elab_az_sedi' then
	   			ret:=agenda.upd_elab_az_sedi(v::json, idtransazione);
	   		when 'del_elab_linee' then
	   			ret:=agenda.del_elab_linee(v::json, idtransazione);
	   		when 'upd_elab_ns_piani' then
	   			ret:=agenda.upd_elab_ns_piani(v::json, idtransazione);
	   		when 'del_elab_ns_piani' then
	   			ret:=agenda.del_elab_ns_piani(v::json, idtransazione);
	   		when 'upd_elab_asl_piani' then
	   			ret:=agenda.upd_elab_ns_piani(v::json, idtransazione);
	   			ret.info:=replace(ret.info,'"asl":','"ns":');
	   		when 'upd_elab_cal_params' then
	   			ret:=agenda.upd_elab_cal_params(v::json, idtransazione);
	   		when 'del_elab_cal_params' then
	   			ret:=agenda.del_elab_cal_params(v::json, idtransazione);
	   		when 'upd_att_associa_nominativo' then
	   			ret:=agenda.upd_att_associa_nominativo(v::json, idtransazione);
	   		when 'upd_att_associa_validita' then
	   			ret:=agenda.upd_att_associa_validita(v::json, idtransazione);
	   		when 'upd_att_cambia_data' then
	   			ret:=agenda.upd_att_cambia_data(v::json, idtransazione);
	   		when 'upd_att_id_tariffa' then
	   			ret:=trf.upd_att_id_tariffa(v::json, idtransazione);
	   		when 'upd_att_id_cliente' then
	   			ret:=trf.upd_att_id_cliente(v::json, idtransazione);	   		
	   		when 'upd_att_da_inviare' then
	   			ret:=trf.upd_att_da_inviare(v::json, idtransazione);
	   		when 'upd_trf_ins_stato_att_da_inviare' then
	   			ret:=trf.upd_trf_ins_stato_att_da_inviare(v::json, idtransazione);
	   		when 'upd_att_close' then
	   			ret:=trf.upd_att_close(v::json, idtransazione);
	   		when 'upd_att_associa_linea' then
	   			ret:=agenda.upd_att_associa_linea(v::json, idtransazione);   
	   		when 'upd_tipologia_controllo_piani' then
	   			ret:=agenda.upd_tipologia_controllo_piani(v::json, idtransazione);
	   		
	   		when 'upd_att_associa_partner' then
	   			ret:=agenda.upd_att_associa_partner(v::json, idtransazione);   
	   		
	   		
	   		when 'upd_ev_associa_nominativo' then
	   			ret:=agenda.upd_ev_associa_nominativo(v::json, idtransazione);
	   		when 'upd_ev_associa_validita' then
	   			ret:=agenda.upd_ev_associa_validita(v::json, idtransazione);
	   		when 'upd_ev_cambia_data' then
	   			ret:=agenda.upd_ev_cambia_data(v::json, idtransazione);
	   		when 'upd_ev_elimina_validita' then
	   			ret:=agenda.upd_ev_elimina_validita(v::json, idtransazione);
	   		when 'upd_ev_elimina_partner' then
	   			ret:=agenda.upd_ev_elimina_partner(v::json, idtransazione);
	   		when 'upd_ev_elimina' then
	   			ret:=agenda.upd_ev_elimina(v::json, idtransazione);
	   		when 'upd_ev_elimina_linea' then
	   			ret:=agenda.upd_ev_elimina_linea(v::json, idtransazione);
	   		when 'upd_ev_associa_linea' then
	   			ret:=agenda.upd_ev_associa_linea(v::json, idtransazione); 
	   		when 'upd_ev_associa_partner' then
	   			ret:=agenda.upd_ev_associa_partner(v::json, idtransazione); 
	   		when 'upd_att_elimina_partner' then
	   			ret:=agenda.upd_att_elimina_partner(v::json, idtransazione);
		   	when 'upd_att_forfet_stato' then
	   			ret:=trf.upd_att_forfet_stato(v::json, idtransazione); 
	   		when 'ins_piano' then
	   			ret:=agenda.ins_piano(v::json, idtransazione);
	   		when 'upd_piano' then
	   			ret:=agenda.upd_piano(v::json, idtransazione);
	   		when 'upd_del_piano' then
	   			ret:=agenda.upd_del_piano(v::json, idtransazione);
	   		when 'ins_asl' then
	   			ret:=agenda.ins_asl(v::json, idtransazione);
	   		when 'upd_asl' then
	   			ret:=agenda.upd_asl(v::json, idtransazione);
	   		when 'upd_del_asl' then
	   			ret:=agenda.upd_del_asl(v::json, idtransazione);
	   		when 'ins_risorsa' then
	   			ret:=agenda.ins_risorsa(v::json, idtransazione);
	   		when 'upd_del_risorsa' then
	   			ret:=agenda.upd_del_risorsa(v::json, idtransazione);
	   		when 'del_tariffa' then
	   			ret:=trf.del_tariffa(v, idtransazione);
	   		when 'ins_tariffa' then
	   			ret:=trf.ins_tariffa(v, idtransazione);
	   		when 'upd_tariffa' then
	   			ret:=trf.upd_tariffa(v, idtransazione);
	   		when 'get_costo_simulato' then
				ret:= trf.get_costo_simulato(v::json,idtransazione);
			    raise notice 'ret.info %',ret.info;
			when 'crea_calendario' then
	   			ret:=agenda.crea_calendario(v, idtransazione);
	   		when 'upd_tariffa_voci' then
	   			SET search_path TO trf,agenda,public;
	   		raise notice 'PARAMETRO V %',v;
	   			ret:=trf.upd_tariffa_voci(v, idtransazione);
	   		when 'upd_linee_piano' then
	   			ret:=agenda.upd_linee_piano(v, idtransazione);
	   		when 'upd_uos_comuni' then
	   			ret:=agenda.upd_uos_comuni(v, idtransazione);
	   		when 'upd_ns_comuni' then
	   			ret:=agenda.upd_ns_comuni(v, idtransazione);
	   		when 'upd_uoc_piani' then
	   			ret:=agenda.upd_uoc_piani(v, idtransazione);
	   		when 'upd_ns_piani' then
	   			ret:=agenda.upd_ns_piani(v, idtransazione);
	   		when 'upd_clona_ns_piani' then
	   			ret:=agenda.upd_clona_ns_piani(v, idtransazione);
	   		when 'upd_clona_tipo_linee_per_piano' then
	   			ret:=agenda.upd_clona_tipo_linee_per_piano (v, idtransazione);
	   		when 'upd_tipo_lista_per_piano' then
	   			ret:=agenda.upd_tipo_lista_per_piano(v, idtransazione);
	   		when 'upd_evento' then
	   			ret:=agenda.upd_evento(v, idtransazione);
	   		when 'riversa_calendario' then
	   			ret:=agenda.riversa_calendario(v::json, idtransazione);	   		
	   		when 'att_elimina_linea' then
	   			ret:=agenda.att_elimina_linea(v, idtransazione);
	   		when 'att_elimina_nominativo' then
	   			ret:=agenda.att_elimina_nominativo(v, idtransazione);	   		
	   		when 'att_elimina_data' then
	   			ret:=agenda.att_elimina_data(v, idtransazione);	
	   		when 'att_elimina_validita' then
	   			ret:=agenda.upd_att_elimina_validita(v::json, idtransazione);	   		
	   		when 'upd_trf_fattura' then
	   			ret:=trf.upd_trf_fattura(v, idtransazione);
	   		when 'upd_rilevazione_attivita' then
	   			ret:=trf.upd_rilevazione_attivita(v::json, idtransazione::int8);
	   		when 'load_cf_allevamenti' then
	   			ret:=agenda.load_cf_allevamenti(v::json, idtransazione::int8);
	   		when 'ins_cf_lista' then
	   			ret:=agenda.ins_cf_lista(v::json, idtransazione::int8);
	   		 when 'load_import_formato_linea' then
	   			ret:=agenda.load_import_formato_linea(v::json, idtransazione::int8);
			 when 'load_import_formato_sicer' then
	   			ret:=agenda.load_import_formato_sicer(v::json, idtransazione::int8);	
			when 'load_import_formato_cf' then
	   			ret:=agenda.load_import_formato_cf(v::json, idtransazione::int8);		
	   		when 'load_import_formato_profilassi' then
	   			ret:=agenda.load_import_formato_profilassi(v::json, idtransazione::int8);			
	   		 when 'ins_lista_import' then
	   			ret:=agenda.ins_lista_import(v::json, idtransazione::int8);
	   		when 'ins_tipo_lista' then
	   			ret:=agenda.ins_tipo_lista(v, idtransazione::int8);
	   		when 'del_tipo_lista' then
	   			ret:=agenda.del_tipo_lista(v, idtransazione::int8);
	   		
	   		when 'ins_evento' then
	   			ret:=agenda.ins_evento(v, idtransazione::int8);
	   		when 'crea_contr_uff_from_evento' then
	   			ret:=agenda.crea_cu_from_evento(v::json, idtransazione::int8);
	   		when 'genera_calendario' then
	   		
	   			raise notice 'V=%',v;
	   			--update agenda.elab_cals set tm_last_elab =null where id = R_EC.id;
	   			--commit;
	   			raise notice 'GENERA CALENDARIO';
	   			ret:=agenda.genera_calendario_funct(v::json,idtransazione);
	   			--commit;
	   			/*begin
				call agenda.genera_calendario_proc(v::json,idtransazione,ret);
				end;*/
				if ret.esito then
					ret.info:='{"eventi":' || ret.info::json;
					ret.info:=ret.info || '}';
		
					raise notice 'ret.info %',ret.info;
				end if;
			when 'ins_calendario' then
				ret:=agenda.ins_calendario(v, idtransazione);
			when 'ins_elaborazione' then
				ret:=agenda.ins_calendario_elab(v, idtransazione);
			when 'delete_elaborazione' then
				ret:=agenda.del_calendario_elab(v, idtransazione);
			when 'delete_calendario' then
				ret:=agenda.del_calendario(v, idtransazione);
			when 'load_linee_xls' then
				ret:=agenda.load_linee_xls(v, idtransazione);
			when 'upd_scontrino_pdf' then
				ret:=trf.upd_scontrino_pdf(v::json, idtransazione);
			when 'upd_cu_add_soggetti_fisici_from_service' then 
	   			ret:=cu_anag.upd_cu_add_soggetti_fisici_from_service(v::json, idtransazione);
	   		when 'move_piano' then
	   			ret:=agenda.move_piano(v::json, idtransazione);
	   		when 'move_piano_ordinamento' then
	   			ret:=agenda.move_piano_ordinamento(v::json, idtransazione);
	   		when 'move_asl_ordinamento' then
	   			ret:=agenda.move_asl_ordinamento(v::json, idtransazione);
	   		when 'ins_unita_di_crisi' then
	   			ret:=agenda.ins_unita_di_crisi(v::json, idtransazione);
	   		when 'upd_unita_di_crisi' then
	   			ret:=agenda.upd_unita_di_crisi(v::json, idtransazione);
	   		when 'upd_del_unita_di_crisi' then
	   			ret:=agenda.upd_del_unita_di_crisi(v::json, idtransazione);
	   		when 'ins_avviso' then
	   			ret:=agenda.ins_avviso(v::json, idtransazione);
	   		when 'upd_avviso' then
	   			ret:=agenda.upd_avviso(v::json, idtransazione);
	   		when 'upd_del_avviso' then
	   			ret:=agenda.upd_del_avviso(v::json, idtransazione);
	   		when 'upd_risorse_avviso' then
	   			ret:=agenda.upd_risorse_avviso(v::json, idtransazione);
	   		when 'upd_visualizzazione_avviso' then
	   			ret:=agenda.upd_visualizzazione_avviso(v::json, idtransazione);
			when 'null' then
				ret.esito:=true;
			else
 			ret.esito := false;
 			ret.info  := 'CASO NON PREVISTO';
	   	end case;
		
	    RAISE notice 'agenda.upd_evento ret.esito: %', ret.esito;
	   
   		if ret.esito=false then 
   			RAISE notice 'agenda.upd_evento if su ret.esito=false';
   			fallito=true;
	   		RAISE notice 'agenda.upd_evento ROLLBACK a seguito di ret.esito=false';
   		end if;
		

	--end;
	
/*	if fallito=true then 
		rollback;
	end if;
2024-09-16*/

	-- AF 20240513 joutput:=row_to_json(ret);
	--id_op:=ag_log.op(proc_name,idtransazione,v,joutput,ts,-1,operazione);

	exception when others then
		fallito:=true;
		RAISE notice 'gds.upd_dati ROLLBACK a seguito di exception';
		GET STACKED DIAGNOSTICS text_msg1 = MESSAGE_TEXT,
                          			text_msg2 = PG_EXCEPTION_DETAIL,
                          			text_msg3 = PG_EXCEPTION_HINT,
                         			text_msg4 = PG_EXCEPTION_CONTEXT;
			ret.esito:=false;
			ret.valore:= null;
		
			if replace(upper(j_user_info->>'ambiente'),'"','') = 'local' or replace(upper(j_user_info->>'ambiente'),'"','') = 'dev'  then
				ret.err_msg:=coalesce(ret.err_msg,'')||coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');
			else
				--ret.err_msg:=coalesce(text_msg1,'');
				ret.err_msg:=coalesce(ret.err_msg,'')||coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');

			end if;
			--ret.msg:=coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');
			RAISE notice '%', ret;
		rollback;
	end;
	--if ret.info is null then ret.valore = 0; end if;
	joutput:=row_to_json(ret);
	id_op:=ag_log.op(proc_name,idtransazione,v,joutput,ts,-1,operazione);
commit;

end;
$$;


ALTER PROCEDURE agenda.upd_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json) OWNER TO postgres;

--
-- Name: upd_del_asl(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_del_asl(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret ag_types.result_type;
		v_j json;
		R_T matrix.tree_nodes;
		v_id_node bigint;
		idtree bigint;
		n integer;
		proc_name varchar;
		idstrutturaasl bigint;
		v_validita tsrange;
		begin
		proc_name:='agenda.upd_del_asl';
		v_j:=v::json;
		v_id_node:=v_j->'id_node';
		idstrutturaasl=v->'user_info'->'id_struttura_root';

		select id_tree into idtree from matrix.tree_nodes tn where id = v_id_node; 	
		select validita into v_validita from matrix.tree_nodes where id = v_id_node;
	
		update matrix.tree_nodes  
		set validita = (tsrange(lower(v_validita) ,current_timestamp::timestamp without time zone,'[)'))
		where id = v_id_node and id_tree = idtree returning * into R_T;
		n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_T,'U');
		
	
	    GET DIAGNOSTICS n = ROW_COUNT;
		 if n < 1 then
			ret.esito:=false;
			ret:=ag_ui.build_ret(ret,proc_name, 'errore_cancellazione_asl');
			return ret;
		 end if;
	  	
	  	ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info = '0';
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
		return ret;
		end;
	END;
$$;


ALTER FUNCTION agenda.upd_del_asl(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_del_avviso(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_del_avviso(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret ag_types.result_type;
		v_j json;
		n integer;
		proc_name varchar;
		idstrutturaasl bigint;
		v_validita tsrange;
		v_id_avviso bigint;
		R_A agenda.avvisi;
		begin
		proc_name:='agenda.upd_del_avviso';
		v_j:=v::json;
		idstrutturaasl=v->'user_info'->'id_struttura_root';
		v_id_avviso:=v->'id_avviso';
		

		select va.validita_avviso into v_validita from agenda.avvisi va where va.id = v_id_avviso;
	
		update agenda.avvisi 
		set validita_avviso = (tsrange(lower(v_validita) ,current_timestamp::timestamp without time zone,'[)'))
		where id = v_id_avviso returning * into R_A;
		n:=ag_log.upd_record('agenda.avvisi',idtransazione,R_A,'U');
		
	
	    GET DIAGNOSTICS n = ROW_COUNT;
		 if n < 1 then
			ret.esito:=false;
			ret:=ag_ui.build_ret(ret,proc_name, 'errore_cancellazione_avviso');
			return ret;
		 end if;
	  	
	  	ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info = '0';
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
		return ret;
		end;
	END;
$$;


ALTER FUNCTION agenda.upd_del_avviso(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_del_piano(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_del_piano(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret ag_types.result_type;
		v_j json;
		--R_SP matrix.struttura_asl;
		v_id_node bigint;
		idtree bigint;
		n integer;
		proc_name varchar;
		v_validita tsrange;
		begin
		proc_name:='agenda.upd_del_piano';
		v_j:=v::json;
		v_id_node:=v_j->'id_node';

		select id_tree into idtree from matrix.tree_nodes tn where id = v_id_node; 	
		select validita into v_validita from matrix.tree_nodes where id = v_id_node;
	
		update matrix.tree_nodes  
		set validita = (tsrange(lower(v_validita) ,current_timestamp::timestamp without time zone,'[)'))
		where id = v_id_node and id_tree = idtree;
		
	
	    GET DIAGNOSTICS n = ROW_COUNT;
		 if n < 1 then
			ret.esito:=false;
			ret:=ag_ui.build_ret(ret,proc_name, 'errore_cancellazione_piano');
			return ret;
		 end if;
	  	
	  	ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info = '0';
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
		return ret;
		end;
	END;
$$;


ALTER FUNCTION agenda.upd_del_piano(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_del_risorsa(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_del_risorsa(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret ag_types.result_type;
		v_j json;
		v_id_utente_struttura bigint;
		n integer;
		proc_name varchar;
		idstrutturaasl bigint;
		v_validita tsrange;
		R_U rbac.utente_strutture;
		begin
		proc_name:='agenda.upd_del_risorsa';
		v_j:=v::json;
		v_id_utente_struttura:=v_j->'id_utente_struttura';
		idstrutturaasl=v->'user_info'->'id_struttura_root';

		select us.validita into v_validita from rbac.utente_strutture us where us.id = v_id_utente_struttura;
	
		update rbac.utente_strutture 
		set validita = (tsrange(lower(v_validita) ,current_timestamp::timestamp without time zone,'[)'))
		where id = v_id_utente_struttura returning * into R_U;
		n:=ag_log.upd_record('agenda.utente_strutture',idtransazione,R_U,'U');
		
	
	    GET DIAGNOSTICS n = ROW_COUNT;
		 if n < 1 then
			ret.esito:=false;
			ret:=ag_ui.build_ret(ret,proc_name, 'errore_cancellazione_risorsa');
			return ret;
		 end if;
	  	
	  	ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info = '0';
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
		return ret;
		end;
	END;
$$;


ALTER FUNCTION agenda.upd_del_risorsa(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_del_unita_di_crisi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_del_unita_di_crisi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	n integer;
	tipo varchar;
	id_unita bigint;
	v_validita tsrange;
	R_U agenda.unita_di_crisi;
	begin
		proc_name:='agenda.upd_del_unita_di_crisi';
		tipo:=v->>'tipo';
		id_unita:=v->>'id_unita';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		if tipo ilike 'fvg' then
			select validita into v_validita from agenda.unita_di_crisi where id = id_unita;
			update agenda.unita_di_crisi set
				validita = (tsrange(lower(v_validita) ,current_timestamp::timestamp without time zone,'[)'))
			where id = id_unita returning * into R_U;
			n:=ag_log.upd_record('agenda.unita_di_crisi',idtransazione,R_U,'U');
		
			ret.esito:=true;	
        	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		elsif tipo ilike 'asu_fc' then
			select validita into v_validita from agenda.unita_di_crisi where id = id_unita;
			update agenda.unita_di_crisi set
				validita = (tsrange(lower(v_validita) ,current_timestamp::timestamp without time zone,'[)'))
			where id = id_unita returning * into R_U;
			n:=ag_log.upd_record('agenda.unita_di_crisi',idtransazione,R_U,'U');
		
			ret.esito:=true;	
        	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		elsif tipo ilike 'asu_gi' then
			select validita into v_validita from agenda.unita_di_crisi where id = id_unita;
			update agenda.unita_di_crisi set
				validita = (tsrange(lower(v_validita) ,current_timestamp::timestamp without time zone,'[)'))
			where id = id_unita returning * into R_U;
			n:=ag_log.upd_record('agenda.unita_di_crisi',idtransazione,R_U,'U');
		
			ret.esito:=true;	
        	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		else
			select validita into v_validita from agenda.unita_di_crisi where id = id_unita;
			update agenda.unita_di_crisi set
				validita = (tsrange(lower(v_validita) ,current_timestamp::timestamp without time zone,'[)'))
			where id = id_unita returning * into R_U;
			n:=ag_log.upd_record('agenda.unita_di_crisi',idtransazione,R_U,'U');
		
			ret.esito:=true;	
        	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		end if;
	end;
end;
$$;


ALTER FUNCTION agenda.upd_del_unita_di_crisi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_elab_asl_piani(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_elab_asl_piani(dati json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idselected bigint;
	proc_name varchar;
	R_CAL agenda.vw_calendari%ROWTYPE;
	R_EC agenda.elab_cals%ROWTYPE;
	REC Record;
	rt json;
	n integer;

	begin
	proc_name:='agenda.upd_calendario_elab_asl_piani';

	R_EC.id:=dati->>'id_elab_cal';
	if R_EC.id is null then
		R_EC.id:=dati->>'id_gen_cal';
	end if;
	R_EC.id_user:= ((dati->>'user_info')::json)->>'id_utente';

	raise notice 'ID_ELAB_CAL ID=% ID_USER=%', R_EC.id,R_EC.id_user;

	select * into R_EC from agenda.elab_cals ec where id =R_EC.id;

	if R_EC.tm_last_elab is not null then
	    ret.esito:=true;
 		ret.msg:=null;
		ret.info:=null;
		return ret;
	end if;

	delete from agenda.linee_selezionate where id_elab_cal =R_EC.id
	and (id_linea,id_piano) not in (
		select id_linea,p.id_piano from agenda.vw_linee_piano_struttura lps 
			join (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements((dati->>'piani')::json) p) p on lps.id_piano=p.id_piano
			join (select replace(a.value::varchar,'"','')::bigint as id_asl   from json_array_elements((dati->>'asl')::json) a)   a on lps.id_struttura_asl  =a.id_asl
	);

	insert into agenda.linee_selezionate 
	select  nextval('agenda.agenda_id_seq'), R_EC.id, lp.id_linea ,lp.id_piano, row_number () over () from 
       (
		select distinct lps.id_linea,lps.id_piano from agenda.vw_linee_piano_struttura lps 
			join (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements((dati->>'piani')::json) p )p on lps.id_piano=p.id_piano
			join (select replace(a.value::varchar,'"','')::bigint as id_asl   from json_array_elements((dati->>'asl')::json) a)  a on lps.id_struttura_asl  =a.id_asl
		where  (lps.id_linea,lps.id_piano) not in (select ls.id_linea,ls.id_piano from agenda.linee_selezionate ls where ls.id_elab_cal =R_EC.id) )lp;

	delete from agenda.elab_cal_param_asl          where id_elab_cal=R_EC.id ;
	delete from agenda.elab_cal_param_piani          where id_elab_cal=R_EC.id ;
	insert into agenda.elab_cal_param_piani
	select  nextval('agenda.agenda_id_seq'),R_EC.id,replace(x.value::varchar,'"','')::bigint
	from json_array_elements((dati->>'piani')::json) x;
	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'PIANI inseriti % record',  n;

	insert into agenda.elab_cal_param_asl
	select  nextval('agenda.agenda_id_seq'),R_EC.id,replace(x.value::varchar,'"','')::bigint
	from json_array_elements((dati->>'asl')::json) x;

	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'ASL inseriti % record',  n;

    ret.esito:=true;
 	ret.msg:=null;
	ret.info:=rt;

	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.upd_elab_asl_piani(dati json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_elab_az_sedi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_elab_az_sedi(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        proc_name varchar; -- end
        R_EC agenda.elab_cals%ROWTYPE;
        begin
		proc_name:='agenda.upd_elab_az_sedi';
		raise notice 'V=%',v_j;

		R_EC.id:=v_j->>'id_elab_cal';
		if R_EC.id is null then
			R_EC.id:=v_j->>'id_gen_cal';
		end if;
	
		select * into R_EC from agenda.elab_cals ec where id =R_EC.id;

		if R_EC.tm_last_elab is not null then
		    ret.esito:=true;
	 		ret.msg:=null;
			ret.info:=null;
			return ret;
		end if;
	
		delete  from agenda.az_sedi_selezionate  where id_elab_cal =R_EC.id;

		insert into agenda.az_sedi_selezionate
			select nextval('agenda.agenda_id_seq'),R_EC.id, lp.id_az_sede ,lp.id_piano,row_number () over() from 
			
			
			
			(select id_az_sede ,id_piano,row_number () over() from 
			json_populate_recordset(null::record,v_j->'id_az_sede_piani') as (id_az_sede int8,id_piano int8) 
			) lp;
		
    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,R_EC.id);
 
		return ret;
	end;

END
$$;


ALTER FUNCTION agenda.upd_elab_az_sedi(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_elab_cal_params(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_elab_cal_params(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idelabcal bigint;
	proc_name varchar;
	R_CAL agenda.vw_calendari%ROWTYPE;
	R_EC agenda.vw_elab_cals%ROWTYPE;
	v_data_old varchar;
	v_data_new varchar;
	REC Record;
	rt json;
	p json;
	n bigint;
	rc record;
	R_E agenda.elab_cal_params;
	begin
		proc_name:='agenda.get_elab_cal_params';
	
		idelabcal:=v_j->'id_elab_cal';
		if idelabcal is null then
			idelabcal:=v_j->>'id_gen_cal';
		end if;
		select * into R_EC from agenda.vw_elab_cals ec where id =idelabcal;

		if R_EC.tm_last_elab is not null then
		    ret.esito:=true;
			ret.msg:=null;
			ret.info:=null;
			return ret;
		end if;
		p:=v_j->'params';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select trim(coalesce(value,''))  into v_data_old from agenda.elab_cal_params
		where id_elab_cal=R_EC.id  and type_param='non_visitati_dal';

	
		for rc in select id from agenda.elab_cal_params where id_elab_cal=idelabcal
		loop
			delete from agenda.elab_cal_params where id=rc.id returning * into R_E;
			n:=ag_log.upd_record('agenda.elab_cals_params',idtransazione,R_E,'D');
		end loop;
		
		for REC in select  nextval('agenda.agenda_id_seq'),idelabcal,replace((x.value->'tag')::varchar,'"','') t,replace((x.value->'val')::varchar,'"','') val
		from  json_array_elements(p) x
		loop
			insert into agenda.elab_cal_params values(nextval('agenda.agenda_id_seq'),REC.idelabcal,REC.t,REC.val) returning * into R_E;
			n:=ag_log.upd_record('agenda.elab_cals_params',idtransazione,R_E,'I');
		end loop;
		
	
		--delete from agenda.elab_cal_params where id_elab_cal=idelabcal;

	/*	insert into agenda.elab_cal_params 
		select  nextval('agenda.agenda_id_seq'),idelabcal,replace((x.value->'tag')::varchar,'"','') t,replace((x.value->'val')::varchar,'"','') val
		from  json_array_elements(p) x; */

		select trim(coalesce(value,''))  into v_data_new from agenda.elab_cal_params
		where id_elab_cal=R_EC.id  and type_param='non_visitati_dal';
	
		if v_data_old != v_data_new then
		   	select into n agenda.aggiorna_linee_selezionate(R_EC.id,R_EC.anno);
		end if;

		ret.esito:=true;
		ret.msg:=null;
 		ret.info:=rt;

	 	return ret;

	end;
end;
$$;


ALTER FUNCTION agenda.upd_elab_cal_params(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_elab_linee(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_elab_linee(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        proc_name varchar; -- end
        R_EC agenda.elab_cals%ROWTYPE;
       	n integer;
       	rc record;
        rls agenda.linee_selezionate;
        begin
		proc_name:='agenda.upd_elab_linee';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V=%',v_j;

		R_EC.id:=v_j->>'id_elab_cal';
		if R_EC.id is null then
			R_EC.id:=v_j->>'id_gen_cal';
		end if;
	
		select * into R_EC from agenda.elab_cals ec where id =R_EC.id;

		if R_EC.tm_last_elab is not null then
		    ret.esito:=true;
			ret.msg:=null;
			ret.info:=null;
			return ret;
		end if;
	
		for rc in select id from agenda.linee_selezionate  where id_elab_cal =R_EC.id
		loop
			delete  from agenda.linee_selezionate  where id=rc.id returning * into rls;
			n:=ag_log.upd_record('agenda.linee_selezionate',idtransazione,rls,'D');	
		end loop;
		
		for rc in select nextval('agenda.agenda_id_seq'),R_EC.id, lp.id_linea ,lp.id_piano,row_number () over() from 
				(select distinct id_linea ,id_piano from 
				json_populate_recordset(null::record,v_j->'id_linea_piani') as (id_linea int8,id_piano int8) 
				) lp
		loop
			insert into agenda.linee_selezionate values(nextval('agenda.agenda_id_seq'),rc.id,rc.id_linea,rc.id_piano) returning * into rls;
			n:=ag_log.upd_record('agenda.linee_selezionate',idtransazione,rls,'I');
		end loop;
		

		/*insert into agenda.linee_selezionate
			select nextval('agenda.agenda_id_seq'),R_EC.id, lp.id_linea ,lp.id_piano,row_number () over() from 
				(select distinct id_linea ,id_piano from 
				json_populate_recordset(null::record,v_j->'id_linea_piani') as (id_linea int8,id_piano int8) 
				) lp returning * into R_EC;
		n:=ag_log.upd_record('agenda.linee_selezionate',idtransazione,R_EC,'I'); */
		
    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,R_EC.id);
 
		return ret;
	end;

END
$$;


ALTER FUNCTION agenda.upd_elab_linee(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_elab_ns_piani(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_elab_ns_piani(dati json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idselected bigint;
	proc_name varchar;
	R_CAL agenda.vw_calendari%ROWTYPE;
	R_EC agenda.vw_elab_cals%ROWTYPE;
	R_EN agenda.elab_cal_param_ns;
	R_EP agenda.elab_cal_param_piani;
	REC Record;
	rc record;
	rcDelNs record; --Per delete elab_cal_param_piani
	rcDelPiani record; --Per delete elab_cal_param_piani
	rt json;
	n integer;
	n_rec bigint;
	anno_calendario integer;

	begin
	proc_name:='agenda.upd_elab_ns_piani';

	R_EC.id:=dati->>'id_elab_cal';
	if R_EC.id is null then
		R_EC.id:=dati->>'id_gen_cal';
	end if;
	R_EC.id_user:= ((dati->>'user_info')::json)->>'id_utente';

	select * into R_EC from agenda.vw_elab_cals ec where id =R_EC.id;

	if R_EC.tm_last_elab is not null then
	    ret.esito:=true;
		ret.msg:=null;
		ret.info:=null;
		return ret;
	end if;

	raise notice 'ID_ELAB_CAL ID=% ID_USER=%', R_EC.id,R_EC.id_user;




/* AF
	insert into agenda.linee_selezionate 
	select  nextval('agenda.agenda_id_seq'), R_EC.id, lp.id_linea ,lp.id_piano, row_number () over () from 
       (
		select distinct l.id_linea,p.id_piano from
			matrix.nominativi_struttura ns
			join (select replace(a.value::varchar,'"','')::bigint as id_ns    from json_array_elements((dati->>'ns')  ::json) a) a on ns.id =a.id_ns
			join agenda.vw_nominativo_comuni nc on nc.id_nominativo_struttura =ns.id 
			join agenda.nominativo_piani np on np.id_nominativo_struttura =ns.id
			join (select replace(p.value::varchar,'"','')::bigint as id_piano from json_array_elements((dati->>'piani')::json) p) p on np.id_piano=p.id_piano
			join matrix.vw_struttura_piani sp on sp.id=p.id_piano
			join agenda.piano_tipo_linea ptl on ptl.id_piano=p.id_piano
			join agenda.vw_linee l on l.id_attivita =ptl.id_tipo_linea and l.id_comune =nc.id_comune and l.linea_principale
			--join agenda.vw_linee_principali lp on lp.id_linea=l.id_linea
			
			--join agenda.vw_linee_piano_struttura lps on lps.id_piano=np.id_piano and lps.id_comune =nc.id_comune 
			
			left join agenda.vw_piano_freq pf on pf.id_piano = p.id_piano and pf.livello=1
			left join agenda.vw_linea_piano_anno_assegnate ass on ass.id_linea=l.id_linea and ass.id_piano=p.id_piano and ass.anno=R_EC.anno
			where  coalesce(assegnate,0)<coalesce(pf.freq,1) and (not sp.flag_cf or 
				(sp.flag_cf and l.id_linea in (select id_linea from agenda.vw_cf_allevamenti vca where anno=R_EC.anno) ))
				
		 )lp;
		 
*/
	n_rec:=0;
	for rcDelNs in select id from agenda.elab_cal_param_ns    where id_elab_cal=R_EC.id and id_ns not in (
		select replace(x.value::varchar,'"','')::bigint id
		from json_array_elements((dati->>'ns')::json) x
	)
	loop
		delete from agenda.elab_cal_param_ns where id=rcDelNs.id returning * into R_EN;
		n:=ag_log.upd_record('agenda.elab_cal_param_ns_piani',idtransazione,R_EN,'D');
	end loop;
	

	/*delete from agenda.elab_cal_param_ns    where id_elab_cal=R_EC.id and id_ns not in (
		select replace(x.value::varchar,'"','')::bigint id
		from json_array_elements((dati->>'ns')::json) x
	); */
	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'NS cancellati % record',  n;
	n_rec:=n_rec+n;

	for rcDelPiani in select id from agenda.elab_cal_param_piani where id_elab_cal=R_EC.id and id_piano not in (
		select replace(x.value::varchar,'"','')::bigint id
		from json_array_elements((dati->>'piani')::json) x
	)
	loop
		delete from agenda.elab_cal_param_piani where id=rcDelPiani.id returning * into R_EP;
		n:=ag_log.upd_record('agenda.elab_cal_param_ns_piani',idtransazione,R_EP,'D');
	end loop;

	/*delete from agenda.elab_cal_param_piani where id_elab_cal=R_EC.id and id_piano not in (
		select replace(x.value::varchar,'"','')::bigint id
		from json_array_elements((dati->>'piani')::json) x
	);*/
	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'Piani cancellati % record',  n;
	n_rec:=n_rec+n;

	for rc in select  nextval('agenda.agenda_id_seq'),R_EC.id,replace(x.value::varchar,'"','')::bigint value
	from json_array_elements((dati->>'piani')::json) x
	where replace(x.value::varchar,'"','')::bigint not in (select id_piano from agenda.elab_cal_param_piani where id_elab_cal=R_EC.id)
	loop
		insert into agenda.elab_cal_param_piani values (nextval('agenda.agenda_id_seq'),rc.id,rc.value) returning * into R_EP;
		n:=ag_log.upd_record('agenda.elab_cal_param_ns_piani',idtransazione,R_EP,'D');
	end loop;
	


	/*insert into agenda.elab_cal_param_piani
	select  nextval('agenda.agenda_id_seq'),R_EC.id,replace(x.value::varchar,'"','')::bigint
	from json_array_elements((dati->>'piani')::json) x
	where replace(x.value::varchar,'"','')::bigint not in (select id_piano from agenda.elab_cal_param_piani where id_elab_cal=R_EC.id); */
	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'PIANI inseriti % record',  n;
	n_rec:=n_rec+n;

	for REC in select  nextval('agenda.agenda_id_seq'),R_EC.id,replace(x.value::varchar,'"','')::bigint value
	from json_array_elements((dati->>'ns')::json) x 
	where replace(x.value::varchar,'"','')::bigint not in (select id_ns    from agenda.elab_cal_param_ns    where id_elab_cal=R_EC.id)
	loop
		insert into agenda.elab_cal_param_ns values(nextval('agenda.agenda_id_seq'),REC.id,REC.value) returning * into R_EN;
		n:=ag_log.upd_record('agenda.elab_cal_param_ns_piani',idtransazione,R_EN,'D');
	end loop;
	

	/*insert into agenda.elab_cal_param_ns
	select  nextval('agenda.agenda_id_seq'),R_EC.id,replace(x.value::varchar,'"','')::bigint
	from json_array_elements((dati->>'ns')::json) x 
	where replace(x.value::varchar,'"','')::bigint not in (select id_ns    from agenda.elab_cal_param_ns    where id_elab_cal=R_EC.id);*/
	GET DIAGNOSTICS n = ROW_COUNT;
    raise notice 'NS inseriti % record',  n;
   	n_rec:=n_rec+n;
   
   	if n_rec > 0 then
   		select into n agenda.aggiorna_linee_selezionate(R_EC.id,R_EC.anno);
   		--n:= 777;
   		--delete from agenda.linee_selezionate where id_elab_cal =R_EC.id;
   	else
   	   	select count(*) into n from agenda.linee_selezionate ls where id_elab_cal=R_EC.id ;
   	end if;


    ret.esito:=true;
 	ret.msg:=null;
	ret.info:='{"linee_selezione":'||n||'}';

	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.upd_elab_ns_piani(dati json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ev_associa_linea(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_ev_associa_linea(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idlinea bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        n bigint;
        begin
		proc_name:='agenda.upd_ev_associa_linea';
		idlinea:=v_j->'id_linea';
			
		for R_EV in select * from agenda.eventi
		
		where id in (
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'id_evento') )loop 
			update agenda.eventi set id_linea =idlinea where id=R_EV.id returning * into R_EV;
			n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'U');	
		end loop;
			
    	ret.esito:=true;	
		ret:=ag_ui.build_ret(ret,proc_name,null);
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_ev_associa_linea(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ev_associa_nominativo(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_ev_associa_nominativo(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idnominativo bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        R_NS matrix.vw_nominativi_struttura;
        n bigint;
        tot bigint;
       	t bigint;
        eff bigint;
       
        begin
		proc_name:='agenda.upd_ev_associa_nominativo';
		idnominativo:=v_j->'id_nominativo';
		if idnominativo is null then
		    ret.esito:=false;	
    		ret:=ag_ui.build_ret(ret,proc_name,'nominativo_non_esplicitato');
			return ret;
		end if;
		select * into R_NS
			from matrix.vw_nominativi_struttura where id=idnominativo;
		tot:=coalesce(json_array_length(v_j->'id_evento'),0);
		eff:=0;
			
		for R_EV in select * from agenda.eventi 
		where id in (select  (value::varchar)::bigint from 
		json_array_elements(v_j->'id_evento') ) loop 
				raise notice 'R_NS.id_nominativo %',R_NS.id_nominativo;
				update agenda.eventi 
					set id_nominativo =R_NS.id_nominativo,
						per_conto     =R_NS.id_struttura,
						id_partner=        case when id_partner is not null and id_partner=R_NS.id_nominativo then null else id_partner end,
						partner_per_conto= case when id_partner is not null and id_partner=R_NS.id_nominativo then null else partner_per_conto end
				where id = R_EV.id returning * into R_EV;
			GET DIAGNOSTICS t := ROW_COUNT;
			eff:=eff+t;
			n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'U');
		end loop;
			
    	ret.esito:=true;	
		ret:=ag_ui.build_ret(ret,proc_name,null);
		ret.msg:='Associate '|| eff ||' attività di '||tot||' selezionate';
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_ev_associa_nominativo(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ev_associa_partner(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_ev_associa_partner(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idpartner bigint;
        proc_name varchar; -- END
       	R_VW_EV agenda.vw_eventi%ROWTYPE; 
       	R_EV agenda.eventi%ROWTYPE; 
       	R_NS matrix.vw_nominativi_struttura;
        n bigint;
               tot bigint;
       	t bigint;
        eff bigint;
       
        begin
		proc_name:='agenda.upd_ev_associa_partner';
		idpartner:=v_j->'id_partner';
		if idpartner is null then
		    ret.esito:=false;	
			ret:=ag_ui.build_ret(ret,proc_name,'partner_non_specificato');
			return ret;
		end if;
		select * into R_NS
		from matrix.vw_nominativi_struttura where id=idpartner;
	
			tot:=coalesce(json_array_length(v_j->'id_evento'),0);
		eff:=0;
			
		for R_VW_EV in 
		--update agenda.eventi  set id_partner =idpartner where id in (
		/*select * from agenda.eventi where id in(
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'id_evento') )   loop AF 20240215 */
		select * from agenda.vw_eventi where id in(
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'id_evento') ) and operativa  loop
			update agenda.eventi  set
				id_partner       =case when id_nominativo is null or id_nominativo!=R_NS.id_nominativo then R_NS.id_nominativo else null end,
				partner_per_conto=case when id_nominativo is null or id_nominativo!=R_NS.id_nominativo then R_NS.id_struttura  else null end
				where id =R_VW_EV.id returning * into R_EV;
			GET DIAGNOSTICS t := ROW_COUNT;
			eff:=eff+t;
			n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'U');
		end loop;
			
    	ret.esito:=true;	
		ret:=ag_ui.build_ret(ret,proc_name,null);
		ret.msg:='Associate '|| eff ||' attività di '||tot||' selezionate';
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_ev_associa_partner(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ev_associa_validita(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_ev_associa_validita(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        proc_name varchar; -- END
        validoda timestamp;
        validoa timestamp;
        R_EV agenda.eventi%ROWTYPE;
        n bigint;
        begin
		proc_name:='agenda.upd_ev_associa_validita';
		validoda:=v_j->'valido_da';
		validoa :=v_j->'valido_a';
		
		for R_EV in select * from agenda.eventi where id in(		
				select  (value::varchar)::bigint from 
				json_array_elements(v_j->'id_evento') ) loop
				update agenda.eventi set valido_da=validoda,valido_a=validoa where id =R_EV.id returning * into R_EV;
				n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'U');				
		end loop;
				
    	ret.esito:=true;	
		ret:=ag_ui.build_ret(ret,proc_name,null);
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_ev_associa_validita(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ev_cambia_data(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_ev_cambia_data(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        proc_name varchar; -- END
        dt_att timestamp;
        dt_shift integer;
      	dt_shift_type varchar;
        R_EV agenda.eventi%ROWTYPE;
        n bigint;
        i_val interval;
  
        begin
		proc_name:='agenda.upd_ev_cambia_data';
		dt_att:=v_j->'data';
		    ret.esito:=true;	
		   raise notice 'DT_ATT=%',coalesce(dt_att::varchar,'NULL');
		if dt_att is not null then
			for R_EV in
			select * from agenda.eventi 	
				where id in (
					select  (value::varchar)::bigint from 
					json_array_elements(v_j->'id_evento') union
					
					select  (value::varchar)::bigint from 
					json_array_elements(v_j->'id_attivita')
					)
			loop
				update agenda.eventi set inizio =inizio + (date_trunc('day',dt_att) - date_trunc('day',inizio)), 
										fine =fine + (date_trunc('day',dt_att) - date_trunc('day',inizio))
				where id =R_EV.id returning * into R_EV;
				n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'U');	
			end loop;		
		else
			dt_shift:=v_j->'shift';
			
			raise notice 'shift=%',coalesce(dt_shift::varchar,'NULL');
			dt_shift_type:=v_j->'shift_type';
			dt_shift_type:=replace(dt_shift_type,'"','');
			raise notice 'shift_type=%',coalesce(dt_shift_type,'NULL');
			if dt_shift_type='mesi'      then
				raise notice 'MESI';
				i_val:=(interval '1 month');
				--update agenda.eventi set inizio =inizio + (interval '1 month')*dt_shift where id in (select  (value::varchar)::bigint from json_array_elements(v_j->'id_attivita') );
			end if;
			if dt_shift_type='giorni'    then
				raise notice 'GIORNI';
				i_val:=(interval '1 day');
				--update agenda.eventi set inizio =inizio + (interval '1 day')  *dt_shift where id in (select  (value::varchar)::bigint from json_array_elements(v_j->'id_attivita') );
			end if;
			if dt_shift_type='settimane' then
				raise notice 'SETTIMANE';	
				i_val:=(interval '1 week');
				--update agenda.eventi set inizio =inizio + (interval '1 week') *dt_shift where id in (select  (value::varchar)::bigint from json_array_elements(v_j->'id_attivita') );
			end if;
			for R_EV in
				select * from agenda.eventi
				--update agenda.eventi set inizio =inizio + i_val *dt_shift
				where id in (select  (value::varchar)::bigint from json_array_elements(v_j->'id_evento') union
							 select  (value::varchar)::bigint from json_array_elements(v_j->'id_attivita')) 
			loop
				update agenda.eventi set inizio =inizio + i_val *dt_shift,fine =fine + i_val *dt_shift
				where id=R_EV.id returning * into R_EV;
				n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'U');	
			end loop;
				
		end if;

		ret:=ag_ui.build_ret(ret,proc_name,null);
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_ev_cambia_data(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ev_elimina(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_ev_elimina(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
	n bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
       valido_da timestamp;
       valido_a timestamp;
        begin
		proc_name:='agenda.upd_ev_elimina';

			
		for R_EV in select * from agenda.eventi 
		--delete from agenda.eventi 
			where id in (
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'id_evento') ) loop
			delete from agenda.eventi where id=R_EV.id returning * into R_EV;
			n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'D');
		end loop;
		
    	ret.esito:=true;	
    	GET DIAGNOSTICS n = ROW_COUNT;
		ret:=ag_ui.build_ret(ret,proc_name,null);
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_ev_elimina(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ev_elimina_linea(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_ev_elimina_linea(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
	n bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
       valido_da timestamp;
       valido_a timestamp;
        begin
		proc_name:='agenda.upd_ev_elimina_linea';

			
		for R_EV in select * from AGENDA.EVENTI where id in (
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'id_evento') )loop
			update agenda.eventi set id_linea  =null where id =R_EV.id returning * into R_EV;
			n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'U');
		end loop;
		
    	ret.esito:=true;	
    	GET DIAGNOSTICS n = ROW_COUNT;
		ret:=ag_ui.build_ret(ret,proc_name,null);
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_ev_elimina_linea(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ev_elimina_partner(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_ev_elimina_partner(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
	n bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
       valido_da timestamp;
       valido_a timestamp;
        begin
		proc_name:='agenda.upd_ev_elimina_partner';

			
		for R_EV in select * from agenda.eventi where id in (
		
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'id_evento') )  loop
			update agenda.eventi set id_partner  =null where id =R_EV.id returning * into R_EV;
			n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'U');
		end loop;
		
    	ret.esito:=true;	
    	GET DIAGNOSTICS n = ROW_COUNT;
		ret:=ag_ui.build_ret(ret,proc_name,null);
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_ev_elimina_partner(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ev_elimina_validita(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_ev_elimina_validita(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
	n bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
       valido_da timestamp;
       valido_a timestamp;
        begin
		proc_name:='agenda.upd_ev_elimina_validita';

		for R_EV in 
		select * from agenda.eventi where id in(
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'id_evento') )  loop
			update agenda.eventi set valido_da =null,valido_a=null where id =R_EV.id returning * into R_EV;
			n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'U');
		end loop;
		
    	ret.esito:=true;	
    	GET DIAGNOSTICS n = ROW_COUNT;
		ret:=ag_ui.build_ret(ret,proc_name,null);
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_ev_elimina_validita(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_evento(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_evento(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;
        idcu bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
       	R_EV_PREC agenda.eventi%ROWTYPE;
        R_ATT trf.trf_attivita%ROWTYPE; 
        R_C trf.clienti%ROWTYPE;
       	R_CU cu.cu%ROWTYPE;
        R_S trf.servizi%ROWTYPE; 
        R_TE ag_types.ag_tipo_eventi; -- START
        R record;
        idtrfoperatore bigint;
        idevento bigint;
        idrisorsa bigint;
        --codintstruttura bigint;
       	old_effettuata boolean;
        v_j json;
       	piani_j json;
        n integer;
        rt json;
        idazsede bigint;
        idlinea bigint;
       	def_min_start          decimal;
		def_ora_start          decimal;
		ora_start interval;
        begin
	       
		proc_name:='agenda.upd_evento';
	
		select value::decimal   into def_ora_start          from ag_conf.ag_conf where cod='cal_start_ora';
		select value::decimal   into def_min_start          from ag_conf.ag_conf where cod='cal_start_minuti';
		ora_start:= (interval '1 hour')*def_ora_start + (interval '1 minute')*def_min_start;
	        
	        
	        
	        
	        

		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		raise notice 'V_J %',v_j;
		raise notice 'V_J->id %',(v_j->'id')::text;
		raise notice 'REPLACE V_J->id %',replace((v_j->'id')::text,'"','');
		idevento:=replace((v_j->'id')::text,'"','')::int8;
		idcu:=v_j->'id_cu';
		select * into R_EV from agenda.eventi where id =idevento;
		R_EV_PREC:=R_EV;
		old_effettuata:=R_EV.effettuata;
		raise notice 'EFFETT %',R_EV.effettuata;
		raise notice 'old_effettuata %',old_effettuata;
		idazsede:=null;
		idlinea :=null;
		if idcu is not null then
			raise notice 'idcu not NULL';
			select * into R_CU from cu.cu where id=idcu;
					/*if R_CU.chiuso then  issue #11556
						ret.esito:=false;
						ret.valore:= null;
						ret.msg:=proc_name || ': CU '||(v_j->'id')::varchar|| ' chiuso';
						RAISE notice '%', ret;
						return ret;
					end if; */
			select json_agg(row_to_json(a.*)) into piani_j from 
				(select id_piano,per_conto from cu.vw_cu_piani p where id_cu=idcu) a;
			idazsede:=R_CU.id_az_sede;
			idlinea:=R_EV.id_linea;
			select n.id_utente into idtrfoperatore from rbac.utente_strutture n where id_nominativo =
				(select id_nominativo from cu.vw_cu_nucleo_ni where id_cu=idcu and sigla_tipo_isp='ref'); 
		else
			raise notice 'idcu NULL';
		 	if R_EV.id_piano is null then
				piani_j:='[]'::json;
			else
				raise notice 'Piano % perconto %',R_EV.id_piano,R_EV.per_conto;
				raise notice 'piani_j %','[{"id_piano":'||R_EV.id_piano||',"per_conto":'||R_EV.per_conto||'}]';
				piani_j:=('[{"id_piano":'||R_EV.id_piano||',"per_conto":'||R_EV.per_conto||'}]')::json;
			end if;
			idlinea:=R_EV.id_linea;
			select id_az_sede into idazsede from agenda.vw_linee where id_linea=R_EV.id_linea;
			-- select n.id_anagrafica into idtrfoperatore from matrix.nominativi n where id =R_EV.id_nominativo;
			select n.id_utente into idtrfoperatore from rbac.utente_strutture n where id_nominativo = R_EV.id_nominativo;

		end if;
		raise notice 'piani_j %',piani_j;
		--idrisorsa:=((v_j->>'extendedProps')::json)->'id_risorsa';
	    --codintstruttura:= ((v_j->>'user_info')::json)->'codice_interno_struttura';
		raise notice 'EXT %',(v_j->'extendedProps')::varchar;
		--raise notice 'idrisorsa %',idrisorsa;
		raise notice 'idEvento: %', idevento;

		if R_EV.id is null then
			ret.esito:=false;
			ret.valore:= null;
			ret.msg:=proc_name || ': id '||(v_j->'id')::varchar|| ' inesistente';
			RAISE notice '%', ret;
			return ret;
		end if;

		R_EV.inizio         := v_j->'start';
		R_EV.fine           := v_j->'end';
		if(extract( hour from R_EV.inizio) = 0 and extract( minute from R_EV.inizio) = 0) then
			R_EV.inizio:=R_EV.inizio+ora_start;
			R_EV.fine:=R_EV.fine+ora_start;
		end if;
		if (v_j->'extendedProps')->'effettuata' is not null then
			R_EV.effettuata     := (v_j->'extendedProps')->'effettuata';
		end if;
		
		raise notice 'R_EV.inizio: %', R_EV.inizio;
		raise notice 'R_EV.fine: %', R_EV.fine;
		raise notice 'R_EV.effettuata: %', R_EV.effettuata;

	
    	update agenda.eventi set (inizio,fine,effettuata) =
    							 (R_EV.inizio,R_EV.fine,R_EV.effettuata) where id=idevento returning * into R_EV;
    	n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'U');
    	if R_EV.id_cu is not null and date_trunc('day',R_EV.inizio) != date_trunc('day',R_EV_PREC.inizio) then
    		update cu.cu set dt=dt + (date_trunc('day',R_EV.inizio) - date_trunc('day',R_EV_PREC.inizio))
    			where id=R_EV.id_cu returning * into R_CU;
    		n:=cu_log.upd_record('cu.cu',idtransazione,R_CU,'U');
		end if;    							--returning R_EV; 

    
    	if  old_effettuata and not R_EV.effettuata then
    		raise notice 'DELETE FROM TRF_ATTIVITA';
    		delete from trf.trf_attivita where id_ref_attivita =R_EV.id;
    	end if;
    	select * into R_TE from ag_types.ag_tipo_eventi where id= R_EV.id_tipo_evento;
	--DA IMPLEMENTARE n:=ag_log.upd_record('agenda.eventi',idtransazione,R_EV,'I');
		--if not old_effettuata and R_EV.effettuata and R_EV.id_piano is not null and R_EV.id_linea is not null then
    	raise notice 'PIANI % AZ_SEDE % oldeff % eff % len_arr %',piani_j,idazsede,old_effettuata,R_EV.effettuata,json_array_length(piani_j);
		if /*(not old_effettuata) and*/R_TE.tariffabile and  R_EV.effettuata and json_array_length(piani_j)>0 then --and idazsede is not null then
			raise notice 'INSERT TRF_ATTIVITA';
			for R in select * from json_populate_recordset(null::record,piani_j) as (id_piano int8, per_conto int8) loop
				raise notice 'INSERT TRF_ATTIVITA LOOP piano % per_conto %' ,R.id_piano,R.per_conto;
	    		--R_ATT.per_conto_di_struttura:=R_EV.per_conto;
				R_ATT.per_conto_di_struttura:=R.per_conto;
				select /*sa.id*/ sa.id_asl into R_ATT.per_conto_di
					from matrix.vw_tree_nodes_down_asl_descr a join matrix.struttura_asl sa on a.id_node_ref =sa.id
					where id_node=R_EV.per_conto  and sa.n_livello=1;
				/* AF 20240223 if idazsede is not null then
					select c.* into R_C from trf.clienti c where id_ref=idazsede and c."type" ='az_sede';
					if R_C.id is null then
						R_C.id:= nextval('agenda.agenda_id_seq');
						R_C.id_ref:=idazsede; --R_EV.id_linea;
						R_C."type" :='az_sede';
						insert into trf.clienti values (R_C.*);
					end if;
					raise notice 'idazsede CLIENTE %',R_C.id;
				else*/
				if idlinea is not null then
					select c.* into R_C from trf.clienti c where id_ref=idlinea and c."type" ='linea';
					if R_C.id is null then
						R_C.id:= nextval('agenda.agenda_id_seq');
						R_C.id_ref:=idlinea; --R_EV.id_linea;
						R_C."type" :='linea';
						insert into trf.clienti values (R_C.*);
					end if;
					raise notice 'linea CLIENTE %',R_C.id;
				else
					if idazsede is not null then
						select c.* into R_C from trf.clienti c where id_ref=idazsede and c."type" ='az_sede';
						if R_C.id is null then
							R_C.id:= nextval('agenda.agenda_id_seq');
							R_C.id_ref:=idazsede; --R_EV.id_linea;
							R_C."type" :='az_sede';
							insert into trf.clienti values (R_C.*);
						end if;
						raise notice 'idazsede CLIENTE %',R_C.id;
					end if;
				end if;
				--end if;
				select s.* into R_S from trf.servizi s where id_ref=R.id_piano and s."type" ='piano';
				if R_S.id is null then
					R_S.id:= nextval('agenda.agenda_id_seq');
					R_S.id_ref:=R.id_piano;
					R_S."type" :='piano';
					insert into trf.servizi values (R_S.*);
				end if;		
			--select id_tariffa into from trf.trf_piano_tariffa where id_piano=R_EV.id_piano
				raise notice 'CLIENTE %',R_C.id;
				R_ATT.id:= nextval('agenda.agenda_id_seq');
				R_ATT.id_cliente:=R_C.id;
				R_ATT.id_servizio:=R_S.id ;
				R_ATT.data_da:=R_EV.inizio;
				R_ATT.data_a:=R_EV.fine;
				R_ATT.id_type_attivita:='piano';
				R_ATT.id_ref_attivita:=R_EV.id;
				R_ATT.closed:=false;
				R_ATT.per_conto_di_struttura:=R.per_conto;
				select id_tariffa into R_ATT.id_tariffa from trf.trf_piano_tariffa where id_piano=R.id_piano;
				--select n.id_anagrafica  into R_ATT.id_trf_operatore from matrix.nominativi n where id =R_EV.id_nominativo;
				R_ATT.id_trf_operatore:=idtrfoperatore;
				insert into trf.trf_attivita values (R_ATT.*);
			end loop;
		end if;
		select row_to_json(ve.*) into rt from (
		select ve.*,R_ATT.id id_trf_attivita, 
			crea_controllo AND id_cu IS NULL     crea_cu,
            crea_controllo AND id_cu IS NOT NULL apri_cu from agenda.vw_eventi ve where id=idevento) ve;
    	ret.esito:=true;
    	ret.info:=rt;
		--ret:=ag_ui.build_ret(ret,proc_name,null::varchar);
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_evento(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_imp_dati(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_imp_dati(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	ret_dati varchar;
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	rt json;
	R_C agenda.config_exp_imp;
	dati varchar;
	stmt varchar;
	fstmt varchar;

	begin
		proc_name:='agenda.upd_imp_dati';
		idstruttura=v->'user_info'->'id_struttura_root';

		ret.info:='';
		ret.esito:=true;
		/*for R_C in select c.* from agenda.vw_config_exp_imp c 
			join  json_array_elements(v->'id') v on v.value::varchar::int8=c.id 
			order by c.id  loop
			raise notice 'ID=%',R_C.id;
			stmt:= 'select ' ||R_C.f_imp||'(%L::json,%L::bigint)';
			raise notice 'STMT=%',stmt;
			fstmt:= format(stmt,v,idtransazione);
			execute fstmt into ret_dati;
			raise notice 'DATI %',ret_dati;
			if ret.info='' then ret.info:='[';
			else ret.info:=ret.info||',';
			end if;
			ret.info:=ret.info||
				'{"nome_foglio":"'||R_C.intestazione||
			    ',"result":"'||ret_dati||'"}';
			raise notice 'RET_INFO %',ret.info;
		end loop;
		if ret.info!='' then ret.info:=ret.info||']'; end if;*/
		ret.info:='';
		ret.esito:=true;
 		ret.msg:=null;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION agenda.upd_imp_dati(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_linee_piano(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_linee_piano(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        idpiano bigint;  
       	idsroot bigint;

        idnode bigint;
        proc_name varchar; -- END
        v_j json;
        u json;
       	R_L agenda.linea_piani;
       	n integer;
       	rc record;
	begin
		proc_name:='agenda.upd_linee_piano';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V=%',v;
		v_j:=v::json;
		--raise notice 'V_J=%',v_j;
		idpiano:=v_j->'id_piano';
       	u := v_j->'user_info';
		idsroot := u->'id_struttura_root';

	
		for rc in select (value::varchar)::bigint id from json_array_elements(v_j->'id_linee') 
		loop 
			delete  from agenda.linea_piani where id_linea not in (rc.id) and id_piano=idpiano and id_linea in 
			(select l.id from agenda.vw_linee l join agenda.vw_struttura_comuni sc on l.id_comune=sc.id_comune join matrix.vw_tree_nodes_down_asl a on sc.id_struttura = a.id_node where id_node_ref=idsroot) returning * into R_L;
			n:=ag_log.upd_record('agenda.linea_piani',idtransazione,R_L,'D');
		end loop;
		
		for rc in select (value::varchar)::bigint id, idpiano from 
			json_array_elements(v_j->'id_linee') 
			where rc.id not in (select id_linea from  agenda.linea_piani sc where id_piano=idpiano)
		loop
			insert into agenda.linea_piani values( nextval('agenda.agenda_id_seq'),rc.id, rc.idpiano) returning * into R_L;
			n:=ag_log.upd_record('agenda.linea_piani',idtransazione,R_L,'I');
		end loop;
		
		
		/*delete  from agenda.linea_piani where id_linea not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_linee'))
			and id_piano=idpiano and id_linea in 
			(select l.id from agenda.vw_linee l join agenda.vw_struttura_comuni sc on l.id_comune=sc.id_comune join matrix.vw_tree_nodes_down_asl a on sc.id_struttura = a.id_node where id_node_ref=idsroot) returning * into R_L;
			n:=ag_log.upd_record('agenda.linea_piani',idtransazione,R_L,'D');
		
		insert into agenda.linea_piani
			select nextval('agenda.agenda_id_seq'),(value::varchar)::bigint, idpiano from 
			json_array_elements(v_j->'id_linee') 
			where (value::varchar)::bigint not in (select id_linea from  agenda.linea_piani sc where id_piano=idpiano) returning * into R_L;
			n:=ag_log.upd_record('agenda.linea_piani',idtransazione,R_L,'I'); */
		
    	ret.esito:=true;	
		ret:=ag_ui.build_ret(ret,proc_name,idpiano);
 
		return ret;
	end;

	/*declare 
	    ret ag_types.result_type; -- START
        idpiano bigint;  
       	idsroot bigint;

        idnode bigint;
        proc_name varchar; -- END
        v_j json;
        begin
		proc_name:='agenda.upd_linee_piano';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		idpiano:=v_j->'id_piano';
       	idsroot := v->"user_info"->"id_struttura_root";

		
		delete  from agenda.linea_piani where id_linea not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_linee'))
			and id_piano=idpiano and id_linea in 
			(select id from vw_linee l join vw_struttura_comuni sc on l.id_comune=sc.id_comune join matrix.vw_tree_nodes_down_asl a on sc.id_struttura = a.id_node where id_node_ref=idsroot);

		insert into agenda.linee_piani
			select nextval('agenda.agenda_id_seq'),(value::varchar)::bigint, idpiano from 
			json_array_elements(v_j->'id_linee') 
			where (value::varchar)::bigint not in (select id_linea from  agenda.linea_piani sc where id_piano=idpiano);
		
    	ret.esito:=true;	
		ret:=ag_ui.build_ret(ret,proc_name,R_EV.id);
 
		return ret;
	end;*/
END
$$;


ALTER FUNCTION agenda.upd_linee_piano(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ns_az_sedi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_ns_az_sedi(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        idnominativostruttura bigint;  
       	idsroot bigint;
       	u json;

        idnode bigint;
        proc_name varchar; -- end
        R_N agenda.nominativo_az_sedi;
       	n integer;
       	rc record;
	begin
		proc_name:='agenda.upd_ns_az_sedi';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idnominativostruttura:=v_j->'id_nominativo_struttura';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';

		for rc in select id from agenda.nominativo_az_sedi where id_nominativo_struttura=idnominativostruttura 
		loop
			delete from agenda.nominativo_az_sedi where id=rc.id returning * into R_N;
			n:=ag_log.upd_record('agenda.nominativo_az_sedi',idtransazione,R_N,'D');
		end loop;
		
		/*delete from agenda.nominativo_az_sedi where id_nominativo_struttura=idnominativostruttura returning * into R_N;
		n:=ag_log.upd_record('agenda.nominativo_az_sedi',idtransazione,R_N,'D');*/
		
		for rc in select (value::varchar)::bigint id from 
			json_array_elements(v_j->'id_az_sedi')
		loop
			insert into agenda.nominativo_az_sedi values (nextval('agenda.agenda_id_seq'),idnominativostruttura,id) returning * into R_N;
			n:=ag_log.upd_record('agenda.nominativo_az_sedi',idtransazione,R_N,'I');
		end loop;
		
	
	
		/*insert into agenda.nominativo_az_sedi
			select nextval('agenda.agenda_id_seq'),idnominativostruttura,(value::varchar)::bigint from 
			json_array_elements(v_j->'id_az_sedi') returning * into R_N;
		n:=ag_log.upd_record('agenda.nominativo_az_sedi',idtransazione,R_N,'I'); */

		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=ag_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_ns_az_sedi(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ns_comuni(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_ns_comuni(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idns bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
        v_j json;
       	R_N agenda.nominativo_comuni;
       	n integer;
       	rc record;
        begin
		proc_name:='agenda.upd_ns_comuni';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		idns:=v_j->'id_nominativo_struttura';
		/*delete from agenda.nominativo_comuni where id_nominativo_struttura=idns;
		
		insert into agenda.nominativo_comuni 
			select nextval('agenda.agenda_id_seq'), idns,(value::varchar)::bigint from json_array_elements(v_j->'id_struttura_comune');*/
		
		for rc in select id from agenda.nominativo_comuni  where id_struttura_comune not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_struttura_comune'))
			and id_nominativo_struttura =idns
		loop
			delete  from agenda.nominativo_comuni  where id=rc.id returning * into R_N;
			n:=ag_log.upd_record('agenda.nominativo_comuni',idtransazione,R_N,'D');
		end loop;
		
	
		/*for rc in select (value::varchar)::bigint id from json_array_elements(v_j->'id_struttura_comune')
		loop
			delete  from agenda.nominativo_comuni  where id_struttura_comune not in (rc.id)
			and id_nominativo_struttura =idns returning * into R_N;
			n:=ag_log.upd_record('agenda.nominativo_comuni',idtransazione,R_N,'D');	
		end loop;*/
	
		for rc in select (value::varchar)::bigint id from json_array_elements(v_j->'id_struttura_comune') 
			where (value::varchar)::bigint not in (select id_struttura_comune from  agenda.nominativo_comuni sc where id_nominativo_struttura =idns)
		loop 
			insert into agenda.nominativo_comuni values (nextval('agenda.agenda_id_seq'), idns, rc.id) returning * into R_N;
			n:=ag_log.upd_record('agenda.nominativo_comuni',idtransazione,R_N,'I');
		end loop;
		
		
		/*delete  from agenda.nominativo_comuni  where id_struttura_comune not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_struttura_comune'))
			and id_nominativo_struttura =idns returning * into R_N;
		n:=ag_log.upd_record('agenda.nominativo_comuni',idtransazione,R_N,'D');


		insert into agenda.nominativo_comuni
			select nextval('agenda.agenda_id_seq'), idns,(value::varchar)::bigint from 
			json_array_elements(v_j->'id_struttura_comune') 
			where (value::varchar)::bigint not in (select id_struttura_comune from  agenda.nominativo_comuni sc where id_nominativo_struttura =idns) returning * into R_N;
		n:=ag_log.upd_record('agenda.nominativo_comuni',idtransazione,R_N,'I');
	 	*/

    	ret.esito:=true;
		ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_ns_comuni(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ns_linee(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_ns_linee(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        idnominativostruttura bigint;  
       	idsroot bigint;
       	u json;

        idnode bigint;
        proc_name varchar; -- end
        R_N agenda.nominativo_linee;
       	n integer;
       	rc record;
	begin
		proc_name:='agenda.upd_ns_linee';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idnominativostruttura:=v_j->'id_nominativo_struttura';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';

		for rc in select id from agenda.nominativo_linee where id_nominativo_struttura=idnominativostruttura
		loop
			delete from agenda.nominativo_linee where id=rc.id returning * into R_N;
			n:=ag_log.upd_record('agenda.nominativo_linee',idtransazione,R_N,'D');
		end loop;
		
		/*delete from agenda.nominativo_linee where id_nominativo_struttura=idnominativostruttura returning * into R_N;
		n:=ag_log.upd_record('agenda.nominativo_linee',idtransazione,R_N,'D');*/
		
		for rc in select (value::varchar)::bigint id from 
			json_array_elements(v_j->'id_linee')
		loop
			insert into agenda.nominativo_linee values(nextval('agenda.agenda_id_seq'),idnominativostruttura,rc.id) returning * into R_N;
			n:=ag_log.upd_record('agenda.nominativo_linee',idtransazione,R_N,'I');
		end loop;
		
		
	/*	insert into agenda.nominativo_linee
			select nextval('agenda.agenda_id_seq'),idnominativostruttura,(value::varchar)::bigint from 
			json_array_elements(v_j->'id_linee') returning * into R_N;
		n:=ag_log.upd_record('agenda.nominativo_linee',idtransazione,R_N,'I'); */

		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=ag_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_ns_linee(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ns_piani(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_ns_piani(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idns bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
        v_j json;
       	R_N agenda.nominativo_piani;
       	n integer;
       	rc record;
        begin
		proc_name:='agenda.upd_ns_piani';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		idns:=v_j->'id_ns';
	
		/*delete from agenda.nominativo_piani where id_nominativo_struttura=idns;
		
		insert into agenda.nominativo_piani 
			select nextval('agenda.agenda_id_seq'), idns,(value::varchar)::bigint from json_array_elements(v_j->'id_piano');*/
			
		for rc in select id from agenda.nominativo_piani  where id_piano not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_piano'))
			and id_nominativo_struttura =idns
		loop
			delete  from agenda.nominativo_piani  where id=rc.id returning * into R_N;
			n:=ag_log.upd_record('agenda.nominativo_piani',idtransazione,R_N,'D');
		end loop;
	
		for rc in select (value::varchar)::bigint id from json_array_elements(v_j->'id_piano') 
			where (value::varchar)::bigint not in (select id_piano from  agenda.nominativo_piani sc where id_nominativo_struttura =idns)
		loop
			insert into agenda.nominativo_piani values (nextval('agenda.agenda_id_seq'), idns, rc.id) returning * into R_N;
			n:=ag_log.upd_record('agenda.nominativo_piani',idtransazione,R_N,'I');
		end loop;
		
	
	
		/*delete  from agenda.nominativo_piani  where id_piano not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_piano'))
			and id_nominativo_struttura =idns returning * into R_N;
		n:=ag_log.upd_record('agenda.nominativo_piani',idtransazione,R_N,'D');
		
		insert into agenda.nominativo_piani
			select nextval('agenda.agenda_id_seq'), idns,(value::varchar)::bigint from 
			json_array_elements(v_j->'id_piano') 
			where (value::varchar)::bigint not in (select id_piano from  agenda.nominativo_piani sc where id_nominativo_struttura =idns) returning * into R_N;
		n:=ag_log.upd_record('agenda.nominativo_piani',idtransazione,R_N,'I');*/

    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,R_EV.id);
         ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_ns_piani(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_piano(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_piano(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret ag_types.result_type;
		v_j json;
		R_SP matrix.struttura_piani;
		R_T matrix.tree_nodes;
		v_id_node bigint;
		n integer;
		proc_name varchar;
		v_inizio_validita timestamp;
		v_fine_validita timestamp;
		v_id bigint; --id del nodo dell'albero specifico, visto che id e id_node possono essere diversi
		begin
		proc_name:='agenda.upd_piano';
		v_j:=v::json;
		v_id_node:=v_j->'id_node';
		v_id:=v_j->'id';
		R_SP.alias:=cu_anag.string_normalize_upper(v_j->>'alias');
		R_SP.descrizione:=cu_anag.string_normalize_upper(v_j->>'descrizione');
		R_SP.descrizione_breve:=cu_anag.string_normalize_upper(v_j->>'descrizione_breve');
	
		if v_j->>'fine_validita' != '' and v_j->>'fine_validita' is not null then
				v_fine_validita:=(v_j->>'fine_validita');
				--v_fine_validita:=(v_j->>'fine_validita')::date + interval '1 day';
		end if;
		
		if v_j->>'inizio_validita' != '' and v_j->>'inizio_validita' is not null then
			v_inizio_validita:=v_j->>'inizio_validita';
		end if;
	
		if v_j->>'inizio_validita' = '' then 
			v_inizio_validita:= null;
		end if;
	
		if v_inizio_validita is not null and  v_fine_validita is not null
				and v_inizio_validita >= v_fine_validita then
			ret.esito:=false;	
			ret:=ag_ui.build_ret(ret,proc_name,'inizio_e_fine_validita_non_compatibli');
			ret.info='0';
			return ret;
		end if;
	
		R_T.validita = tsrange(v_inizio_validita, v_fine_validita, '[)');
	
		select count(*) into n from matrix.struttura_piani sa 
		join matrix.tree_nodes tn on sa.id = tn.id
		where alias = R_SP.alias and v_id_node!=sa.id
		and validita && tsrange(v_inizio_validita,null,'[)');
		
		if n > 0 then
		    ret:=ag_ui.build_ret(ret,proc_name, 'struttura_piano_esistente');
		   	ret.esito:=false;
	   		return ret;
		end if;
		
		update matrix.struttura_piani 
		set alias = R_SP.alias,
			descrizione = R_SP.descrizione,
			descrizione_breve = R_SP.descrizione_breve
		where id = v_id_node returning * into R_SP;
		n:=ag_log.upd_record('agenda.struttura_piani',idtransazione,R_SP,'U');
		
		update matrix.tree_nodes 
		set validita = R_T.validita
		where id = v_id returning * into R_T;
		n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_T,'U');
		
	
	    GET DIAGNOSTICS n = ROW_COUNT;
		 if n < 1 then
			ret.esito:=false;
			ret:=ag_ui.build_ret(ret,proc_name, 'errore_aggiornamento_piano');
			return ret;
		 end if;
	  	
	  	ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info = '0';
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
		return ret;
		end;
	END;
$$;


ALTER FUNCTION agenda.upd_piano(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_piano_freq(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_piano_freq(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        idpiano bigint;  
        proc_name varchar; -- end
        R_P agenda.piano_freq;
       	n integer;
       	rc record;
	begin
		proc_name:='agenda.upd_piano_freq';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_j=%',v_j;
		idpiano:=v_j->'id_piano';
		
		for rc in select id  from agenda.piano_freq where id_piano=idpiano 
		loop
			delete from agenda.piano_freq where id=rc.id returning * into R_P;
			n:=ag_log.upd_record('agenda.piano_freq',idtransazione,R_P,'D');
		end loop;
		
		/*delete from agenda.piano_freq where id_piano=idpiano returning * into R_P;
		n:=ag_log.upd_record('agenda.piano_freq',idtransazione,R_P,'D'); */
		
		for rc in select * from json_populate_recordset(null::agenda.piano_freq,v_j->'piano_freq') 
		loop
			insert into agenda.piano_freq values (nextval('agenda.agenda_id_seq'),idpiano,rc.livello,rc.num,rc.den) returning * into R_P;
			n:=ag_log.upd_record('agenda.piano_freq',idtransazione,R_P,'I');
		end loop;
		
	
		/*insert into agenda.piano_freq
			select nextval('agenda.agenda_id_seq'),idpiano,x.livello,x.num,x.den from 
			(select * from json_populate_recordset(null::agenda.piano_freq,v_j->'piano_freq') ) x returning * into R_P;
		n:=ag_log.upd_record('agenda.piano_freq',idtransazione,R_P,'I'); */
		
		ret.esito:=true;
		ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_ok');
 		ret.msg:='';
	    ret.info:=0;
	    ret.valore:=0;
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idpiano);
	   ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_piano_freq(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_piano_periodo(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_piano_periodo(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        idpiano bigint;  
        proc_name varchar; -- end
        R_P agenda.piano_periodo;
       	n integer;
       	rc record;
	begin
		proc_name:='agenda.upd_piano_periodo';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_j=%',v_j;
		idpiano:=v_j->'id_piano';
		
		for rc in select id from agenda.piano_periodo where id_piano=idpiano 
		loop
			delete from agenda.piano_periodo where id=rc.id returning * into R_P;
			n:=ag_log.upd_record('agenda.piano_periodo',idtransazione,R_P,'D');
		end loop;
		
		/*delete from agenda.piano_periodo where id_piano=idpiano returning * into R_P;
		n:=ag_log.upd_record('agenda.piano_periodo',idtransazione,R_P,'D'); */
	
		for rc in select * from json_populate_recordset(null::agenda.piano_periodo,v_j->'piano_periodo') 
		loop
			insert into agenda.piano_periodo values (nextval('agenda.agenda_id_seq'),idpiano,tsrange(rc.da,rc.a,'[]')) returning * into R_P;
			n:=ag_log.upd_record('agenda.piano_periodo',idtransazione,R_P,'I');
		end loop;
		
	
		/*insert into agenda.piano_periodo
			select nextval('agenda.agenda_id_seq'),idpiano,tsrange(x.da,x.a,'[]') from 
			(select * from json_populate_recordset(null::agenda.piano_periodo,v_j->'piano_periodo') ) x returning * into R_P;
		n:=ag_log.upd_record('agenda.piano_periodo',idtransazione,R_P,'I'); */
		
		ret.esito:=true;

 		ret.msg:='';
	    ret.info:=0;
	    ret.valore:=0;
	   	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_ok');
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idpiano);
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_piano_periodo(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_risorse_avviso(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_risorse_avviso(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idavviso bigint;
        proc_name varchar; -- END
        v_j json;
       	n integer;
       	R_A agenda.avviso_risorse;
       	rc record;
       	REC record;
        begin
		proc_name:='agenda.upd_risorse_avviso';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		idavviso:=v_j->'id_avviso';
		
		for rc in select id from agenda.avviso_risorse  where id_risorsa not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_risorse'))
			and id_avviso = idavviso
		loop
			delete from agenda.avviso_risorse where id = rc.id returning * into R_A;
			n:=ag_log.upd_record('agenda.avviso_risorse',idtransazione,R_A,'D');
		end loop;
		
		/*delete from agenda.avviso_risorse  where id_risorsa not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_risorse'))
			and id_avviso = idavviso returning * into R_A;
		n:=ag_log.upd_record('agenda.avviso_risorse',idtransazione,R_A,'D'); */

		for REC in select idavviso,(value::varchar)::bigint idrisorsa from 
			json_array_elements(v_j->'id_risorse') 
			where (value::varchar)::bigint not in (select id_risorsa from agenda.avviso_risorse where id_avviso = idavviso)
		loop
			insert into agenda.avviso_risorse values(nextval('agenda.avviso_risorse_id_seq'), REC.idavviso, REC.idrisorsa) returning * into R_A;
			n:=ag_log.upd_record('agenda.avviso_risorse',idtransazione,R_A,'I');
		end loop;
	
		/*insert into agenda.avviso_risorse
			select nextval('agenda.avviso_risorse_id_seq'), idavviso,(value::varchar)::bigint from 
			json_array_elements(v_j->'id_risorse') 
			where (value::varchar)::bigint not in (select id_risorsa from  agenda.avviso_risorse where id_avviso = idavviso) returning * into R_A;
		n:=ag_log.upd_record('agenda.avviso_risorse',idtransazione,R_A,'I'); */
		

    	ret.esito:=true;
		ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_risorse_avviso(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_tipo_linee_per_piano(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_tipo_linee_per_piano(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        idpiano bigint;  
       	idsroot bigint;

        idnode bigint;
        proc_name varchar; -- END
        v_j json;
        u json;
       n integer;
      	R_P agenda.piano_tipo_linea;
      	rc record;
	begin
		proc_name:='agenda.upd_tipo_linee_per_piano';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V=%',v;
		v_j:=v::json;
		--raise notice 'V_J=%',v_j;
		idpiano:=v_j->'id_piano';
       	u := v_j->'user_info';
		idsroot := u->'id_struttura_root';
		
		for rc in select id from agenda.piano_tipo_linea where id_piano=idpiano
		loop
			delete  from agenda.piano_tipo_linea where id=rc.id returning * into R_P;
			n:=ag_log.upd_record('agenda.piano_tipo_linea',idtransazione,R_P,'D');
		end loop;
		
		
		--if json_array_length(v_j->'id_tipo_linee') > 0 then
			for rc in select  distinct idpiano,(value::varchar)::bigint id from 
				json_array_elements(v_j->'id_tipo_linee')
			loop
				/*insert into agenda.piano_tipo_linea
				select a.* ,nextval('agenda.agenda_id_seq') from rc a returning * into R_P;
				n:=ag_log.upd_record('agenda.piano_tipo_linea',idtransazione,R_P,'I'); */
				insert into agenda.piano_tipo_linea values(rc.idpiano,rc.id,nextval('agenda.agenda_id_seq')) returning * into R_P;
				n:=ag_log.upd_record('agenda.piano_tipo_linea',idtransazione,R_P,'I'); 
			end loop;
			
			/*insert into agenda.piano_tipo_linea
				select a.* ,nextval('agenda.agenda_id_seq') from (select  distinct idpiano,(value::varchar)::bigint from 
				json_array_elements(v_j->'id_tipo_linee')) a returning * into R_P;
			n:=ag_log.upd_record('agenda.piano_tipo_linea',idtransazione,R_P,'I'); */
			GET DIAGNOSTICS n = ROW_COUNT;
			raise notice 'NUMERO RIGHE %', n;
		--end if;
		
    	ret.esito:=true;
    	ret.info:=n;
		ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_tipo_linee_per_piano(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_tipo_lista_per_piano(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_tipo_lista_per_piano(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        idtipolista bigint;  
   --    	idsroot bigint;

    --    idnode bigint;
        proc_name varchar; -- END
        v_j json;
        u json;
       n integer;
      	R_P agenda.tipo_lista_piano;
      	rc record;
	begin
		proc_name:='agenda.upd_tipo_lista_per_piano';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V=%',v;
		v_j:=v::json;
		--raise notice 'V_J=%',v_j;
		idtipolista:=v_j->'id_tipo_lista';
       	u := v_j->'user_info';
	--	idsroot := u->'id_struttura_root';

       	select count(*) into n
       	from json_array_elements(v_j->'id_piano') js
       	join agenda.vw_tipo_lista_piani t on (js.value::varchar)::bigint  = t.id_piano
       	where t.id_tipo_lista != idtipolista;
       
       
      	if n > 0
      	then 
	      	ret.esito:=false;
	    	ret.info:=n;
			ret:=ag_ui.build_ret(ret,proc_name,'piano_gia_utilizzato_per_altri_tipo_liste');
			ret.info=null;
		
		
		return ret;
	end if;
		
		for rc in select id from agenda.tipo_lista_piano where id_tipo_lista=idtipolista
		loop
			delete  from agenda.tipo_lista_piano where id=rc.id returning * into R_P;
			n:=ag_log.upd_record('agenda.tipo_lista_piano',idtransazione,R_P,'D');
		end loop;
		
		
		/*delete  from agenda.tipo_lista_piano where id_tipo_lista=idtipolista returning * into R_P;
		n:=ag_log.upd_record('agenda.tipo_lista_piano',idtransazione,R_P,'D'); */
		
		for rc in select (value::varchar)::bigint id from 
			json_array_elements(v_j->'id_piano')
		loop
			insert into agenda.tipo_lista_piano values(rc.id, idtipolista, nextval('agenda.agenda_id_seq')) returning * into R_P;
			n:=ag_log.upd_record('agenda.tipo_lista_piano',idtransazione,R_P,'I');
		end loop;
		
	
		/*if json_array_length(v_j->'id_piano') > 0 then
			insert into agenda.tipo_lista_piano
			select (value::varchar)::bigint,idtipolista , nextval('agenda.agenda_id_seq') from 
			json_array_elements(v_j->'id_piano') returning * into R_P;
			n:=ag_log.upd_record('agenda.tipo_lista_piano',idtransazione,R_P,'I');
			GET DIAGNOSTICS n = ROW_COUNT;
			raise notice 'NUMERO RIGHE %', n;
		end if; */
		
    	ret.esito:=true;
    	ret.info:=n;
		ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info='0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_tipo_lista_per_piano(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_tipologia_controllo_piani(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_tipologia_controllo_piani(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idpiano bigint;
       	idtipologiacontrollo bigint;
        proc_name varchar; -- END
        v_j json;
       	R_T agenda.tipologia_controllo_piani;
       	n integer;
       	rc record;
        begin
		proc_name:='agenda.upd_tipologia_controllo_piani';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		idpiano:=v_j->'id_piano';
		idtipologiacontrollo:= json_array_elements(v_j->'id_tipologia_controllo');
		
		raise notice 'v%', v_j;
		raise notice 'id_tipologia_controllo %', v_j->'id_tipologia_controllo';
		
		for rc in select id from agenda.tipologia_controllo_piani where id_tipologia_controllo not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_tipologia_controllo'))
			and id_piano =idpiano
		loop
			delete from agenda.tipologia_controllo_piani where id=rc.id returning * into R_T;
			n:=ag_log.upd_record('agenda.tipologia_controllo_piani',idtransazione,R_T,'D');
		end loop;
		
		for rc in select (value::varchar)::bigint id from json_array_elements(v_j->'id_tipologia_controllo')
		loop
			insert into agenda.tipologia_controllo_piani (id_tipologia_controllo, id_piano) values (rc.id,idpiano) returning * into R_T;
			n:=ag_log.upd_record('agenda.tipologia_controllo_piani',idtransazione,R_T,'I');			
		end loop;
		
		/*delete from agenda.tipologia_controllo_piani where id_tipologia_controllo not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_tipologia_controllo'))
			and id_piano =idpiano returning * into R_T;
		n:=ag_log.upd_record('agenda.tipologia_controllo_piani',idtransazione,R_T,'D');
	
		insert into agenda.tipologia_controllo_piani (id_tipologia_controllo, id_piano) values (idtipologiacontrollo,idpiano) returning * into R_T;
		n:=ag_log.upd_record('agenda.tipologia_controllo_piani',idtransazione,R_T,'I'); */

    	ret.esito:=true;	
        --ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_tipologia_controllo_piani(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_unita_di_crisi(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_unita_di_crisi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	n integer;
	tipo varchar;
	v_ruolo varchar;
	v_nome varchar;
	v_cognome varchar;
	v_email varchar;
	v_telefono varchar;
	v_cellulare varchar;
	id_unita bigint;
	R_U agenda.unita_di_crisi;
	begin
		proc_name:='agenda.upd_unita_di_crisi';
		tipo:=v->>'tipo';
		v_ruolo:=cu_anag.string_normalize_upper(v->>'ruolo');
		v_nome:=cu_anag.string_normalize_upper(v->>'nome');
		v_cognome:=cu_anag.string_normalize_upper(v->>'cognome');
		v_email:=v->>'email';	
		v_telefono:=v->>'telefono';
		v_cellulare:=v->>'cellulare';
		id_unita:=v->>'id_unita';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		if tipo ilike 'fvg' then
			update agenda.unita_di_crisi set
				ruolo = v_ruolo,
				responsabile_nome = v_nome,
				responsabile_cognome = v_cognome,
				email = v_email,
				telefono = v_telefono,
				cellulare = v_cellulare
			where id = id_unita returning * into R_U;
			n:=ag_log.upd_record('agenda.unita_di_crisi',idtransazione,R_U,'U');
		
			ret.esito:=true;	
        	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		elsif tipo ilike 'asu_fc' then
			update agenda.unita_di_crisi set
				ruolo = v_ruolo,
				responsabile_nome = v_nome,
				responsabile_cognome = v_cognome,
				email = v_email,
				telefono = v_telefono,
				cellulare = v_cellulare
			where id = id_unita returning * into R_U;
			n:=ag_log.upd_record('agenda.unita_di_crisi',idtransazione,R_U,'U');
		
			ret.esito:=true;	
        	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		elsif tipo ilike 'asu_gi' then
			update agenda.unita_di_crisi set
				ruolo = v_ruolo,
				responsabile_nome = v_nome,
				responsabile_cognome = v_cognome,
				email = v_email,
				telefono = v_telefono,
				cellulare = v_cellulare
			where id = id_unita returning * into R_U;
			n:=ag_log.upd_record('agenda.unita_di_crisi',idtransazione,R_U,'U');
		
			ret.esito:=true;	
        	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		else
			update agenda.unita_di_crisi set
				ruolo = v_ruolo,
				responsabile_nome = v_nome,
				responsabile_cognome = v_cognome,
				email = v_email,
				telefono = v_telefono,
				cellulare = v_cellulare
			where id = id_unita returning * into R_U;
			n:=ag_log.upd_record('agenda.unita_di_crisi',idtransazione,R_U,'U');
		
			ret.esito:=true;	
        	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		end if;
	end;
end;
$$;


ALTER FUNCTION agenda.upd_unita_di_crisi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_uoc_piani(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_uoc_piani(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idstrutturaasl bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
        v_j json;
       	R_A agenda.asl_piani;
       	n integer;
       	rc record;
RC_I agenda.asl_piani;
        begin
		proc_name:='agenda.upd_uoc_piani';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		idstrutturaasl:=v_j->'id_struttura_asl';

/*
		delete from agenda.asl_piani where id_struttura in (select id from matrix.tree_nodes where id_parent=idstrutturaasl);
		
		insert into agenda.asl_piani
			--select nextval('agenda.agenda_id_seq'),idstrutturaasl,(value::varchar)::bigint, idns from json_array_elements(v_j->'id_piani');
		
		select nextval('agenda.agenda_id_seq'),n.id,(a.value::varchar)::bigint from json_array_elements(v_j->'id_piano') a join matrix.tree_nodes n on n.id_parent=idstrutturaasl;
 */
		for rc in select id from agenda.asl_piani where id_struttura in (select id from matrix.tree_nodes where id_parent=idstrutturaasl) loop
			delete from agenda.asl_piani where id=rc.id returning * into R_A;
			n:=ag_log.upd_record('agenda.asl_piani',idtransazione,R_A,'D');
		end loop;

		for RC_I in select nextval('agenda.agenda_id_seq') id,n.id id_struttura,(a.value::varchar)::bigint id_piano
			from json_array_elements(v_j->'id_piano') a join matrix.tree_nodes n on n.id_parent=idstrutturaasl loop
			insert into agenda.asl_piani values (RC_I.*) returning * into R_A;
			n:=ag_log.upd_record('agenda.asl_piani',idtransazione,R_A,'I');
		end loop;

   	

				    ret.esito:=true;
						ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
						ret.info='0';
				 
						return ret;
	/*
		for rc in select id from agenda.asl_piani where id_piano not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_piano'))
			and id_struttura in (select id from matrix.tree_nodes where id_parent=idstrutturaasl)
		loop
			delete from agenda.asl_piani where id=rc.id returning * into R_A;
			n:=ag_log.upd_record('agenda.asl_piani',idtransazione,R_A,'D');
		end loop;
	
		for rc in select nextval('agenda.agenda_id_seq'),n.id id_tree_nodes,(value::varchar)::bigint id from 
			json_array_elements(v_j->'id_piano') a join matrix.tree_nodes n on n.id_parent=idstrutturaasl
			where (value::varchar)::bigint not in (select id_piano from agenda.asl_piani where id_struttura in (select id from matrix.tree_nodes where id_parent=idstrutturaasl))
		loop 
			insert into agenda.asl_piani values (nextval('agenda.agenda_id_seq'),rc.id_tree_nodes, rc.id) returning * into R_A;
			n:=ag_log.upd_record('agenda.asl_piani',idtransazione,R_A,'I');
		end loop;
		
		
	*/
		/*	delete  from agenda.asl_piani where id_piano not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_piano'))
			and id_struttura in (select id from matrix.tree_nodes where id_parent=idstrutturaasl) returning * into R_A;
			--n:=ag_log.upd_record('agenda.asl_piani',idtransazione,R_A,'D');


		insert into agenda.asl_piani
			select nextval('agenda.agenda_id_seq'),n.id,(value::varchar)::bigint from 
			json_array_elements(v_j->'id_piano') a join matrix.tree_nodes n on n.id_parent=idstrutturaasl
			where (value::varchar)::bigint not in (select id_piano from agenda.asl_piani where id_struttura in (select id from matrix.tree_nodes where id_parent=idstrutturaasl)) returning * into R_A;
		--n:=ag_log.upd_record('agenda.asl_piani',idtransazione,R_A,'I');
		
	
	
	
	

    	    ret.esito:=true;
		ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
 
		return ret;*/
	end;
END
$$;


ALTER FUNCTION agenda.upd_uoc_piani(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_uos_comuni(character varying, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_uos_comuni(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idnode bigint;
        proc_name varchar; -- END
       	R_EV agenda.eventi%ROWTYPE; 
        idevento bigint;
        v_j json;
       	text_msg1 varchar;	
		text_msg2 varchar;	
		text_msg3 varchar;	
		text_msg4 varchar;
		R_S agenda.struttura_comuni;
		n integer;
		rc record;
        begin
		proc_name:='agenda.upd_uos_comuni';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		idnode:=v_j->'id_struttura_asl';
		/*delete from agenda.struttura_comuni where id_struttura=idnode;
		
		insert into agenda.struttura_comuni 
			select nextval('agenda.agenda_id_seq'),(value::varchar)::bigint, idnode from json_array_elements(v_j->'id_comuni');*/
    	ret.esito:=true;
    		ret:=ag_ui.build_ret(ret,proc_name,R_EV.id);
		begin
			for rc in select id from agenda.struttura_comuni where id_comune not in 
			(select (value::varchar)::bigint id from json_array_elements(v_j->'id_comuni'))
			and id_struttura=idnode
			loop
				delete  from agenda.struttura_comuni where id=rc.id returning * into R_S;
				n:=ag_log.upd_record('agenda.struttura_comuni',idtransazione,R_S,'D');
			end loop;
			
		/*delete  from agenda.struttura_comuni where id_comune not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_comuni'))
			and id_struttura=idnode returning * into R_S;
			n:=ag_log.upd_record('agenda.struttura_comuni',idtransazione,R_S,'D'); */
		
			exception when others then

			RAISE notice 'agenda.get_dati ROLLBACK a seguito di exception';
			GET STACKED DIAGNOSTICS text_msg1 = MESSAGE_TEXT,
		                  			text_msg2 = PG_EXCEPTION_DETAIL,
		                  			text_msg3 = PG_EXCEPTION_HINT,
		                 			text_msg4 = PG_EXCEPTION_CONTEXT;
			ret.esito:=false;
			ret.valore:= null;
			ret.msg:='Dati collegati non cancellabili'|| chr(10) || coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');
		end;

		for rc in select nextval('agenda.agenda_id_seq'),(value::varchar)::bigint id, idnode from 
			json_array_elements(v_j->'id_comuni') 
			where (value::varchar)::bigint not in (select id_comune from  agenda.struttura_comuni sc where id_struttura=idnode)
		loop
			raise notice 'rc%',rc;
			insert into agenda.struttura_comuni (id, id_comune, id_struttura) values(nextval('agenda.agenda_id_seq'), rc.id, idnode) returning * into R_S;
			n:=ag_log.upd_record('agenda.struttura_comuni',idtransazione,R_S,'I');
		end loop;
		
		/*insert into agenda.struttura_comuni
			select nextval('agenda.agenda_id_seq'),(value::varchar)::bigint, idnode from 
			json_array_elements(v_j->'id_comuni') 
			where (value::varchar)::bigint not in (select id_comune from  agenda.struttura_comuni sc where id_struttura=idnode) returning * into R_S;
		n:=ag_log.upd_record('agenda.struttura_comuni',idtransazione,R_S,'I');*/
		
		
		
		
	
	    ret.esito:=true;
		ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_uos_comuni(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_visualizzazione_avviso(json, bigint); Type: FUNCTION; Schema: agenda; Owner: postgres
--

CREATE FUNCTION agenda.upd_visualizzazione_avviso(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
       	v_visualizzabile bool;
     	v_data_prima_visualizzazione timestamp;
    	v_id_avviso_risorsa bigint;
    	v_id_utente bigint;
		n integer;
        proc_name varchar; -- END
        v_j json;
       	R_AV agenda.avviso_risorse;
       	rc record;
        begin
		proc_name:='agenda.upd_visualizzazione_avviso';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_id_utente:=v->'user_info'->'id_utente';
		v_j:=v::json;
		v_visualizzabile:=v_j->>'visualizzabile';
		v_data_prima_visualizzazione:=v_j->>'data_prima_visualizzazione';
		v_id_avviso_risorsa:=v_j->'id_avviso_risorsa';	
	
		raise notice 'v_j:%',v_j; 
		raise notice 'visualizzabile %',v_visualizzabile;
	
		for rc in select ar.id from agenda.avviso_risorse ar join matrix.vw_nominativi_struttura_validi vnsv on vnsv.id = ar.id_risorsa  where vnsv.id_anagrafica = v_id_utente and visualizzabile is true 
		loop
			update agenda.avviso_risorse 
			set visualizzabile = v_visualizzabile,
			dt_prima_visualizzazione = coalesce(dt_prima_visualizzazione,v_data_prima_visualizzazione)
			where id = rc.id returning * into R_AV;
			n:=ag_log.upd_record('agenda.avviso_risorse',idtransazione,R_AV,'U');
		end loop;
		
	
		/*update agenda.avviso_risorse  
		set visualizzabile = v_visualizzabile,
			dt_prima_visualizzazione = coalesce(dt_prima_visualizzazione,v_data_prima_visualizzazione)
		where id_risorsa = v_id_utente_struttura
		returning * into R_AV;
		n:=ag_log.upd_record('agenda.avviso_risorse',idtransazione,R_AV,'U');*/
	  	
		raise notice 'R_AV%',R_AV;

    	ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION agenda.upd_visualizzazione_avviso(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: allinea_ml_allev(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.allinea_ml_allev(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	n integer;
	ret ag_types.result_type;
	begin
delete from public.ml_allev_da_gisa;
insert into public.ml_allev_da_gisa  select * from vw_ml_allev_da_gisa;
create or replace view public.vw_ml_allev as select * from public.ml_allev_da_gisa;

delete from  agenda.ag_tree_nodes;
insert into agenda.ag_tree_nodes
SELECT DISTINCT  
" a".id_node,
" a".id_tree,
" a".id_node_parent,
" a".path_ord,
" a".descr,
" a".id_node_parent
FROM ( SELECT 'tipo_linee'::text AS name_tree,
10 AS id_node,
1538447 AS id_tree,
NULL::integer AS id_node_parent,
''::character varying AS path,
''::text AS path_ord,
''::text AS path_descr,
'-1'::integer AS id,
'Tipo linee'::text AS cod,
'Master List'::text AS descr,
0 AS livello
UNION
SELECT 'tipo_linee'::text AS name_tree,
vgim.id_norma * 10 + 1 AS id_node,
1538447 AS id_tree,
10 AS id_node_parent,
vgim.id_norma::character varying AS path,
TRIM(BOTH FROM vgim.codice_norma) AS path_ord,
TRIM(BOTH FROM vgim.codice_norma) AS path_descr,
vgim.id_norma AS id,
TRIM(BOTH FROM vgim.codice_norma) AS cod,
TRIM(BOTH FROM vgim.codice_norma) AS descr,
1 AS livello
FROM matrix.get_info_masterlist vgim
UNION
SELECT 'tipo_linee'::text AS name_tree,
'-20'::integer AS id_node,
1538447 AS id_tree,
10 AS id_node_parent,
'ALLEVAMENTI'::character varying AS path,
'ALLEVAMENTI'::text AS path_ord,
'ALLEVAMENTI'::text AS path_descr,
'-20'::integer AS id,
'ALLEVAMENTI'::text AS cod,
'ALLEVAMENTI'::text AS descr,
1 AS livello
UNION
SELECT 'tipo_linee'::text AS name_tree,
g.id AS id_node,
1538447 AS id_tree,
COALESCE(g.id_node_parent, '-20'::integer) AS id_parent,
g.descr AS path,
g.path_ord,
g.path_descr,
g.id,
g.descr,
g.descr,
g.lev + 1 AS livello
FROM vw_ml_allev g
UNION
SELECT 'tipo_linee'::text AS name_tree,
vgim.id_macroarea * 10 + 2 AS id_node,
1538447 AS id_tree,
vgim.id_norma * 10 + 1,
(vgim.id_norma || '/'::text) || vgim.id_macroarea AS path,
(TRIM(BOTH FROM vgim.codice_norma) || '/'::text) || TRIM(BOTH FROM vgim.macroarea) AS path_ord,
(TRIM(BOTH FROM vgim.codice_norma) || '/'::text) || TRIM(BOTH FROM vgim.macroarea) AS path_descr,
vgim.id_macroarea AS id,
TRIM(BOTH FROM vgim.macroarea) AS cod,
TRIM(BOTH FROM vgim.macroarea) AS descr,
2 AS livello
FROM matrix.get_info_masterlist vgim
UNION
SELECT 'tipo_linee'::text AS name_tree,
vgim.id_aggregazione * 10 + 3 AS id_node,
1538447 AS id_tree,
vgim.id_macroarea * 10 + 2,
(((vgim.id_norma || '/'::text) || vgim.id_macroarea) || '/'::text) || vgim.id_aggregazione AS path,
(((TRIM(BOTH FROM vgim.codice_norma) || '/'::text) || TRIM(BOTH FROM vgim.macroarea)) || '/'::text) || vgim.codice_aggregazione AS path_ord,

(((TRIM(BOTH FROM vgim.codice_norma) || '/'::text) || TRIM(BOTH FROM vgim.macroarea)) || '/'::text) || vgim.aggregazione AS path_descr,

vgim.id_aggregazione AS id,

TRIM(BOTH FROM vgim.codice_aggregazione) AS cod,

TRIM(BOTH FROM vgim.aggregazione) AS descr,

3 AS livello

FROM matrix.get_info_masterlist vgim

UNION

SELECT 'tipo_linee'::text AS name_tree,

vgim.id_linea * 10 + 4 AS id_node,

1538447 AS id_tree,

vgim.id_aggregazione * 10 + 3,

(((((vgim.id_norma || '/'::text) || vgim.id_macroarea) || '/'::text) || vgim.id_aggregazione) || '/'::text) || vgim.id_linea AS path,

lower((((((TRIM(BOTH FROM vgim.codice_norma) || '/'::text) || TRIM(BOTH FROM vgim.macroarea)) || '/'::text) || vgim.codice_aggregazione) || '/'::text) || vgim.attivita) AS path_ord,

(((((TRIM(BOTH FROM vgim.codice_norma) || '/'::text) || TRIM(BOTH FROM vgim.macroarea)) || '/'::text) || vgim.aggregazione) || '/'::text) || vgim.attivita AS path_descr,

vgim.id_linea AS id,

TRIM(BOTH FROM vgim.attivita) AS cod,

TRIM(BOTH FROM vgim.attivita) AS descr,

4 AS livello

FROM matrix.get_info_masterlist vgim) " a";
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION conf_ext.allinea_ml_allev(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: carica_frequenze(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.carica_frequenze(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	proc_name varchar;
	ret ag_types.result_type; 
	begin
		proc_name:='conf_ext.carica_frequenze';
		delete from agenda.piano_freq;
		insert into agenda.piano_freq
			select nextval('agenda.agenda_id_seq'),p.id, 2, coalesce(volte_basso,1),coalesce(anno_basso,1) from conf_ext.dpar_piani_tipolinea_frequenze f 
			join matrix.struttura_piani p on p.alias =f.alias_indicatore 
			where anno_alto is not null
			union
			select nextval('agenda.agenda_id_seq'),p.id, 1, coalesce(volte_medio,1),coalesce(anno_medio,1) from conf_ext.dpar_piani_tipolinea_frequenze f 
			join matrix.struttura_piani p on p.alias =f.alias_indicatore 
			where anno_alto is not null
			union
			select nextval('agenda.agenda_id_seq'),p.id, 0, coalesce(volte_alto,1),coalesce(anno_alto,1) from conf_ext.dpar_piani_tipolinea_frequenze f 
			join matrix.struttura_piani p on p.alias =f.alias_indicatore 
			where anno_alto is not null;
		ret.esito:=true;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION conf_ext.carica_frequenze(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: check_anagrafe_persone_fisiche(); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.check_anagrafe_persone_fisiche() RETURNS text
    LANGUAGE plpgsql
    AS $_$
   DECLARE
   msg text;
   counter integer;
   n integer;
   n_g INTEGER;
   n_b INTEGER;
	BEGIN

		counter := 0;
		delete from conf_ext.v_anagrafe_persone_fisiche_fvg;
		delete from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto;
		insert into conf_ext.v_anagrafe_persone_fisiche_fvg select * from conf_ext.vw_persone_fisiche_sicer;
 		get diagnostics n = row_count; 		raise notice 'RIGHE INSERITE INIZIALI %',n;
 	
		insert into conf_ext.v_anagrafe_persone_fisiche_fvg_scarto
			 select *,'CODICE FISCALE NON PRESENTE o DI LUNGHEZZA != 16' from conf_ext.v_anagrafe_persone_fisiche_fvg where codice_fiscale is null or length(codice_fiscale)!=16;
 		get diagnostics n = row_count; 		raise notice 'RIGHE INSERITE SCARTO !=16 %',n;
		delete from conf_ext.v_anagrafe_persone_fisiche_fvg f where f.id in (select a.id from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto a);	
		get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO !=16 %',n;
		select count(*) into n_G from conf_ext.v_anagrafe_persone_fisiche_fvg;
		select count(*) into n_B from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%',n_g,n_b;

		insert into conf_ext.v_anagrafe_persone_fisiche_fvg_scarto
			 select *,'CODICE FISCALE DUPICATO' from conf_ext.v_anagrafe_persone_fisiche_fvg where codice_fiscale in (
				select codice_fiscale from conf_ext.v_anagrafe_persone_fisiche_fvg group by 1 having count(*) > 1);
		get diagnostics n = row_count; 		raise notice 'RIGHE INSERITE SCARTO DUP %',n;
		delete from conf_ext.v_anagrafe_persone_fisiche_fvg f where f.id in (select a.id from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto a);
		get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO DUP %',n;
		select count(*) into n_G from conf_ext.v_anagrafe_persone_fisiche_fvg;
		select count(*) into n_B from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%',n_g,n_b;
	
	
		insert into conf_ext.v_anagrafe_persone_fisiche_fvg_scarto
			 select *,'CODICE FISCALE NON CORRETTO' from conf_ext.v_anagrafe_persone_fisiche_fvg where
					codice_fiscale !~ '^(?:[A-Z][AEIOU][AEIOUX]|[AEIOU]X{2}|[B-DF-HJ-NP-TV-Z]{2}[A-Z]){2}(?:[\dLMNP-V]{2}(?:[A-EHLMPR-T](?:[04LQ][1-9MNP-V]|[15MR][\dLMNP-V]|[26NS][0-8LMNP-U])|[DHPS][37PT][0L]|[ACELMRT][37PT][01LM]|[AC-EHLMPR-T][26NS][9V])|(?:[02468LNQSU][048LQU]|[13579MPRTV][26NS])B[26NS][9V])(?:[A-MZ][1-9MNP-V][\dLMNP-V]{2}|[A-M][0L](?:[1-9MNP-V][\dLMNP-V]|[0L][1-9MNP-V]))[A-Z]$';
		get diagnostics n = row_count; 		raise notice 'RIGHE INSERITE SCARTO MATCH %',n;
		delete from conf_ext.v_anagrafe_persone_fisiche_fvg f where f.id in (select a.id from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto a);		get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO MATCH %',n;	
		select count(*) into n_G from conf_ext.v_anagrafe_persone_fisiche_fvg;
		select count(*) into n_B from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;
	
	
		insert into conf_ext.v_anagrafe_persone_fisiche_fvg_scarto
			select s.*,'CODICE/DESCRIZIONE COMUNE RESIDENZA NON PRESENTE '||res_prov_istat||res_com_istat||' '|| res_com_desc			 
			 from conf_ext.v_anagrafe_persone_fisiche_fvg s
			 left join conf_ext.anpr_aRCHIVIO_COMUNI  c on c.codistat  = (res_prov_istat||res_com_istat)::integer
			 where c.denominazione_it  is null and (res_prov_istat||res_com_istat) != '000000';		
		get diagnostics n = row_count; 		raise notice 'RIGHE INSERITE SCARTO MATCH %',n;
		delete from conf_ext.v_anagrafe_persone_fisiche_fvg f where f.id in (select a.id from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto a);		get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO COMUNE RESIDENZA %',n;	
		select count(*) into n_G from conf_ext.v_anagrafe_persone_fisiche_fvg;
		select count(*) into n_B from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;
	
	
		insert into conf_ext.v_anagrafe_persone_fisiche_fvg_scarto
			 select s.*,'CODICE/DESCRIZIONE COMUNE NASCITA NON PRESENTE '||nato_prov_istat||nato_com_istat||' '|| nato_com_desc
			 from conf_ext.v_anagrafe_persone_fisiche_fvg s
			 left join conf_ext.anpr_aRCHIVIO_COMUNI  c on c.codistat  = (nato_prov_istat||nato_com_istat)::integer
			 where c.denominazione_it  is null and (nato_prov_istat||nato_com_istat) != '000000';
		get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO COM NASCITA %',n;
		delete from conf_ext.v_anagrafe_persone_fisiche_fvg f where f.id in (select a.id from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto a);
		select count(*) into n_G from conf_ext.v_anagrafe_persone_fisiche_fvg;
		select count(*) into n_B from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;
	
		insert into conf_ext.v_anagrafe_persone_fisiche_fvg_scarto
			 select s.*,'ERRATO CODICE FISCALE (CIN) '||codice_fiscale cf
			 from conf_ext.v_anagrafe_persone_fisiche_fvg s
			 where conf_ext.check_cf(codice_fiscale) is false;
		get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO CIN %',n;
		delete from conf_ext.v_anagrafe_persone_fisiche_fvg f where f.id in (select a.id from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto a);
		select count(*) into n_G from conf_ext.v_anagrafe_persone_fisiche_fvg;
		select count(*) into n_B from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;
	
		insert into conf_ext.v_anagrafe_persone_fisiche_fvg_scarto
			 select s.*,'TOPONIMO DUG NON PREVISTO '||res_dug cf
			 from conf_ext.v_anagrafe_persone_fisiche_fvg s
			 where trim(res_dug) not in (select sigla from conf_ext.toponimi union select descrizione from conf_ext.toponimi );
		get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO DUG %',n;
		delete from conf_ext.v_anagrafe_persone_fisiche_fvg f where f.id in (select a.id from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto a);
		select count(*) into n_G from conf_ext.v_anagrafe_persone_fisiche_fvg;
		select count(*) into n_B from conf_ext.v_anagrafe_persone_fisiche_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;
	

		RETURN msg;
	END
$_$;


ALTER FUNCTION conf_ext.check_anagrafe_persone_fisiche() OWNER TO postgres;

--
-- Name: check_gisa_imprese(); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.check_gisa_imprese() RETURNS text
    LANGUAGE plpgsql
    AS $_$

DECLARE
	
	stmt varchar;
	fstmt varchar;
	n integer;
	n_g INTEGER;
	n_b INTEGER;
	m varchar;

BEGIN


--DROP TABLE 
	
stmt := 'drop table if exists ' || 'bck.gisa_imprese_fvg_' || replace(current_date::text,'-','') || ';';
raise notice 'STMT= %',stmt;

fstmt := format(stmt);
execute fstmt;

stmt := 'drop table if exists ' || 'bck.gisa_imprese_fvg_scarto_' || replace(current_date::text,'-','') || ';';
raise notice 'STMT= %',stmt;

fstmt := format(stmt);
execute fstmt;
	

--CREAZIONE TABELLE DI BACKUP	
	
stmt := 'create table ' || 'bck.gisa_imprese_fvg_' || replace(current_date::text,'-','') || 
' as select * from conf_ext.gisa_imprese_fvg';
raise notice 'STMT= %',stmt;

fstmt := format(stmt);
execute fstmt;

stmt := 'create table ' || 'bck.gisa_imprese_fvg_scarto_' || replace(current_date::text,'-','') || 
' as select * from conf_ext.gisa_imprese_fvg_scarto';
raise notice 'STMT= %',stmt;

fstmt := format(stmt);
execute fstmt;
	

--SVUOTAMENTO E CREAZIONE TABELLE
/*
drop table if exists conf_ext.gisa_imprese_fvg;
drop table if exists conf_ext.gisa_imprese_fvg_scarto;
create table conf_ext.gisa_imprese_fvg_scarto as select *,'' motivo from conf_ext.fvg_gisa_imprese where 0=1;
create table conf_ext.gisa_imprese_fvg as select * from conf_ext.fvg_gisa_imprese;
*/
--truncate table conf_ext.gisa_imprese_fvg;
--truncate table conf_ext.gisa_imprese_fvg_scarto;

drop table if exists conf_ext.gisa_imprese_fvg cascade;

raise notice 'drop table conf_ext.gisa_imprese_fvg cascade;';

drop table if exists conf_ext.gisa_imprese_fvg_scarto cascade;

raise notice 'drop table conf_ext.gisa_imprese_fvg_scarto cascade;';

--MODIFICATA IL 02-08-2023

-- I dati dell'AZIENDA (IMPRESA) devono essere presi dai campi fg quando fg_figura_tipo_descr è SEDE LEGALE

create table conf_ext.gisa_imprese_fvg_scarto as select i.*,

sl.fg_tipo_figura_descr as sl_fg_tipo_figura_descr,
sl.fg_an_nome as sl_fg_an_nome,
sl.fg_an_cf as sl_fg_an_cf,
sl.fg_an_iva as sl_fg_an_iva,
sl.fg_an_pec as sl_fg_an_pec,
sl.fg_an_email as sl_fg_an_email,
sl.fg_data_fine as sl_fg_an_data_fine,

sl.fg_an_res_provincia as sl_fg_an_res_provincia,
sl.fg_an_res_istat as sl_fg_an_res_istat,
sl.fg_an_res_comune as sl_fg_an_res_comune,
sl.fg_an_res_toponimo as sl_fg_an_res_toponimo,
sl.fg_an_res_indirizzo as sl_fg_an_res_indirizzo,
sl.fg_an_res_civico as sl_fg_an_res_civico, 
sl.fg_an_tipo_persona as sl_fg_an_tipo_persona,
sl.fg_an_tipo_pers_descr as sl_fg_an_tipo_pers_descr,
sl.sd_cod_tipologia_struttura as sl_sd_cod_tipologia_struttura,
sl.sd_tipologia_struttura as sl_sd_tipologia_struttura,
sl.az_cod_aziendale as sl_az_cod_aziendale,
sl.sd_cod_regionale as sl_sd_cod_regionale,

sl.fg_an_split_payment as sl_fg_an_split_payment,
sl.fg_an_sdi as sl_fg_an_sdi,

'' motivo
from conf_ext.fvg_gisa_imprese i
join conf_ext.fvg_gisa_imprese sl on i.sd_id = sl.sd_id and sl.fg_tipo_figura_descr::text ilike '%Sede%Legale%'::text
where 0=1;

raise notice 'create table conf_ext.gisa_imprese_fvg_scarto';

--Aggiunta distinct il 02-10-2023
create table conf_ext.gisa_imprese_fvg as select distinct i.*, 

sl.fg_tipo_figura_descr as sl_fg_tipo_figura_descr,
sl.fg_an_nome as sl_fg_an_nome,
sl.fg_an_cf as sl_fg_an_cf,
sl.fg_an_iva as sl_fg_an_iva,
sl.fg_an_pec as sl_fg_an_pec,
sl.fg_an_email as sl_fg_an_email,
sl.fg_data_fine as sl_fg_data_fine,

sl.fg_an_res_provincia as sl_fg_an_res_provincia,
sl.fg_an_res_istat as sl_fg_an_res_istat,
sl.fg_an_res_comune as sl_fg_an_res_comune,
sl.fg_an_res_toponimo as sl_fg_an_res_toponimo,
sl.fg_an_res_indirizzo as sl_fg_an_res_indirizzo,
sl.fg_an_res_civico as sl_fg_an_res_civico,

sl.fg_an_tipo_persona as sl_fg_an_tipo_persona,
sl.fg_an_tipo_pers_descr as sl_fg_an_tipo_pers_descr,
sl.sd_cod_tipologia_struttura as sl_sd_cod_tipologia_struttura,
sl.sd_tipologia_struttura as sl_sd_tipologia_struttura,
sl.az_cod_aziendale as sl_az_cod_aziendale,
sl.sd_cod_regionale as sl_sd_cod_regionale,

sl.fg_an_split_payment as sl_fg_an_split_payment,
sl.fg_an_sdi as sl_fg_an_sdi

from conf_ext.fvg_gisa_imprese i
join conf_ext.fvg_gisa_imprese sl on i.sd_id = sl.sd_id and sl.fg_tipo_figura_descr::text ilike '%Sede%Legale%'::text

where 
--i.sd_id is not null and i.sd_cod_tipologia_struttura::text != '853'::text and  i.sd_cod_tipologia_struttura is not null
--and i.sd_tipologia_struttura::text not ilike '%allevament%'::text and 
i.az_cod_aziendale::text !~ '^[0-9]{3}[A-Z]{2}[0-9]{3}'::text
and i.fg_tipo_figura_descr::text ilike '%Legale%Rappresentante%'::text
and (i.fg_data_fine is null or i.fg_data_fine > current_timestamp)
and (i.az_data_fine is null or i.az_data_fine > current_timestamp)
and (i.sd_data_fine is null or i.sd_data_fine > current_timestamp)
and (sl.fg_data_fine is null or sl.fg_data_fine > current_timestamp)
and i.sd_cod_tipologia_struttura in ('852', '99907', '0SA', 'CA', 'CG', 'FI', 'FIE', 'MOCA', 'PS', 'RSP', 'SS', 'ST', 'STA', 'T11', 'Z01');


create or replace view conf_ext.vw_gisa_imprese_partenza
as select distinct i.*, 

sl.fg_tipo_figura_descr as sl_fg_tipo_figura_descr,
sl.fg_an_nome as sl_fg_an_nome,
sl.fg_an_cf as sl_fg_an_cf,
sl.fg_an_iva as sl_fg_an_iva,
sl.fg_an_pec as sl_fg_an_pec,
sl.fg_an_email as sl_fg_an_email,
sl.fg_data_fine as sl_fg_data_fine,

sl.fg_an_res_provincia as sl_fg_an_res_provincia,
sl.fg_an_res_istat as sl_fg_an_res_istat,
sl.fg_an_res_comune as sl_fg_an_res_comune,
sl.fg_an_res_toponimo as sl_fg_an_res_toponimo,
sl.fg_an_res_indirizzo as sl_fg_an_res_indirizzo,
sl.fg_an_res_civico as sl_fg_an_res_civico,

sl.fg_an_tipo_persona as sl_fg_an_tipo_persona,
sl.fg_an_tipo_pers_descr as sl_fg_an_tipo_pers_descr,
sl.sd_cod_tipologia_struttura as sl_sd_cod_tipologia_struttura,
sl.sd_tipologia_struttura as sl_sd_tipologia_struttura,
sl.az_cod_aziendale as sl_az_cod_aziendale,
sl.sd_cod_regionale as sl_sd_cod_regionale,

sl.fg_an_split_payment as sl_fg_an_split_payment,
sl.fg_an_sdi as sl_fg_an_sdi
from conf_ext.fvg_gisa_imprese i
join conf_ext.fvg_gisa_imprese sl on i.sd_id = sl.sd_id and sl.fg_tipo_figura_descr::text ilike '%Sede%Legale%'::text

where 
--i.sd_id is not null and i.sd_cod_tipologia_struttura::text != '853'::text and  i.sd_cod_tipologia_struttura is not null
--and i.sd_tipologia_struttura::text not ilike '%allevament%'::text and 
i.az_cod_aziendale::text !~ '^[0-9]{3}[A-Z]{2}[0-9]{3}'::text
and i.fg_tipo_figura_descr::text ilike '%Legale%Rappresentante%'::text
and (i.fg_data_fine is null or i.fg_data_fine > current_timestamp)
and (i.az_data_fine is null or i.az_data_fine > current_timestamp)
and (i.sd_data_fine is null or i.sd_data_fine > current_timestamp)
and (sl.fg_data_fine is null or sl.fg_data_fine > current_timestamp)
and i.sd_cod_tipologia_struttura in ('852', '99907', '0SA', 'CA', 'CG', 'FI', 'FIE', 'MOCA', 'PS', 'RSP', 'SS', 'ST', 'STA', 'T11', 'Z01');



--MODIFICATA IL 24-08-2023 - Controllati solo alcuni stabilimenti (Dopo indicazioni di Giovanatto)

raise notice 'create table conf_ext.gisa_imprese_fvg';

get diagnostics n = row_count; 		raise notice 'RIGHE INSERITE INIZIALI %',n;


--DATI MANCANTI SULL'AZIENDA (az_id)

insert into conf_ext.gisa_imprese_fvg_scarto
select i.*,'DATI MANCANTI SULLA AZIENDA' motivo
from conf_ext.gisa_imprese_fvg i
where i.az_id is null;

 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED AZIENDA MANCANTE');

--DATI MANCANTI SULLO STABILIMENTO (sd_id)

insert into conf_ext.gisa_imprese_fvg_scarto
select i.*,'DATI MANCANTI SULLO STABILIMENTO' motivo
from conf_ext.gisa_imprese_fvg i
where i.sd_id is NULL;
 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED STABILIMENTO MANCANTE');

--DATI MANCANTI SULLA FIGURA AZIENDALE (fg_id)

insert into conf_ext.gisa_imprese_fvg_scarto
select i.*,'DATI MANCANTI SULLA FIGURA AZIENDALE' motivo
from conf_ext.gisa_imprese_fvg i
where i.fg_id is NULL;
 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED FIGURA AZIENDALE MANCANTE');


/*
 
--RIMOSSO IL 06-07-2023

--CONTROLLO AZIENDA (az_id)

insert into conf_ext.gisa_imprese_fvg_scarto
select i.*,'AZ_ID RIPETUTO: '||az_id  motivo
from conf_ext.gisa_imprese_fvg i
where i.az_id in (select a.az_id from (select distinct 
		az_id, az_data_inizio, az_data_fine, az_cod_aziendale, az_bdn_id, 
		az_latitudine, az_longitudine, az_tipo_impresa, az_id_anagrafica, 
		az_denominazione, az_an_dato_fiscale, az_an_cf, az_an_iva, 
		az_an_data_nascita, az_an_tipo, az_an_tipo_descr, az_an_tipo_persona, 
		az_an_tipo_pers_descr, az_an_data_fine, az_an_data_decesso, 
		az_an_provincia, az_an_istat, az_an_comune, az_an_toponimo, 
		az_an_indirizzo, az_an_civico, az_di_cod_asl, az_di_descr_asl
		from conf_ext.gisa_imprese_fvg) a
		group by 1
		having count (*) > 1)
		order by i.az_id asc;
 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED AZIENDA RIPETUTA');
 	
*/

--CONTROLLO STABILIMENTO (sd_id)

insert into conf_ext.gisa_imprese_fvg_scarto
select i.*,'SD_ID RIPETUTO: '||sd_id motivo
from conf_ext.gisa_imprese_fvg i
where i.sd_id in (select a.sd_id from (select distinct 
		sd_id, az_id, sd_bdn_id, sd_bdn_specie, sd_specie_descr, 
		sd_cod_tipologia_struttura, sd_tipologia_struttura, 
		sd_data_inizio, sd_data_fine, sd_vet_id, sd_vet_cf, 
		sd_vet_cognome, sd_vet_nome, sd_an_id, sd_an_nome, 
		sd_an_dato_fiscale, sd_an_cf, sd_an_iva, sd_an_data_nascita, 
		sd_an_tipo, sd_an_tipo_descr, sd_an_tipo_persona, 
		sd_an_tipo_pers_descr, sd_an_data_fine, sd_an_data_decesso, 
		sd_an_res_provincia, sd_an_res_istat, sd_an_res_comune, sd_an_res_toponimo, 
		sd_an_res_indirizzo, sd_an_res_civico, sd_an_dom_provincia, sd_an_dom_istat,
		sd_an_dom_comune, sd_an_dom_toponimo, sd_an_dom_indirizzo, sd_an_dom_civico
		from conf_ext.gisa_imprese_fvg) a
		group by 1
		having count (*) > 1)
		order by i.az_id asc, i.sd_id asc;

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED STABILIMENTO RIPETUTO');	

--CONTROLLO FIGURA AZIENDALE (fg_id)

insert into conf_ext.gisa_imprese_fvg_scarto
select i.*,'FG_ID RIPETUTO: '||fg_id motivo
from conf_ext.gisa_imprese_fvg i
where i.fg_id in (select a.fg_id from (select distinct 	
		fg_id, az_id, fg_data_inizio, fg_data_fine, fg_cod_tipo_figura, fg_tipo_figura_descr, 
		fg_id_anagrafica, fg_an_nome, fg_an_dato_fiscale, fg_an_cf, fg_an_iva, 
		fg_an_data_nascita, fg_an_tipo, fg_an_tipo_descr, fg_an_tipo_persona, 
		fg_an_tipo_pers_descr, fg_an_data_fine, fg_an_res_provincia, fg_an_res_istat, 
		fg_an_res_comune, fg_an_res_toponimo, fg_an_res_indirizzo, fg_an_res_civico, 
		fg_an_dom_provincia, fg_an_dom_istat, fg_an_dom_comune, fg_an_dom_toponimo, 
		fg_an_dom_indirizzo, fg_an_dom_civico		
		from conf_ext.gisa_imprese_fvg) a
		group by 1
		having count (*) > 1)
		order by i.az_id asc, i.sd_id asc;

	m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED FIGURA AZIENDALE RIPETUTA');	

---------------------------------------------------------------------------------------------------------------------

--CONTROLLO DATI AZIENDA


/*
 
--RIMOSSO IL 06-07-2023

--CONTROLLO PARTITA IVA PER AZIENDA (az_an)

insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'AZIENDA - ERRATA PARTITA IVA: '||coalesce(az_an_iva,'') motivo
from conf_ext.gisa_imprese_fvg s
where 
 cu_anag.check_piva(('IT'::text || s.az_an_iva::text)::character varying) is false;

	m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO PIVA');	
*/


--CONTROLLO COMUNE/STATO ESTERO PER AZIENDA (az_an)

insert into conf_ext.gisa_imprese_fvg_scarto	
select s.*,'AZIENDA - STATO ESTERO: '||coalesce(s.sl_fg_an_res_istat,'')||' '|| coalesce(s.sl_fg_an_res_comune,'') motivo			 
from conf_ext.gisa_imprese_fvg s
where s.sl_fg_an_res_comune = 'STATO ESTERO';	

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO STATO ESTERO');	


insert into conf_ext.gisa_imprese_fvg_scarto	
select s.*,'AZIENDA - CODICE COMUNE NON PRESENTE: '||coalesce(s.sl_fg_an_res_istat,'')||' '|| coalesce(s.sl_fg_an_res_comune,'') motivo			 
from conf_ext.gisa_imprese_fvg s
--left join public.comuni1 c on c.istat::integer = s.sl_fg_an_res_istat::integer
left join conf_ext.vw_comuni_vigenti c on c.istat = s.sl_fg_an_res_istat
where c.denominazione_it is null;
--where c.nome is null; 

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO COMUNE');	

	
insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'AZIENDA - TOPONIMO DUG NON PREVISTO: '||coalesce(s.sl_fg_an_res_toponimo,'') cf
from conf_ext.gisa_imprese_fvg s
where trim(s.sl_fg_an_res_toponimo) not in (select sigla from conf_ext.toponimi 
union select descrizione from conf_ext.toponimi) and trim(s.sl_fg_an_res_toponimo) not in ('RIVE','STRADE');

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO TOPONIMO DUG NON PREVISTO');	


---------------------------------------------------------------------------------------------------------------------

--CONTROLLO DATI STABILIMENTO

/*
 
--RIMOSSO IL 06-07-2023

--CONTROLLO PARTITA IVA NULL PER STABILIMENTO (sd_an)

insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'STABILIMENTO - PARTITA IVA NULL' motivo
from conf_ext.gisa_imprese_fvg s
where s.sd_an_iva is null;
m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO PARTITA IVA NULL');	

--CONTROLLO PARTITA IVA PER STABILIMENTO (sd_an)

insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'STABILIMENTO - ERRATA PARTITA IVA: '||coalesce(s.sd_an_iva,'') motivo
from conf_ext.gisa_imprese_fvg s
where cu_anag.check_piva(('IT'::text || s.sd_an_iva::text)::character varying) is false;
m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO ERRATA PARTITA IVA');	

*/

--CONTROLLO COMUNE/STATO ESTERO PER STABILIMENTO (sd_an)

insert into conf_ext.gisa_imprese_fvg_scarto	
select s.*,'STABILIMENTO - STATO ESTERO: '||coalesce(s.sd_an_res_istat,'')||' '|| coalesce(s.sd_an_res_comune,'') motivo			 
from conf_ext.gisa_imprese_fvg s
where s.sd_an_res_comune = 'STATO ESTERO';		

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO STATO ESTERO');
	
insert into conf_ext.gisa_imprese_fvg_scarto	
select s.*,'STABILIMENTO - CODICE COMUNE NON PRESENTE: '||coalesce(s.sd_an_res_istat,'')||' '|| coalesce(s.sd_an_res_comune,'') motivo			 
from conf_ext.gisa_imprese_fvg s
--left join public.comuni1 c on c.istat::integer = s.sd_an_res_istat::integer where c.nome is null;	
left join conf_ext.vw_comuni_vigenti c on c.istat = s.sd_an_res_istat 
where c.denominazione_it is null;
m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO CODICE COMUNE NON PRESENTE');
	
insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'STABILIMENTO - TOPONIMO DUG NON PREVISTO: '||coalesce(s.sd_an_res_toponimo,'') motivo
from conf_ext.gisa_imprese_fvg s
where trim(s.sd_an_res_toponimo) not in (select sigla from conf_ext.toponimi 
union select descrizione from conf_ext.toponimi) and trim(s.sd_an_res_toponimo) not in ('RIVE','STRADE');

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO TOPONIMO DUG NON PREVISTO');


--------------------  AF
/*
insert into conf_ext.gisa_imprese_fvg_scarto
select *,'STABILIMENTO - PIVA CON MULTIPLE DENOMINAZIONI' from conf_ext.gisa_imprese_fvg
where sd_an_iva in (
select sd_an_iva from (
select distinct sd_an_iva ,sd_an_nome  from conf_ext.gisa_imprese_fvg gif ) a
group by 1 having count(*) > 1);

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO PIVA CON MULTIPLE DENOMINAZIONI');
*/

/* RIMOSSO IL 24-11-2023
insert into conf_ext.gisa_imprese_fvg_scarto
select *,'LEGALE RAPPRESENTANTE - LEGALI MULTIPLI' from conf_ext.gisa_imprese_fvg
where sd_an_iva in (
select sd_an_iva from (
select distinct sd_an_iva, fg_an_cf from conf_ext.gisa_imprese_fvg where fg_an_data_fine is null) a
--Aggiunta where il 12-09-2023
group by 1 having count(*) > 1);

 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO LEGALI RAPPRESENTANTI MULTIPLI');
*/


insert into conf_ext.gisa_imprese_fvg_scarto
select *,'STABILIMENTO - DATI DUPLICATI: ' || sd_an_nome||sd_an_res_istat||sd_an_res_comune||sd_an_res_toponimo||sd_an_res_indirizzo||sd_an_res_civico
from conf_ext.gisa_imprese_fvg where 
(sd_an_nome,sd_an_res_istat,sd_an_res_comune,sd_an_res_toponimo,sd_an_res_indirizzo,sd_an_res_civico)
in (select sd_an_nome,sd_an_res_istat,sd_an_res_comune,sd_an_res_toponimo,sd_an_res_indirizzo,sd_an_res_civico
from conf_ext.gisa_imprese_fvg gif 
group by 1,2,3,4,5,6
having count(*) > 1) ;

 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO DATI DUPLCATI');
---------------------------------------------------------------------------------------------------------------------

--CONTROLLO DATI LEGALE RAPPRESENTANTE

--CONTROLLO CODICE FISCALE LEGALE RAPPRESENTANTE


insert into conf_ext.gisa_imprese_fvg_scarto
select *,'LEGALE RAPPRESENTANTE - DATA FINE NON ACCETTATA' from conf_ext.gisa_imprese_fvg
where fg_tipo_figura_descr::text ilike '%Legale%Rappresentante%'::text and fg_data_fine is not null and fg_data_fine < '2023-01-01';

 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO LEGALE DATA FINE');
/*
insert into conf_ext.gisa_imprese_fvg_scarto	
select s.*,'LEGALE RAPPRESENTANTE - STATO ESTERO RESIDENZA: '||coalesce(fg_an_res_istat,'')||' '|| coalesce(fg_an_res_comune,'') motivo			 
from conf_ext.gisa_imprese_fvg s
where s.fg_an_res_comune = 'STATO ESTERO';		

 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO STATO ESTERO');

insert into conf_ext.gisa_imprese_fvg_scarto	
select s.*,'LEGALE RAPPRESENTANTE - CODICE COMUNE RESIDENZA NON PRESENTE: '||coalesce(fg_an_res_istat,'')||' '|| coalesce(fg_an_res_comune,'') motivo			 
from conf_ext.gisa_imprese_fvg s
left join public.comuni1 c on c.istat::integer = fg_an_res_istat::integer
where c.nome is null; 

 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO CODICE COMUNE NON PRESENTE');
	
insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'LEGALE RAPPRESENTANTE - TOPONIMO DUG RESIDENZA NON PREVISTO: '||coalesce(fg_an_res_toponimo,'') motivo
from conf_ext.gisa_imprese_fvg s
where trim(s.fg_an_res_toponimo) not in (select sigla from conf_ext.toponimi 
union select descrizione from conf_ext.toponimi) and trim(s.fg_an_res_toponimo) not in ('RIVE','STRADE');

 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO TOPONIMO DUG NON PREVISTO');
*/
insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'LEGALE RAPPRESENTANTE - NON TROVATO IN SOGGETTI FISICI: '|| coalesce(s.fg_an_cf, '') motivo	
--coalesce(s1.nome_completo ,'') motivo		--Modificato il 09-10-2023
from conf_ext.gisa_imprese_fvg s
left join conf_ext.vw_soggetti_fisici_fvg s1 ON s.fg_an_cf::text = s1.codice_fiscale::text
--left join conf_ext.soggetti_fisici_fvg s1 ON s.fg_an_cf::text = s1.codice_fiscale::text
where s1.codice_fiscale is null;
 
 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO SOGGETTI FISICI');
--DA TABELLA A VISTA --06-09-2023

--CONTROLLO LINEE DI ATTIVITA

insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'AZIENDA SENZA LINEE ATTIVITA' motivo
from conf_ext.gisa_imprese_fvg s 
where sd_id not in (select gi_sd_id from conf_ext.fvg_gisa_imprese_produzione);
 
m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO AZIENDA SENZA LINEE');


--MODIFICATO IL 20-07-2023 (Rimosso il controllo su pr_inattivo dato che su sicer non lo valorizzano)
insert into conf_ext.gisa_imprese_fvg_scarto
select distinct s.*,'LINEA ATTIVITA - DATA FINE NOT NULL'  motivo
--select s.*,'LINEA ATTIVITA - INATTIVO O DATA FINE NOT NULL'  motivo
from conf_ext.gisa_imprese_fvg s 
left join (select distinct on (pr_id) gi_sd_id, pr_id, pr_data_inizio, pr_data_fine, 
			sn_codice, ss_codice, sa_codice, sp_codice, pr_cod_attivita, pr_inattivo
			from conf_ext.fvg_gisa_imprese_produzione
			where pr_principale = 1		--Aggiunto il 12-09-2023
			) p on p.gi_sd_id = s.sd_id 
where --p.pr_inattivo != 0 or 
p.pr_data_fine is not null;

 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO LINEE');

insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'LINEA ATTIVITA - CODICE ATECO NULL'  motivo
from conf_ext.gisa_imprese_fvg s 
left join (select distinct on (pr_id) gi_sd_id, pr_id, pr_data_inizio, pr_data_fine, 
			sn_codice, ss_codice, sa_codice, sp_codice, pr_cod_attivita, pr_inattivo
			from conf_ext.fvg_gisa_imprese_produzione) p on p.gi_sd_id = s.sd_id
where p.pr_cod_attivita is null;

 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO LINEE');

insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'LINEA ATTIVITA - DATA INIZIO NULL' motivo 
from conf_ext.gisa_imprese_fvg s 
left join (select distinct on (pr_id) gi_sd_id, pr_id, pr_data_inizio, pr_data_fine, 
			sn_codice, ss_codice, sa_codice, sp_codice, pr_cod_attivita, pr_inattivo
			from conf_ext.fvg_gisa_imprese_produzione) p on p.gi_sd_id = s.sd_id
where p.pr_data_inizio is null;

 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO LINEE');

------------------------

--03-05-2023 

--CONTROLLO LINEE DI ATTIVITA

insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'STABILIMENTO - LINEA ATTIVITA PRINCIPALE DUPLICATA' motivo 
from conf_ext.gisa_imprese_fvg s
where s.sd_id in (select sd_id   
			from conf_ext.gisa_imprese_fvg s 
			left join (select distinct on (pr_id) gi_sd_id, pr_id, pr_data_inizio, pr_data_fine, 
						sn_codice, ss_codice, sa_codice, sp_codice, pr_cod_attivita, pr_inattivo, pr_principale
						from conf_ext.fvg_gisa_imprese_produzione) p on p.gi_sd_id = s.sd_id
			where p.pr_principale = 1
			group by s.sd_id 
			having count (*)>1);
		
 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO LINEE');


/*
 
--RIMOSSO IL 06-07-2023

insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'STABILIMENTO - DATI LINEA ATTIVITA MANCANTI' motivo 
from conf_ext.gisa_imprese_fvg s
where s.sd_id in (select sd_id  
			from conf_ext.gisa_imprese_fvg s 
			left join (select distinct on (pr_id) gi_sd_id, pr_id, pr_data_inizio, pr_data_fine, 
						sn_codice, ss_codice, sa_codice, sp_codice, pr_cod_attivita, pr_inattivo, pr_principale
						from conf_ext.fvg_gisa_imprese_produzione) p on p.gi_sd_id = s.sd_id
			where p.sn_codice is null 
			or p.ss_codice is null 
			or p.sa_codice is null 
			or p.sp_codice is null);
			
 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO LINEE');

*/

--06-07-2023
--02-08-2023 (Modificato il campo iva: da az_an_iva a sl_fg_an_iva)

insert into conf_ext.gisa_imprese_fvg_scarto
select distinct s.*, 'AZIENDA E STABILIMENTO - ERRATA PARTITA IVA: '||
coalesce(s.sl_fg_an_iva,'')||'; '||coalesce(s.sd_an_iva,'') motivo
from conf_ext.gisa_imprese_fvg s
where (cu_anag.check_piva(('IT'::text || s.sl_fg_an_iva::text)::character varying) is false 
AND
cu_anag.check_piva(('IT'::text || s.sd_an_iva::text)::character varying) is false);

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO PIVA');


insert into conf_ext.gisa_imprese_fvg_scarto
select distinct s.*, 'AZIENDA E STABILIMENTO - PARTITA IVA NULL' motivo
--  '||coalesce(s.sl_fg_an_iva,'')||'; '||coalesce(s.sd_an_iva,'') motivo
from conf_ext.gisa_imprese_fvg s
where s.sl_fg_an_iva is null 	and 	s.sd_an_iva is null;

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO PIVA NULL');



--18-07-2023

--Aggiunta controllo per scartare le aziende/stabilimenti aventi linee con ateco non presente nella ML

insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'LINEA ATTIVITA - CODICE ATECO NON PRESENTE: ' || p.pr_cod_attivita  motivo
from conf_ext.gisa_imprese_fvg s
left join (select distinct on (pr_id) gi_sd_id, pr_id, pr_data_inizio, pr_data_fine, 
			sn_codice, ss_codice, sa_codice, sp_codice, pr_cod_attivita, pr_inattivo
			from conf_ext.fvg_gisa_imprese_produzione
			where pr_principale = 1) p on p.gi_sd_id = s.sd_id
where p.pr_cod_attivita not in 
--(select replace(replace(replace(regexp_match(descr, '([^]$]*)'::text)::character varying::text, '{'::text, ''::text), '}'::text, ''::text)::character varying::text, '['::text, ''::text)
	(select cod_mod	from agenda.vw_ag_tree_nodes_up_tipo_linee);
	--(select replace(replace(replace(regexp_match(descrizione, '([^]$]*)'::text)::character varying::text, '{'::text, ''::text), '}'::text, ''::text)::character varying::text, '['::text, ''::text)
	--from public.ml8_linee_attivita_nuove_materializzata);
	
m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO LINEE');


--02-08-2023 (Modificato il campo iva: da az_an_iva a sl_fg_an_iva)

insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'AZIENDA - ERRATA PARTITA IVA: ' || s.sl_fg_an_iva  motivo
from conf_ext.gisa_imprese_fvg s
where s.sl_fg_an_iva = 'XXXXXXXXXXX';

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO PIVA');

--DIVISI IN 3 CONTROLLI DIVERSI --08-09-2023

insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'AZIENDA - COMUNE NON ATTIVO: ' || s.sl_fg_an_res_istat  motivo
from conf_ext.gisa_imprese_fvg s
where s.sl_fg_an_res_istat not in (select istat from conf_ext.vw_comuni_vigenti);
--in (select istat::integer from public.comuni1 where notused is true and istat not in (select istat from public.comuni1 where notused is not true));

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO ISTAT');


insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'STABILIMENTO - COMUNE NON ATTIVO: ' || s.sd_an_res_istat  motivo
from conf_ext.gisa_imprese_fvg s
where s.sd_an_res_istat not in (select istat from conf_ext.vw_comuni_vigenti);
--in (select istat::integer from public.comuni1 where notused is true and istat not in (select istat from public.comuni1 where notused is not true));

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO ISTAT');

/*
insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'LEGALE - COMUNE NON ATTIVO: ' || s.fg_an_res_istat  motivo
from conf_ext.gisa_imprese_fvg s
where s.fg_an_res_istat::integer in (select istat::integer from public.comuni1 where notused is true and istat not in (select istat from public.comuni1 where notused is not true));

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO ISTAT');

insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'AZIENDA/STABILIMENTO/LEGALE - COMUNE NON ATTIVO: ' || s.sl_fg_an_res_istat || s.sd_an_res_istat || s.fg_an_res_istat  motivo
from conf_ext.gisa_imprese_fvg s
where s.sl_fg_an_res_istat::integer in (select istat::integer from public.comuni1 where notused is true and istat not in (select istat from public.comuni1 where notused is not true))
or s.sd_an_res_istat::integer in (select istat::integer from public.comuni1 where notused is true and istat not in (select istat from public.comuni1 where notused is not true))
or s.fg_an_res_istat::integer in (select istat::integer from public.comuni1 where notused is true and istat not in (select istat from public.comuni1 where notused is not true));

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO ISTAT');
*/

--19-07-2023

insert into conf_ext.gisa_imprese_fvg_scarto	
select s.*,'STABILIMENTO - PROVINCIA FUORI REGIONE: '||coalesce(s.sd_an_res_provincia,'') motivo			 
from conf_ext.gisa_imprese_fvg s
where s.sd_an_res_provincia not in ('UD', 'PN', 'TS', 'GO');		

m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO PROVINCIA');
	

--01-08-2023



insert into conf_ext.gisa_imprese_fvg_scarto
select s.*,'STABILIMENTO - LINEA ATTIVITA PRINCIPALE MANCANTE' motivo 
from conf_ext.gisa_imprese_fvg s 
where sd_id not in 
(select gi_sd_id from conf_ext.fvg_gisa_imprese_produzione where pr_principale =1);
--join fvg_gisa_imprese_produzione p on s.sd_id = p.gi_sd_id 
--and p.pr_principale !=1;
		
 m:=conf_ext.check_gisa_imprese_info('RIGHE DELETED SCARTO LINEE');




--26-06-2023


CREATE OR REPLACE VIEW conf_ext.vw_imprese_fvg_scarto_motivi
AS SELECT regexp_match(gifs.motivo, '^[^:]*'::text) AS motivo,
		  count(*) AS count
FROM conf_ext.gisa_imprese_fvg_scarto gifs
GROUP BY (regexp_match(gifs.motivo, '^[^:]*'::text))
ORDER BY (count(*)) DESC;

perform conf_ext.create_view_imprese();

return 'OK';

	END;
$_$;


ALTER FUNCTION conf_ext.check_gisa_imprese() OWNER TO postgres;

--
-- Name: check_gisa_imprese_a_b(); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.check_gisa_imprese_a_b() RETURNS text
    LANGUAGE plpgsql
    AS $_$
	BEGIN


drop table if exists conf_ext.tmp_gisa_imprese_fvg_a cascade;
drop table if exists conf_ext.tmp_gisa_imprese_fvg_b cascade;
drop table if exists conf_ext.tmp_gisa_imprese_fvg_b_mod cascade;


create table conf_ext.tmp_gisa_imprese_fvg_a as
select * from conf_ext.gisa_imprese_fvg;



CREATE OR REPLACE VIEW conf_ext.vw_gisa_imprese_completa_a
AS SELECT i.az_id AS impresa_id,
    i.sl_fg_an_nome AS impresa_ragione_sociale,
    COALESCE(i.sl_fg_an_iva, i.sd_an_iva) AS impresa_piva,
    COALESCE(i.sl_fg_an_cf, i.sd_an_cf) AS impresa_cf,
    --16-01-24 (invertito il coalesce dando precedenza alla sede legale)
    i.az_cod_aziendale as impresa_cod_aziendale,
    i.sl_fg_an_res_toponimo AS impresa_indirizzo_toponimo,
    i.sl_fg_an_res_indirizzo AS impresa_indirizzo,
    i.sl_fg_an_res_civico AS impresa_indirizzo_civico,
    i.sl_fg_an_res_istat AS impresa_indirizzo_istat_comune,
    i.sl_fg_an_res_provincia AS impresa_indirizzo_provincia,
    --COALESCE(i.sl_fg_an_pec, i.sl_fg_an_email) AS impresa_pec,
    i.sl_fg_an_pec as impresa_pec,
    i.sl_fg_an_email as impresa_email,
    
    i.sl_fg_an_split_payment as impresa_split_payment,
	i.sl_fg_an_sdi as impresa_sdi,
		i.sl_fg_tipo_figura_descr as impresa_tipo_figura_descr,
    
i.sl_fg_an_tipo_persona as impresa_tipo_persona,
i.sl_fg_an_tipo_pers_descr as impresa_tipo_pers_descr,
i.sl_sd_cod_tipologia_struttura as stabilimento_cod_tipologia_struttura,
i.sl_sd_tipologia_struttura as impresa_tipologia_struttura,
i.sl_az_cod_aziendale as impresa_codice_aziendale,

    i.sd_id AS stabilimento_id,
    i.sd_an_nome AS stabilimento_denominazione,
    i.sl_sd_cod_regionale as stabilimento_codice_regionale,
    i.sd_an_res_toponimo AS stabilimento_indirizzo_toponimo,
    i.sd_an_res_indirizzo AS stabilimento_indirizzo,
    i.sd_an_res_civico AS stabilimento_indirizzo_civico,
    i.sd_an_res_istat AS stabilimento_indirizzo_istat_comune,
    i.sd_an_res_provincia AS stabilimento_indirizzo_provincia,
    i.sd_an_res_cap as stabilimento_indirizzo_cap,
    i.az_latitudine AS stabilimento_latitudine,
    i.az_longitudine AS stabilimento_longitudine,
    s.id AS soggetto_id,
    s.nome AS soggetto_nome,
    s.cognome AS soggetto_cognome,
    s.sesso AS soggetto_sesso,
    s.codice_catastale_nascita AS soggetto_codice_catastale_comune_nascita,
    s.data_nascita AS soggetto_data_nascita,
    s.codice_fiscale AS soggetto_codice_fiscale,
    s.email AS soggetto_email,
    s.telefono AS soggetto_telefono,
    s.res_toponimo AS soggetto_indirizzo_toponimo,
    s.res_indirizzo AS soggetto_indirizzo,
    s.res_civico AS soggetto_indirizzo_civico,
    s.res_istat AS soggetto_indirizzo_istat_comune,
    s.res_provincia AS soggetto_indirizzo_provincia,
    p.pr_id AS linea_id,
    p.pr_data_inizio AS linea_data_inizio,
    p.pr_data_fine AS linea_data_fine,
    p.sn_codice AS linea_norma_codice,
    p.ss_codice AS linea_macroarea_codice,
    p.sa_codice AS linea_aggregazione_codice,
    p.sp_codice AS linea_attivita_codice,
    p.pr_cod_attivita AS linea_ateco,
        CASE
            WHEN i.az_denominazione::text ~~* '%trasport%'::text OR i.sd_an_nome::text ~~* '%trasport%'::text THEN false
            ELSE true
        END AS attivita_fissa,
    p.pr_principale AS linea_principale
   FROM conf_ext.tmp_gisa_imprese_fvg_a i
     JOIN conf_ext.vw_soggetti_fisici_fvg s ON i.fg_an_cf::text = s.codice_fiscale::text
     JOIN ( SELECT DISTINCT ON (fvg_gisa_imprese_produzione.pr_id) fvg_gisa_imprese_produzione.pr_id,
            fvg_gisa_imprese_produzione.gi_sd_id,
            fvg_gisa_imprese_produzione.pr_data_inizio,
            fvg_gisa_imprese_produzione.pr_data_fine,
            fvg_gisa_imprese_produzione.sn_codice,
            fvg_gisa_imprese_produzione.ss_codice,
            fvg_gisa_imprese_produzione.sa_codice,
            fvg_gisa_imprese_produzione.sp_codice,
            fvg_gisa_imprese_produzione.pr_cod_attivita,
            fvg_gisa_imprese_produzione.pr_principale
           FROM conf_ext.fvg_gisa_imprese_produzione
          WHERE fvg_gisa_imprese_produzione.pr_principale = 1::numeric
          ORDER BY fvg_gisa_imprese_produzione.pr_id, fvg_gisa_imprese_produzione.gi_sd_id, fvg_gisa_imprese_produzione.pr_data_inizio DESC) p ON i.sd_id = p.gi_sd_id
  WHERE p.pr_principale IS NOT NULL
  ORDER BY i.az_id, i.sd_id;

raise notice 'Creata vista vw_gisa_imprese_completa_a';

/*
create table conf_ext.tmp_gisa_imprese_fvg_b as
select * from conf_ext.gisa_imprese_fvg_scarto;
*/
 
create table conf_ext.tmp_gisa_imprese_fvg_b as
select * from conf_ext.gisa_imprese_fvg_scarto
where motivo NOT ilike '%STABILIMENTO - DATI DUPLICATI%';

insert into conf_ext.tmp_gisa_imprese_fvg_b
select distinct * from conf_ext.gisa_imprese_fvg_scarto
where motivo ilike '%STABILIMENTO - DATI DUPLICATI%';	--Se ne perde uno solo id=79515



--Modificata il 02-10-2023
create table conf_ext.tmp_gisa_imprese_fvg_b_mod as
select distinct on (id) i.*, p.pr_id, p.gi_sd_id, p.pr_data_inizio, p.pr_data_fine,
p.sn_codice, p.ss_codice, p.sa_codice, p.sp_codice, p.pr_cod_attivita, p.pr_principale
from conf_ext.tmp_gisa_imprese_fvg_b i
--conf_ext.gisa_imprese_fvg_scarto i
join (SELECT DISTINCT ON (pr_id) pr_id,
            gi_sd_id,
            pr_data_inizio,
            pr_data_fine,
            sn_codice,
            ss_codice,
            sa_codice,
            sp_codice,
            pr_cod_attivita,
            pr_principale
           FROM conf_ext.fvg_gisa_imprese_produzione
           where fvg_gisa_imprese_produzione.pr_id is not null
          --WHERE fvg_gisa_imprese_produzione.pr_principale = 1::numeric
          ORDER BY pr_id, pr_principale, gi_sd_id, pr_data_inizio DESC) p ON i.sd_id = p.gi_sd_id
  --WHERE p.pr_principale IS NOT NULL
          where p.pr_id is not null
  order by i.id desc;

--UPDATE 
 
update conf_ext.tmp_gisa_imprese_fvg_b_mod 
set sn_codice = null,
ss_codice = 'NON.MAPP.',
sp_codice = 'NON.MAPP.',
sa_codice = 'NON.MAPP.',
pr_cod_attivita = null,
pr_data_fine = null
where motivo ilike '%AZIENDA SENZA LINEE ATTIVITA%'
or motivo ilike '%LINEA ATTIVITA - CODICE ATECO NON PRESENTE%'
or motivo ilike '%LINEA ATTIVITA - CODICE ATECO NULL%'
or motivo ilike '%STABILIMENTO - LINEA ATTIVITA PRINCIPALE DUPLICATA%'
or motivo ilike '%STABILIMENTO - LINEA ATTIVITA PRINCIPALE MANCANTE%';


update conf_ext.tmp_gisa_imprese_fvg_b_mod 
set sn_codice = null,
ss_codice = 'NON.MAPP.',
sp_codice = 'NON.MAPP.',
sa_codice = 'NON.MAPP.',
pr_cod_attivita = null,
pr_data_fine = null
where pr_cod_attivita not in 
		--(select replace(replace(replace(regexp_match(descr, '([^]$]*)'::text)::character varying::text, '{'::text, ''::text), '}'::text, ''::text)::character varying::text, '['::text, ''::text)
		(select cod_mod from agenda.vw_ag_tree_nodes_up_tipo_linee);
	--(select replace(replace(replace(regexp_match(descrizione, '([^]$]*)'::text)::character varying::text, '{'::text, ''::text), '}'::text, ''::text)::character varying::text, '['::text, ''::text)
	--from public.ml8_linee_attivita_nuove_materializzata);


update conf_ext.tmp_gisa_imprese_fvg_b_mod 
set sd_an_res_istat = '111111'
where motivo ilike '%STABILIMENTO - COMUNE NON ATTIVO%';


update conf_ext.tmp_gisa_imprese_fvg_b_mod 
set sl_fg_an_res_istat = '111111'
where motivo ilike '%AZIENDA - COMUNE NON ATTIVO%';


update conf_ext.tmp_gisa_imprese_fvg_b_mod 
set sl_fg_an_res_istat = '000000'
where motivo ilike '%AZIENDA - STATO ESTERO%';



CREATE OR REPLACE VIEW conf_ext.vw_gisa_imprese_completa_b
AS SELECT distinct i.az_id AS impresa_id,
    i.sl_fg_an_nome AS impresa_ragione_sociale,
    COALESCE(i.sl_fg_an_iva, i.sd_an_iva) AS impresa_piva,
    COALESCE(i.sl_fg_an_cf, i.sd_an_cf) AS impresa_cf,
    --16-01-24 (invertito il coalesce dando precedenza alla sede legale)
    i.az_cod_aziendale as impresa_cod_aziendale,
    i.sl_fg_an_res_toponimo AS impresa_indirizzo_toponimo,
    i.sl_fg_an_res_indirizzo AS impresa_indirizzo,
    i.sl_fg_an_res_civico AS impresa_indirizzo_civico,
    i.sl_fg_an_res_istat AS impresa_indirizzo_istat_comune,
    i.sl_fg_an_res_provincia AS impresa_indirizzo_provincia,
    --COALESCE(i.sl_fg_an_pec, i.sl_fg_an_email) AS impresa_pec,
    i.sl_fg_an_pec as impresa_pec,
    i.sl_fg_an_email as impresa_email,
   
	i.sl_fg_an_split_payment as impresa_split_payment,
	i.sl_fg_an_sdi as impresa_sdi,
    	i.sl_fg_tipo_figura_descr as impresa_tipo_figura_descr,
    	
i.fg_an_tipo_persona as impresa_tipo_persona,
i.fg_an_tipo_pers_descr as impresa_tipo_pers_descr,
i.sd_cod_tipologia_struttura as stabilimento_cod_tipologia_struttura,
i.sd_tipologia_struttura as impresa_tipologia_struttura,
i.sl_az_cod_aziendale as impresa_codice_aziendale,

    i.sd_id AS stabilimento_id,
    i.sd_an_nome AS stabilimento_denominazione,
    i.sl_sd_cod_regionale as stabilimento_codice_regionale,
    i.sd_an_res_toponimo AS stabilimento_indirizzo_toponimo,
    i.sd_an_res_indirizzo AS stabilimento_indirizzo,
    i.sd_an_res_civico AS stabilimento_indirizzo_civico,
    i.sd_an_res_istat AS stabilimento_indirizzo_istat_comune,
    i.sd_an_res_provincia AS stabilimento_indirizzo_provincia,
    i.sd_an_res_cap as stabilimento_indirizzo_cap,
    i.az_latitudine AS stabilimento_latitudine,
    i.az_longitudine AS stabilimento_longitudine,
    s.id AS soggetto_id,
    s.nome AS soggetto_nome,
    s.cognome AS soggetto_cognome,
    s.sesso AS soggetto_sesso,
    s.codice_catastale_nascita AS soggetto_codice_catastale_comune_nascita,
    s.data_nascita AS soggetto_data_nascita,
    s.codice_fiscale AS soggetto_codice_fiscale,
    s.email AS soggetto_email,
    s.telefono AS soggetto_telefono,
    s.res_toponimo AS soggetto_indirizzo_toponimo,
    s.res_indirizzo AS soggetto_indirizzo,
    s.res_civico AS soggetto_indirizzo_civico,
    s.res_istat AS soggetto_indirizzo_istat_comune,
    s.res_provincia AS soggetto_indirizzo_provincia,
    
 	i.pr_id AS linea_id,
    i.pr_data_inizio AS linea_data_inizio,
    i.pr_data_fine AS linea_data_fine,
    i.sn_codice AS linea_norma_codice,
    i.ss_codice AS linea_macroarea_codice,
    i.sa_codice AS linea_aggregazione_codice,
    i.sp_codice AS linea_attivita_codice,
    i.pr_cod_attivita AS linea_ateco,
        CASE
            WHEN i.az_denominazione::text ~~* '%trasport%'::text OR i.sd_an_nome::text ~~* '%trasport%'::text THEN false
            ELSE true
        END AS attivita_fissa,
    i.pr_principale AS linea_principale
   FROM conf_ext.tmp_gisa_imprese_fvg_b_mod i
   LEFT JOIN conf_ext.vw_soggetti_fisici_fvg s ON i.fg_an_cf::text = s.codice_fiscale::text
/*    JOIN ( SELECT DISTINCT ON (fvg_gisa_imprese_produzione.pr_id) fvg_gisa_imprese_produzione.pr_id,
            fvg_gisa_imprese_produzione.gi_sd_id,
            fvg_gisa_imprese_produzione.pr_data_inizio,
            fvg_gisa_imprese_produzione.pr_data_fine,
            fvg_gisa_imprese_produzione.sn_codice,
            fvg_gisa_imprese_produzione.ss_codice,
            fvg_gisa_imprese_produzione.sa_codice,
            fvg_gisa_imprese_produzione.sp_codice,
            fvg_gisa_imprese_produzione.pr_cod_attivita,
            fvg_gisa_imprese_produzione.pr_principale
           FROM conf_ext.fvg_gisa_imprese_produzione
          WHERE fvg_gisa_imprese_produzione.pr_principale = 1::numeric
          ORDER BY fvg_gisa_imprese_produzione.pr_id, fvg_gisa_imprese_produzione.gi_sd_id, fvg_gisa_imprese_produzione.pr_data_inizio DESC) p ON i.sd_id = p.gi_sd_id
  WHERE p.pr_principale IS NOT NULL		*/
  ORDER BY i.az_id, i.sd_id;


raise notice 'Creata vista vw_gisa_imprese_completa_b';


 --Aggiunto il 04-03-2024
 
 CREATE OR REPLACE VIEW conf_ext.vw_gisa_imprese_linee_secondarie_a
AS SELECT i.impresa_id,
    i.stabilimento_id,
    i.impresa_ragione_sociale,
    i.stabilimento_denominazione,
    p.pr_id AS linea_id,
    p.pr_data_inizio AS linea_data_inizio,
    p.pr_data_fine AS linea_data_fine,
    p.sn_codice AS linea_norma_codice,
    p.ss_codice AS linea_macroarea_codice,
    p.sa_codice AS linea_aggregazione_codice,
    p.sp_codice AS linea_attivita_codice,
    p.pr_cod_attivita AS linea_ateco,
    p.pr_principale AS linea_principale
   FROM conf_ext.vw_gisa_imprese_completa_a i
     JOIN ( SELECT DISTINCT ON (fvg_gisa_imprese_produzione.pr_id) fvg_gisa_imprese_produzione.pr_id,
            fvg_gisa_imprese_produzione.gi_sd_id,
            fvg_gisa_imprese_produzione.pr_data_inizio,
            fvg_gisa_imprese_produzione.pr_data_fine,
            fvg_gisa_imprese_produzione.sn_codice,
            fvg_gisa_imprese_produzione.ss_codice,
            fvg_gisa_imprese_produzione.sa_codice,
            fvg_gisa_imprese_produzione.sp_codice,
            fvg_gisa_imprese_produzione.pr_cod_attivita,
            fvg_gisa_imprese_produzione.pr_principale
           FROM conf_ext.fvg_gisa_imprese_produzione
          WHERE (fvg_gisa_imprese_produzione.pr_cod_attivita::text IN ( SELECT vw_ag_tree_nodes_up_tipo_linee.cod_mod
                   FROM agenda.vw_ag_tree_nodes_up_tipo_linee)) AND (fvg_gisa_imprese_produzione.pr_principale = 0::numeric OR fvg_gisa_imprese_produzione.pr_principale IS NULL) AND NOT (fvg_gisa_imprese_produzione.pr_id IN ( SELECT vw_gisa_imprese_completa_a.linea_id
                   FROM conf_ext.vw_gisa_imprese_completa_a))
          ORDER BY fvg_gisa_imprese_produzione.pr_id, fvg_gisa_imprese_produzione.gi_sd_id, fvg_gisa_imprese_produzione.pr_data_inizio DESC) p ON i.stabilimento_id = p.gi_sd_id
  WHERE p.pr_data_fine IS NULL;

 
raise notice 'Creata vista vw_gisa_imprese_linee_secondarie_a';

-- cu_anag.vw_gisa_imprese_completa_ab source

CREATE OR REPLACE VIEW cu_anag.vw_gisa_imprese_completa_ab
AS SELECT 'A'::text AS tipo_ab,
    vw_gisa_imprese_completa_a.impresa_id,
    vw_gisa_imprese_completa_a.impresa_ragione_sociale,
    vw_gisa_imprese_completa_a.impresa_piva,
    vw_gisa_imprese_completa_a.impresa_cf,
    vw_gisa_imprese_completa_a.impresa_cod_aziendale,
    vw_gisa_imprese_completa_a.impresa_indirizzo_toponimo,
    vw_gisa_imprese_completa_a.impresa_indirizzo,
    vw_gisa_imprese_completa_a.impresa_indirizzo_civico,
    vw_gisa_imprese_completa_a.impresa_indirizzo_istat_comune,
    vw_gisa_imprese_completa_a.impresa_indirizzo_provincia,
    vw_gisa_imprese_completa_a.impresa_pec,
    vw_gisa_imprese_completa_a.impresa_email,
    vw_gisa_imprese_completa_a.impresa_split_payment,
    vw_gisa_imprese_completa_a.impresa_sdi,
    vw_gisa_imprese_completa_a.impresa_tipo_figura_descr,
    vw_gisa_imprese_completa_a.impresa_tipo_persona,
    vw_gisa_imprese_completa_a.impresa_tipo_pers_descr,
    vw_gisa_imprese_completa_a.stabilimento_cod_tipologia_struttura,
    vw_gisa_imprese_completa_a.impresa_tipologia_struttura,
    vw_gisa_imprese_completa_a.impresa_codice_aziendale,
    vw_gisa_imprese_completa_a.stabilimento_id,
    vw_gisa_imprese_completa_a.stabilimento_denominazione,
    vw_gisa_imprese_completa_a.stabilimento_codice_regionale,
    vw_gisa_imprese_completa_a.stabilimento_indirizzo_toponimo,
    vw_gisa_imprese_completa_a.stabilimento_indirizzo,
    vw_gisa_imprese_completa_a.stabilimento_indirizzo_civico,
    vw_gisa_imprese_completa_a.stabilimento_indirizzo_istat_comune,
    vw_gisa_imprese_completa_a.stabilimento_indirizzo_provincia,
    vw_gisa_imprese_completa_a.stabilimento_indirizzo_cap,
    vw_gisa_imprese_completa_a.stabilimento_latitudine,
    vw_gisa_imprese_completa_a.stabilimento_longitudine,
    vw_gisa_imprese_completa_a.soggetto_id,
    vw_gisa_imprese_completa_a.soggetto_nome,
    vw_gisa_imprese_completa_a.soggetto_cognome,
    vw_gisa_imprese_completa_a.soggetto_sesso,
    vw_gisa_imprese_completa_a.soggetto_codice_catastale_comune_nascita,
    vw_gisa_imprese_completa_a.soggetto_data_nascita,
    vw_gisa_imprese_completa_a.soggetto_codice_fiscale,
    vw_gisa_imprese_completa_a.soggetto_email,
    vw_gisa_imprese_completa_a.soggetto_telefono,
    vw_gisa_imprese_completa_a.soggetto_indirizzo_toponimo,
    vw_gisa_imprese_completa_a.soggetto_indirizzo,
    vw_gisa_imprese_completa_a.soggetto_indirizzo_civico,
    vw_gisa_imprese_completa_a.soggetto_indirizzo_istat_comune,
    vw_gisa_imprese_completa_a.soggetto_indirizzo_provincia,
    vw_gisa_imprese_completa_a.linea_id,
    vw_gisa_imprese_completa_a.linea_data_inizio,
    vw_gisa_imprese_completa_a.linea_data_fine,
    vw_gisa_imprese_completa_a.linea_norma_codice,
    vw_gisa_imprese_completa_a.linea_macroarea_codice,
    vw_gisa_imprese_completa_a.linea_aggregazione_codice,
    vw_gisa_imprese_completa_a.linea_attivita_codice,
    vw_gisa_imprese_completa_a.linea_ateco,
    vw_gisa_imprese_completa_a.attivita_fissa,
    vw_gisa_imprese_completa_a.linea_principale
   FROM conf_ext.vw_gisa_imprese_completa_a
UNION
 SELECT 'B'::text AS tipo_ab,
    vw_gisa_imprese_completa_b.impresa_id,
    vw_gisa_imprese_completa_b.impresa_ragione_sociale,
    vw_gisa_imprese_completa_b.impresa_piva,
    vw_gisa_imprese_completa_b.impresa_cf,
    vw_gisa_imprese_completa_b.impresa_cod_aziendale,
    vw_gisa_imprese_completa_b.impresa_indirizzo_toponimo,
    vw_gisa_imprese_completa_b.impresa_indirizzo,
    vw_gisa_imprese_completa_b.impresa_indirizzo_civico,
    vw_gisa_imprese_completa_b.impresa_indirizzo_istat_comune,
    vw_gisa_imprese_completa_b.impresa_indirizzo_provincia,
    vw_gisa_imprese_completa_b.impresa_pec,
    vw_gisa_imprese_completa_b.impresa_email,
    vw_gisa_imprese_completa_b.impresa_split_payment,
    vw_gisa_imprese_completa_b.impresa_sdi,
    vw_gisa_imprese_completa_b.impresa_tipo_figura_descr,
    vw_gisa_imprese_completa_b.impresa_tipo_persona,
    vw_gisa_imprese_completa_b.impresa_tipo_pers_descr,
    vw_gisa_imprese_completa_b.stabilimento_cod_tipologia_struttura,
    vw_gisa_imprese_completa_b.impresa_tipologia_struttura,
    vw_gisa_imprese_completa_b.impresa_codice_aziendale,
    vw_gisa_imprese_completa_b.stabilimento_id,
    vw_gisa_imprese_completa_b.stabilimento_denominazione,
    vw_gisa_imprese_completa_b.stabilimento_codice_regionale,
    vw_gisa_imprese_completa_b.stabilimento_indirizzo_toponimo,
    vw_gisa_imprese_completa_b.stabilimento_indirizzo,
    vw_gisa_imprese_completa_b.stabilimento_indirizzo_civico,
    vw_gisa_imprese_completa_b.stabilimento_indirizzo_istat_comune,
    vw_gisa_imprese_completa_b.stabilimento_indirizzo_provincia,
    vw_gisa_imprese_completa_b.stabilimento_indirizzo_cap,
    vw_gisa_imprese_completa_b.stabilimento_latitudine,
    vw_gisa_imprese_completa_b.stabilimento_longitudine,
    vw_gisa_imprese_completa_b.soggetto_id,
    vw_gisa_imprese_completa_b.soggetto_nome,
    vw_gisa_imprese_completa_b.soggetto_cognome,
    vw_gisa_imprese_completa_b.soggetto_sesso,
    vw_gisa_imprese_completa_b.soggetto_codice_catastale_comune_nascita,
    vw_gisa_imprese_completa_b.soggetto_data_nascita,
    vw_gisa_imprese_completa_b.soggetto_codice_fiscale,
    vw_gisa_imprese_completa_b.soggetto_email,
    vw_gisa_imprese_completa_b.soggetto_telefono,
    vw_gisa_imprese_completa_b.soggetto_indirizzo_toponimo,
    vw_gisa_imprese_completa_b.soggetto_indirizzo,
    vw_gisa_imprese_completa_b.soggetto_indirizzo_civico,
    vw_gisa_imprese_completa_b.soggetto_indirizzo_istat_comune,
    vw_gisa_imprese_completa_b.soggetto_indirizzo_provincia,
    vw_gisa_imprese_completa_b.linea_id,
    vw_gisa_imprese_completa_b.linea_data_inizio,
    vw_gisa_imprese_completa_b.linea_data_fine,
    vw_gisa_imprese_completa_b.linea_norma_codice,
    vw_gisa_imprese_completa_b.linea_macroarea_codice,
    vw_gisa_imprese_completa_b.linea_aggregazione_codice,
    vw_gisa_imprese_completa_b.linea_attivita_codice,
    vw_gisa_imprese_completa_b.linea_ateco,
    vw_gisa_imprese_completa_b.attivita_fissa,
    vw_gisa_imprese_completa_b.linea_principale
   FROM conf_ext.vw_gisa_imprese_completa_b;


raise notice 'Creata vista vw_gisa_imprese_completa_ab'; 
  
return 'CHECK_A_B';
		
	END;
$_$;


ALTER FUNCTION conf_ext.check_gisa_imprese_a_b() OWNER TO postgres;

--
-- Name: check_gisa_imprese_info(character varying); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.check_gisa_imprese_info(msg character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$

DECLARE
	n integer;
	n_g INTEGER;
	n_b INTEGER;

BEGIN
	get diagnostics n = row_count;
	raise notice 'RIGHE INSERITE SCARTO MATCH %',n;
	delete from conf_ext.gisa_imprese_fvg f where f.id in (select a.id from conf_ext.gisa_imprese_fvg_scarto a);
    get diagnostics n = row_count; 		raise notice '% %' ,msg,n  ;	
	select count(*) into n_G from conf_ext.gisa_imprese_fvg;
	select count(*) into n_B from conf_ext.gisa_imprese_fvg_scarto;
	raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;
return '';
	END;
$$;


ALTER FUNCTION conf_ext.check_gisa_imprese_info(msg character varying) OWNER TO postgres;

--
-- Name: check_gisa_imprese_info_c(character varying); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.check_gisa_imprese_info_c(msg character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$

DECLARE
	n integer;
	n_g INTEGER;
	n_b INTEGER;

BEGIN
	get diagnostics n = row_count;
	raise notice 'RIGHE INSERITE SCARTO MATCH %',n;
	delete from conf_ext.new_gisa_imprese_fvg f where f.id in (select a.id from conf_ext.new_gisa_imprese_fvg_scarto a);
    get diagnostics n = row_count; 		raise notice '% %' ,msg,n  ;	
	select count(*) into n_G from conf_ext.new_gisa_imprese_fvg;
	select count(*) into n_B from conf_ext.new_gisa_imprese_fvg_scarto;
	raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;
return '';
	END;
$$;


ALTER FUNCTION conf_ext.check_gisa_imprese_info_c(msg character varying) OWNER TO postgres;

--
-- Name: check_gisa_imprese_sicer_c_2024(); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.check_gisa_imprese_sicer_c_2024() RETURNS text
    LANGUAGE plpgsql
    AS $_$

DECLARE
	
	stmt varchar;
	fstmt varchar;
	n integer;
	n_g INTEGER;
	n_b INTEGER;
	m varchar;

BEGIN


--DROP TABLE 
	
stmt := 'drop table if exists ' || 'bck.new_gisa_imprese_fvg_' || replace(current_date::text,'-','') || ';';
raise notice 'STMT= %',stmt;

fstmt := format(stmt);
execute fstmt;

stmt := 'drop table if exists ' || 'bck.new_gisa_imprese_fvg_scarto_' || replace(current_date::text,'-','') || ';';
raise notice 'STMT= %',stmt;

fstmt := format(stmt);
execute fstmt;
	

--CREAZIONE TABELLE DI BACKUP	
	
stmt := 'create table ' || 'bck.new_gisa_imprese_fvg_' || replace(current_date::text,'-','') || 
' as select * from conf_ext.new_gisa_imprese_fvg';
raise notice 'STMT= %',stmt;

fstmt := format(stmt);
execute fstmt;

stmt := 'create table ' || 'bck.new_gisa_imprese_fvg_scarto_' || replace(current_date::text,'-','') || 
' as select * from conf_ext.new_gisa_imprese_fvg_scarto';
raise notice 'STMT= %',stmt;

fstmt := format(stmt);
execute fstmt;
	

--SVUOTAMENTO E CREAZIONE TABELLE
/*
drop table if exists conf_ext.new_gisa_imprese_fvg;
drop table if exists conf_ext.new_gisa_imprese_fvg_scarto;
create table conf_ext.new_gisa_imprese_fvg_scarto as select *,'' motivo from conf_ext.fvg_gisa_imprese where 0=1;
create table conf_ext.new_gisa_imprese_fvg as select * from conf_ext.fvg_gisa_imprese;
*/
--truncate table conf_ext.new_gisa_imprese_fvg;
--truncate table conf_ext.new_gisa_imprese_fvg_scarto;

drop table if exists conf_ext.new_gisa_imprese_fvg cascade;

raise notice 'drop table conf_ext.new_gisa_imprese_fvg cascade;';

drop table if exists conf_ext.new_gisa_imprese_fvg_scarto cascade;

raise notice 'drop table conf_ext.new_gisa_imprese_fvg_scarto cascade;';

--MODIFICATA IL 02-08-2023

-- I dati dell'AZIENDA (IMPRESA) devono essere presi dai campi fg quando fg_figura_tipo_descr è SEDE LEGALE

create table conf_ext.new_gisa_imprese_fvg_scarto as select i.*,

sl.fg_tipo_figura_descr as sl_fg_tipo_figura_descr,
sl.fg_an_nome as sl_fg_an_nome,
sl.fg_an_cf as sl_fg_an_cf,
sl.fg_an_iva as sl_fg_an_iva,
sl.fg_an_pec as sl_fg_an_pec,
sl.fg_an_email as sl_fg_an_email,
sl.fg_data_fine as sl_fg_an_data_fine,

sl.fg_an_res_provincia as sl_fg_an_res_provincia,
sl.fg_an_res_istat as sl_fg_an_res_istat,
sl.fg_an_res_comune as sl_fg_an_res_comune,
sl.fg_an_res_toponimo as sl_fg_an_res_toponimo,
sl.fg_an_res_indirizzo as sl_fg_an_res_indirizzo,
sl.fg_an_res_civico as sl_fg_an_res_civico, 
sl.fg_an_tipo_persona as sl_fg_an_tipo_persona,
sl.fg_an_tipo_pers_descr as sl_fg_an_tipo_pers_descr,
sl.sd_cod_tipologia_struttura as sl_sd_cod_tipologia_struttura,
sl.sd_tipologia_struttura as sl_sd_tipologia_struttura,
sl.az_cod_aziendale as sl_az_cod_aziendale,
sl.sd_cod_regionale as sl_sd_cod_regionale,

sl.fg_an_split_payment as sl_fg_an_split_payment,
sl.fg_an_sdi as sl_fg_an_sdi,

'' motivo
from conf_ext.fvg_gisa_imprese i
join conf_ext.fvg_gisa_imprese sl on i.sd_id = sl.sd_id and sl.fg_tipo_figura_descr::text ilike '%Sede%Legale%'::text
where 0=1;

raise notice 'create table conf_ext.new_gisa_imprese_fvg_scarto';

--Aggiunta distinct il 02-10-2023
create table conf_ext.new_gisa_imprese_fvg as select distinct i.*, 

sl.fg_tipo_figura_descr as sl_fg_tipo_figura_descr,
sl.fg_an_nome as sl_fg_an_nome,
sl.fg_an_cf as sl_fg_an_cf,
sl.fg_an_iva as sl_fg_an_iva,
sl.fg_an_pec as sl_fg_an_pec,
sl.fg_an_email as sl_fg_an_email,
sl.fg_data_fine as sl_fg_data_fine,

sl.fg_an_res_provincia as sl_fg_an_res_provincia,
sl.fg_an_res_istat as sl_fg_an_res_istat,
sl.fg_an_res_comune as sl_fg_an_res_comune,
sl.fg_an_res_toponimo as sl_fg_an_res_toponimo,
sl.fg_an_res_indirizzo as sl_fg_an_res_indirizzo,
sl.fg_an_res_civico as sl_fg_an_res_civico,

sl.fg_an_tipo_persona as sl_fg_an_tipo_persona,
sl.fg_an_tipo_pers_descr as sl_fg_an_tipo_pers_descr,
sl.sd_cod_tipologia_struttura as sl_sd_cod_tipologia_struttura,
sl.sd_tipologia_struttura as sl_sd_tipologia_struttura,
sl.az_cod_aziendale as sl_az_cod_aziendale,
sl.sd_cod_regionale as sl_sd_cod_regionale,

sl.fg_an_split_payment as sl_fg_an_split_payment,
sl.fg_an_sdi as sl_fg_an_sdi

from conf_ext.fvg_gisa_imprese i
join conf_ext.fvg_gisa_imprese sl on i.sd_id = sl.sd_id and sl.fg_tipo_figura_descr::text ilike '%Sede%Legale%'::text

where 
i.sd_cod_regionale not in (select cod_regionale from cu_anag.stabilimenti where cod_regionale is not null)
and i.sd_id not in (select sd_id from cu_anag.stabilimenti where sd_id is not null)

and i.az_cod_aziendale::text !~ '^[0-9]{3}[A-Z]{2}[0-9]{3}'::text
and i.fg_tipo_figura_descr::text ilike '%Legale%Rappresentante%'::text

and (i.fg_data_fine is null or i.fg_data_fine > '2022-01-01')
and (i.az_data_fine is null or i.az_data_fine > '2022-01-01')
and (i.sd_data_fine is null or i.sd_data_fine > '2022-01-01')
and (sl.fg_data_fine is null or sl.fg_data_fine > '2022-01-01')
and i.sd_cod_tipologia_struttura in ('852', '99907', 'CG', 'FI', 'FIE', 'MOCA', 'PS', 'RSP', 'ST', 'STA', 'T11', 'Z01');


create or replace view conf_ext.vw_gisa_imprese_partenza_c
as select distinct i.*, 


sl.fg_tipo_figura_descr as sl_fg_tipo_figura_descr,
sl.fg_an_nome as sl_fg_an_nome,
sl.fg_an_cf as sl_fg_an_cf,
sl.fg_an_iva as sl_fg_an_iva,
sl.fg_an_pec as sl_fg_an_pec,
sl.fg_an_email as sl_fg_an_email,
sl.fg_data_fine as sl_fg_data_fine,

sl.fg_an_res_provincia as sl_fg_an_res_provincia,
sl.fg_an_res_istat as sl_fg_an_res_istat,
sl.fg_an_res_comune as sl_fg_an_res_comune,
sl.fg_an_res_toponimo as sl_fg_an_res_toponimo,
sl.fg_an_res_indirizzo as sl_fg_an_res_indirizzo,
sl.fg_an_res_civico as sl_fg_an_res_civico,

sl.fg_an_tipo_persona as sl_fg_an_tipo_persona,
sl.fg_an_tipo_pers_descr as sl_fg_an_tipo_pers_descr,
sl.sd_cod_tipologia_struttura as sl_sd_cod_tipologia_struttura,
sl.sd_tipologia_struttura as sl_sd_tipologia_struttura,
sl.az_cod_aziendale as sl_az_cod_aziendale,
sl.sd_cod_regionale as sl_sd_cod_regionale,

sl.fg_an_split_payment as sl_fg_an_split_payment,
sl.fg_an_sdi as sl_fg_an_sdi

from conf_ext.fvg_gisa_imprese i
join conf_ext.fvg_gisa_imprese sl on i.sd_id = sl.sd_id and sl.fg_tipo_figura_descr::text ilike '%Sede%Legale%'::text

where 
i.sd_cod_regionale not in (select cod_regionale from cu_anag.stabilimenti where cod_regionale is not null)
and i.sd_id not in (select sd_id from cu_anag.stabilimenti where sd_id is not null)

and i.az_cod_aziendale::text !~ '^[0-9]{3}[A-Z]{2}[0-9]{3}'::text
and i.fg_tipo_figura_descr::text ilike '%Legale%Rappresentante%'::text

and (i.fg_data_fine is null or i.fg_data_fine > '2022-01-01')
and (i.az_data_fine is null or i.az_data_fine > '2022-01-01')
and (i.sd_data_fine is null or i.sd_data_fine > '2022-01-01')
and (sl.fg_data_fine is null or sl.fg_data_fine > '2022-01-01')
and i.sd_cod_tipologia_struttura in ('852', '99907', 'CG', 'FI', 'FIE', 'MOCA', 'PS', 'RSP', 'ST', 'STA', 'T11', 'Z01');



--MODIFICATA IL 24-08-2023 - Controllati solo alcuni stabilimenti (Dopo indicazioni di Giovanatto)

raise notice 'create table conf_ext.new_gisa_imprese_fvg';

get diagnostics n = row_count; 		raise notice 'RIGHE INSERITE INIZIALI %',n;


--DATI MANCANTI SULL'AZIENDA (az_id) --2024

insert into conf_ext.new_gisa_imprese_fvg_scarto
select i.*,'DATI MANCANTI SULLA AZIENDA' motivo
from conf_ext.new_gisa_imprese_fvg i
where i.az_id is null 
and ((i.sd_cod_tipologia_struttura = '852' and i.sd_cod_regionale is null)
or i.sd_cod_tipologia_struttura != '852');

 m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED AZIENDA MANCANTE');

--DATI MANCANTI SULLO STABILIMENTO (sd_id)

insert into conf_ext.new_gisa_imprese_fvg_scarto
select i.*,'DATI MANCANTI SULLO STABILIMENTO' motivo
from conf_ext.new_gisa_imprese_fvg i
where i.sd_id is NULL;
 m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED STABILIMENTO MANCANTE');

--DATI MANCANTI SULLA FIGURA AZIENDALE (fg_id)

insert into conf_ext.new_gisa_imprese_fvg_scarto
select i.*,'DATI MANCANTI SULLA FIGURA AZIENDALE' motivo
from conf_ext.new_gisa_imprese_fvg i
where i.fg_id is NULL;
 m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED FIGURA AZIENDALE MANCANTE');


--CONTROLLO STABILIMENTO (sd_id)

insert into conf_ext.new_gisa_imprese_fvg_scarto
select i.*,'SD_ID RIPETUTO: '||sd_id motivo
from conf_ext.new_gisa_imprese_fvg i
where i.sd_id in (select a.sd_id from (select distinct 
		sd_id, az_id, sd_bdn_id, sd_bdn_specie, sd_specie_descr, 
		sd_cod_tipologia_struttura, sd_tipologia_struttura, 
		sd_data_inizio, sd_data_fine, sd_vet_id, sd_vet_cf, 
		sd_vet_cognome, sd_vet_nome, sd_an_id, sd_an_nome, 
		sd_an_dato_fiscale, sd_an_cf, sd_an_iva, sd_an_data_nascita, 
		sd_an_tipo, sd_an_tipo_descr, sd_an_tipo_persona, 
		sd_an_tipo_pers_descr, sd_an_data_fine, sd_an_data_decesso, 
		sd_an_res_provincia, sd_an_res_istat, sd_an_res_comune, sd_an_res_toponimo, 
		sd_an_res_indirizzo, sd_an_res_civico, sd_an_dom_provincia, sd_an_dom_istat,
		sd_an_dom_comune, sd_an_dom_toponimo, sd_an_dom_indirizzo, sd_an_dom_civico
		from conf_ext.new_gisa_imprese_fvg) a
		group by 1
		having count (*) > 1)
		order by i.az_id asc, i.sd_id asc;

m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED STABILIMENTO RIPETUTO');	

--CONTROLLO FIGURA AZIENDALE (fg_id)

insert into conf_ext.new_gisa_imprese_fvg_scarto
select i.*,'FG_ID RIPETUTO: '||fg_id motivo
from conf_ext.new_gisa_imprese_fvg i
where i.fg_id in (select a.fg_id from (select distinct 	
		fg_id, az_id, fg_data_inizio, fg_data_fine, fg_cod_tipo_figura, fg_tipo_figura_descr, 
		fg_id_anagrafica, fg_an_nome, fg_an_dato_fiscale, fg_an_cf, fg_an_iva, 
		fg_an_data_nascita, fg_an_tipo, fg_an_tipo_descr, fg_an_tipo_persona, 
		fg_an_tipo_pers_descr, fg_an_data_fine, fg_an_res_provincia, fg_an_res_istat, 
		fg_an_res_comune, fg_an_res_toponimo, fg_an_res_indirizzo, fg_an_res_civico, 
		fg_an_dom_provincia, fg_an_dom_istat, fg_an_dom_comune, fg_an_dom_toponimo, 
		fg_an_dom_indirizzo, fg_an_dom_civico		
		from conf_ext.new_gisa_imprese_fvg) a
		group by 1
		having count (*) > 1)
		order by i.az_id asc, i.sd_id asc;

	m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED FIGURA AZIENDALE RIPETUTA');	

---------------------------------------------------------------------------------------------------------------------

--CONTROLLO DATI AZIENDA



--CONTROLLO COMUNE/STATO ESTERO PER AZIENDA (az_an)

insert into conf_ext.new_gisa_imprese_fvg_scarto	
select s.*,'AZIENDA - STATO ESTERO: '||coalesce(s.sl_fg_an_res_istat,'')||' '|| coalesce(s.sl_fg_an_res_comune,'') motivo			 
from conf_ext.new_gisa_imprese_fvg s
where s.sl_fg_an_res_comune = 'STATO ESTERO';	

m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO STATO ESTERO');	


insert into conf_ext.new_gisa_imprese_fvg_scarto	
select s.*,'AZIENDA - CODICE COMUNE NON PRESENTE: '||coalesce(s.sl_fg_an_res_istat,'')||' '|| coalesce(s.sl_fg_an_res_comune,'') motivo			 
from conf_ext.new_gisa_imprese_fvg s
--left join public.comuni1 c on c.istat::integer = s.sl_fg_an_res_istat::integer
left join conf_ext.vw_comuni_vigenti c on c.istat = s.sl_fg_an_res_istat
where c.denominazione_it is null;
--where c.nome is null; 

m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO COMUNE');	

/*--2024
insert into conf_ext.new_gisa_imprese_fvg_scarto
select s.*,'AZIENDA - TOPONIMO DUG NON PREVISTO: '||coalesce(s.sl_fg_an_res_toponimo,'') cf
from conf_ext.new_gisa_imprese_fvg s
where trim(s.sl_fg_an_res_toponimo) not in (select sigla from conf_ext.toponimi 
union select descrizione from conf_ext.toponimi) and trim(s.sl_fg_an_res_toponimo) not in ('RIVE','STRADE');

m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO TOPONIMO DUG NON PREVISTO');	
*/

---------------------------------------------------------------------------------------------------------------------

--CONTROLLO DATI STABILIMENTO


--CONTROLLO COMUNE/STATO ESTERO PER STABILIMENTO (sd_an)

insert into conf_ext.new_gisa_imprese_fvg_scarto	
select s.*,'STABILIMENTO - STATO ESTERO: '||coalesce(s.sd_an_res_istat,'')||' '|| coalesce(s.sd_an_res_comune,'') motivo			 
from conf_ext.new_gisa_imprese_fvg s
where s.sd_an_res_comune = 'STATO ESTERO';		

m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO STATO ESTERO');
	
insert into conf_ext.new_gisa_imprese_fvg_scarto	
select s.*,'STABILIMENTO - CODICE COMUNE NON PRESENTE: '||coalesce(s.sd_an_res_istat,'')||' '|| coalesce(s.sd_an_res_comune,'') motivo			 
from conf_ext.new_gisa_imprese_fvg s
--left join public.comuni1 c on c.istat::integer = s.sd_an_res_istat::integer where c.nome is null;	
left join conf_ext.vw_comuni_vigenti c on c.istat = s.sd_an_res_istat 
where c.denominazione_it is null;
m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO CODICE COMUNE NON PRESENTE');
	
/*
insert into conf_ext.new_gisa_imprese_fvg_scarto
select s.*,'STABILIMENTO - TOPONIMO DUG NON PREVISTO: '||coalesce(s.sd_an_res_toponimo,'') motivo
from conf_ext.new_gisa_imprese_fvg s
where trim(s.sd_an_res_toponimo) not in (select sigla from conf_ext.toponimi 
union select descrizione from conf_ext.toponimi) and trim(s.sd_an_res_toponimo) not in ('RIVE','STRADE');

m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO TOPONIMO DUG NON PREVISTO');

--2024*/



insert into conf_ext.new_gisa_imprese_fvg_scarto
select *,'STABILIMENTO - DATI DUPLICATI: ' || sd_cod_regionale
|| sd_an_nome||sd_an_res_istat||sd_an_res_comune||sd_an_res_toponimo||sd_an_res_indirizzo||sd_an_res_civico
from conf_ext.new_gisa_imprese_fvg where 
(sd_cod_regionale,sd_an_nome,sd_an_res_istat,sd_an_res_comune,sd_an_res_toponimo,sd_an_res_indirizzo,sd_an_res_civico)
in (select sd_cod_regionale, sd_an_nome,sd_an_res_istat,sd_an_res_comune,sd_an_res_toponimo,sd_an_res_indirizzo,sd_an_res_civico
from conf_ext.new_gisa_imprese_fvg gif 
group by 1,2,3,4,5,6,7
having count(*) > 1) ;

 m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO DATI DUPLCATI');
---------------------------------------------------------------------------------------------------------------------

--CONTROLLO DATI LEGALE RAPPRESENTANTE

--CONTROLLO CODICE FISCALE LEGALE RAPPRESENTANTE

/*
insert into conf_ext.new_gisa_imprese_fvg_scarto
select *,'LEGALE RAPPRESENTANTE - DATA FINE NON ACCETTATA' from conf_ext.new_gisa_imprese_fvg
where fg_tipo_figura_descr::text ilike '%Legale%Rappresentante%'::text 
and fg_data_fine is not null and fg_data_fine < '2023-01-01';

 m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO LEGALE DATA FINE');
 
 --2024 */



insert into conf_ext.new_gisa_imprese_fvg_scarto
select s.*,'LEGALE RAPPRESENTANTE - NON TROVATO IN SOGGETTI FISICI: '|| coalesce(s.fg_an_cf, '') motivo	
--coalesce(s1.nome_completo ,'') motivo		--Modificato il 09-10-2023
from conf_ext.new_gisa_imprese_fvg s
left join conf_ext.vw_soggetti_fisici_fvg s1 ON s.fg_an_cf::text = s1.codice_fiscale::text
--left join conf_ext.soggetti_fisici_fvg s1 ON s.fg_an_cf::text = s1.codice_fiscale::text
where s1.codice_fiscale is null;
 
 m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO SOGGETTI FISICI');
--DA TABELLA A VISTA --06-09-2023

--CONTROLLO LINEE DI ATTIVITA

/*
insert into conf_ext.new_gisa_imprese_fvg_scarto
select s.*,'AZIENDA SENZA LINEE ATTIVITA' motivo
from conf_ext.new_gisa_imprese_fvg s 
where sd_id not in (select gi_sd_id from conf_ext.fvg_gisa_imprese_produzione);
 
m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO AZIENDA SENZA LINEE');

--2024


--MODIFICATO IL 20-07-2023 (Rimosso il controllo su pr_inattivo dato che su sicer non lo valorizzano)
insert into conf_ext.new_gisa_imprese_fvg_scarto
select distinct s.*,'LINEA ATTIVITA - DATA FINE NOT NULL'  motivo
--select s.*,'LINEA ATTIVITA - INATTIVO O DATA FINE NOT NULL'  motivo
from conf_ext.new_gisa_imprese_fvg s 
left join (select distinct on (pr_id) gi_sd_id, pr_id, pr_data_inizio, pr_data_fine, 
			sn_codice, ss_codice, sa_codice, sp_codice, pr_cod_attivita, pr_inattivo
			from conf_ext.fvg_gisa_imprese_produzione
			where pr_principale = 1		--Aggiunto il 12-09-2023
			) p on p.gi_sd_id = s.sd_id 
where --p.pr_inattivo != 0 or 
p.pr_data_fine is not null;

 m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO LINEE');

insert into conf_ext.new_gisa_imprese_fvg_scarto
select s.*,'LINEA ATTIVITA - CODICE ATECO NULL'  motivo
from conf_ext.new_gisa_imprese_fvg s 
left join (select distinct on (pr_id) gi_sd_id, pr_id, pr_data_inizio, pr_data_fine, 
			sn_codice, ss_codice, sa_codice, sp_codice, pr_cod_attivita, pr_inattivo
			from conf_ext.fvg_gisa_imprese_produzione) p on p.gi_sd_id = s.sd_id
where p.pr_cod_attivita is null;

 m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO LINEE');

/*
insert into conf_ext.new_gisa_imprese_fvg_scarto
select s.*,'LINEA ATTIVITA - DATA INIZIO NULL' motivo 
from conf_ext.new_gisa_imprese_fvg s 
left join (select distinct on (pr_id) gi_sd_id, pr_id, pr_data_inizio, pr_data_fine, 
			sn_codice, ss_codice, sa_codice, sp_codice, pr_cod_attivita, pr_inattivo
			from conf_ext.fvg_gisa_imprese_produzione) p on p.gi_sd_id = s.sd_id
where p.pr_data_inizio is null;

 m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO LINEE');
--2024
*/
*
**/
------------------------

--03-05-2023 

--CONTROLLO LINEE DI ATTIVITA

/*
insert into conf_ext.new_gisa_imprese_fvg_scarto
select s.*,'STABILIMENTO - LINEA ATTIVITA PRINCIPALE DUPLICATA' motivo 
from conf_ext.new_gisa_imprese_fvg s
where s.sd_id in (select sd_id   
			from conf_ext.new_gisa_imprese_fvg s 
			left join (select distinct on (pr_id) gi_sd_id, pr_id, pr_data_inizio, pr_data_fine, 
						sn_codice, ss_codice, sa_codice, sp_codice, pr_cod_attivita, pr_inattivo, pr_principale
						from conf_ext.fvg_gisa_imprese_produzione) p on p.gi_sd_id = s.sd_id
			where p.pr_principale = 1
			group by s.sd_id 
			having count (*)>1);
		
 m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO LINEE');

--2024
*/



--06-07-2023
--02-08-2023 (Modificato il campo iva: da az_an_iva a sl_fg_an_iva)

insert into conf_ext.new_gisa_imprese_fvg_scarto
select distinct s.*, 'AZIENDA E STABILIMENTO - ERRATA PARTITA IVA: '||
coalesce(s.sl_fg_an_iva,'')||'; '||coalesce(s.sd_an_iva,'') motivo
from conf_ext.new_gisa_imprese_fvg s
where (cu_anag.check_piva(('IT'::text || s.sl_fg_an_iva::text)::character varying) is false 
AND
cu_anag.check_piva(('IT'::text || s.sd_an_iva::text)::character varying) is false);

m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO PIVA');


insert into conf_ext.new_gisa_imprese_fvg_scarto
select distinct s.*, 'AZIENDA E STABILIMENTO - PARTITA IVA NULL' motivo
--  '||coalesce(s.sl_fg_an_iva,'')||'; '||coalesce(s.sd_an_iva,'') motivo
from conf_ext.new_gisa_imprese_fvg s
where s.sl_fg_an_iva is null 	and 	s.sd_an_iva is null;

m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO PIVA NULL');



--18-07-2023

--Aggiunta controllo per scartare le aziende/stabilimenti aventi linee con ateco non presente nella ML

/*
insert into conf_ext.new_gisa_imprese_fvg_scarto
select s.*,'LINEA ATTIVITA - CODICE ATECO NON PRESENTE: ' || p.pr_cod_attivita  motivo
from conf_ext.new_gisa_imprese_fvg s
left join (select distinct on (pr_id) gi_sd_id, pr_id, pr_data_inizio, pr_data_fine, 
			sn_codice, ss_codice, sa_codice, sp_codice, pr_cod_attivita, pr_inattivo
			from conf_ext.fvg_gisa_imprese_produzione
			where pr_principale = 1) p on p.gi_sd_id = s.sd_id
where p.pr_cod_attivita not in 
--(select replace(replace(replace(regexp_match(descr, '([^]$]*)'::text)::character varying::text, '{'::text, ''::text), '}'::text, ''::text)::character varying::text, '['::text, ''::text)
	(select cod_mod	from agenda.vw_ag_tree_nodes_up_tipo_linee);
	--(select replace(replace(replace(regexp_match(descrizione, '([^]$]*)'::text)::character varying::text, '{'::text, ''::text), '}'::text, ''::text)::character varying::text, '['::text, ''::text)
	--from public.ml8_linee_attivita_nuove_materializzata);
	
m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO LINEE');

--2024
*/

--02-08-2023 (Modificato il campo iva: da az_an_iva a sl_fg_an_iva)

insert into conf_ext.new_gisa_imprese_fvg_scarto
select s.*,'AZIENDA - ERRATA PARTITA IVA: ' || s.sl_fg_an_iva  motivo
from conf_ext.new_gisa_imprese_fvg s
where s.sl_fg_an_iva ~ '[A-Z a-z-]{4}.*';
--per straniere

m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO PIVA');

--DIVISI IN 3 CONTROLLI DIVERSI --08-09-2023

/*
insert into conf_ext.new_gisa_imprese_fvg_scarto
select s.*,'AZIENDA - COMUNE NON ATTIVO: ' || s.sl_fg_an_res_istat  motivo
from conf_ext.new_gisa_imprese_fvg s
where s.sl_fg_an_res_istat not in (select istat from conf_ext.vw_comuni_vigenti);
--in (select istat::integer from public.comuni1 where notused is true and istat not in (select istat from public.comuni1 where notused is not true));

m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO ISTAT');

--2024
*/
insert into conf_ext.new_gisa_imprese_fvg_scarto
select s.*,'STABILIMENTO - COMUNE NON ATTIVO: ' || s.sd_an_res_istat  motivo
from conf_ext.new_gisa_imprese_fvg s
where s.sd_an_res_istat not in (select istat from conf_ext.vw_comuni_vigenti);
--in (select istat::integer from public.comuni1 where notused is true and istat not in (select istat from public.comuni1 where notused is not true));

m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO ISTAT');


--19-07-2023

insert into conf_ext.new_gisa_imprese_fvg_scarto	
select s.*,'STABILIMENTO - PROVINCIA FUORI REGIONE: '||coalesce(s.sd_an_res_provincia,'') motivo			 
from conf_ext.new_gisa_imprese_fvg s
where s.sd_an_res_provincia not in ('UD', 'PN', 'TS', 'GO');		

m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO PROVINCIA');
	

--01-08-2023


/*
insert into conf_ext.new_gisa_imprese_fvg_scarto
select s.*,'STABILIMENTO - LINEA ATTIVITA PRINCIPALE MANCANTE' motivo 
from conf_ext.new_gisa_imprese_fvg s 
where sd_id not in 
(select gi_sd_id from conf_ext.fvg_gisa_imprese_produzione where pr_principale =1);
--join fvg_gisa_imprese_produzione p on s.sd_id = p.gi_sd_id 
--and p.pr_principale !=1;
		
 m:=conf_ext.check_gisa_imprese_info_c('RIGHE DELETED SCARTO LINEE');

--2024
*/


--26-06-2023


CREATE OR REPLACE VIEW conf_ext.vw_new_imprese_fvg_scarto_motivi
AS SELECT regexp_match(gifs.motivo, '^[^:]*'::text) AS motivo,
		  count(*) AS count
FROM conf_ext.new_gisa_imprese_fvg_scarto gifs
GROUP BY (regexp_match(gifs.motivo, '^[^:]*'::text))
ORDER BY (count(*)) DESC;

-- 2024 perform conf_ext.create_view_imprese();

return 'OK';

	END;
$_$;


ALTER FUNCTION conf_ext.check_gisa_imprese_sicer_c_2024() OWNER TO postgres;

--
-- Name: check_gisa_imprese_sicer_c_fase_2(); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.check_gisa_imprese_sicer_c_fase_2() RETURNS text
    LANGUAGE plpgsql
    AS $_$
	BEGIN


drop table if exists conf_ext.tmp_new_gisa_imprese_fvg_c1 cascade;
drop table if exists conf_ext.tmp_new_gisa_imprese_fvg_c2 cascade;
drop table if exists conf_ext.tmp_new_gisa_imprese_fvg_c2_mod cascade;


create table conf_ext.tmp_new_gisa_imprese_fvg_c1 as
select * from conf_ext.new_gisa_imprese_fvg;

update conf_ext.tmp_new_gisa_imprese_fvg_c1 
set sd_an_cf = null,
sl_fg_an_cf = null
where sl_fg_an_iva ~ '^[0-9]' and (sl_fg_an_cf !~ '^[0-9]' 
and not cu_anag.check_cf(sl_fg_an_cf));

CREATE OR REPLACE VIEW conf_ext.vw_gisa_imprese_completa_c1
AS SELECT i.az_id AS impresa_id,
    i.sl_fg_an_nome AS impresa_ragione_sociale,
    COALESCE(i.sl_fg_an_iva, i.sd_an_iva) AS impresa_piva,
    COALESCE(i.sl_fg_an_cf, i.sd_an_cf) AS impresa_cf,
    --16-01-24 (invertito il coalesce dando precedenza alla sede legale)
    i.az_cod_aziendale as impresa_cod_aziendale,
    i.sl_fg_an_res_toponimo AS impresa_indirizzo_toponimo,
    i.sl_fg_an_res_indirizzo AS impresa_indirizzo,
    i.sl_fg_an_res_civico AS impresa_indirizzo_civico,
    i.sl_fg_an_res_istat AS impresa_indirizzo_istat_comune,
    i.sl_fg_an_res_provincia AS impresa_indirizzo_provincia,
    --COALESCE(i.sl_fg_an_pec, i.sl_fg_an_email) AS impresa_pec,
    i.sl_fg_an_pec as impresa_pec,
    i.sl_fg_an_email as impresa_email,
    
    i.sl_fg_an_split_payment as impresa_split_payment,
	i.sl_fg_an_sdi as impresa_sdi,
	i.sl_fg_tipo_figura_descr as impresa_tipo_figura_descr,
    
i.sl_fg_an_tipo_persona as impresa_cod_tipo_persona,
i.sl_fg_an_tipo_pers_descr as impresa_tipo_persona,

--i.sl_az_cod_aziendale as impresa_codice_aziendale,

    i.az_data_inizio AS impresa_data_inizio,
	i.az_data_fine as impresa_data_fine,
	
    i.sd_id AS stabilimento_id,
    i.sd_an_nome AS stabilimento_denominazione,
    i.sl_sd_cod_regionale as stabilimento_codice_regionale,
    i.sl_sd_cod_tipologia_struttura as stabilimento_cod_tipologia_struttura,
	i.sl_sd_tipologia_struttura as stabilimento_tipologia_struttura,
    i.sd_an_res_toponimo AS stabilimento_indirizzo_toponimo,
    i.sd_an_res_indirizzo AS stabilimento_indirizzo,
    i.sd_an_res_civico AS stabilimento_indirizzo_civico,
    i.sd_an_res_istat AS stabilimento_indirizzo_istat_comune,
    i.sd_an_res_provincia AS stabilimento_indirizzo_provincia,
    i.sd_an_res_cap as stabilimento_indirizzo_cap,
    i.az_latitudine AS stabilimento_latitudine,
    i.az_longitudine AS stabilimento_longitudine,
    i.sd_data_inizio AS stabilimento_data_inizio,
	i.sd_data_fine as stabilimento_data_fine,
    /*s.id AS soggetto_id,
    s.nome AS soggetto_nome,
    s.cognome AS soggetto_cognome,
    s.sesso AS soggetto_sesso,
    s.codice_catastale_nascita AS soggetto_codice_catastale_comune_nascita,
    s.data_nascita AS soggetto_data_nascita,*/
    s.codice_fiscale AS soggetto_codice_fiscale,
    i.fg_data_inizio as soggetto_data_inizio,
    i.fg_data_fine as soggetto_data_fine
    /*s.email AS soggetto_email,
    s.telefono AS soggetto_telefono,
    s.res_toponimo AS soggetto_indirizzo_toponimo,
    s.res_indirizzo AS soggetto_indirizzo,
    s.res_civico AS soggetto_indirizzo_civico,
    s.res_istat AS soggetto_indirizzo_istat_comune,
    s.res_provincia AS soggetto_indirizzo_provincia,
    p.pr_id AS linea_id,
    p.pr_data_inizio AS linea_data_inizio,
    p.pr_data_fine AS linea_data_fine,
    p.sn_codice AS linea_norma_codice,
    p.ss_codice AS linea_macroarea_codice,
    p.sa_codice AS linea_aggregazione_codice,
    p.sp_codice AS linea_attivita_codice,
    p.pr_cod_attivita AS linea_ateco,
        CASE
            WHEN i.az_denominazione::text ~~* '%trasport%'::text OR i.sd_an_nome::text ~~* '%trasport%'::text THEN false
            ELSE true
        END AS attivita_fissa,
    p.pr_principale AS linea_principale*/
   FROM conf_ext.tmp_new_gisa_imprese_fvg_c1 i
   LEFT JOIN conf_ext.vw_soggetti_fisici_fvg s ON i.fg_an_cf::text = s.codice_fiscale::text
   /*  JOIN ( SELECT DISTINCT ON (fvg_gisa_imprese_produzione.pr_id) fvg_gisa_imprese_produzione.pr_id,
            fvg_gisa_imprese_produzione.gi_sd_id,
            fvg_gisa_imprese_produzione.pr_data_inizio,
            fvg_gisa_imprese_produzione.pr_data_fine,
            fvg_gisa_imprese_produzione.sn_codice,
            fvg_gisa_imprese_produzione.ss_codice,
            fvg_gisa_imprese_produzione.sa_codice,
            fvg_gisa_imprese_produzione.sp_codice,
            fvg_gisa_imprese_produzione.pr_cod_attivita,
            fvg_gisa_imprese_produzione.pr_principale
           FROM conf_ext.fvg_gisa_imprese_produzione
          WHERE fvg_gisa_imprese_produzione.pr_principale = 1::numeric
          ORDER BY fvg_gisa_imprese_produzione.pr_id, fvg_gisa_imprese_produzione.gi_sd_id, fvg_gisa_imprese_produzione.pr_data_inizio DESC) p ON i.sd_id = p.gi_sd_id
  WHERE p.pr_principale IS NOT NULL*/
  ORDER BY i.az_id, i.sd_id;

raise notice 'Creata vista vw_gisa_imprese_completa_c1';

/*
create table conf_ext.tmp_new_gisa_imprese_fvg_c2 as
select * from conf_ext.new_gisa_imprese_fvg_scarto;
*/
 
create table conf_ext.tmp_new_gisa_imprese_fvg_c2 as
select * from conf_ext.new_gisa_imprese_fvg_scarto
where motivo NOT ilike '%STABILIMENTO - DATI DUPLICATI%';

insert into conf_ext.tmp_new_gisa_imprese_fvg_c2
select distinct * from conf_ext.new_gisa_imprese_fvg_scarto
where motivo ilike '%STABILIMENTO - DATI DUPLICATI%';	--Se ne perde uno solo id=79515




--Modificata il 02-10-2023
create table conf_ext.tmp_new_gisa_imprese_fvg_c2_mod as
select distinct on (id) i.*
/*, p.pr_id, p.gi_sd_id, p.pr_data_inizio, p.pr_data_fine,
p.sn_codice, p.ss_codice, p.sa_codice, p.sp_codice, p.pr_cod_attivita, p.pr_principale*/
from conf_ext.tmp_new_gisa_imprese_fvg_c2 i
/*join (SELECT DISTINCT ON (pr_id) pr_id,
            gi_sd_id,
            pr_data_inizio,
            pr_data_fine,
            sn_codice,
            ss_codice,
            sa_codice,
            sp_codice,
            pr_cod_attivita,
            pr_principale
           FROM conf_ext.fvg_gisa_imprese_produzione
           where fvg_gisa_imprese_produzione.pr_id is not null
          --WHERE fvg_gisa_imprese_produzione.pr_principale = 1::numeric
          ORDER BY pr_id, pr_principale, gi_sd_id, pr_data_inizio DESC) p ON i.sd_id = p.gi_sd_id
  --WHERE p.pr_principale IS NOT NULL
          where p.pr_id is not null*/
  order by i.id desc;

 
--UPDATE 

 /*
update conf_ext.tmp_new_gisa_imprese_fvg_c2_mod 
set sn_codice = null,
ss_codice = 'NON.MAPP.',
sp_codice = 'NON.MAPP.',
sa_codice = 'NON.MAPP.',
pr_cod_attivita = null,
pr_data_fine = null
where motivo ilike '%AZIENDA SENZA LINEE ATTIVITA%'
or motivo ilike '%LINEA ATTIVITA - CODICE ATECO NON PRESENTE%'
or motivo ilike '%LINEA ATTIVITA - CODICE ATECO NULL%'
or motivo ilike '%STABILIMENTO - LINEA ATTIVITA PRINCIPALE DUPLICATA%'
or motivo ilike '%STABILIMENTO - LINEA ATTIVITA PRINCIPALE MANCANTE%';


update conf_ext.tmp_new_gisa_imprese_fvg_c2_mod 
set sn_codice = null,
ss_codice = 'NON.MAPP.',
sp_codice = 'NON.MAPP.',
sa_codice = 'NON.MAPP.',
pr_cod_attivita = null,
pr_data_fine = null
where pr_cod_attivita not in 
		--(select replace(replace(replace(regexp_match(descr, '([^]$]*)'::text)::character varying::text, '{'::text, ''::text), '}'::text, ''::text)::character varying::text, '['::text, ''::text)
		(select cod_mod from agenda.vw_ag_tree_nodes_up_tipo_linee);
	--(select replace(replace(replace(regexp_match(descrizione, '([^]$]*)'::text)::character varying::text, '{'::text, ''::text), '}'::text, ''::text)::character varying::text, '['::text, ''::text)
	--from public.ml8_linee_attivita_nuove_materializzata);
*/

update conf_ext.tmp_new_gisa_imprese_fvg_c2_mod 
set sd_an_res_istat = null
where motivo ilike '%STABILIMENTO - COMUNE NON ATTIVO%';


update conf_ext.tmp_new_gisa_imprese_fvg_c2_mod 
set sl_fg_an_res_istat = null
where motivo ilike '%AZIENDA - COMUNE NON ATTIVO%';


update conf_ext.tmp_new_gisa_imprese_fvg_c2_mod 
set sl_fg_an_res_istat = null
where motivo ilike '%AZIENDA - STATO ESTERO%';

--12-07-2024

update conf_ext.tmp_new_gisa_imprese_fvg_c2_mod 
set sd_an_cf = null,
sl_fg_an_cf = null
where sl_fg_an_iva ~ '^[0-9]' and (sl_fg_an_cf !~ '^[0-9]' 
and not cu_anag.check_cf(sl_fg_an_cf));


CREATE OR REPLACE VIEW conf_ext.vw_gisa_imprese_completa_c2
AS SELECT distinct i.az_id AS impresa_id,
    i.sl_fg_an_nome AS impresa_ragione_sociale,
    COALESCE(i.sl_fg_an_iva, i.sd_an_iva) AS impresa_piva,
    COALESCE(i.sl_fg_an_cf, i.sd_an_cf) AS impresa_cf,
    --16-01-24 (invertito il coalesce dando precedenza alla sede legale)
    i.az_cod_aziendale as impresa_cod_aziendale,
    i.sl_fg_an_res_toponimo AS impresa_indirizzo_toponimo,
    i.sl_fg_an_res_indirizzo AS impresa_indirizzo,
    i.sl_fg_an_res_civico AS impresa_indirizzo_civico,
    i.sl_fg_an_res_istat AS impresa_indirizzo_istat_comune,
    i.sl_fg_an_res_provincia AS impresa_indirizzo_provincia,
    --COALESCE(i.sl_fg_an_pec, i.sl_fg_an_email) AS impresa_pec,
    i.sl_fg_an_pec as impresa_pec,
    i.sl_fg_an_email as impresa_email,
    
    i.sl_fg_an_split_payment as impresa_split_payment,
	i.sl_fg_an_sdi as impresa_sdi,
	i.sl_fg_tipo_figura_descr as impresa_tipo_figura_descr,
    
i.sl_fg_an_tipo_persona as impresa_cod_tipo_persona,
i.sl_fg_an_tipo_pers_descr as impresa_tipo_persona,
--i.sl_az_cod_aziendale as impresa_codice_aziendale,
i.az_data_inizio AS impresa_data_inizio,
	i.az_data_fine as impresa_data_fine,

    i.sd_id AS stabilimento_id,
    i.sd_an_nome AS stabilimento_denominazione,
    i.sl_sd_cod_regionale as stabilimento_codice_regionale,
    i.sl_sd_cod_tipologia_struttura as stabilimento_cod_tipologia_struttura,
	i.sl_sd_tipologia_struttura as stabilimento_tipologia_struttura,

    i.sd_an_res_toponimo AS stabilimento_indirizzo_toponimo,
    i.sd_an_res_indirizzo AS stabilimento_indirizzo,
    i.sd_an_res_civico AS stabilimento_indirizzo_civico,
    i.sd_an_res_istat AS stabilimento_indirizzo_istat_comune,
    i.sd_an_res_provincia AS stabilimento_indirizzo_provincia,
    i.sd_an_res_cap as stabilimento_indirizzo_cap,
    i.az_latitudine AS stabilimento_latitudine,
    i.az_longitudine AS stabilimento_longitudine,
    i.sd_data_inizio AS stabilimento_data_inizio,
	i.sd_data_fine as stabilimento_data_fine,
    /*s.id AS soggetto_id,
    s.nome AS soggetto_nome,
    s.cognome AS soggetto_cognome,
    s.sesso AS soggetto_sesso,
    s.codice_catastale_nascita AS soggetto_codice_catastale_comune_nascita,
    s.data_nascita AS soggetto_data_nascita,*/
    s.codice_fiscale AS soggetto_codice_fiscale,
    i.fg_data_inizio as soggetto_data_inizio,
    i.fg_data_fine as soggetto_data_fine
    /*s.email AS soggetto_email,
    s.telefono AS soggetto_telefono,
    s.res_toponimo AS soggetto_indirizzo_toponimo,
    s.res_indirizzo AS soggetto_indirizzo,
    s.res_civico AS soggetto_indirizzo_civico,
    s.res_istat AS soggetto_indirizzo_istat_comune,
    s.res_provincia AS soggetto_indirizzo_provincia,
    p.pr_id AS linea_id,
    p.pr_data_inizio AS linea_data_inizio,
    p.pr_data_fine AS linea_data_fine,
    p.sn_codice AS linea_norma_codice,
    p.ss_codice AS linea_macroarea_codice,
    p.sa_codice AS linea_aggregazione_codice,
    p.sp_codice AS linea_attivita_codice,
    p.pr_cod_attivita AS linea_ateco,
        CASE
            WHEN i.az_denominazione::text ~~* '%trasport%'::text OR i.sd_an_nome::text ~~* '%trasport%'::text THEN false
            ELSE true
        END AS attivita_fissa,
    p.pr_principale AS linea_principale*/
   FROM conf_ext.tmp_new_gisa_imprese_fvg_c2_mod i
   LEFT JOIN conf_ext.vw_soggetti_fisici_fvg s ON i.fg_an_cf::text = s.codice_fiscale::text
/*    JOIN ( SELECT DISTINCT ON (fvg_gisa_imprese_produzione.pr_id) fvg_gisa_imprese_produzione.pr_id,
            fvg_gisa_imprese_produzione.gi_sd_id,
            fvg_gisa_imprese_produzione.pr_data_inizio,
            fvg_gisa_imprese_produzione.pr_data_fine,
            fvg_gisa_imprese_produzione.sn_codice,
            fvg_gisa_imprese_produzione.ss_codice,
            fvg_gisa_imprese_produzione.sa_codice,
            fvg_gisa_imprese_produzione.sp_codice,
            fvg_gisa_imprese_produzione.pr_cod_attivita,
            fvg_gisa_imprese_produzione.pr_principale
           FROM conf_ext.fvg_gisa_imprese_produzione
          WHERE fvg_gisa_imprese_produzione.pr_principale = 1::numeric
          ORDER BY fvg_gisa_imprese_produzione.pr_id, fvg_gisa_imprese_produzione.gi_sd_id, fvg_gisa_imprese_produzione.pr_data_inizio DESC) p ON i.sd_id = p.gi_sd_id
  WHERE p.pr_principale IS NOT NULL		*/
  ORDER BY i.az_id, i.sd_id;


raise notice 'Creata vista vw_gisa_imprese_completa_c2';




CREATE OR REPLACE VIEW conf_ext.vw_gisa_imprese_completa_c
AS SELECT 'C_1'::text AS tipo_c,
    vw_gisa_imprese_completa_c1.*
   FROM conf_ext.vw_gisa_imprese_completa_c1
UNION
 SELECT 'C_2'::text AS tipo_c,
    vw_gisa_imprese_completa_c2.*
   FROM conf_ext.vw_gisa_imprese_completa_c2;


raise notice 'Creata vista vw_gisa_imprese_completa_c'; 

create or replace view conf_ext.vw_gisa_imprese_completa_c_new as
select distinct on (stabilimento_codice_regionale)stabilimento_codice_regionale as cod_reg, * 
from conf_ext.vw_gisa_imprese_completa_c 
order by stabilimento_codice_regionale, soggetto_codice_fiscale asc;

raise notice 'Creata vista vw_gisa_imprese_completa_c_new'; 

 -- Da togliere commento

 CREATE OR REPLACE VIEW conf_ext.vw_gisa_imprese_linee_c
AS SELECT i.impresa_id,
    i.stabilimento_id,
    i.impresa_ragione_sociale,
    i.stabilimento_denominazione,
    p.pr_id AS linea_id,
    p.pr_data_inizio AS linea_data_inizio,
    p.pr_data_fine AS linea_data_fine,
    p.sn_codice AS linea_norma_codice,
    p.ss_codice AS linea_macroarea_codice,
    p.sa_codice AS linea_aggregazione_codice,
    p.sp_codice AS linea_attivita_codice,
    p.pr_cod_attivita AS linea_ateco,
    p.pr_principale AS linea_principale
   FROM conf_ext.vw_gisa_imprese_completa_c_new i
     JOIN ( SELECT DISTINCT ON (fvg_gisa_imprese_produzione.pr_id) fvg_gisa_imprese_produzione.pr_id,
            fvg_gisa_imprese_produzione.gi_sd_id,
            fvg_gisa_imprese_produzione.pr_data_inizio,
            fvg_gisa_imprese_produzione.pr_data_fine,
            fvg_gisa_imprese_produzione.sn_codice,
            fvg_gisa_imprese_produzione.ss_codice,
            fvg_gisa_imprese_produzione.sa_codice,
            fvg_gisa_imprese_produzione.sp_codice,
            fvg_gisa_imprese_produzione.pr_cod_attivita,
            fvg_gisa_imprese_produzione.pr_principale
           FROM conf_ext.fvg_gisa_imprese_produzione
          WHERE (fvg_gisa_imprese_produzione.pr_cod_attivita::text IN ( SELECT vw_ag_tree_nodes_up_tipo_linee.cod_mod
                   FROM agenda.vw_ag_tree_nodes_up_tipo_linee)) 
          --AND (fvg_gisa_imprese_produzione.pr_principale = 0::numeric OR fvg_gisa_imprese_produzione.pr_principale IS NULL) AND NOT (fvg_gisa_imprese_produzione.pr_id IN ( SELECT vw_gisa_imprese_completa_a.linea_id
                  -- FROM conf_ext.vw_gisa_imprese_completa_a))
          ORDER BY fvg_gisa_imprese_produzione.pr_id, fvg_gisa_imprese_produzione.gi_sd_id, fvg_gisa_imprese_produzione.pr_data_inizio DESC) p ON i.stabilimento_id = p.gi_sd_id
  WHERE p.pr_data_fine IS NULL;

 
raise notice 'Creata vista vw_gisa_imprese_linee_c';

  
return 'CHECK_C_2';
		
	END;
$_$;


ALTER FUNCTION conf_ext.check_gisa_imprese_sicer_c_fase_2() OWNER TO postgres;

--
-- Name: check_soggetti_fisici(); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.check_soggetti_fisici() RETURNS text
    LANGUAGE plpgsql
    AS $_$

	DECLARE
	
	counter integer;
	n integer;
	n_g INTEGER;
	n_b INTEGER;
  	stmt varchar;
	fstmt varchar;
  
  
	BEGIN

		counter := 0;

alter table conf_ext.fvg_gisa_privati 
add column codice_catastale_nascita varchar;

alter table conf_ext.fvg_gisa_privati 
add column data_nascita_fiscale varchar;

raise notice 'AGGIUNTE LE COLONNE ALLA TABELLA FVG_GISA_PRIVATI';

update conf_ext.fvg_gisa_privati  t1
set codice_catastale_nascita = 
    (("substring"(t1.codice_fiscale::text, 12, 1) ||
        CASE "substring"(t1.codice_fiscale::text, 13, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            ELSE "substring"(t1.codice_fiscale::text, 13, 1)
        END) ||
        CASE "substring"(t1.codice_fiscale::text, 14, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            ELSE "substring"(t1.codice_fiscale::text, 14, 1)
        END) ||
        CASE "substring"(t1.codice_fiscale::text, 15, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            ELSE "substring"(t1.codice_fiscale::text, 15, 1)
        END;
     
        
             
-------------------------------------------------------------------------------------------------------------------------   
       
 
update conf_ext.fvg_gisa_privati  t1
set data_nascita_fiscale = 
       
    (((("left"(
    	to_char(t1.data_nascita::timestamp with time zone, 'YYYY'::text), 2) 
    	||
        CASE "substring"(t1.codice_fiscale::text, 7, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
           /* WHEN 'Q'::text THEN '0'::text
            WHEN 'R'::text THEN '1'::text
            WHEN 'S'::text THEN '2'::text
            WHEN 'T'::text THEN '3'::text*/
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
         
            ELSE "substring"(t1.codice_fiscale::text, 7, 1)
        END) ||
        CASE "substring"(t1.codice_fiscale::text, 8, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            ELSE "substring"(t1.codice_fiscale::text, 8, 1)
        END) || '-' ||
        CASE "substring"(t1.codice_fiscale::text, 9, 1)
            WHEN 'A'::text THEN '01'::text
            WHEN 'B'::text THEN '02'::text
            WHEN 'C'::text THEN '03'::text
            WHEN 'D'::text THEN '04'::text
            WHEN 'E'::text THEN '05'::text
            WHEN 'H'::text THEN '06'::text
            WHEN 'L'::text THEN '07'::text
            WHEN 'M'::text THEN '08'::text
            WHEN 'P'::text THEN '09'::text
            WHEN 'R'::text THEN '10'::text
            WHEN 'S'::text THEN '11'::text
            WHEN 'T'::text THEN '12'::text
            ELSE "substring"(t1.codice_fiscale::text, 9, 1)
        END) || '-' ||
        CASE "substring"(t1.codice_fiscale::text, 10, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            WHEN '4'::text THEN '0'::text
            WHEN '5'::text THEN '1'::text
            WHEN '6'::text THEN '2'::text
            WHEN '7'::text THEN '3'::text
            ELSE "substring"(t1.codice_fiscale::text, 10, 1)
        END) ||
        CASE "substring"(t1.codice_fiscale::text, 11, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            ELSE "substring"(t1.codice_fiscale::text, 11, 1)
        end;
       
update conf_ext.fvg_gisa_privati  t1
set data_nascita_fiscale = '19'||substring(data_nascita_fiscale,3)
where substring(data_nascita_fiscale,1,4)::integer > 2025;			--2024-03-04

raise notice 'AGGIUNTI I DATI ALLA TABELLA FVG_GISA_PRIVATI';
   	
--DROP TABLE 
	
stmt := 'drop table if exists ' || 'bck.soggetti_fisici_fvg_' || replace(current_date::text,'-','') || ';';
raise notice 'STMT= %',stmt;

fstmt := format(stmt);
execute fstmt;

stmt := 'drop table if exists ' || 'bck.soggetti_fisici_fvg_scarto_' || replace(current_date::text,'-','') || ';';
raise notice 'STMT= %',stmt;

fstmt := format(stmt);
execute fstmt;
	
	
--CREAZIONE TABELLE DI BACKUP	

stmt := 'create table ' || 'bck.soggetti_fisici_fvg_' || replace(current_date::text,'-','') || 
' as select * from conf_ext.soggetti_fisici_fvg';
raise notice 'STMT= %',stmt;

fstmt := format(stmt);
execute fstmt;

stmt := 'create table ' || 'bck.soggetti_fisici_fvg_scarto_' || replace(current_date::text,'-','') || 
' as select * from conf_ext.soggetti_fisici_fvg_scarto';
raise notice 'STMT= %',stmt;

fstmt := format(stmt);
execute fstmt;	
	
	
	
		/*delete from conf_ext.soggetti_fisici_fvg;
		delete from conf_ext.soggetti_fisici_fvg_scarto;
		insert into conf_ext.soggetti_fisici_fvg select * from conf_ext.vw_persone_fisiche_sicer;*/
	
		/*drop table conf_ext.soggetti_fisici_fvg;
		drop table conf_ext.soggetti_fisici_fvg_scarto;
		create table conf_ext.soggetti_fisici_fvg_scarto as select *,'' motivo from conf_ext.fvg_gisa_privati where 0=1;
	    create table conf_ext.soggetti_fisici_fvg as
		select * from conf_ext.fvg_gisa_privati;	*/
	
		delete from conf_ext.soggetti_fisici_fvg;
		delete from conf_ext.soggetti_fisici_fvg_scarto;
		insert into conf_ext.soggetti_fisici_fvg select * from conf_ext.fvg_gisa_privati;

 		get diagnostics n = row_count; 		raise notice 'RIGHE INSERITE INIZIALI %',n;
 	
		insert into conf_ext.soggetti_fisici_fvg_scarto
		select *,'CODICE FISCALE NON PRESENTE o DI LUNGHEZZA != 16' from conf_ext.soggetti_fisici_fvg 
		where codice_fiscale is null or length(codice_fiscale)!=16;
 		get diagnostics n = row_count; 		raise notice 'RIGHE INSERITE SCARTO !=16 %',n;
		delete from conf_ext.soggetti_fisici_fvg f where f.id in (select a.id from conf_ext.soggetti_fisici_fvg_scarto a);	
		get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO !=16 %',n;
		select count(*) into n_G from conf_ext.soggetti_fisici_fvg;
		select count(*) into n_B from conf_ext.soggetti_fisici_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%',n_g,n_b;

		insert into conf_ext.soggetti_fisici_fvg_scarto
		select *,'CODICE FISCALE DUPLICATO' from conf_ext.soggetti_fisici_fvg where codice_fiscale in (
		select codice_fiscale from conf_ext.soggetti_fisici_fvg group by 1 having count(*) > 1);
		get diagnostics n = row_count; 		raise notice 'RIGHE INSERITE SCARTO DUP %',n;
		delete from conf_ext.soggetti_fisici_fvg f where f.id in (select a.id from conf_ext.soggetti_fisici_fvg_scarto a);
		get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO DUP %',n;
		select count(*) into n_G from conf_ext.soggetti_fisici_fvg;
		select count(*) into n_B from conf_ext.soggetti_fisici_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%',n_g,n_b;
	
	
		insert into conf_ext.soggetti_fisici_fvg_scarto
		select *,'CODICE FISCALE NON CORRETTO' from conf_ext.soggetti_fisici_fvg where
		codice_fiscale !~ '^(?:[A-Z][AEIOU][AEIOUX]|[AEIOU]X{2}|[B-DF-HJ-NP-TV-Z]{2}[A-Z]){2}(?:[\dLMNP-V]{2}(?:[A-EHLMPR-T](?:[04LQ][1-9MNP-V]|[15MR][\dLMNP-V]|[26NS][0-8LMNP-U])|[DHPS][37PT][0L]|[ACELMRT][37PT][01LM]|[AC-EHLMPR-T][26NS][9V])|(?:[02468LNQSU][048LQU]|[13579MPRTV][26NS])B[26NS][9V])(?:[A-MZ][1-9MNP-V][\dLMNP-V]{2}|[A-M][0L](?:[1-9MNP-V][\dLMNP-V]|[0L][1-9MNP-V]))[A-Z]$';
		get diagnostics n = row_count; 		raise notice 'RIGHE INSERITE SCARTO MATCH %',n;
		delete from conf_ext.soggetti_fisici_fvg f where f.id in (select a.id from conf_ext.soggetti_fisici_fvg_scarto a);		get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO MATCH %',n;	
		select count(*) into n_G from conf_ext.soggetti_fisici_fvg;
		select count(*) into n_B from conf_ext.soggetti_fisici_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;
	
	
	
		/*insert into conf_ext.soggetti_fisici_fvg_scarto
		select s.*,'CODICE/DESCRIZIONE COMUNE NASCITA NON PRESENTE '||nato_prov_istat||nato_com_istat||' '|| nato_com_desc motivo
		from conf_ext.soggetti_fisici_fvg s
		left join conf_ext.anpr_aRCHIVIO_COMUNI  c on c.codistat  = (nato_prov_istat||nato_com_istat)::integer 
		where c.denominazione_it  is null ;--and (nato_prov_istat||nato_com_istat) != '000000';
		get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO COM NASCITA %',n;
		delete from conf_ext.soggetti_fisici_fvg f where f.id in (select a.id from conf_ext.soggetti_fisici_fvg_scarto a);
		select count(*) into n_G from conf_ext.soggetti_fisici_fvg;
		select count(*) into n_B from conf_ext.soggetti_fisici_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;*/
	
		insert into conf_ext.soggetti_fisici_fvg_scarto
		select s.*,'ERRATO CODICE FISCALE (CIN) '||coalesce(codice_fiscale,'') cf
		from conf_ext.soggetti_fisici_fvg s
		where cu_anag.check_cf(codice_fiscale) is false;
		get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO CIN %',n;
		delete from conf_ext.soggetti_fisici_fvg f where f.id in (select a.id from conf_ext.soggetti_fisici_fvg_scarto a);
		select count(*) into n_G from conf_ext.soggetti_fisici_fvg;
		select count(*) into n_B from conf_ext.soggetti_fisici_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;
	
		insert into conf_ext.soggetti_fisici_fvg_scarto	
		select s.*,'STATO ESTERO '||coalesce(res_istat,'')||' '|| coalesce(res_comune,'') motivo			 
		from conf_ext.soggetti_fisici_fvg s
		where s.res_comune = 'STATO ESTERO';		
		get diagnostics n = row_count; 		raise notice 'RIGHE INSERITE SCARTO MATCH %',n;
		delete from conf_ext.soggetti_fisici_fvg f where f.id in (select a.id from conf_ext.soggetti_fisici_fvg_scarto a);
	    get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO STATO ESTERO %',n;	
		select count(*) into n_G from conf_ext.soggetti_fisici_fvg;
		select count(*) into n_B from conf_ext.soggetti_fisici_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;
	
		insert into conf_ext.soggetti_fisici_fvg_scarto	
		select s.*,'CODICE COMUNE RESIDENZA NON PRESENTE '||coalesce(res_istat,'')||' '|| coalesce(res_comune,'') motivo			 
		from conf_ext.soggetti_fisici_fvg s
		left join conf_ext.anpr_aRCHIVIO_COMUNI  c on c.codistat  = (res_istat)::integer 
		--left join conf_ext.vw_comuni_vigenti c on c.istat  = res_istat
		
		where c.denominazione_it  is null ; --and (res_prov_istat||res_com_istat) != '000000';		
		get diagnostics n = row_count; 		raise notice 'RIGHE INSERITE SCARTO MATCH %',n;
		delete from conf_ext.soggetti_fisici_fvg f where f.id in (select a.id from conf_ext.soggetti_fisici_fvg_scarto a);
	    get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO COMUNE RESIDENZA %',n;	
		select count(*) into n_G from conf_ext.soggetti_fisici_fvg;
		select count(*) into n_B from conf_ext.soggetti_fisici_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;
	
		insert into conf_ext.soggetti_fisici_fvg_scarto
		select s.*,'TOPONIMO DUG NON PREVISTO '||coalesce(res_toponimo,'') cf
		from conf_ext.soggetti_fisici_fvg s
		where trim(res_toponimo) not in (select sigla from conf_ext.toponimi union select descrizione from conf_ext.toponimi  ) and trim(res_toponimo)  not in ('RIVE','STRADE');
		get diagnostics n = row_count; 		raise notice 'RIGHE DELETED SCARTO DUG %',n;
		delete from conf_ext.soggetti_fisici_fvg f where f.id in (select a.id from conf_ext.soggetti_fisici_fvg_scarto a);
		select count(*) into n_G from conf_ext.soggetti_fisici_fvg;
		select count(*) into n_B from conf_ext.soggetti_fisici_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;
	
		insert into conf_ext.soggetti_fisici_fvg_scarto
		select s.*,'CODICE/DESCRIZIONE COMUNE NASCITA NON PRESENTE  '||coalesce(substring(s.codice_fiscale,12,4),'')||' ' ||coalesce(s.codice_catastale_nascita,'' )
		from conf_ext.soggetti_fisici_fvg s
		left join conf_ext.anpr_aRCHIVIO_COMUNI  c on c.codcatastale  = s.codice_catastale_nascita 
		where substring(s.codice_fiscale,12,1)!='Z' and  c.denominazione_it  is null ;--and (nato_prov_istat||nato_com_istat) != '000000';
		delete from conf_ext.soggetti_fisici_fvg f where f.id in (select a.id from conf_ext.soggetti_fisici_fvg_scarto a);
		select count(*) into n_G from conf_ext.soggetti_fisici_fvg;
		select count(*) into n_B from conf_ext.soggetti_fisici_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;
	
		insert into conf_ext.soggetti_fisici_fvg_scarto
		select  s.*,'CODICE/DESCRIZIONE STATO ESTERO NASCITA NON PRESENTE  '||coalesce(substring(s.codice_fiscale,12,4),'')||' ' ||coalesce(s.codice_catastale_nascita,'')  motivo
		from conf_ext.soggetti_fisici_fvg s join conf_ext.stati_esteri e on e.codice_at=s.codice_catastale_nascita 
		join conf_ext.lookup_nazioni_ n on upper(n.description)= upper(e.denom_it)
		where left(s.codice_catastale_nascita,1)='Z' and e.denom_it is null;
		delete from conf_ext.soggetti_fisici_fvg f where f.id in (select a.id from conf_ext.soggetti_fisici_fvg_scarto a);
		select count(*) into n_G from conf_ext.soggetti_fisici_fvg;
		select count(*) into n_B from conf_ext.soggetti_fisici_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;
	
		insert into conf_ext.soggetti_fisici_fvg_scarto
		select  s.*,'SECOLO DI NASCITA ERRATO  '||coalesce(s.data_nascita::varchar,'')  motivo
		from conf_ext.soggetti_fisici_fvg s
		where  to_char(s.data_nascita,'YYYY')::integer not between 1800 and 2099;
		delete from conf_ext.soggetti_fisici_fvg f where f.id in (select a.id from conf_ext.soggetti_fisici_fvg_scarto a);
		select count(*) into n_G from conf_ext.soggetti_fisici_fvg;
		select count(*) into n_B from conf_ext.soggetti_fisici_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;	
	
		insert into conf_ext.soggetti_fisici_fvg_scarto
		select  s.*,'NOME E COGNOME ASSENTI, ERRATI O CAMPO UNICO '||coalesce(s.nome_completo::varchar,'')  motivo
		from conf_ext.soggetti_fisici_fvg s
		where  s.nome is null and s.cognome is null;
		delete from conf_ext.soggetti_fisici_fvg f where f.id in (select a.id from conf_ext.soggetti_fisici_fvg_scarto a);
		select count(*) into n_G from conf_ext.soggetti_fisici_fvg;
		select count(*) into n_B from conf_ext.soggetti_fisici_fvg_scarto;
		raise notice 'RECORD GOOD=% BAD=%' ,n_g,n_b;

update conf_ext.soggetti_fisici_fvg set sesso = 
	 CASE
           WHEN
           ( CASE "substring"(codice_fiscale::text, 10, 1)
                WHEN 'L'::text THEN '0'::text
                WHEN 'M'::text THEN '1'::text
                WHEN 'N'::text THEN '2'::text
                WHEN 'P'::text THEN '3'::text
                WHEN 'Q'::text THEN '4'::text
                WHEN 'R'::text THEN '5'::text
                WHEN 'S'::text THEN '6'::text
                WHEN 'T'::text THEN '7'::text
                WHEN 'U'::text THEN '8'::text
                WHEN 'V'::text THEN '9'::text
                ELSE "substring"(codice_fiscale::text, 10, 1)
            end)::integer > 3 THEN 'F'::varchar
            ELSE 'M'::varchar end;
	
           
--29-09-2023

CREATE OR REPLACE VIEW conf_ext.vw_soggetti_fisici_fvg_scarto_motivi
AS SELECT regexp_match(gifs.motivo, '^[^:]*'::text) AS motivo,
    count(*) AS count
   FROM conf_ext.soggetti_fisici_fvg_scarto gifs
  GROUP BY (regexp_match(gifs.motivo, '^[^:]*'::text))
  ORDER BY (count(*)) DESC;           
         
           
	RETURN 'OK';
	end

$_$;


ALTER FUNCTION conf_ext.check_soggetti_fisici() OWNER TO postgres;

--
-- Name: check_soggetti_fisici_fvg_modificati(); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.check_soggetti_fisici_fvg_modificati() RETURNS text
    LANGUAGE plpgsql
    AS $$

DECLARE
	
	stmt varchar;
	fstmt varchar;

BEGIN

	/*
--CREAZIONE TABELLE DI BACKUP	
	
stmt := 'create table ' || 'bck.opu_indirizzo_' || replace(current_date::text,'-','') || 
' as select * from public.opu_indirizzo';
raise notice 'STMT= %',stmt;

fstmt := format(stmt);
execute fstmt;

stmt := 'create table ' || 'bck.opu_soggetto_fisico_' || replace(current_date::text,'-','') || 
' as select * from public.opu_soggetto_fisico';
raise notice 'STMT= %',stmt;

fstmt := format(stmt);
execute fstmt;
*/
-----------------------------------------------


drop table if exists conf_ext.soggetti_fisici_fvg_modificati cascade;

create table conf_ext.soggetti_fisici_fvg_modificati as
select * from conf_ext.soggetti_fisici_fvg_scarto 
where motivo != 'CODICE FISCALE NON CORRETTO';

raise notice 'INSERT IN soggetti_fisici_fvg_modificati';



/*
update conf_ext.soggetti_fisici_fvg_modificati
set res_istat = subquery.istat2,
res_comune = upper(subquery.denominazione_it2)
from (
select c.istat, c.denominazione_it, c.notused, c2.notused,
c2.istat as istat2, c2.denominazione_it as denominazione_it2 from conf_ext.vw_comuni_vigenti c
left join conf_ext.vw_comuni_vigenti c2 on c.denominazione_it=c2.denominazione_it
where c.istat in (	
	select res_istat
	from conf_ext.soggetti_fisici_fvg_modificati s
	--where s.id not in (select id from public.opu_soggetto_fisico)
				)
--and c.notused is true and c2.notused is not true
	) as subquery
where soggetti_fisici_fvg_modificati.res_istat = subquery.istat;
*/

update conf_ext.soggetti_fisici_fvg_modificati 
set res_istat = '111111',
res_comune = 'Comune NON dichiarato'
where motivo ilike '%CODICE COMUNE RESIDENZA NON PRESENTE%';

update conf_ext.soggetti_fisici_fvg_modificati 
set codice_catastale_nascita = 'ZZZZ',
comune_nascita = 'Comune NON presente in Italia'
where motivo ilike '%CODICE/DESCRIZIONE COMUNE NASCITA NON PRESENTE%';


update conf_ext.soggetti_fisici_fvg_modificati 
set codice_catastale_nascita = 'ZZZZ'
where codice_catastale_nascita ilike 'Z%';


update conf_ext.soggetti_fisici_fvg_modificati
set data_nascita_fiscale = data_nascita 
where data_nascita_fiscale = '1900-02-29';

/*
update conf_ext.soggetti_fisici_fvg_modificati
set res_istat = '111111',
res_comune = 'Comune NON dichiarato'
where motivo ilike '%ERRORE IMPORT OPU%'
and res_istat not in (select istat from conf_ext.vw_comuni_vigenti); --where notused is not true);


update conf_ext.soggetti_fisici_fvg_modificati s
set codice_catastale_nascita = '111111',
comune_nascita = 'Comune NON dichiarato'
where motivo ilike '%ERRORE IMPORT OPU%'
and codice_catastale_nascita not in (select codice_catastale from conf_ext.vw_comuni_vigenti); --where notused is not true);
*/
raise notice 'FINE UPDATE';



update conf_ext.soggetti_fisici_fvg_modificati set sesso = 
	 CASE
           WHEN
           ( CASE "substring"(codice_fiscale::text, 10, 1)
                WHEN 'L'::text THEN '0'::text
                WHEN 'M'::text THEN '1'::text
                WHEN 'N'::text THEN '2'::text
                WHEN 'P'::text THEN '3'::text
                WHEN 'Q'::text THEN '4'::text
                WHEN 'R'::text THEN '5'::text
                WHEN 'S'::text THEN '6'::text
                WHEN 'T'::text THEN '7'::text
                WHEN 'U'::text THEN '8'::text
                WHEN 'V'::text THEN '9'::text
                ELSE "substring"(codice_fiscale::text, 10, 1)
            end)::integer > 3 THEN 'F'::varchar
            ELSE 'M'::varchar end;

	

CREATE OR REPLACE VIEW conf_ext.vw_soggetti_fisici_fvg				--116.588
AS SELECT soggetti_fisici_fvg.id,
    soggetti_fisici_fvg.sicer_id,
    soggetti_fisici_fvg.nome_completo,
    soggetti_fisici_fvg.nome,
    soggetti_fisici_fvg.cognome,
    soggetti_fisici_fvg.sesso,
    soggetti_fisici_fvg.comune_nascita,
    soggetti_fisici_fvg.data_nascita,
    soggetti_fisici_fvg.data_decesso,
    soggetti_fisici_fvg.codice_fiscale,
    soggetti_fisici_fvg.tipo,
    soggetti_fisici_fvg.tipo_persona,
    soggetti_fisici_fvg.pec,
    soggetti_fisici_fvg.email,
    soggetti_fisici_fvg.sdi,
    soggetti_fisici_fvg.split_payment,
    soggetti_fisici_fvg.telefono,
    soggetti_fisici_fvg.documento,
    soggetti_fisici_fvg.nazione,
    soggetti_fisici_fvg.res_provincia,
    soggetti_fisici_fvg.res_istat,
    soggetti_fisici_fvg.res_comune,
    soggetti_fisici_fvg.res_toponimo,
    soggetti_fisici_fvg.res_indirizzo,
    soggetti_fisici_fvg.res_civico,
    soggetti_fisici_fvg.res_cap,
    soggetti_fisici_fvg.dom_provincia,
    soggetti_fisici_fvg.dom_istat,
    soggetti_fisici_fvg.dom_comune,
    soggetti_fisici_fvg.dom_toponimo,
    soggetti_fisici_fvg.dom_indirizzo,
    soggetti_fisici_fvg.dom_civico,
    soggetti_fisici_fvg.dom_cap,
    soggetti_fisici_fvg.latitudine,
    soggetti_fisici_fvg.longitudine,
    soggetti_fisici_fvg.errori,
    soggetti_fisici_fvg.score,
    soggetti_fisici_fvg.inviare,
    soggetti_fisici_fvg.codice_catastale_nascita,
    soggetti_fisici_fvg.data_nascita_fiscale
   FROM conf_ext.soggetti_fisici_fvg
UNION
 SELECT soggetti_fisici_fvg_modificati.id,
    soggetti_fisici_fvg_modificati.sicer_id,
    soggetti_fisici_fvg_modificati.nome_completo,
    soggetti_fisici_fvg_modificati.nome,
    soggetti_fisici_fvg_modificati.cognome,
    soggetti_fisici_fvg_modificati.sesso,
    soggetti_fisici_fvg_modificati.comune_nascita,
    soggetti_fisici_fvg_modificati.data_nascita,
    soggetti_fisici_fvg_modificati.data_decesso,
    soggetti_fisici_fvg_modificati.codice_fiscale,
    soggetti_fisici_fvg_modificati.tipo,
    soggetti_fisici_fvg_modificati.tipo_persona,
    soggetti_fisici_fvg_modificati.pec,
    soggetti_fisici_fvg_modificati.email,
    soggetti_fisici_fvg_modificati.sdi,
    soggetti_fisici_fvg_modificati.split_payment,
    soggetti_fisici_fvg_modificati.telefono,
    soggetti_fisici_fvg_modificati.documento,
    soggetti_fisici_fvg_modificati.nazione,
    soggetti_fisici_fvg_modificati.res_provincia,
    soggetti_fisici_fvg_modificati.res_istat,
    soggetti_fisici_fvg_modificati.res_comune,
    soggetti_fisici_fvg_modificati.res_toponimo,
    soggetti_fisici_fvg_modificati.res_indirizzo,
    soggetti_fisici_fvg_modificati.res_civico,
    soggetti_fisici_fvg_modificati.res_cap,
    soggetti_fisici_fvg_modificati.dom_provincia,
    soggetti_fisici_fvg_modificati.dom_istat,
    soggetti_fisici_fvg_modificati.dom_comune,
    soggetti_fisici_fvg_modificati.dom_toponimo,
    soggetti_fisici_fvg_modificati.dom_indirizzo,
    soggetti_fisici_fvg_modificati.dom_civico,
    soggetti_fisici_fvg_modificati.dom_cap,
    soggetti_fisici_fvg_modificati.latitudine,
    soggetti_fisici_fvg_modificati.longitudine,
    soggetti_fisici_fvg_modificati.errori,
    soggetti_fisici_fvg_modificati.score,
    soggetti_fisici_fvg_modificati.inviare,
    soggetti_fisici_fvg_modificati.codice_catastale_nascita,
    soggetti_fisici_fvg_modificati.data_nascita_fiscale
   FROM conf_ext.soggetti_fisici_fvg_modificati
  WHERE NOT (soggetti_fisici_fvg_modificati.codice_fiscale::text IN ( SELECT soggetti_fisici_fvg.codice_fiscale
           FROM conf_ext.soggetti_fisici_fvg));		
	
      

	return 0;	
		
	END;
$$;


ALTER FUNCTION conf_ext.check_soggetti_fisici_fvg_modificati() OWNER TO postgres;

--
-- Name: create_view_imprese(); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.create_view_imprese() RETURNS text
    LANGUAGE plpgsql
    AS $$
	BEGIN

--CREAZIONE VISTE IMPRESE (schema conf_ext)

		/*
--GISA_IMPRESE_FVG		
		
CREATE OR REPLACE VIEW conf_ext.vw_import_imprese
AS SELECT *  FROM conf_ext.gisa_imprese_fvg;		
		

--GISA_IMPRESE_MINIMALE

CREATE OR REPLACE VIEW conf_ext.vw_gisa_imprese_minimale
AS SELECT i.az_id,
    i.az_denominazione,
    i.sd_an_cf,
    i.sd_an_iva,
    i.az_an_indirizzo,
    i.az_an_civico,
    i.az_an_istat,
    i.az_an_provincia,
    i.sd_an_res_indirizzo,
    i.sd_an_res_civico,
    i.sd_an_res_istat,
    i.sd_an_res_provincia,
    i.fg_an_cf,
    p.pr_data_inizio,
    p.sn_codice,
    p.ss_codice,
    p.sa_codice,
    p.sp_codice,
    p.pr_cod_attivita,
        CASE
            WHEN i.az_denominazione::text ~~* '%trasport%'::text THEN false
            ELSE true
        END AS fissa
   FROM conf_ext.gisa_imprese_fvg i
     LEFT JOIN ( SELECT DISTINCT ON (fvg_gisa_imprese_produzione.gi_sd_id) fvg_gisa_imprese_produzione.gi_sd_id,
            fvg_gisa_imprese_produzione.pr_id,
            fvg_gisa_imprese_produzione.pr_data_inizio,
            fvg_gisa_imprese_produzione.pr_data_fine,
            fvg_gisa_imprese_produzione.sn_codice,
            fvg_gisa_imprese_produzione.ss_codice,
            fvg_gisa_imprese_produzione.sa_codice,
            fvg_gisa_imprese_produzione.sp_codice,
            fvg_gisa_imprese_produzione.pr_cod_attivita
           FROM conf_ext.fvg_gisa_imprese_produzione
          ORDER BY fvg_gisa_imprese_produzione.gi_sd_id, fvg_gisa_imprese_produzione.pr_data_inizio DESC) p ON i.az_id = p.gi_sd_id
  WHERE p.sn_codice IS NOT NULL AND p.pr_data_inizio IS NOT NULL
  ORDER BY i.az_id;		
	
*/
--GISA_IMPRESE_COMPLETA

CREATE OR REPLACE VIEW conf_ext.vw_gisa_imprese_completa
AS SELECT i.az_id AS impresa_id,
    i.sl_fg_an_nome AS impresa_ragione_sociale,
    COALESCE(i.sl_fg_an_iva, i.sd_an_iva) AS impresa_piva,
    COALESCE(i.sl_fg_an_cf, i.sd_an_cf) AS impresa_cf,
    --16-01-24 (invertito il coalesce dando precedenza alla sede legale)
    i.az_cod_aziendale as impresa_cod_aziendale,
    i.sl_fg_an_res_toponimo AS impresa_indirizzo_toponimo,
    i.sl_fg_an_res_indirizzo AS impresa_indirizzo,
    i.sl_fg_an_res_civico AS impresa_indirizzo_civico,
    i.sl_fg_an_res_istat AS impresa_indirizzo_istat_comune,
    i.sl_fg_an_res_provincia AS impresa_indirizzo_provincia,
    --COALESCE(i.sl_fg_an_pec, i.sl_fg_an_email) AS impresa_pec,
    i.sl_fg_an_pec as impresa_pec,
    i.sl_fg_an_email as impresa_email,
    
	i.sl_fg_an_split_payment as impresa_split_payment,
	i.sl_fg_an_sdi as impresa_sdi,
	i.sl_fg_tipo_figura_descr as impresa_tipo_figura_descr,
    
i.fg_an_tipo_persona as impresa_tipo_persona,
i.fg_an_tipo_pers_descr as impresa_tipo_pers_descr,
i.sd_cod_tipologia_struttura as stabilimento_cod_tipologia_struttura,
i.sd_tipologia_struttura as impresa_tipologia_struttura,
i.sl_az_cod_aziendale as impresa_codice_aziendale,

    i.sd_id AS stabilimento_id,
    i.sd_an_nome AS stabilimento_denominazione,
    i.sl_sd_cod_regionale as stabilimento_codice_regionale,
    i.sd_an_res_toponimo AS stabilimento_indirizzo_toponimo,
    i.sd_an_res_indirizzo AS stabilimento_indirizzo,
    i.sd_an_res_civico AS stabilimento_indirizzo_civico,
    i.sd_an_res_istat AS stabilimento_indirizzo_istat_comune,
    i.sd_an_res_provincia AS stabilimento_indirizzo_provincia,
    i.az_latitudine AS stabilimento_latitudine,
    i.az_longitudine AS stabilimento_longitudine,
    s.id AS soggetto_id,
    s.nome AS soggetto_nome,
    s.cognome AS soggetto_cognome,
    s.sesso AS soggetto_sesso,
    s.codice_catastale_nascita AS soggetto_codice_catastale_comune_nascita,
    s.data_nascita AS soggetto_data_nascita,
    s.codice_fiscale AS soggetto_codice_fiscale,
    s.email AS soggetto_email,
    s.telefono AS soggetto_telefono,
    s.res_toponimo AS soggetto_indirizzo_toponimo,
    s.res_indirizzo AS soggetto_indirizzo,
    s.res_civico AS soggetto_indirizzo_civico,
    s.res_istat AS soggetto_indirizzo_istat_comune,
    s.res_provincia AS soggetto_indirizzo_provincia,
    p.pr_id AS linea_id,
    p.pr_data_inizio AS linea_data_inizio,
    p.pr_data_fine AS linea_data_fine,
    p.sn_codice AS linea_norma_codice,
    p.ss_codice AS linea_macroarea_codice,
    p.sa_codice AS linea_aggregazione_codice,
    p.sp_codice AS linea_attivita_codice,
    p.pr_cod_attivita AS linea_ateco,
        CASE
            WHEN i.az_denominazione::text ~~* '%trasport%'::text OR i.sd_an_nome::text ~~* '%trasport%'::text THEN false
            ELSE true
        END AS attivita_fissa,
    p.pr_principale AS linea_principale
   FROM conf_ext.gisa_imprese_fvg i
     JOIN conf_ext.soggetti_fisici_fvg s ON i.fg_an_cf::text = s.codice_fiscale::text
     JOIN ( SELECT DISTINCT ON (fvg_gisa_imprese_produzione.pr_id) fvg_gisa_imprese_produzione.pr_id,
            fvg_gisa_imprese_produzione.gi_sd_id,
            fvg_gisa_imprese_produzione.pr_data_inizio,
            fvg_gisa_imprese_produzione.pr_data_fine,
            fvg_gisa_imprese_produzione.sn_codice,
            fvg_gisa_imprese_produzione.ss_codice,
            fvg_gisa_imprese_produzione.sa_codice,
            fvg_gisa_imprese_produzione.sp_codice,
            fvg_gisa_imprese_produzione.pr_cod_attivita,
            fvg_gisa_imprese_produzione.pr_principale
           FROM conf_ext.fvg_gisa_imprese_produzione
          WHERE fvg_gisa_imprese_produzione.pr_principale = 1::numeric
          ORDER BY fvg_gisa_imprese_produzione.pr_id, fvg_gisa_imprese_produzione.gi_sd_id, fvg_gisa_imprese_produzione.pr_data_inizio DESC) p ON i.sd_id = p.gi_sd_id
  WHERE p.pr_principale IS NOT NULL
  ORDER BY i.az_id, i.sd_id;
 

 --GISA_IMPRESE_CATEGORIA_RISCHIO
 
 --MODIFICATA IL 16-03-2024
 
CREATE OR REPLACE VIEW conf_ext.vw_gisa_imprese_categoria_rischio
AS SELECT g.impresa_id,
    g.impresa_ragione_sociale,
    g.impresa_piva,
    g.stabilimento_id,
    g.stabilimento_denominazione,
    i.data_ril AS categoria_rischio_data_controllo,
    i.valore_rischio AS categoria_rischio_valore
   FROM conf_ext.vw_gisa_imprese_completa g
     LEFT JOIN ( SELECT DISTINCT a.gi_sd_id,
            max(a.ind_ultimo_rilevamento) AS data_ril,
            a.valore_rischio
           FROM conf_ext.fvg_gisa_imprese_indice_old a
          GROUP BY a.gi_sd_id, a.ind_valore_rischio, a.valore_rischio
         HAVING count(a.gi_sd_id) = 1) i ON g.stabilimento_id = i.gi_sd_id
  ORDER BY g.stabilimento_id;
 
 
 /*
CREATE OR REPLACE VIEW conf_ext.vw_gisa_imprese_categoria_rischio
AS SELECT g.impresa_id,
    g.impresa_ragione_sociale,
    g.impresa_piva,
    g.stabilimento_id,
    g.stabilimento_denominazione,
    i.data_ril AS categoria_rischio_data_controllo,
    i.ind_valore_rischio AS categoria_rischio_valore_indice,
    i.ind_gruppo_rischio_codice AS categoria_rischio_codice,
    i.ind_gruppo_rischio AS categoria_rischio_gruppo,
    i.ind_rischio_codice AS categoria_rischio_indice,
    i.ind_rischio_descrizione AS categoria_rischio_descrizione,
    i.peso_rischio AS categoria_rischio_peso,
    i.valore_rischio AS categoria_rischio_valore
   FROM conf_ext.vw_gisa_imprese_completa g
     LEFT JOIN ( SELECT DISTINCT a.gi_sd_id,
            max(a.ind_ultimo_rilevamento) AS data_ril,
            a.ind_valore_rischio,
            a.ind_gruppo_rischio_codice,
            a.ind_gruppo_rischio,
            a.ind_rischio_codice,
            a.ind_rischio_descrizione,
            a.peso_rischio,
            a.valore_rischio
           FROM conf_ext.fvg_gisa_imprese_indice a
          GROUP BY a.gi_sd_id, a.ind_valore_rischio, a.ind_gruppo_rischio_codice, a.ind_gruppo_rischio, a.ind_rischio_codice, a.ind_rischio_descrizione, a.peso_rischio, a.valore_rischio
         HAVING count(a.gi_sd_id) = 1) i ON g.stabilimento_id = i.gi_sd_id
  WHERE i.data_ril IS NOT NULL
  ORDER BY g.stabilimento_id;
 */
	
return 'OK';

	END;
$$;


ALTER FUNCTION conf_ext.create_view_imprese() OWNER TO postgres;

--
-- Name: get_cf_da_bonificare(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.get_cf_da_bonificare(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
		begin 
			proc_name:='conf_ext.get_cf_da_bonificare';
			ret.esito:=false;
		select json_agg(row_to_json(a.*)) into rt from (
			/*select codice_fiscale from conf_ext.cf_da_bonificare
			where codice_fiscale in ( select codice_fiscale 
										  from conf_ext.vw_cf_da_bonificare b) */
			select codice_fiscale from conf_ext.utenti_fvg_soggetti_fisici 
			where codice_fiscale not in (select codice_fiscale from conf_ext.utenti_fvg_bonifica_soggetti_fisici )
		) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
	 	return ret;
		end;
		
	END;
$$;


ALTER FUNCTION conf_ext.get_cf_da_bonificare(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_codici_nascita(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.get_codici_nascita(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
		begin 
			proc_name:='conf_ext.get_codici_nascita';
			ret.esito:=false;
		select json_agg(row_to_json(a.*)) into rt from (
			select codcatastale,upper(denominazione_it) denominazione_it from conf_ext.vw_comuni_vigenti_catastali
		  union 
		 select codice_at,upper(denom_it) from conf_ext.vw_stati_esteri ) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
	 	return ret;
		end;
		
	END;
$$;


ALTER FUNCTION conf_ext.get_codici_nascita(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_comuni(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.get_comuni(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
		begin 
			proc_name:='conf_ext.get_comuni';
			ret.esito:=false;
		select json_agg(row_to_json(a.*)) into rt from (
			select codice_istat,denominazione_it,caps from conf_ext.vw_comuni_vigenti_attivi c 
					left join conf_ext.vw_istat_lista_cap cap on c.codice_istat=cap.istat) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
	 	return ret;
		end;
		
	END;
$$;


ALTER FUNCTION conf_ext.get_comuni(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_comuni_associati(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.get_comuni_associati(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
	ret ag_types.result_type; 
	proc_name varchar;
	idstrutturaroot bigint;
	rt json;
		begin 
			proc_name:='conf_ext.get_comuni_associati';
			idstrutturaroot:=v->'user_info'->'id_struttura_root';
			ret.esito:=false;
		select json_agg(row_to_json(a.*)) into rt from (
			select distinct on (istat_comune) istat_comune codice_istat,comune denominazione_it,caps from agenda.vw_struttura_comuni 
			join matrix.vw_tree_nodes_down_asl a on a.id_node=id_struttura
			left join conf_ext.vw_istat_lista_cap cap on istat_comune=cap.istat
			where idstrutturaroot=id_node_ref
		) a;

		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
	 	return ret;
		end;
		
	END;
$$;


ALTER FUNCTION conf_ext.get_comuni_associati(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_dettaglio_scarto_aziende(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.get_dettaglio_scarto_aziende(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
	flusso text;
 

	begin
		proc_name:='conf_ext.get_dettaglio_scarto_aziende';
		flusso=(v_j->>'flusso')::text;
		
		raise notice 'flusso%', flusso ;	
	 
	    if lower(flusso)=lower('Aziende') then --'Flusso Aziende'
	    	raise notice 'primo if';
	   	  select json_agg(row_to_json(c.*)) into rt from  conf_ext.vw_dettaglio_scarto_aziende c;
	     ---   --'Flusso Aziende Importante
	     end if;
	   	 if lower(flusso)=lower('Aziende Importate') then
	   	  	raise notice 'secondo if';
	   	 	   select json_agg(row_to_json(c.*)) into rt from  conf_ext.vw_dettaglio_scarto_aziende_importate c;
	   	 	  raise notice 'secondo if rt%',rt;	
	    end if;
	

		raise notice '%',rt;	
		if rt is null then
			ret.esito:=false;	
    	    ret:=ag_ui.build_ret(ret,proc_name, 'get_dettaglio_scarto_aziende_valori_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null; 		 		
 			ret.info:='{"dati":' || rt;
			ret.info:=ret.info || '}';

		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION conf_ext.get_dettaglio_scarto_aziende(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_dettaglio_scarto_persone(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.get_dettaglio_scarto_persone(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
	flusso text;
 

	begin
	proc_name:='conf_ext.get_dettaglio_scarto_persone';
		select json_agg(row_to_json(c.*)) into rt from conf_ext.vw_dettaglio_scarto_persone c;
		raise notice '%',rt;	
		if rt is null then
			ret.esito:=false;	
    	    ret:=ag_ui.build_ret(ret,proc_name, 'get_dettaglio_scarto_persone_valori_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null; 		 		
 			ret.info:='{"dati":' || rt;
			ret.info:=ret.info || '}';

		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION conf_ext.get_dettaglio_scarto_persone(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_indirizzi_per_comune(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.get_indirizzi_per_comune(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
	v_istat varchar;
	v_toponimo varchar;
		begin 
			proc_name:='conf_ext.get_indirizzi_per_comune';
			ret.esito:=false;
			v_istat:= v->>'codice_istat';
			v_toponimo:= v->>'toponimo';
		select json_agg(row_to_json(a.*)) into rt from (
			select * from conf_ext.com_vie_fvg
			where cod_istat = v_istat and toponimo = v_toponimo) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
	 	return ret;
		end;
		
	END;
$$;


ALTER FUNCTION conf_ext.get_indirizzi_per_comune(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_monitoraggio_flusso_import(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.get_monitoraggio_flusso_import(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;

	begin
		proc_name:='conf_ext.get_monitoraggio_flusso_import';
		select json_agg(row_to_json(c.*)) into rt from conf_ext.vw_monitoraggio_flusso_import_gisa c;
		raise notice '%',rt;	
		if rt is null then
			ret.esito:=false;	
    	    ret:=ag_ui.build_ret(ret,proc_name, 'get_monitoraggio_flusso_import_valori_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null; 		 		
 			ret.info:='{"dati":' || rt;
			ret.info:=ret.info || '}';

		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION conf_ext.get_monitoraggio_flusso_import(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_nazioni(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.get_nazioni(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
		begin 
			proc_name:='conf_ext.get_nazioni';
			ret.esito:=false;
		select json_agg(row_to_json(a.*)) into rt from (
			select sigla_estesa,descrizione_upper  from conf_ext.vw_nazioni) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
	 	return ret;
		end;
		
	END;
$$;


ALTER FUNCTION conf_ext.get_nazioni(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_piva_da_bonificare(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.get_piva_da_bonificare(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
		begin 
			proc_name:='conf_ext.get_piva_da_bonificare';
			ret.esito:=false;
		select json_agg(row_to_json(a.*)) into rt from (
		select piva from conf_ext.piva_da_bonificare
			where piva not in ( select piva 
										 from conf_ext.bonifica_imprese b) 
				and piva not in ( select cf from conf_ext.bonifica_imprese )
			and piva not in ( select piva from conf_ext.log_bonifica_imprese lbi )
										 ) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
	 	return ret;
		end;
		
	END;
$$;


ALTER FUNCTION conf_ext.get_piva_da_bonificare(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_scarto_flusso_aziende(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.get_scarto_flusso_aziende(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
	flusso bigint;

	begin
		proc_name:='conf_ext.get_dettaglio_scarto_aziende';
		flusso=v->'flusso';
	    if flusso == 0 then --'Flusso Aziende'
	   	  select json_agg(row_to_json(c.*)) into rt from  vw_dettaglio_scarto_aziende c;
	    else ---   --'Flusso Aziende Importante'
	   	 select json_agg(row_to_json(c.*)) into rt from  vw_dettaglio_scarto_aziende_importate c;
	    end if;
	    
		
		raise notice '%',rt;	
		if rt is null then
			ret.esito:=false;	
    	    ret:=ag_ui.build_ret(ret,proc_name, 'get_dettaglio_scarto_aziende_valori_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null; 		 		
 			ret.info:='{"dati":' || rt;
			ret.info:=ret.info || '}';

		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION conf_ext.get_scarto_flusso_aziende(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_toponimi(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.get_toponimi(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
		begin 
			proc_name:='conf_ext.get_toponimi';
			ret.esito:=false;
		select json_agg(row_to_json(a.*)) into rt from (
			select sigla,descrizione from conf_ext.vw_toponimi) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
	 	return ret;
		end;
		
	END;
$$;


ALTER FUNCTION conf_ext.get_toponimi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: load_as_fo_piscine(); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.load_as_fo_piscine() RETURNS text
    LANGUAGE plpgsql
    AS $$
	

DECLARE 
R record;
R_C record;
N integer :=1;

--PER ELIMINARE I DATI INSERITI CI SONO LE TABELLE DI BACKUP IN bck

BEGIN

for R in select * from conf_ext.as_fo_piscine asfo loop	
	
--AZIENDE
	
insert into agenda.aziende (
id,
rag_soc)
values (nextval ('agenda.agenda_id_seq'),
R.denominazione);


select * into R_C from agenda.comuni c where c.comune ilike (trim('.' from upper(R.comune))||'%');


--AZ_SEDI

insert into agenda.az_sedi (
id,
id_azienda,
stato_sede_operativa,
denominazione_sede_operativa,
indirizzo,
id_comune,
id_struttura,
nazione)
values (currval ('agenda.agenda_id_seq'),
currval ('agenda.agenda_id_seq'),
'ATTIVO',
R.denominazione,
R.indirizzo,
R_C.id,
6019408,		--id_gisa della tabella struttura_asl	AS FO
'ITA');

--LINEE

insert into agenda.linee (
id,
denominazione,
indirizzo,
id_az_sede,
id_comune,
id_tipo_linea)
values (currval ('agenda.agenda_id_seq'),
R.denominazione,
R.indirizzo,
currval ('agenda.agenda_id_seq'),
R_C.id,
85);		--id della tabella tipo_linee (85-86-87 gerarchia 'Gestione di piscine')

raise notice 'Eseguita insert n: %', N;
N := N + 1;	
		

end loop;

return '';
		
	END;
$$;


ALTER FUNCTION conf_ext.load_as_fo_piscine() OWNER TO postgres;

--
-- Name: load_piano_tipo_linee(json, bigint); Type: FUNCTION; Schema: conf_ext; Owner: postgres
--

CREATE FUNCTION conf_ext.load_piano_tipo_linee(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	proc_name varchar;
	begin
		proc_name:='ag_conf.load_piano_tipo_linee';

delete from agenda.piano_tipo_linea ;

insert into agenda.piano_tipo_linea 
select id,tl_id, nextval('agenda.agenda_id_seq') from (


			select   distinct a.id, tl.id tl_id--a.alias,,tl.descr 
			--,upper(split_part(a.a,' ',1)),upper(split_part(split_part(t.cod,'-',1),' ',1))
			from (
			select p.id,p.alias,tipo_linea,descrizione,
				case when tipo_linea ilike '%allevamenti%' then 
					case
					when descrizione ilike '%avicoli%' then 'avicoli'
					when descrizione ilike '%broiler%' then 'avicoli'
					when descrizione ilike '%ovaiol%' then 'avicoli'
					when descrizione ilike '%apiar%' then 'api'
					when descrizione ilike '%equidi%' then 'cavalli'
					when descrizione ilike '%annutol%' then 'bufalini'
					else split_part( regexp_replace(descrizione,
						'.*allevament. *',''),' ',1) end else tipo_linea end a ,
			tipo_linea,f.* from conf_ext.dpar_piani_tipolinea_frequenze f 
			join matrix.struttura_piani p on p.alias =f.alias_indicatore
			where tipo_linea is not null and upper(tipo_linea) not in ('','TUTTE','CONTROLLO',',','ISPEZIONE')
			order by alias) a  join agenda.vw_ag_tree_nodes_up_tipo_linee t
				on upper(split_part(a.a,' ',1))=upper(split_part(split_part(t.cod,'-',1),' ',1))
				
				
				join agenda.vw_ag_tree_nodes_down n on t.id_node=n.id_node_ref
				--where t.livello =4
				join agenda.vw_ag_tree_nodes_up_tipo_linee tl on tl.id_node =n.id_node and tl.livello=4   ) b;
				
					 	return ret;
	end;
end;
$$;


ALTER FUNCTION conf_ext.load_piano_tipo_linee(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: crea_cu_from_evento(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.crea_cu_from_evento(v json, idtransazione bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type;
	R_CU cu.cu;
	R_EV agenda.vw_eventi;
	R_CN cu.cu_nucleo;
	R_CP cu.cu_piani;
	id_op bigint;   
	proc_name varchar;
	idcu bigint;
	idazsede bigint;
	idlinea bigint;
	idpiano bigint;
	idperconto bigint;
	idpartner bigint;
	idpartnerpercontodi bigint;
	idrisorsa bigint;
	idnp bigint;
	rt json;
	nord integer;
	idlineaprincipale bigint;
    R_CO cu.cu_oggetti;
	r record;
	n bigint;
	begin
		proc_name:='cu.crea_cu_from_evento';
		ret.esito:=false;
	 	ret.info:=null;
		R_CU.id:=nextval('cu.cu_id_seq');
		R_CU.codice:=nextval('cu.cu_codice_cu')::varchar;
		
		R_CU.id_evento:=v->'id_evento';
		select * into R_EV from agenda.vw_eventi where id=R_CU.id_evento;
		raise notice 'EVENTO %',R_CU.id_evento;
		raise notice 'EVENTO ID_CU %',R_EV.id_cu;
		if R_EV.id_cu is not null then
			raise notice 'EVENTO NULL ID_CU % ',R_EV.id_cu;
			ret.esito:=false;
			ret:=cu_ui.build_ret(ret,proc_name,'cu_gia_generato');
			rt:=row_to_json(ret.*);
			return rt;
		end if;
		R_CU.dt:=R_EV.inizio;
		R_CU.rilievi:= false;
		R_CU.preavviso:= false;
		idrisorsa:=(v->'risorsa')::varchar::bigint;
		if idrisorsa is null then
			idrisorsa:=R_EV.id_risorsa;
		end if;
		idazsede:=(v->'id_az_sede')::varchar::bigint;
		if idazsede is null then
			idazsede:=R_EV.id_az_sede;
		end if;
		R_CU.id_responsabile:=idrisorsa;
		R_CU.chiuso:=false;
		select id into R_CU.id_tecnica from cu_conf.vw_cu_tecniche where
			sigla=R_EV.sigla_tipo_evento;
		idlinea:=v->'id_linea';
		if idlinea is null then
			idlinea:=R_EV.id_linea;
		end if;
		if idlinea is not null then
			select id_az_sede  into R_CU.id_az_sede from agenda.vw_linee where id=idlinea;
			if R_CU.id_az_sede is null then
				ret.esito:=false;
				ret:=cu_ui.build_ret(ret,proc_name,'stabilimento_non_trovato');
				rt:=row_to_json(ret.*);
				return rt;
			end if;
		else
			R_CU.id_az_sede:=v->'id_az_sede';
		end if;
		idpiano:=v->'id_piano';
		if idpiano is null then
			idpiano:=R_EV.id_piano;
		end if;
		/*if R_EV.sigla_tipo_evento='CU' then
			idpiano:=v->'id_piano';
		else
			select p.id into idpiano from cu_conf.piani_speciali cp
			join matrix.strutttura_piani p on p.alias= cp.val
			where sigla='FU_PIANO_DEF' and validita @> current_timestamp;
		
		end if;*/
		idperconto:=v->'per_conto_di';
		if idperconto is null then
			idperconto:=R_EV.id_per_conto;
		end if;
		idpartner:=v->'id_partner';
		raise notice 'PRIMA IDPARTNER %',idpartner;
		if idpartner is null then
			idpartner:=R_EV.id_partner;
		end if;
		raise notice 'DOPO IDPARTNER %',idpartner;
		insert into cu.cu values(R_CU.*) returning * into r;
		n:=cu_log.upd_record('cu.cu',idtransazione,r,'I');

		R_CP.id            :=nextval('cu.cu_id_seq');
		R_CP.id_cu         :=R_CU.id;
		R_CP.id_piano      :=idpiano;
		R_CP.ord           :=1; 
		R_CP.id_perconto_di:=idperconto;
		insert into cu.cu_piani values (R_CP.*) returning * into r;
		n:=cu_log.upd_record('cu.cu_piani',idtransazione,r,'I');
		for R_CO in
			select nextval('cu.cu_id_seq'),R_CU.id, row_number ()over (),op.id_tipo_oggetto,false from
					(select distinct op.id_tipo_oggetto 
			from cu.cu_piani p
			join cu_conf.vw_cu_tipo_oggetto_piani op on op.id_piano =p.id_piano
			left join cu.cu_oggetti o on o.id_cu =p.id_cu and o.id_tipo_oggetto =op.id_tipo_oggetto 
			where p.id_cu=R_CU.id and o.id_cu is null 
			and validita @> localtimestamp) op loop
				insert into cu.cu_oggetti values(R_CO.*) returning * into r;
				n:=cu_log.upd_record('cu.cu_oggetti',idtransazione,r,'I');
				/*
				insert into cu.cu_oggetti_cl
					select nextval('cu.cu_id_seq'),R_CO.id,r.id from cu_conf.cu_requisiti r
					where id_tipo_oggetto= R_CO.id_tipo_oggetto;
				*/
				for r in (select * from cu_conf.cu_requisiti where id_tipo_oggetto= R_CO.id_tipo_oggetto ) loop
					insert into cu.cu_oggetti_cl select nextval('cu.cu_id_seq'),R_CO.id,r.id returning * into r;
					n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,r,'I');
				end loop;
		end loop;
			
		R_CN.id:=nextval('cu.cu_id_seq');
		R_CN.id_cu:=R_CU.id;
		R_CN.id_nominativo :=idrisorsa; --(v->'risorsa')::varchar::bigint;
		R_CN.ord           :=1;
		select id into R_CN.id_tipo_isp from cu_conf.vw_cu_tipo_isp where sigla='ref';
		--R_CN.id_tipo_isp   :=1;
		R_CN.id_tipo_nucleo:=1;
		R_CN.ruolo         :=null;
		R_CN.per_conto_di  :=idperconto; --(v->'per_conto_di')::varchar::bigint;
		insert into cu.cu_nucleo values (R_CN.*) returning * into r;
		n:=cu_log.upd_record('cu.cu_nucleo',idtransazione,r,'I');

		insert into cu.cu_nucleo_periodi values (nextval('cu.cu_id_seq'),R_CN.id,tsrange(null,null,'[)'),R_CP.id) returning * into r;
		n:=cu_log.upd_record('cu.cu_nucleo_periodi',idtransazione,r,'I');

		raise notice 'prima if  IDPARTNER %',idpartner;
		if idpartner is not null then
			raise notice 'dentro  if  IDPARTNER %',idpartner;
			idpartnerpercontodi:=v->'id_partner_per_conto_di';
			idnp:=nextval('cu.cu_id_seq');
			insert into cu.cu_nucleo values (idnp,R_CU.id,idpartner,2,
						(select id from cu_conf.vw_cu_tipo_isp where sigla='def'),1,null,
				idpartnerpercontodi) returning * into r;
			n:=cu_log.upd_record('cu.cu_nucleo',idtransazione,r,'I');

			insert into cu.cu_nucleo_periodi values (nextval('cu.cu_id_seq'),idnp,tsrange(null,null,'[)'),R_CP.id) returning * into r;
			n:=cu_log.upd_record('cu.cu_nucleo_periodi',idtransazione,r,'I');
		end if;

		if upper(R_EV.sigla_tipo_evento)='CU' or upper(R_EV.sigla_tipo_evento)='AS' or upper(R_EV.sigla_tipo_evento)='CT' then
			select id into idlineaprincipale from cu_anag.linee
				where id_stabilimento=idazsede and linea_principale order by id limit 1;
			nord=1;
			/* issue #11491 
			if idlineaprincipale!=idlinea then
				insert into cu.cu_linee values (nextval('cu.cu_id_seq'),R_CU.id,idlineaprincipale,1);
				nord:=2;
			end if;
			*/
			insert into cu.cu_linee values (nextval('cu.cu_id_seq'),R_CU.id,idlinea,nord, true) returning * into r;
			n:=cu_log.upd_record('cu.cu_linee',idtransazione,r,'I');
			insert into cu.cu_nominativo_provv values (nextval('cu.cu_id_seq'), R_CU.id, idrisorsa) returning * into r;
			n:=cu_log.upd_record('cu.cu_nominativo_provv',idtransazione,r,'I');
		end if;
		
		if upper(R_EV.sigla_tipo_evento)='FU' then
			insert into cu.cu_provv_fu
				select nextval('cu.cu_id_seq'),R_CU.id,p.id from cu.vw_cu_provv p 
				where (select chiuso from cu.vw_cu where id_cu = R_CU.id) and id_az_sede=R_CU.id_az_sede and dt <=R_CU.dt and fu_richiesto and (p.chiuso is null or p.chiuso is not true);
		end if;
	
			
		if upper(R_EV.sigla_tipo_evento)='FS' then
			update cu.cu_provv_sopralluogo_fu 
			set id_cu = R_CU.id
			where id_cu = R_EV.id;
		end if;
		
		
		if upper(R_EV.sigla_tipo_evento)='S' then
			insert into cu.cu_evidenze_s
				select nextval('cu.cu_id_seq'),R_CU.id,e.id,e.id_cu_grado_evidenza,risultanza, id_cu_classe_evidenza,
				row_number () over (order by dt_cu,ord)from cu.vw_cu_evidenze e 
				where id_az_sede=R_CU.id_az_sede and dt <=R_CU.dt and sigla_classe_evidenza='S';
		end if;

    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:='{"id_cu":'||R_CU.id||'}';
	 	rt:=row_to_json(ret.*);
	 	return rt;
	end;
end;
$$;


ALTER FUNCTION cu.crea_cu_from_evento(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: cu_aggiorna_norme_violate(bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.cu_aggiorna_norme_violate(idcu bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type;
	retl cu_types.result_type;
	id_op bigint;   
	proc_name varchar;
	R_NV cu.cu_norme_violate%ROWTYPE;
	R_E cu.vw_cu_evidenze%ROWTYPE;
	rt json;
	begin
		proc_name:='cu.cu_aggiorna_norme_violate';
		ret.esito:=false;
	
		--16/04/2024 SL
		for R_NV in (select * from cu.cu_norme_violate 
					 where id_cu=idcu and id_norma 
					 not in (select distinct e.id_norma from cu.vw_cu_evidenze e where e.id_cu = idcu))
		loop
			retl:=cu.cu_del_provv_norme_violate(R_NV.id);
		end loop;
		

		for R_E in (select * from cu.vw_cu_evidenze e
					where e.id_cu = idcu and id_norma 
					not in (select id_norma from cu.cu_norme_violate where id_cu=idcu))
		loop 
			insert into cu.cu_norme_violate values(nextval('cu.cu_id_seq'),R_E.id_cu,R_E.id_norma) returning * into R_NV;
			--cu_log.upd_record('cu.cu_norme_violate','I',R_NV);
		end loop;
	
		/*
		delete from cu.cu_norme_violate where id_cu=idcu and id_norma not in (
			select distinct  e.id_norma
			from cu.vw_cu_evidenze e 
			where e.id_cu = idcu);
		*/
	
		/*
		insert into cu.cu_norme_violate
		select nextval('cu.cu_id_seq'),idcu,a.id_norma from
		
		(select distinct  e.id_norma
			from cu.vw_cu_evidenze e 
			where e.id_cu = idcu and id_norma not in (
			select id_norma from cu.cu_norme_violate where id_cu=idcu
			)) a;
		*/
		
		raise notice 'RT %',rt;
	
		ret.esito:=true;
		--ret.info:='{"dati":'||coalesce(rt,'[]')::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.cu_aggiorna_norme_violate(idcu bigint) OWNER TO postgres;

--
-- Name: cu_aggiorna_norme_violate(bigint, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.cu_aggiorna_norme_violate(idcu bigint, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type;
	retl cu_types.result_type;
	id_op bigint;   
	proc_name varchar;
	R_NV cu.cu_norme_violate%ROWTYPE;
	R_E cu.vw_cu_evidenze%ROWTYPE;
	n bigint;
	rt json;
	begin
		proc_name:='cu.cu_aggiorna_norme_violate';
		ret.esito:=false;
	
		--16/04/2024 SL
		for R_NV in (select * from cu.cu_norme_violate 
					 where id_cu=idcu and id_norma 
					 not in (select distinct e.id_norma from cu.vw_cu_evidenze e 
					 		where e.id_cu = idcu and e.sigla_classe_evidenza ilike 'nc'))
		loop
			retl:=cu.cu_del_provv_norme_violate(R_NV.id);
		end loop;
		

		for R_E in (select * from cu.vw_cu_evidenze e
					where e.id_cu = idcu and id_norma 
					not in (select id_norma from cu.cu_norme_violate where id_cu=idcu)
					and e.sigla_classe_evidenza ilike 'nc')
		loop 
			insert into cu.cu_norme_violate values(nextval('cu.cu_id_seq'),R_E.id_cu,R_E.id_norma) returning * into R_NV;
			n:=cu_log.upd_record('cu.cu_norme_violate',idtransazione,R_NV,'I');
		end loop;
	
		/*
		delete from cu.cu_norme_violate where id_cu=idcu and id_norma not in (
			select distinct  e.id_norma
			from cu.vw_cu_evidenze e 
			where e.id_cu = idcu);
		*/
	
		/*
		insert into cu.cu_norme_violate
		select nextval('cu.cu_id_seq'),idcu,a.id_norma from
		
		(select distinct  e.id_norma
			from cu.vw_cu_evidenze e 
			where e.id_cu = idcu and id_norma not in (
			select id_norma from cu.cu_norme_violate where id_cu=idcu
			)) a;
		*/
		
		raise notice 'RT %',rt;
	
		ret.esito:=true;
		--ret.info:='{"dati":'||coalesce(rt,'[]')::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.cu_aggiorna_norme_violate(idcu bigint, idtransazione bigint) OWNER TO postgres;

--
-- Name: cu_check_automezzi(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.cu_check_automezzi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idcu bigint;
	n_automezzi bigint;
	n_indirizzi bigint;
	begin
		proc_name:='cu.cu_check_automezzi';
		ret.esito:=false;
		idcu=v->'id_cu'; 
	
				
		select count(*) into n_indirizzi from cu.cu_indirizzi
		where id_cu = idcu;
		
		select count(*) into n_automezzi from cu.cu_automezzi
		where id_cu = idcu;

		if n_indirizzi <= 0 and n_automezzi <= 0 then
			ret:=cu_ui.build_ret(ret,proc_name,'automezzi_inserire_indirizzo_e_automezzo');
			return ret;
		end if;	

		if n_indirizzi <= 0 then
			ret:=cu_ui.build_ret(ret,proc_name,'automezzi_inserire_indirizzo');
			return ret;
		end if;	
		if n_automezzi <= 0 then
			ret:=cu_ui.build_ret(ret,proc_name,'automezzi_inserire_automezzo');
			return ret;
		end if;	
	
		ret.esito:=true;
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.cu_check_automezzi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: cu_check_categoria_rischio(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.cu_check_categoria_rischio(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idcu bigint;
	idroot bigint = null;
	n bigint;
	n_gruppi_foglie bigint;
	R_CU record;
	R_STAB record;
	_n_check_piani bigint;
	_n_check_categ_storico bigint;
	_latest_categ timestamp;
	_latest_linea timestamp;
	begin
		proc_name:='cu.cu_check_categoria_rischio';
		ret.esito:=false;
		idcu=v->'id_cu';
	
		select *  into R_CU from cu.cu where id=idcu;
	
		--prendi nodo radice da tipologia struttura 15/05/2024 SL
		select id_categorizzazione_rischio into idroot from cu_anag.stabilimenti s 
		join cu.categorizzazione_rischio_tipo_stabilimento c on s.id_tipologia_struttura = c.id_tipo_stabilimento 
		where s.id = (select id_az_sede from cu.cu where id = idcu);
	
		--15/07/2024 issue #11980
	if idroot > 0 then
		if R_CU.chiuso is false then
			if (select count(*) from cu.vw_cu_piani p where p.id_cu = idcu and p.alias ilike '%A61_A%') = 0 then
			
				select * into R_STAB from cu_anag.vw_stabilimenti_all s where s.id_stabilimento = R_CU.id_az_sede;
				select count(*) into _n_check_piani from cu.vw_cu_piani p
				where p.id_cu = idcu 
				and p.descrizione_piano ilike '%audit%' and R_STAB.cod_tipologia_struttura in ('852','853');
			
				raise notice 'AUDIT _n_check_piani %',_n_check_piani;
					
				--852 e 853 categ_null
				select dt_storico into _latest_categ from cu.cu_categ_evals_storico
				where id_stabilimento = R_STAB.id_stabilimento
				and R_STAB.cod_tipologia_struttura in ('852')--,'853') 
				order by dt_storico desc
				limit 1;
			
				select la.inizio_validita into _latest_linea from cu.vw_cu_linee cl
				join cu_anag.vw_linee_all la on la.id_linea = cl.id_linea 
				where cl.id_cu = R_CU.id
				order by la.inizio_validita desc
				limit 1;
			
				if (_latest_categ is null or _latest_categ < _latest_linea) and R_STAB.cod_tipologia_struttura != '853' then
					_n_check_categ_storico := 1;
				else
					_n_check_categ_storico := 0;
				end if;
			
				if _n_check_piani <= 0 and _n_check_categ_storico <= 0 	then
					idroot:= 0;
				end if;
		
			end if;
		
			
		else --R_CU.chiuso true
			if (select count(*) from cu.cu_categ_evals_storico where id_cu = R_CU.id) <= 0 then
				idroot:= 0;
			end if;
		end if;
		
	
	end if;
		
		if idroot > 0 then
			select count(*) into n from cu.vw_cu_categ_evals where id_cu = idcu;
			
			select count(distinct n.id_node_parent) into n_gruppi_foglie from cu_conf.vw_cu_categ_nodes n
			join cu_conf.vw_cu_categ_nodes_down down on n.id_node = down.id_node 
			where down.id_node_ref = idroot
			and n.id_node not in 
			(select distinct id_node_parent from cu_conf.vw_cu_categ_nodes where id_node_parent is not null);
	
			--albero 852
			if (idroot = 247) then
				n_gruppi_foglie = n_gruppi_foglie - 1;
			end if;
		
			if n != n_gruppi_foglie then
				ret:=cu_ui.build_ret(ret,proc_name,'completare_categorizzazione_rischio');
				return ret;
			end if;	
	 	end if;
	
		ret.esito:=true;
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.cu_check_categoria_rischio(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: cu_check_nuclei(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.cu_check_nuclei(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idcu bigint;
	n bigint;
	begin
		proc_name:='cu.cu_check_ni';
		ret.esito:=false;
		idcu=v->'id_cu';
	
		select count(*) into n from (
			select n.id_tipo_isp ,t.rng,count(*) cnt from cu_conf.vw_cu_tipo_isp t 
			left join cu.vw_cu_nucleo_ni n on n.id_tipo_isp =t.id_tipo_isp and id_cu=idcu
			group by 1,2
		) a where not (a.rng @> cnt::numeric);
		if n>0 then
			ret:=cu_ui.build_ret(ret,proc_name,'numero_di_ispettori_non_rispettato');
			return ret;
		end if;
	
		/*controllare che ci sia il responsabile*/
		select count(*) into n from cu_conf.vw_cu_tipo_isp t 
		left join cu.vw_cu_nucleo_ni n on n.id_tipo_isp =t.id_tipo_isp
		where t.id = 2 and id_cu=idcu;
	
		if n<=0 then
			ret:=cu_ui.build_ret(ret,proc_name,'numero_di_ispettori_non_rispettato');
			return ret;
		end if;
	
		--controllare che ci sia il numero minimo di personale presente
		/* potrebbe servire in futuro 05/03/2024
		select count(*) into n from cu.vw_cu_nucleo_p p
		where id_cu=idcu;
	
		if n<=0 then
			ret:=cu_ui.build_ret(ret,proc_name,'numero_di_ispettori_non_rispettato');
			return ret;
		end if;
		*/
	
		/* DA CONTROLLARE che tutti abbiano un orario */

		
		select count(*) into n from cu.vw_cu_nucleo t 
		left join cu.cu_nucleo_periodi n on n.id_cu_nucleo =t.id 
		where t.id_cu=idcu and (n.id is null or lower_inf(periodo) or upper_inf(periodo));

		if n>0 then
			raise notice 'Chiamare build_ret %',proc_name;
			ret:=cu_ui.build_ret(ret,proc_name,'mancano_i_periodi_per_i_presenti');
			return ret;
		end if;	
		ret.esito:=true;
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.cu_check_nuclei(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: cu_check_oggetti(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.cu_check_oggetti(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idcu bigint;
	n_ogg bigint;
	n_ogg_chiusi bigint;
	begin
		proc_name:='cu.cu_check_oggetti';
		ret.esito:=false;
		idcu=v->'id_cu';
	
		select count(*) into n_ogg from cu.vw_cu_oggetti where id_cu = idcu;
		select count(*) into n_ogg_chiusi from cu.vw_cu_oggetti where id_cu = idcu and chiuso;
	
		if n_ogg=0 then
			ret:=cu_ui.build_ret(ret,proc_name,'nessun_oggetto_associato');
			return ret;
		end if;	
	
		if n_ogg_chiusi != n_ogg then
			ret:=cu_ui.build_ret(ret,proc_name,'chiudere_tutti_gli_oggetti');
			return ret;
		end if;	
	
		ret.esito:=true;
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.cu_check_oggetti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: cu_check_provv_fu(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.cu_check_provv_fu(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idcu bigint;
	n_provv bigint;
	n_provv_null bigint;
	begin
		proc_name:='cu.cu_check_provv_fu';
		ret.esito:=false;
		idcu=v->'id_cu';
	
		select count(*) into n_provv from cu.vw_cu_provv_fu where id_cu = idcu and risolta is null;
		select count(*) into n_provv_null from cu.vw_cu_oggetti where id_cu = idcu and risolta is null;
	
		if n_provv=0 then
			ret:=cu_ui.build_ret(ret,proc_name,'fu_nessun_provvedimento_associato');
			return ret;
		end if;	
	
		if n_provv_null > 0 then
			ret:=cu_ui.build_ret(ret,proc_name,'fu_risolvere_tutti_i_provvedimenti');
			return ret;
		end if;	
	
		ret.esito:=true;
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.cu_check_provv_fu(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: cu_check_provvedimenti(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.cu_check_provvedimenti(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idcu bigint;
	n bigint;
	begin
		proc_name:='cu.cu_check_provvedimenti';
		ret.esito:=false;
		idcu=v->'id_cu'; 
	
				
		select count(*) into n from (	
			select id_norma from cu.vw_cu_evidenze vce where id_cu = idcu
			and id_cu_classe_evidenza in (1,2)
		) a where a.id_norma not in (
			select distinct(vcnv.id_norma) from cu.vw_cu_norme_violate vcnv 
			join cu.vw_cu_provv vcp on vcp.id_evidenza = vcnv.id_norma_violata 
			where vcp.id_cu = idcu and vcp.id_norma in (
					select id_norma from cu.vw_cu_evidenze vce 
					where vce.id_cu = idcu
					and id_cu_classe_evidenza in (1,2)
				)
		);
		
		if n > 0 then
			ret:=cu_ui.build_ret(ret,proc_name,'nc_senza_provvedimenti');
			return ret;
		end if;	
	
		ret.esito:=true;
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.cu_check_provvedimenti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: cu_check_provvedimenti_fu(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.cu_check_provvedimenti_fu(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idcu bigint;
	n bigint;
	begin
		proc_name:='cu.cu_check_provvedimenti_fu';
		ret.esito:=false;
		idcu=v->'id_cu'; 
	
				
		select count(*) into n from cu.vw_cu_provv_fu vcpf
		where risolta is null --tutti i provv associati al fu non risolti
		and id_cu = idcu;
		
		if n > 0 then
			ret:=cu_ui.build_ret(ret,proc_name,'provv_associati_non_risolti');
			return ret;
		end if;	
	
		ret.esito:=true;
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.cu_check_provvedimenti_fu(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: cu_check_stabilimento(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.cu_check_stabilimento(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idcu bigint;
	n bigint;
	R_CU cu.vw_cu;
	R_STAB cu_anag.vw_stabilimenti;
	begin
		proc_name:='cu.cu_check_stabilimento';
		ret.esito:=false;
		idcu=v->'id_cu';
		select * into R_CU from cu.vw_cu where id=idcu;
		select * into R_STAB from cu_anag.vw_stabilimenti
			where id=R_CU.id_az_sede; 
	
		/*if n<=0 then
			ret:=cu_ui.build_ret(ret,proc_name,'numero_di_ispettori_non_rispettato');
			return ret;
		end if;*/
		if not R_STAB.verificato then
			ret:=cu_ui.build_ret(ret,proc_name,'anagrafica_stabilimento_incompleta');
			return ret;
		end if;	
	/*	if not R_STAB.verificato_impresa then
			ret:=cu_ui.build_ret(ret,proc_name,'anagrafica_impresa_incompleta');
			return ret;
		end if;	*/
		ret.esito:=true;
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.cu_check_stabilimento(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: cu_del_provv_norme_violate(bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.cu_del_provv_norme_violate(id_norma bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_NV cu.cu_norme_violate%ROWTYPE;
	R_P cu.cu_provv%ROWTYPE;
	n bigint;
	rt json;
	begin
		proc_name:='cu.cu_del_provv_norme_violate';
		ret.esito:=false;
		--16/04/2024 SL
	
		--elimina provvedimenti
		for R_P in (select * from cu.cu_provv where id_norma_violata = id_norma)
		loop 
			--log
			delete from cu.cu_provv where id = R_P.id;
			--n:=cu_log.upd_record('cu.cu_provv',-1,R_P.'D');
		end loop;
		
		--elimina norma_violata
		delete from cu.cu_norme_violate where id = $1 returning * into R_NV;
		n:=cu_log.upd_record('cu.cu_norme_violate',-1,R_NV,'D');
	
		
		raise notice 'RT %',rt;
	
		ret.esito:=true;
		--ret.info:='{"dati":'||coalesce(rt,'[]')::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$_$;


ALTER FUNCTION cu.cu_del_provv_norme_violate(id_norma bigint) OWNER TO postgres;

--
-- Name: delete_cu(bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.delete_cu(idcu bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
begin
	declare
	R_CU cu.cu;
	total_rows integer;
	begin
		
	select * into R_CU from cu.cu where id=idcu;

	if R_CU.id is null then return false; end if;
		
delete from cu.nomi_file_pdf_controlli where id_cu = idcu;	
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM nomi_file_pdf_controlli %',total_rows;	 

delete from cu.nomi_file_pdf_evidenze where id_evidenza in (select id from cu.vw_cu_evidenze where id_cu = idcu);	
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM nomi_file_pdf_evidenze %',total_rows;

delete from cu.cu_nucleo_periodi where id_cu_nucleo in (select id from cu.cu_nucleo where id_cu = idcu);
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu_nucleo_periodi %',total_rows;

delete from cu.cu_dichiarazioni where id_cu_nucleo in (select id from cu.cu_nucleo where id_cu = idcu);
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu_dichiarazioni %',total_rows;

delete from cu.cu_nucleo where id_cu = idcu;
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu_nucleo %',total_rows;

delete from cu.cu_evidenza_linee where id_cu_linea in (select id from cu.cu_linee where id_cu = idcu);
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu_evidenza_linee %',total_rows;

delete from cu.cu_linee where id_cu = idcu;
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu_linee %',total_rows;

delete from cu.cu_categ_evals where id_cu = idcu;
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu_categ_evals %',total_rows;

delete from cu.cu_evidenze_sp where id_cu = idcu;
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu_evidenze_sp %',total_rows;

delete from cu.cu_evidenze where id_cu_oggetto_cl in 
(select oc.id from cu.cu_oggetti_cl oc 
join cu.cu_oggetti o on oc.id_cu_oggetto = o.id
where o.id_cu = idcu);
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu_evidenze %',total_rows;

delete from cu.cu_oggetti_cl where id_cu_oggetto in (select id from cu.cu_oggetti where id_cu = idcu);
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu_oggetti_cl %',total_rows;

delete from cu.cu_oggetti where id_cu = idcu;
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu_oggetti %',total_rows;

--delete from cu.cu_provv_fu where id_cu = idcu;	--2024-05-08
delete from cu.cu_provv_fu where id_provv in (
select id from cu.cu_provv where id_norma_violata in (select id from cu.cu_norme_violate where id_cu =idcu));
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu_provv_fu %',total_rows;


delete from cu.cu_provv where id_norma_violata in (select id from cu.cu_norme_violate where id_cu = idcu);
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu_provv %',total_rows;


delete from cu.cu_norme_violate where id_cu = idcu;
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu_norme_violate %',total_rows;

delete from cu.cu_piani where id_cu = idcu;
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu_piani %',total_rows;
		
delete from cu.cu where id=idcu;		
GET DIAGNOSTICS total_rows := ROW_COUNT;
raise notice 'DELETE FROM cu %',total_rows;
	
	 	return true;
end;
end;
$$;


ALTER FUNCTION cu.delete_cu(idcu bigint) OWNER TO postgres;

--
-- Name: delete_cu_by_codice(bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.delete_cu_by_codice(cod bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
begin
	declare
	R_CU cu.cu;
	total_rows integer;
	begin
		
	select * into R_CU from cu.cu where cu.codice::bigint = cod;

	if R_CU.id is null then return false; end if;

return cu.delete_cu(R_CU.id);
	 	
end;
end;
$$;


ALTER FUNCTION cu.delete_cu_by_codice(cod bigint) OWNER TO postgres;

--
-- Name: get_asl(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_asl(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$

begin

declare

ret cu_types.result_type;

id_op bigint;

proc_name varchar;

R_CU cu.vw_cu%ROWTYPE;

rt json;

idcu bigint;

idstrutturaasl bigint;

R_ASL record;

idasl bigint;


begin

proc_name:='cu.get_piani';

ret.esito:=false;

/*idcu=v->'id_cu';

 select * into R_CU from cu.vw_cu where id_cu=idcu;

 if R_CU.id is null then

 ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');

 return ret;

 end if;*/

idstrutturaasl=v->'user_info'->'id_struttura_root';

idasl=v->'user_info'->'id_asl';


select json_agg(row_to_json(a.*)) into rt from (


--select * from matrix.vw_tree_nodes_up_asl 

select c.name_tree,c.id_node,c.id_tree,case when c.n_livello =1 then null else c.id_node_parent end id_node_parent,

c.id_node_parent id_node_ref,c.id,c.id_gisa,c.id_asl,c.codice_interno_fk,

c.descrizione descrizione,c.n_livello,c.anno,c.descrizione_breve,c.ups,c.uba

from matrix.vw_tree_nodes_up_asl c

where c.id_asl=idasl and

anno=(select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int

/* and c.data_Scadenza is null and c.trashed_date is null */order by c.descrizione_breve


) a;

raise notice 'RT %',rt;


ret.esito:=true;

--ret.info:=rt;

ret.info:='{"dati":'||rt::varchar||'}';

raise notice 'ret.info %',ret.info;

return ret;

end;

end;

$$;


ALTER FUNCTION cu.get_asl(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_categorie_rischio_alberi(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_categorie_rischio_alberi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin 
		declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
        idtipostruttura bigint;
    	rt json;
		begin
		proc_name:='cu.get_categorie_rischio_alberi';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		idtipostruttura:= v->'id_tipo_struttura';
		raise notice 'V=%', v;
	
		select json_agg(row_to_json(a.*)) into rt   from (
			select * , crts.id is not null selezionato
			from cu_conf.vw_cu_categ_alberi vcca
			join cu_types.vw_tipologie_struttura vts on 1=1
			left join cu.categorizzazione_rischio_tipo_stabilimento crts on crts.id_categorizzazione_rischio = vcca.id and crts.id_tipo_stabilimento = vts.id_tipologia_struttura 
			where vts.id_tipologia_struttura = idtipostruttura) a;
		
		raise notice 'RT %',rt;
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
 		return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_categorie_rischio_alberi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	idstrutturaroot bigint;
	proc_name varchar;
	R_CU cu.vw_cu_con_periodo%ROWTYPE;
	rt json;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu.get_cu';
		ret.esito:=false;
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
	
		--idstrutturaasl=v->'user_info'->'id_struttura_root';
		--raise notice 'idstrutturaasl: %', idstrutturaasl;
		--select * into R_ASL from matrix.struttura_asl where id=idstrutturaasl;
		--raise notice 'idasl: %', R_ASL.id_asl;

		select json_agg(row_to_json(a.*)) into rt   from (select * from cu.vw_cu_con_periodo order by dt desc, codice desc) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_automezzi(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_automezzi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin 
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idcu bigint;
	begin
		proc_name:='cu.get_cu_automezzi';

		idcu:=v->>'id_cu';
	
		select json_agg(row_to_json(a.*)) into rt from (
			select * from cu.cu_automezzi ca
			join cu_anag.vw_automezzi va on ca.id_automezzo = va.id_automezzo 
			where ca.id_cu = idcu
		) a ;
		raise notice 'RT %',rt;
		
		/*
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'automezzi_non_trovati');
			ret.esito:=false;
			return ret;
    	end if;
		*/
	 	--ret.info:=rt;

		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_automezzi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_categ_eval(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_categ_eval(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	rt json;
	idcu bigint;
	idroot bigint;
	begin
		proc_name:='cu.get_cu_categ_eval';
		ret.esito:=false;
		idcu=v->'id_cu';
		
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
	
		--prendi nodo radice da conf in base al piano del cu OBS
		/*
		select id_node into idroot from cu.vw_cu_piani p
		join cu_conf.cu_piani_categ c on p.id_piano = c.id_piano 
		where id_cu = R_CU.id;
		*/
		if R_CU.chiuso then
			select albero_cs into rt from cu.cu_categ_evals_storico where id_cu = R_CU.id;
		else
			--prendi nodo radice da tipologia struttura 15/05
			select id_categorizzazione_rischio into idroot from cu_anag.stabilimenti s 
			join cu.categorizzazione_rischio_tipo_stabilimento c on s.id_tipologia_struttura = c.id_tipo_stabilimento 
			where s.id = R_CU.id_az_sede;
			
			select json_agg(row_to_json(c.*)) into rt   from (
			
						select n.descr ||
					case when v.valore != 0 then ' ('||v.valore ||')' else '' end ||
					case when n.peso   != 0 then ' ('||n.peso||')'    else '' end ||
					case when n.fattore!= 1 then ' x'||n.fattore else '' end || coalesce(' '||e.descr,'') descrizione_breve 
					,case when n.id_node = idroot then null else n.id_node_parent end id_node_parent
					,n.id,n.cod,n.sigla,n.descr,n.fattore,n.peso,n.id_node
					,n.path,n.path_ord,n.path_descr
					,n.lv,n.node_descr,n.ordinamento
					,v.valore
					,ev.id is not null selezionato
					,e.descr
				from cu_conf.vw_cu_categ_nodes_up_descr n join
				(select n.id_node_ref,sum(peso*coalesce(e.valore,0)) valore
				from cu_conf.vw_cu_categ_nodes_down n left join cu.vw_cu_categ_evals e on n.id_node=e.id_categ and id_cu=idcu
				group by 1) v on n.id_node =v.id_node_ref
				left join cu.vw_cu_categ_evals ev on n.id_node=ev.id_categ and id_cu=idcu
				left join cu_conf.vw_cu_categ_esiti e on n.id_node_parent is null and  e.rng  @> v.valore
				join cu_conf.vw_cu_categ_nodes_down down on n.id_node = down.id_node 
				where down.id_node_ref = idroot
				order by n.id_node
			) c ;
		end if;
		
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_categ_eval(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_cl_nuovi_stati(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_cl_nuovi_stati(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcu  bigint;
      	idns bigint;
     	ini timestamp;
     	fin timestamp;
        proc_name varchar; -- end
        R_CL cu.vw_cu_oggetti_cl;
       	chiudi boolean;
       	nuovostato varchar;
      	idcuoggettocl bigint;
     	n_ev integer;
    	rt json;
	begin
		proc_name:='cu.get_cu_cl_nuovi_stati';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;
		idcuoggettocl:=v_j->'id_cu_oggetto_cl';
		select * into R_CL from cu.vw_cu_oggetti_cl where id_cu_oggetto_cl=idcuoggettocl;
		if R_CL.id is null then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'oggetto_cl_non_esiste');
	    		return ret;
		end if;
		if R_CL.chiuso  then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'oggetto_cl_gia_chiuso');
	    		return ret;
		end if;
		select count(*) into n_ev from cu.cu_evidenze where id_cu_oggetto_cl=idcuoggettocl;
		if n_ev>0 then n_ev:=1; end if;
	
			select json_agg(row_to_json(a.*)) into rt   from (
			select *  from cu_types.vw_cu_stati_cl where evidenze>= n_ev) a;
		raise notice 'RT %',rt;
		ret.esito:=true;
	 	ret.info:='{"nuovi_stati":'||rt::varchar||'}';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.get_cu_cl_nuovi_stati(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_cl_nuovi_stati_massivo(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_cl_nuovi_stati_massivo(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcu  bigint;
      	idns bigint;
     	ini timestamp;
     	fin timestamp;
        proc_name varchar; -- end
        R_CL cu.vw_cu_oggetti_cl;
       	chiudi boolean;
       	nuovostato varchar;
      	idcuoggettocl bigint;
     	n_ev integer;
    	rt json;
	begin
		proc_name:='cu.get_cu_cl_nuovi_stati_massivo';
		raise notice 'V_J=%', v_j;
	
		/*
		idcuoggettocl:=v_j->'id_cu_oggetto_cl';
		select * into R_CL from cu.vw_cu_oggetti_cl where id_cu_oggetto_cl=idcuoggettocl;
		if R_CL.id is null then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'oggetto_cl_non_esiste');
	    		return ret;
		end if;
		if R_CL.chiuso  then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'oggetto_cl_gia_chiuso');
	    		return ret;
		end if;
		*/
	
		n_ev := 0;
		for idcuoggettocl in select (value::varchar)::bigint id
			from json_array_elements(v_j->'id_cu_oggetto_cl') loop
				n_ev := n_ev + (select count(*) from cu.cu_evidenze 
								where id_cu_oggetto_cl=idcuoggettocl and id_cu_classe_evidenza between 1 and 2);
		end loop;
			
		--select count(*) into n_ev from cu.cu_evidenze where id_cu_oggetto_cl=idcuoggettocl;
		if n_ev>0 then n_ev:=1; end if;

		select json_agg(row_to_json(a.*)) into rt   from (
			select *, (evidenze = n_ev) selezionabile
			from cu_types.vw_cu_stati_cl --where evidenze>= n_ev 
		order by ord) a;
		
		raise notice 'RT %',rt;
		ret.esito:=true;
	 	ret.info:='{"nuovi_stati":'||rt::varchar||'}';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.get_cu_cl_nuovi_stati_massivo(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_dichiarazione(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_dichiarazione(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CUN cu.cu_nucleo%ROWTYPE;
	rt json;
	idcunucleo bigint;
	begin
		proc_name:='cu.get_cu_dichiarazione';
		ret.esito:=false;
		idcunucleo=v->'id_cu_nucleo';
		
		
		if (select id from cu.vw_cu_nucleo where id_cu_nucleo=idcunucleo) is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_nucleo_non_trovato');
			return ret;
		end if;
		
		select json_agg(row_to_json(c.*)) into rt   from (
				select *
				from cu.vw_cu_dichiarazioni
				where id_cu_nucleo=idcunucleo
			
		) c ;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_dichiarazione(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_esterni(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_esterni(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	rt json;
	idcu bigint;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu.get_cu_esterni';
		ret.esito:=false;
		idcu=v->'id_cu';
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;

		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu.vw_cu_nucleo_periodi where id_cu =R_CU.id and id_tipo_nucleo=2) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||',"controllo_chiuso":'||R_CU.chiuso||'}';

		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_esterni(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_evidenze(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_evidenze(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CL cu.vw_cu_oggetti_cl%ROWTYPE;
	R_CU cu.vw_cu%ROWTYPE;
	idcu bigint;
	rt json;
	rt_cl json;
	idcuoggettocl bigint;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu.get_cu_evidenze';
		ret.esito:=false;
		idcuoggettocl=v->'id_cu_oggetto_cl';
		idcu=v->'id_cu';
		select * into R_CL from cu.vw_cu_oggetti_cl where id=idcuoggettocl;
		if R_CL.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_oggetto_cl_non_trovato');
			return ret;
		end if;
		--idstrutturaasl=v->'user_info'->'id_struttura_root';
		--raise notice 'idstrutturaasl: %', idstrutturaasl;
		--select * into R_ASL from matrix.struttura_asl where id=idstrutturaasl;
		--raise notice 'idasl: %', R_ASL.id_asl;
		if idcu is null then
			select * into R_CU from cu.vw_cu where id_cu=R_CL.id_cu;
			if R_CU.id is null then
				ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
				return ret;
			end if;
		else
			select * into R_CU from cu.vw_cu where id_cu=idcu;
			if R_CU.id is null then
				ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
				return ret;
			end if;
		end if;

		if R_CU.sigla_tecnica = 'SP'
		then
			select json_agg(row_to_json(a.*)) into rt   from (
				select e.* ,false selezionato
				--, not (R_CU.chiuso or R_CL.chiuso) selezionabile
				, not (R_CU.chiuso or R_CL.chiuso) and /*R_CU.id_tecnica != 4*/ R_CU.sigla_tecnica = 'CU' selezionabile
					from (select e.*,l.descr descr_linee, l.id_cu_linea,p.n_provv
					from cu.cu_evdenze_sp esp join cu.vw_cu_evidenze e on e.id=esp.id_cu_evidenza
					left join cu.vw_evidenza_lista_linee l on e.id=l.id_cu_evidenza
					join cu.vw_evidenza_numero_provv p on p.id_evidenza=e.id_evidenza
					where id_cu_oggetto_cl=idcuoggettocl) e
			) a;
		else
			select json_agg(row_to_json(a.*)) into rt   from (
				/* 07/03/2024 per rimuovere le evidenze duplicate (solo in visualizzazione)
				select e.* ,false selezionato
				--, not (R_CU.chiuso or R_CL.chiuso) selezionabile
				, not (R_CU.chiuso or R_CL.chiuso) and /*R_CU.id_tecnica != 4*/ R_CU.sigla_tecnica = 'CU' selezionabile
					from (select e.*,l.descr descr_linee, l.id_cu_linea,p.n_provv
					from cu.vw_cu_evidenze e
					left join cu.vw_evidenza_lista_linee l on e.id=l.id_cu_evidenza
					join cu.vw_evidenza_numero_provv p on p.id_evidenza=e.id_evidenza
					where id_cu_oggetto_cl=idcuoggettocl) e 
				
				*/
				select e.* ,false selezionato
				--, not (R_CU.chiuso or R_CL.chiuso) selezionabile
				, not (R_CU.chiuso or R_CL.chiuso) and /*R_CU.id_tecnica != 4*/ R_CU.sigla_tecnica = 'CU' selezionabile
					from (select e.*  
					,(select string_agg(descr, ', ') from cu.vw_evidenza_lista_linee l where l.id_cu_evidenza = e.id) descr_linee
					,(select array_agg(id_cu_linea) from cu.vw_evidenza_lista_linee l where l.id_cu_evidenza = e.id) lista_linee
					,p.n_provv
					from cu.vw_cu_evidenze e
					join cu.vw_evidenza_numero_provv p on p.id_evidenza=e.id_evidenza
					where id_cu_oggetto_cl=idcuoggettocl) e
					
			) a;
		end if;
		raise notice 'RT %',rt;
	
		--select json_build_object('id_tipo_oggetto', R_CL.id_tipo_oggetto,'descr_oggetto', R_CL.descr_oggetto, 'descr_requisito', R_CL.descr_requisito) into rt_cl;
		
		select to_json(R_CL) into rt_cl;
			
		ret.esito:=true;
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||rt::varchar||',"chiuso":'||R_CL.chiuso||'}';
		--ret.info:='{"dati":'||coalesce(rt,'[]')::varchar||',"controllo_chiuso":'||R_CU.chiuso||',"chiuso":'||R_CL.chiuso||',"oggetto_cl":'||rt_cl::varchar||'}';
		ret.info:='{"dati":'||coalesce(rt,'[]')::varchar||
		',"controllo_chiuso":'||R_CU.chiuso||
		',"chiuso":'||R_CL.chiuso||
		',"oggetto_cl":'||rt_cl::varchar||
		',"follow_up":'||(R_CU.id_tecnica = 4)::boolean||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_evidenze(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_evidenze_by_norma(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_evidenze_by_norma(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	R_CU cu.vw_cu%ROWTYPE;
	idcu bigint;
	idnormaviolata bigint;

	begin
		proc_name:='cu.get_cu_evidenze_by_norma';
		ret.esito:=false;
		idcu=v->'id_cu';
		idnormaviolata=v->'id_norma_violata';
	
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
		
		select json_agg(row_to_json(a.*)) into rt   from (
			select e.* from (select e.*,l.descr descr_linee --, p.n_provv
			from cu.vw_cu_evidenze e
			left join cu.vw_evidenza_lista_linee l on e.id=l.id_cu_evidenza
			--join cu.vw_evidenza_numero_provv p on p.id_evidenza=e.id_evidenza
			where id_cu = idcu and id_norma = (select id_norma from cu.vw_cu_norme_violate where id_norma_violata= idnormaviolata)
			and e.sigla_classe_evidenza ilike 'nc' 
			) e
) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||rt::varchar||',"chiuso":'||R_CL.chiuso||'}';
		--ret.info:='{"dati":'||coalesce(rt,'[]')::varchar||'}';
		--ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||',"controllo_chiuso":'||R_CU.chiuso||'}';
		ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||
					',"controllo_chiuso":'||R_CU.chiuso||
					',"follow_up":'||(R_CU.id_tecnica = 4)::boolean||'}';

		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_evidenze_by_norma(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_evidenze_linee_fu(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_evidenze_linee_fu(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idprovvfu bigint;
	R_PF cu.vw_cu_provv_fu%ROWTYPE;
	rt json;
	begin
		proc_name:='cu.get_cu_evidenze_linee_fu';
		ret.esito:=false;
		idprovvfu=v->'id_provv_fu';
		select * into R_PF from cu.vw_cu_provv_fu where id_provv_fu=idprovvfu;
		if R_PF.id_provv_fu is null then
			ret:=cu_ui.build_ret(ret,proc_name,'fu_provvediemento_non_trovato');
			return ret;
		end if;
	
		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu.vw_cu_provv p
			join cu.vw_cu_evidenza_linee e on p.id_norma =e.id_norma  and e.id_cu =p.id_cu 
			where id_provv=R_PF.id_provv
		) a;
		raise notice 'RT %',rt;
		ret.esito:=true;
		ret.info:='{"dati":'||rt::varchar||'}';
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||rt::varchar||',"chiuso":'||R_CL.chiuso||'}';
		--ret.info:='{"dati":'||coalesce(rt,'[]')::varchar||',"controllo_chiuso":'||R_CU.chiuso||',"chiuso":'||R_CL.chiuso||',"oggetto_cl":'||rt_cl::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_evidenze_linee_fu(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_indirizzi_trasportatori(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_indirizzi_trasportatori(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin 
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idcu bigint;
	begin
		proc_name:='cu.get_cu_indirizzi_trasportatori';
		
		idcu:=v->>'id_cu';

		if idcu is null then
			ret.esito:=false;
			ret:=cu_ui.build_ret(ret,proc_name, 'fornire_id_cu');
			return ret;
		end if;
	
		select json_agg(row_to_json(a.*)) into rt from (
			select * from cu.cu_indirizzi ci
			join cu_anag.vw_indirizzi i on  ci.id_indirizzo = i.id 
			where id_cu = idcu
		) a ;
		raise notice 'RT %',rt;

		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_mancante');
			return ret;
    	end if;

	 	--ret.info:=rt;

		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_indirizzi_trasportatori(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_info(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_info(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	user_info json;
	rt json;
	rt_text text;
	rt_cu json;
	rt_cu_periodo json;
	rt_cu_linee json;
	rt_cu_nucleo json;
	rt_cu_oggetti json;
	rt_cu_piani json;
	rt_cu_provv json;
	rt_cu_provv_fu json;
	rt_cu_provv_s json;
	rt_cu_provv_in_corso json;
	rt_cu_programmati json;
	rt_cu_effettuati json;
	rt_cu_diffide json;
	rt_cu_categ json;
	idcu bigint;
	idroot bigint;
	idstrutturaasl bigint;
	R_ASL record;
	R_STAB record;
	ui_def json;
	_n_check_piani bigint;
	_n_check_categ_storico bigint;
	_latest_categ timestamp;
	_latest_linea timestamp;

	begin
		proc_name:='cu.get_cu_info';
		ret.esito:=false;
		user_info :=v->'user_info';
		--select * into R_ASL from matrix.struttura_asl where id=idstrutturaasl;
		--raise notice 'idasl: %', R_ASL.id_asl;
		idcu=v->'id_cu';
		raise notice 'START %',clock_timestamp ( );
		select * into R_CU from cu.vw_cu where id=idcu;
		--select * into ui_def from cu_ui.form_definition where funct=proc_name and sigla=R_CU.sigla_tecnica;
		select json_agg(row_to_json(a.*)) into ui_def from (
			select (
				select case when user_info->>'responsabile' = 'true' and user_info->>'livello' = '0' then (
					select str_conf from cu_ui.form_definition 
					where funct=proc_name 
					and sigla=R_CU.sigla_tecnica
					and note = 'view_only' 
				) else (
					select str_conf from cu_ui.form_definition 
					where funct=proc_name 
					and sigla=R_CU.sigla_tecnica
					and note = 'standard'
				) end case
			) str_conf
		) a;
/*		AF NUOVA GESTIONE FORM DEFINITION select string_agg(a.str_conf,',')   from (
			select str_conf from cu_ui.vw_form_definition_detail where funct='cu.get_cu_info' and sigla='CU'
			union
			select str_conf from cu_ui.vw_form_definition_detail fdd join cu.vw_cu_piani p on p.alias=fdd.sigla
			where funct='piani' and p.id_cu=idcu) a */
	
		select row_to_json(a.*) into rt_cu from (select * from cu.vw_cu where id_cu=idcu ) a;
		if rt_cu is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
	
		select row_to_json(a.*) into rt_cu_periodo from (select * from cu.vw_cu_periodo where id_cu=idcu ) a;
	raise notice 'CU %',clock_timestamp ( );
		select json_agg(row_to_json(a.*)) into rt_cu_piani          from (select * from cu.vw_cu_piani where id_cu=idcu ) a;
	raise notice 'CU_PIANI %',clock_timestamp ( );
		select json_agg(row_to_json(a.*)) into rt_cu_nucleo         from (select * from cu.vw_cu_nucleo where id_cu=idcu order by id_tipo_nucleo,id_tipo_isp) a;
	raise notice 'CU_NUCLEO %',clock_timestamp ( );
		select json_agg(row_to_json(a.*)) into rt_cu_programmati    from (/*select dt,descr_tecnica descr from cu.vw_cu        where id_az_sede=R_CU.id_az_sede and dt >= R_CU.dt and id_cu != R_CU.id */
				--select dt,t.descr descr_tecnica    FROM cu.cu c
			    --JOIN cu_conf.vw_cu_tecniche t ON c.id_tecnica = t.id_tecnica
			   /* select dt,descr_tecnica,'('||string_agg(c.alias,', ')||')' alias    FROM cu.vw_cu_piani c 
			    where id_az_sede=R_CU.id_az_sede and not chiuso
			    	and dt between current_timestamp -interval '2 years' and current_timestamp +interval '1 years' --and dt >= R_CU.dt  and c.id != R_CU.id 
			 group by dt,descr_tecnica,c.id_cu*/
--2024-08-19	#12243
			   select inizio /*date_trunc('day',inizio)*/ as dt, descr_tipo_evento as descr_tecnica, 
				'('||string_agg(c.alias,', ')||')' alias,id_az_sede
			   FROM agenda.vw_eventi_singoli c 
			    where id_az_sede=R_CU.id_az_sede 
			    and not effettuata and date_trunc('day',inizio) between current_timestamp -interval '2 years' and current_timestamp +interval '1 years' --and dt >= R_CU.dt  and c.id != R_CU.id 
			 group by /*date_trunc('day',inizio)*/ id, inizio, descr_tipo_evento, id_az_sede
			 
			) a;
	raise notice 'CU_PROG %',clock_timestamp ( );
		select json_agg(row_to_json(a.*)) into rt_cu_effettuati     from (/*select dt,descr_tecnica descr from cu.vw_cu        where id_az_sede=R_CU.id_az_sede and dt < R_CU.dt*/
			select dt,descr_tecnica,'('||string_agg(c.alias,', ')||')' alias    FROM cu.vw_cu_piani c
		    --JOIN cu_conf.vw_cu_tecniche t ON c.id_tecnica = t.id_tecnica 
		    where id_az_sede=R_CU.id_az_sede and chiuso 
		    and dt between current_timestamp -interval '2 years' and current_timestamp +interval '1 years' --dt < R_CU.dt
		    group by dt,descr_tecnica,c.id_cu
		) a;
	raise notice 'CU_EFF %',clock_timestamp ( );
		--select json_agg(row_to_json(a.*)) into rt_cu_provv_in_corso from (select * from cu.vw_cu_provv p  where p.id_cu != idcu and p.id_az_sede = R_CU.id_az_sede ) a ;
		select json_agg(row_to_json(a.*)) into rt_cu_provv_in_corso from (select * from cu.vw_cu_provv p where p.id_cu != idcu and p.id_az_sede = R_CU.id_az_sede and p.id_provv not in (select id_provv  from cu.vw_cu_provv_fu pf where id_az_sede = R_CU.id_az_sede and risolta) ) a ;
	raise notice 'CU_IN CORSO %',clock_timestamp ( );
		
		--if R_CU.sigla_tecnica = 'FU' then
		--end if;
		--select json_agg(row_to_json(a.*)) into rt_cu_linee          from (select * from cu.vw_cu_linee where id_cu=idcu ) a;
		select json_agg(row_to_json(a.*)) into rt_cu_linee          from (select * from cu.cu_linee cl join cu_anag.vw_linee_all l on l.id_linea = cl.id_linea where id_cu=idcu ) a;
	raise notice 'CU_LINEE %',clock_timestamp ( );
		select json_agg(row_to_json(a.*)) into rt_cu_oggetti        from (select * from cu.vw_cu_oggetti where id_cu=idcu ) a;
	raise notice 'CU_OGGETTI %',clock_timestamp ( );
		select json_agg(row_to_json(a.*)) into rt_cu_provv          from (select * from cu.vw_cu_provv where id_cu=idcu ) a;
	raise notice 'CU_PROVV %',clock_timestamp ( );
		select json_agg(row_to_json(a.*)) into rt_cu_provv_fu       from (select * from cu.vw_cu_provv_fu where id_cu=idcu ) a;
	raise notice 'CU_PROVV_FU %',clock_timestamp ( );
		select json_agg(row_to_json(a.*)) into rt_cu_provv_s       from (select * from cu.vw_cu_provv_sopralluogo where id_cu=idcu ) a;
	raise notice 'CU_PROVV_S %',clock_timestamp ( );
	--select json_agg(row_to_json(a.*)) into rt_cu_diffide     from (select dt,azione descr        from cu.vw_cu_provv  where id_az_sede=R_CU.id_az_sede and dt >= current_timestamp) a;

	--15/05/2024 mostra categ. rischio se configurata
	select id_categorizzazione_rischio into idroot from cu_anag.stabilimenti s 
	join cu.categorizzazione_rischio_tipo_stabilimento c on s.id_tipologia_struttura = c.id_tipo_stabilimento 
	where s.id = (select id_az_sede from cu.cu where id = idcu);

	--15/07/2024 issue #11980
	if idroot > 0 then
		if R_CU.chiuso is false then
			if (select count(*) from cu.vw_cu_piani p where p.id_cu = idcu and p.alias ilike '%A61_A%') = 0 then
			
				select * into R_STAB from cu_anag.vw_stabilimenti_all s where s.id_stabilimento = R_CU.id_az_sede;
				select count(*) into _n_check_piani from cu.vw_cu_piani p
				where p.id_cu = idcu 
				and p.descrizione_piano ilike '%audit%' and R_STAB.cod_tipologia_struttura in ('852','853');
			
				raise notice 'AUDIT _n_check_piani %',_n_check_piani;
					
				--852 categ_null
				select dt_storico into _latest_categ from cu.cu_categ_evals_storico
				where id_stabilimento = R_STAB.id_stabilimento
				and R_STAB.cod_tipologia_struttura in ('852')--,'853') 
				order by dt_storico desc
				limit 1;
			
				select la.inizio_validita into _latest_linea from cu.vw_cu_linee cl
				join cu_anag.vw_linee_all la on la.id_linea = cl.id_linea 
				where cl.id_cu = R_CU.id
				order by la.inizio_validita desc
				limit 1;
			
				if (_latest_categ is null or _latest_categ < _latest_linea) and R_STAB.cod_tipologia_struttura != '853' then
					_n_check_categ_storico := 1;
				else
					_n_check_categ_storico := 0;
				end if;
			
				if _n_check_piani <= 0 and _n_check_categ_storico <= 0 	then
					idroot:= 0;
				end if;
		
			end if;
		
			
		else --R_CU.chiuso true
			if (select count(*) from cu.cu_categ_evals_storico where id_cu = R_CU.id) <= 0 then
				idroot:= 0;
			end if;
		end if;
		
	
	end if;
	
	if R_CU.chiuso is false then
		if idroot > 0 then
			select row_to_json(a.*)	into rt_cu_categ from (
					select n.descr ||
						case when v.valore != 0 then ' ('||v.valore ||')' else '' end ||
						case when n.peso   != 0 then ' ('||n.peso||')'    else '' end ||
						case when n.fattore!= 1 then ' x'||n.fattore else '' end || coalesce(' '||e.descr,'') descrizione_breve , *,v.valore,ev.id is not null selezionato,e.descr 
					from cu_conf.vw_cu_categ_nodes_up_descr n join
					(select n.id_node_ref,sum(peso*coalesce(e.valore,0)) valore
					from cu_conf.vw_cu_categ_nodes_down n left join cu.vw_cu_categ_evals e on n.id_node=e.id_categ and id_cu=idcu
					group by 1) v on n.id_node =v.id_node_ref
					left join cu.vw_cu_categ_evals ev on n.id_node=ev.id_categ and id_cu=idcu
					left join cu_conf.vw_cu_categ_esiti e on n.id_node_parent is null and  e.rng  @> v.valore
					order by id_node ) a
			where a.id_node_parent is null;
		end if;
	else
		select row_to_json(a.*)	into rt_cu_categ from (
			select *,descr as descrizione_breve from cu.vw_cu_categ_evals_storico where id_cu = R_CU.id
		) a;

	end if;

		rt_text:= '{"cu":'||coalesce(rt_cu::text,'')||',"cu_linee":'||coalesce(rt_cu_linee::text,'[]')||
				  ',"cu_nucleo":'||coalesce(rt_cu_nucleo::text,'[]')||',"cu_oggetti":'||coalesce(rt_cu_oggetti::text,'[]')||
				  ',"cu_programmati":'||coalesce(rt_cu_programmati::text,'[]')||',"cu_effettuati":'||coalesce(rt_cu_effettuati::text,'[]')||
				  ',"cu_diffide":'||coalesce(rt_cu_diffide::text,'[]')||
				  ',"cu_provv":'||coalesce(rt_cu_provv::text,'[]')||
				  ',"cu_provv_in_corso":'||coalesce(rt_cu_provv_in_corso::text,'[]')||
				  ',"cu_provv_fu":'||coalesce(rt_cu_provv_fu::text,'[]')||
				  ',"cu_provv_s":'||coalesce(rt_cu_provv_s::text,'[]')||
				  ',"cu_form_ui":'||coalesce(ui_def::text,'{}')||
				  ',"cu_periodo":'||coalesce(rt_cu_periodo::text,'{}')||
				  ',"cu_categ":'||coalesce(rt_cu_categ::text,'{}')||
				  ',"cu_piani":' ||coalesce(rt_cu_piani::text,'[]')||'}';
		raise notice 'RT_text %',rt_text;
	
		ret.esito:=true;
	 	ret.info:=rt_text::json;

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_info(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_info_per_verbale(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_info_per_verbale(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	rt_text text;
	rt_cu json;
	rt_anag json;
	rt_ref_proc json;
	rt_legale_rapp json;
	rt_stab json;
	rt_sede_l json;
	rt_cu_linee json;
	rt_cu_nucleo json;
	rt_cu_nucleo_esterni json;
	rt_cu_nucleo_personale json;
	rt_cu_oggetti json;
	rt_cu_piani json;
	rt_cu_evidenze json;
	rt_cu_provv json;
	rt_cu_dichiarazioni json;
	rt_custode json;

	idcu bigint;
	idimpresa bigint;
	idstab bigint;
	idoggetti bigint[];
	idstrutturaasl bigint;
	R_ASL record;

	n bigint;

	begin
		proc_name:='cu.get_cu_info_per_verbale';
		ret.esito:=false;
	
		idcu=v->'id_cu';

		select count(*) into n from documenti.pdf
		where descr_modulo = 'verbale_cu'
		and id_modulo = idcu;

		if n >= 1 then
			rt_text:= '{"nuovoPdf":false}';
			ret.esito:=true;
	 		ret.info:=rt_text::json;
			return ret;
		end if;

		select row_to_json(a.*) into rt_cu from 
		(
			select *, 
			to_char(dt at time zone 'Europe/Rome', 'DD/MM/YYYY ore HH24:MI') as dt,
			to_char(dt_chiusura at time zone 'Europe/Rome', 'DD/MM/YYYY ore HH24:MI') as dt_chiusura
			from cu.vw_cu where id_cu=idcu 
		) a;
		
		if rt_cu is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
	
		select id_az_sede into idstab from cu.vw_cu_con_periodo where id_cu=idcu;
		select id_impresa into idimpresa from cu_anag.vw_stabilimenti_all where id_stabilimento = idstab;
		select json_agg(row_to_json(a.*)) into rt_anag   	 from (select * from cu_anag.vw_stabilimenti_all  where id_stabilimento = idstab ) a;
		
		select json_agg(row_to_json(a.*)) into rt_legale_rapp from (select *, to_char(data_nascita  at time zone 'Europe/Rome', 'DD/MM/YYYY') as dt_nascita from cu_anag.vw_stabilimento_figure_all 
																	where id_stabilimento = idstab
																	and descr_tipo_figura = 'Legale Rappresentante per procura'
																	and validita @> LOCALTIMESTAMP ) a;
		if rt_legale_rapp is null then
		select json_agg(row_to_json(a.*)) into rt_legale_rapp from (select *, to_char(data_nascita  at time zone 'Europe/Rome', 'DD/MM/YYYY') as dt_nascita from cu_anag.vw_impresa_figure_all 
																	where id_impresa = idimpresa
																	and descr_tipo_figura = 'Legale Rappresentante'
																	and validita @> LOCALTIMESTAMP ) a;
		end if;
																
		select json_agg(row_to_json(a.*)) into rt_stab   	 from (select * from cu_anag.vw_stabilimenti_all
																	where id_stabilimento = idstab
																	and validita @> LOCALTIMESTAMP) a;
		
		select json_agg(row_to_json(a.*)) into rt_sede_l  	 from (select * from cu_anag.vw_stabilimento_sedi_all
																	where id_stabilimento = idstab
																	and sigla_tipo_sede = 'DL'
																	and validita @> LOCALTIMESTAMP) a;
																
		if rt_sede_l is null then
			select json_agg(row_to_json(a.*)) into rt_sede_l  	 from (select * from cu_anag.vw_impresa_sedi_all
																	where id_impresa = idimpresa
																	and sigla_tipo_sede = 'SL'
																	and validita @> LOCALTIMESTAMP) a;
		end if;
		
		select json_agg(row_to_json(a.*)) into rt_cu_linee   from (select * from cu.vw_cu_linee where id_cu=idcu ) a;
		select json_agg(row_to_json(a.*)) into rt_ref_proc  from (select * from cu.vw_cu_nucleo_periodi where id_cu=idcu and descr_isp='Referente procedimento' order by id) a;
		select json_agg(row_to_json(a.*)) into rt_cu_nucleo  from (select * from cu.vw_cu_nucleo_periodi where id_cu=idcu and id_tipo_nucleo=1 order by id) a;
		select json_agg(row_to_json(a.*)) into rt_cu_nucleo_esterni  from (select * from cu.vw_cu_nucleo_periodi where id_cu=idcu and id_tipo_nucleo=2 order by id) a;
		select json_agg(row_to_json(a.*)) into rt_cu_nucleo_personale  from (select * from cu.vw_cu_nucleo_periodi where id_cu=idcu and id_tipo_nucleo=3 order by id) a;
		select json_agg(row_to_json(a.*)) into rt_custode  from (select to_char(dt_nascita  at time zone 'Europe/Rome', 'DD/MM/YYYY') as data_nascita ,* from cu.vw_cu_nucleo_periodi where id_cu=idcu and custode_verbale order by id) a;
		select json_agg(row_to_json(a.*)) into rt_cu_oggetti from (select * from cu.vw_cu_oggetti where id_cu=idcu ) a;
		select json_agg(row_to_json(a.*)) into rt_cu_piani   from (select * from cu.vw_cu_piani where id_cu=idcu ) a;
		select json_agg(row_to_json(a.*)) into rt_cu_dichiarazioni   from (select * from cu.vw_cu_dichiarazioni where id_cu=idcu ) a;
	

		select array_agg(id_cu_oggetto) from cu.vw_cu_oggetti vco where vco.id_cu = idcu into idoggetti;
		select json_agg(row_to_json(a.*)) into rt_cu_evidenze   from (select * from cu.vw_cu_evidenze vce where id_cu_oggetto_cl in (select id_cu_oggetto_cl  from cu.vw_cu_oggetti_cl vcoc where id_cu_oggetto = any(idoggetti)) ) a;
		select json_agg(row_to_json(a.*)) into rt_cu_provv 		from (select vcp.*, vcnv.norma from cu.vw_cu_provv vcp join cu.vw_cu_norme_violate vcnv on vcp.id_evidenza = vcnv.id_norma_violata where vcp.id_cu = idcu) a;
	
		rt_text:= '{"cu":'||rt_cu::text||
				  ',"anag":'||coalesce(rt_anag::text,'[]')||
				  ',"ref_proc":'||coalesce(rt_ref_proc::text,'[]')||
				  ',"legale_rapp":'||coalesce(rt_legale_rapp::text,'[]')||
				  ',"firmatario_verbale":'||coalesce(rt_custode::text,'[]')||
				  ',"sede_legale":'||coalesce(rt_sede_l::text,'[]')||
				  ',"stabilimento":'||coalesce(rt_stab::text,'[]')||
				  ',"anag":'||coalesce(rt_anag::text,'[]')||
				  ',"cu_linee":'||coalesce(rt_cu_linee::text,'[]')||
				  ',"cu_nucleo":'||coalesce(rt_cu_nucleo::text,'[]')||
				  ',"cu_nucleo_esterni":'||coalesce(rt_cu_nucleo_esterni::text,'[]')||
				  ',"cu_nucleo_personale":'||coalesce(rt_cu_nucleo_personale::text,'[]')||
				  ',"cu_oggetti":'||coalesce(rt_cu_oggetti::text,'[]')||
				  ',"cu_piani":' ||coalesce(rt_cu_piani::text,'[]')||
				  ',"cu_dichiarazioni":' ||coalesce(rt_cu_dichiarazioni::text,'[]')||
				  ',"cu_evidenze":' ||coalesce(rt_cu_evidenze::text,'[]')||
				  ',"cu_provv":' ||coalesce(rt_cu_provv::text,'[]')||
				  ',"nuovoPdf":true}';
		raise notice 'RT_text %',rt_text;
	
		ret.esito:=true;
	 	ret.info:=rt_text::json;

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_info_per_verbale(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_linee(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_linee(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	rt json;
	idcu bigint;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu.get_cu_linee';
		ret.esito:=false;
		idcu=v->'id_cu';
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
		--idstrutturaasl=v->'user_info'->'id_struttura_root';
		--raise notice 'idstrutturaasl: %', idstrutturaasl;
		--select * into R_ASL from matrix.struttura_asl where id=idstrutturaasl;
		--raise notice 'idasl: %', R_ASL.id_asl;

		/*
		select json_agg(row_to_json(a.*)) into rt   from (
			select l.desc_tipo_linea ,cl.id is not null as selezionato, 
			--coalesce(c.n,0) <= 0 and R_CU.chiuso = false selezionabile,
			not l.linea_principale and coalesce(c.n,0) <= 0 and R_CU.chiuso = false and R_CU.id_tecnica != 4 selezionabile,
			l.denominazione_sede_operativa, cl.id_cu_linea, cl.id, cl.id_cu, l.id_linea, cl.comune
			from agenda.vw_linee l
			left join cu.vw_cu_linee cl on cl.id_linea =l.id_linea and cl.id_cu =R_CU.id
						left join (
				select id_cu_linea, count(*) n from cu.vw_cu_evidenza_linee vce 
				where id_cu=R_CU.id
				group by 1
			
			) c on c.id_cu_linea=cl.id_cu_linea	
			where l.id_az_sede=R_CU.id_az_sede) a; 
		*/
	
		/*select json_agg(row_to_json(a.*)) into rt   from (
			select l.desc_tipo_linea ,cl.id is not null as selezionato, 
			--coalesce(c.n,0) <= 0 and R_CU.chiuso = false selezionabile,
			not l.linea_principale and coalesce(c.n,0) <= 0 and R_CU.chiuso = false and R_CU.cod_tecnica != 'FU' selezionabile,
			l.denominazione_sede_operativa, cl.id_cu_linea, cl.id, cl.id_cu, l.id_linea, cl.comune
			from cu.vw_cu_linee cl
			join agenda.vw_linee l  on cl.id_linea =l.id_linea 
						left join (
				select id_cu_linea, count(*) n from cu.vw_cu_evidenza_linee vce 
				where id_cu=R_CU.id
				group by 1
			
			) c on c.id_cu_linea=cl.id_cu_linea	
			where cl.id_cu =R_CU.id
			--where l.id_az_sede=R_CU.id_az_sede
		) a;*/
	

		
			/*select json_agg(row_to_json(a.*)) into rt   from (
				select tl.descr desc_tipo_linea ,cl.id is not null as selezionato, 
			--coalesce(c.n,0) <= 0 and R_CU.chiuso = false selezionabile,
			not l.linea_principale and coalesce(c.n,0) <= 0 and R_CU.chiuso = false and R_CU.cod_tecnica != 'FU' selezionabile,
			--l.denominazione_sede_operativa,
			 cl.id id_cu_linea, cl.id, cl.id_cu, l.id id_linea--, l.comune
			from cu.cu_linee cl
			join cu_anag.linee l  on cl.id_linea =l.id
			join agenda.vw_tipo_linee tl on tl.id_tipo_linea=l.id_tipo_linea
						left join (
				select id_cu_linea, count(*) n from cu.vw_cu_evidenza_linee vce 
				where id_cu=R_CU.id
				group by 1
			
			) c on c.id_cu_linea=cl.id	
			where cl.id_cu =R_CU.id
					) a;*/
	
			select json_agg(row_to_json(a.*)) into rt   from (
				select tl.descr desc_tipo_linea ,cl.id is not null as selezionato, 
					--coalesce(c.n,0) <= 0 and R_CU.chiuso = false selezionabile,
					--not l.linea_principale and coalesce(c.n,0) <= 0 and R_CU.chiuso = false and R_CU.sigla_tecnica != 'FU' selezionabile, 
					--issue #11491
					not cl.linea_originaria and coalesce(c.n,0) <= 0 and R_CU.chiuso = false and R_CU.sigla_tecnica != 'FU' selezionabile, 
					--l.denominazione_sede_operativa,
					cl.id id_cu_linea, cl.id, cl.id_cu, l.id id_linea--, l.comune
		
					from  cu_anag.linee l
					join agenda.vw_tipo_linee tl on tl.id_tipo_linea=l.id_tipo_linea
					left join  cu.cu_linee cl on cl.id_linea =l.id and id_cu=R_CU.id
					left join (
						select id_cu_linea, count(*) n from cu.vw_cu_evidenza_linee vce 
						where id_cu=R_CU.id
						group by 1	
					) c on c.id_cu_linea=cl.id
					where l.id_stabilimento=R_CU.id_az_sede			
			) a;
		
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||rt::varchar||'}';
		--ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||',"controllo_chiuso":'||R_CU.chiuso||'}';
		ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||
					',"controllo_chiuso":'||R_CU.chiuso||
					',"follow_up":'||(R_CU.id_tecnica = 4)::boolean||'}';

raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_linee(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_linee_associate(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_linee_associate(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	rt json;
	idcu bigint;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu.get_cu_linee_associate';
		ret.esito:=false;
		idcu=v->'id_cu';
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
		--idstrutturaasl=v->'user_info'->'id_struttura_root';
		--raise notice 'idstrutturaasl: %', idstrutturaasl;
		--select * into R_ASL from matrix.struttura_asl where id=idstrutturaasl;
		--raise notice 'idasl: %', R_ASL.id_asl;

	
		select json_agg(row_to_json(a.*)) into rt   from (
			select l.desc_tipo_linea, cl.id as id_cu_linea, cl.id, cl.id_cu, l.id_linea, coalesce(c.n,0) <= 0 selezionabile
			from cu_anag.vw_linee_all l
			join cu.cu_linee cl on cl.id_linea =l.id_linea and cl.id_cu =R_CU.id
			left join (
						select id_cu_linea, count(*) n from cu.vw_cu_evidenza_linee vce 
						where id_cu=R_CU.id
						group by 1
					  ) c on c.id_cu_linea=cl.id
			where l.id_stabilimento=R_CU.id_az_sede
		) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||rt::varchar||'}';
raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_linee_associate(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_nomi_pdf_controlli(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_nomi_pdf_controlli(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare
		ret cu_types.result_type; 
		proc_name varchar;
		rt json;
		idcu bigint;
		begin 
			proc_name:='cu.get_cu_nomi_pdf_controlli';
			ret.esito:=false;
			idcu=v->'id_cu';
			
		select json_agg(row_to_json(a.*)) into rt   from (
			select nfpc.id,nfpc.nome from cu.nomi_file_pdf_controlli nfpc  
			join cu.vw_cu vc on nfpc.id_cu = vc.id_cu 
			where nfpc.id_cu = idcu and nfpc.validita @> CURRENT_TIMESTAMP::timestamp without time zone
		) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||rt::varchar||',"chiuso":'||R_CL.chiuso||'}';
		ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
		end;
		
	END;
$$;


ALTER FUNCTION cu.get_cu_nomi_pdf_controlli(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_nomi_pdf_evidenze(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_nomi_pdf_evidenze(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare
		ret cu_types.result_type; 
		proc_name varchar;
		rt json;
		idevidenza bigint;
		begin 
			proc_name:='cu.get_cu_nomi_pdf_evidenze';
			ret.esito:=false;
			idevidenza=v->'id_evidenza';
			
		select json_agg(row_to_json(a.*)) into rt   from (
			select nfpe.id,nfpe.nome from cu.nomi_file_pdf_evidenze nfpe 
			join cu.vw_cu_evidenze vce on nfpe.id_evidenza = vce.id_evidenza 
			where nfpe.id_evidenza = idevidenza and nfpe.validita @> CURRENT_TIMESTAMP::timestamp without time zone
		) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||rt::varchar||',"chiuso":'||R_CL.chiuso||'}';
		ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
		end;
		
	END;
$$;


ALTER FUNCTION cu.get_cu_nomi_pdf_evidenze(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_nominativo_provv(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_nominativo_provv(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idcu bigint;

	begin
		proc_name:='cu.get_cu_nominativo_provv';
		ret.esito:=false;
		idcu=v->'id_cu';
		raise notice 'v=%',v;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
	
		select row_to_json(a.*) into rt   from (
			select * from cu.vw_cu_nominativo_provv np
			where np.id_cu = idcu
		) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_nominativo_provv(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_norme_violate(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_norme_violate(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_E cu.cu_evidenze%ROWTYPE;
	rt json;
	idcu bigint;

	begin
		proc_name:='cu.get_cu_norme_violate';
		ret.esito:=false;
		idcu=v->'id_cu'; 
	
		--ret:=cu.cu_aggiorna_norme_violate(idcu);
	
		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu.vw_cu_norme_violate nv
			left join (
			select vcnv.id_norma, coalesce(count(*), 0) as n_provv,
			string_agg(vcp.sigla_tipo_provv,',') tipi_provv
			from cu.vw_cu_norme_violate vcnv 
			join cu.vw_cu_provv vcp on vcp.id_evidenza = vcnv.id_norma_violata 
			where vcp.id_cu = idcu and vcnv.id_norma in (
			select id_norma from cu.vw_cu_evidenze vce where id_cu = idcu
			--and id_cu_classe_evidenza in (1,2)
			) group by vcnv.id_norma
			
			) n on n.id_norma = nv.id_norma
			where nv.id_cu = idcu
		) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
		ret.info:='{"dati":'||coalesce(rt,'[]')::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_norme_violate(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_nucleo(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_nucleo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	rt json;
	idcu bigint;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu.get_cu_nucleo';
		ret.esito:=false;
		idcu=v->'id_cu';
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;

		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu.vw_cu_nucleo_periodi ni
			--join cu.vw_cu_nucleo_periodi vcnp on vcnp.id_nucleo_periodo = ni.id
			where ni.id_cu =R_CU.id and sigla_tipo_nucleo::text = 'NI'::text) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||',"controllo_chiuso":'||R_CU.chiuso||'}';

		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_nucleo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_oggetti(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_oggetti(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	rt json;
	rt_sel json;
	rt_no_sel json;
	str_conf varchar;
	idcu bigint;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu.get_cu_oggetti';
		ret.esito:=false;
		idcu=v->'id_cu';
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
		--idstrutturaasl=v->'user_info'->'id_struttura_root';
		--raise notice 'idstrutturaasl: %', idstrutturaasl;
		--select * into R_ASL from matrix.struttura_asl where id=idstrutturaasl;
		--raise notice 'idasl: %', R_ASL.id_asl;
	
		if R_CU.sigla_tecnica ='SP' then
			select json_agg(row_to_json(a.*)) into rt_sel from (
				select o.*
				--, not chiuso and not R_CU.chiuso as selezionabile
				, false as selezionabile
				, ev.cnt from cu.vw_cu_oggetti o
				left join cu.vw_evidenze_per_oggetto ev on o.id_cu_oggetto=ev.id_cu_oggetto
				where o.id_cu_oggetto in (
					select distinct e.id_cu_oggetto from cu.vw_cu_evidenze e join cu.cu_evidenze_sp es on es.id_cu_evidenza= e.id where es.id_cu=idcu
				) 
			)a;
		
		else

			select json_agg(row_to_json(a.*)) into rt_sel from (
			select o.*
			, not chiuso and not R_CU.chiuso and R_CU.sigla_tecnica in ('CU','CT') and f.id_tipo_oggetto is null and ev.cnt = 0 as selezionabile
			, ev.cnt from cu.vw_cu_oggetti o
			left join cu.vw_evidenze_per_oggetto ev on o.id_cu_oggetto=ev.id_cu_oggetto
			left join (
			select distinct op.id_tipo_oggetto from
				cu.cu_piani p
				join cu_conf.vw_cu_tipo_oggetto_piani op on op.id_piano =p.id_piano
				where p.id_cu=R_CU.id
			) f on f.id_tipo_oggetto=o.id_tipo_oggetto
			where id_cu=idcu) a;
			
			select json_agg(row_to_json(a.*)) into rt_no_sel  from (
				select t.*,
				R_CU.chiuso = false and R_CU.sigla_tecnica in ('CU','CT') as selezionabile
				from cu_conf.vw_cu_tipo_oggetti_validi t left join  cu.vw_cu_oggetti o
				on t.id_tipo_oggetto=o.id_tipo_oggetto and id_cu=idcu
				where o.id_tipo_oggetto is null) a;
			raise notice 'RT %',rt;
		end if;
	
		ret.esito:=true;
		str_conf:= cu_ui.get_ui_definition(''::varchar,'cu.get_cu_oggetti_sel',999::varchar::int8,idtransazione);
		--str_conf:= cu_ui.get_ui_definition(''::varchar,'cu.get_cu_oggetti_sel',((j_user_info->'id_struttura_root')::varchar)::int8
		--/*999::varchar::int8*/,idtransazione);
		if str_conf is not null and str_conf != '' then
	 		ret.info:='{"lista_sel":{'||str_conf||',"dati":'||coalesce(rt_sel,'[]')||'}';
		else
			 ret.info:='{"lista_sel":{"dati":'||coalesce(rt_sel,'[]')||'}';
	 	end if;
	 	str_conf:= cu_ui.get_ui_definition(''::varchar,'cu.get_cu_oggetti_no_sel',999::varchar::int8,idtransazione);
		if str_conf is not null and str_conf != '' then
	 		ret.info:=ret.info||',"lista_no_sel":{'||str_conf||',"dati":'||coalesce(rt_no_sel,'[]')||'}';
		else
			ret.info:=ret.info ||',"lista_no_sel":{"dati":'||rt_sel::varchar||'}';
	 	end if;

	 	--ret.info:='{"lista_sel":'||rt_sel||',"lista_no_sel":'||coalesce(rt_no_sel,'[]')||'}';
		--ret.info:=ret.info ||',"controllo_chiuso":'||R_CU.chiuso||'}';
	 	ret.info:=ret.info ||',"controllo_chiuso":'||R_CU.chiuso||',"follow_up":'||(/*R_CU.id_tecnica = 4*/R_CU.sigla_tecnica ='FU')::boolean||'}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_oggetti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_oggetti_cl(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_oggetti_cl(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	R_CO cu.vw_cu_oggetti%ROWTYPE;
	rt json;
	idcuoggetto bigint;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu.get_cu_oggetti_cl';
		ret.esito:=false;
		idcuoggetto=v->'id_cu_oggetto';
	
		select * into R_CO from cu.vw_cu_oggetti where id_cu_oggetto=idcuoggetto;
		if R_CO.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
	
		select * into R_CU from cu.vw_cu where id_cu=R_CO.id_cu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
	

		select json_agg(row_to_json(a.*)) into rt from (
		select cl.*
		--, not chiuso and not R_CU.chiuso and not R_CO.chiuso as selezionabile
		, not chiuso and not R_CU.chiuso and not R_CO.chiuso and /*R_CU.id_tecnica != 4*/ R_CU.sigla_tecnica = 'CU' as selezionabile
		,ev.cnt from cu.vw_cu_oggetti_cl cl
		left join cu.vw_evidenze_per_cl ev on ev.id_cu_oggetto_cl=cl.id_cu_oggetto_cl
		where id_cu_oggetto=idcuoggetto
		order by ord) a;

	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||rt::varchar||'}';
		--ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||',"controllo_chiuso":'||R_CU.chiuso||',"oggetto_chiuso":'||R_CO.chiuso||'}';
		ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||
					',"controllo_chiuso":'||R_CU.chiuso||
					',"oggetto_chiuso":'||R_CO.chiuso||
					',"follow_up":'||(R_CU.sigla_tecnica = 'FU')::boolean||'}';

		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_oggetti_cl(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_personale(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_personale(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	rt json;
	idcu bigint;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu.get_cu_personale';
		ret.esito:=false;
		idcu=v->'id_cu';
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;

		select json_agg(row_to_json(a.*)) into rt   from (
			select case when custode_verbale then 'SI' else 'NO' end as firmatario
			,* from cu.vw_cu_nucleo_periodi where id_cu =R_CU.id and id_tipo_nucleo=3) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||',"controllo_chiuso":'||R_CU.chiuso||'}';

		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_personale(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_piani(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_piani(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	rt json;
	idcu bigint;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu.get_cu_piani';
		ret.esito:=false;
		idcu=v->'id_cu';
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;

		select json_agg(row_to_json(a.*)) into rt   from (
		/* 
		select p.*,c.n <=0 selezionabile from cu.vw_cu_piani p join
		
		(select id_cu_piano,count(*) n from cu.cu_piani cp   left join cu.cu_nucleo_periodi cnp on cp.id=cnp.id_cu_piano 
		where cp.id_cu=R_CU.id  group by 1) c on c.id_cu_piano=p.id_cu_piano
		where id_cu=R_CU.id*/
		
		/* 16/11 s.l.
						select p.*,coalesce(c.n,0) <=0 selezionabile from /*cu.vw_cu_piani*/public.vw_tree_nodes_up_piani p left join
		
		(select cp.id id_cu_piano,count(*) n from cu.cu_piani cp   
		 join cu.cu_nucleo_periodi cnp on cp.id=cnp.id_cu_piano 
		where cp.id_cu=R_CU.id  group by 1) c on c.id_cu_piano=p.id_node --p.id_cu_piano
		--where p.id_cu=R_CU.id 
		where p.anno=extract ('year' from R_CU.dt)
		*/
		
		/*  parte decommentata*/
		select p.*, --coalesce(c.n,0) <=0 selezionabile
					--coalesce(c.n,0) <= 0 and R_CU.chiuso = false selezionabile 
					coalesce(c.n,0) <= 0 and R_CU.chiuso = false and R_CU.id_tecnica != 4 selezionabile 
		from cu.vw_cu_piani p left join
		
		(select cp.id id_cu_piano,count(*) n from cu.cu_piani cp   
		join cu.cu_nucleo_periodi cnp on cp.id=cnp.id_cu_piano 
		where cp.id_cu=R_CU.id  group by 1) c on c.id_cu_piano=p.id_cu_piano
		where id_cu=R_CU.id

		) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||rt::varchar||'}';
		--ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||',"controllo_chiuso":'||R_CU.chiuso||'}';
		ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||
					',"controllo_chiuso":'||R_CU.chiuso||
					',"follow_up":'||(R_CU.id_tecnica = 4)::boolean||'}';

		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_piani(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_piani_associati(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_piani_associati(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	rt json;
	idcu bigint;

	begin
		proc_name:='cu.get_cu_piani_associati';
		ret.esito:=false;
		idcu=v->'id_cu';
	
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
	
		select json_agg(row_to_json(a.*)) into rt from (
			select id_piano, descrizione_completa_piano from cu.vw_cu_piani 
			where id_cu = R_CU.id_cu
		) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
		ret.info:='{"dati":'||coalesce(rt,'[]')::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_piani_associati(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_provv(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_provv(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_E cu.cu_evidenze%ROWTYPE;
	R_CL cu.cu_oggetti_cl%ROWTYPE;
	rt json;
	idevidenza bigint;

	begin
		proc_name:='cu.get_cu_provv';
		ret.esito:=false;
		idevidenza=v->'id_evidenza';
		/*
		select * into R_E from cu.cu_evidenze where id=idevidenza;
		if R_E.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_evidenza_non_trovata');
			return ret;
		end if;
		
	
		select * into R_CL from cu.cu_oggetti_cl where id=R_E.id_cu_oggetto_cl;
		if R_CL.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_oggetto_cl_non_trovato');
			return ret;
		end if;
		*/
	
		select json_agg(row_to_json(a.*)) into rt from (
			select * from cu.vw_cu_provv where id_evidenza =idevidenza order by id_provv
		) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||rt::varchar||'}';
		ret.info:='{"dati":'||coalesce(rt,'[]')::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_provv(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_provv_fu(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_provv_fu(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	rt json;
	rt_sel json;
	rt_no_sel json;
	str_conf varchar;
	idcu bigint;
	idstrutturaasl bigint;
	R_ASL record;
	j_user_info json;

	begin
		proc_name:='cu.get_cu_provv_fu';
		ret.esito:=false;
		idcu=v->'id_cu';
		j_user_info:=v->'user_info';
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
		--idstrutturaasl=v->'user_info'->'id_struttura_root';
		--raise notice 'idstrutturaasl: %', idstrutturaasl;
		--select * into R_ASL from matrix.struttura_asl where id=idstrutturaasl;
		--raise notice 'idasl: %', R_ASL.id_asl;

		select json_agg(row_to_json(a.*)) into rt_sel from (
		select p.*, 
		--true as selezionabile 
		not R_CU.chiuso as selezionabile
		from cu.vw_cu_provv_fu p
		where id_cu=idcu) a;
		
		select json_agg(row_to_json(a.*)) into rt_no_sel  from (
			select p.*,
			--true as selezionabile
			not R_CU.chiuso as selezionabile
			from cu.vw_cu_provv p 
			where p.id_az_sede=R_CU.id_az_sede and not p.chiuso and id_provv not in (
				select pf.id_provv from cu.vw_cu_provv_fu pf
				where id_cu=idcu)
			) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
		str_conf:= cu_ui.get_ui_definition(''::varchar,'cu.get_cu_provv_fu_sel',((j_user_info->'id_struttura_root')::varchar)::int8
	/*999::varchar::int8*/,idtransazione);
		if str_conf is not null and str_conf != '' then
	 		ret.info:='{"provv_sel":{'||str_conf||',"dati":'||coalesce(rt_sel,'[]')||'}';
		else
			 ret.info:='{"provv_sel":{"dati":'||coalesce(rt_sel,'[]')||'}';
	 	end if;
	 
	 	str_conf:= cu_ui.get_ui_definition(''::varchar,'cu.get_cu_provv_fu_no_sel',((j_user_info->'id_struttura_root')::varchar)::int8
	 /*999::varchar::int8*/,idtransazione);
		if str_conf is not null and str_conf != '' then
	 		ret.info:=ret.info||',"provv_no_sel":{'||str_conf||',"dati":'||coalesce(rt_no_sel,'[]')||'}';
		else
			ret.info:=ret.info ||',"provv_no_sel":{"dati":'||rt_sel::varchar||'}';
	 	end if;

	 	--ret.info:='{"lista_sel":'||rt_sel||',"lista_no_sel":'||coalesce(rt_no_sel,'[]')||'}';
		ret.info:=ret.info ||',"controllo_chiuso":'||R_CU.chiuso||'}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_provv_fu(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_provv_sopralluogo(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_provv_sopralluogo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	rt json;
	idcu bigint;

	begin
		proc_name:='cu.get_cu_provv_sopralluogo';
		ret.esito:=false;
		idcu=v->'id_cu';
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
	
		select json_agg(row_to_json(a.*)) into rt from (
			select * from cu.vw_cu_provv_sopralluogo where id_cu =R_CU.id_cu order by id
		) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||rt::varchar||'}';
		ret.info:='{"dati":'||coalesce(rt,'[]')::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_provv_sopralluogo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_provv_sopralluogo_fu(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_provv_sopralluogo_fu(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	rt json;
	idcu bigint;

	begin
		proc_name:='cu.get_cu_provv_sopralluogo_fu';
		ret.esito:=false;
		idcu=v->'id_cu';
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
	
		select json_agg(row_to_json(a.*)) into rt from (
			select * from cu.vw_cu_provv_sopralluogo_fu where id_cu =R_CU.id_cu order by id
		) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||rt::varchar||'}';
		ret.info:='{"dati":'||coalesce(rt,'[]')::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_provv_sopralluogo_fu(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_singolo(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_singolo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU record;
	rt json;
	ui_def json;
	idstrutturaasl bigint;
	idcu bigint;

	begin
		proc_name:='cu.get_cu';
		ret.esito:=false;
		idcu=v->'id_cu';
		raise notice 'v=%',v;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
	
		select json_agg(row_to_json(a.*)) into rt   from (
			select c.id_cu,
			    c.id,
			    c.codice,
			    c.dt,
			    c.id_tecnica,
			    c.preavviso,
			    c.rilievi,
			    c.id_evento,
			    c.sigla_tecnica,
			    c.descr_tecnica,
			    c.id_az_sede,
			    c.cu_inizio,
			    c.cu_fine,
			    c.denominazione_sede_operativa,
			    c.chiuso,
			    c.stato,
			    c.dt_chiusura,
			    c.pec,
			    c.id_responsabile,
			    c.nominativo_responsabile,
			    coalesce(c.cu_inizio, date_trunc('year', now()) - interval '2 month') as data_min,
			    coalesce(c.cu_fine, date_trunc('year', now()) + interval '1 year' - interval '1 day') as data_max
    		from cu.vw_cu_con_periodo c
			where c.id_cu = idcu
			order by dt desc, codice desc
		) a;
		raise notice 'RT %',rt;

		select * into R_CU from cu.vw_cu where id=idcu;

		select json_agg(row_to_json(a.*)) into ui_def from (
			select (
				select case when v->'user_info'->>'responsabile' = 'true' and v->'user_info'->>'livello' = '0' then (
					select str_conf from cu_ui.form_definition 
					where funct='cu.get_cu_info' 
					and sigla=R_CU.sigla_tecnica
					and note = 'view_only' 
				) else (
					select str_conf from cu_ui.form_definition 
					where funct='cu.get_cu_info' 
					and sigla=R_CU.sigla_tecnica
					and note = 'standard'
				) end case
			) str_conf
		) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt||',"ui_def":'||coalesce(ui_def::text,'{}')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stabilimento_automezzi(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_stabilimento_automezzi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin 
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idcu bigint;
	idstab bigint;
	begin
		proc_name:='cu.get_cu_stabilimento_automezzi';
		
		idcu:=v->>'id_cu';
		idstab:=v->>'id_stabilimento';
	
		select json_agg(row_to_json(a.*)) into rt from (
			select va.id_automezzo, va.marca, va.modello, va.targa, 
				   s.validita, lower(s.validita) as inizio_validita, upper(s.validita) as fine_validita   
			from cu_anag.vw_stabilimento_automezzi s
			join cu_anag.vw_automezzi va on s.id_automezzo = va.id_automezzo 
			where s.id_stabilimento = idstab and s.validita @> localtimestamp
			and va.id_automezzo not in (select id_automezzo from cu.cu_automezzi where id_cu = idcu)
		) a ;
		raise notice 'RT %',rt;

		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'automezzi_associabili_non_trovati');
			ret.esito:=false;
			return ret;
    	end if;

	 	--ret.info:=rt;

		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_cu_stabilimento_automezzi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stati_cu(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_stati_cu(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type;
		proc_name varchar;
    	rt json;
	begin
		proc_name:='cu.get_cu_stati_cu';
		raise notice 'V_J=%', v_j;

		select json_agg(row_to_json(a.*)) into rt   from (
			select *, true selezionabile
			from cu_types.vw_cu_stati_cu --where evidenze>= n_ev 
		order by ord) a;
		
		raise notice 'RT %',rt;
		ret.esito:=true;
	 	ret.info:='{"stati_cu":'||rt::varchar||'}';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.get_cu_stati_cu(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stati_oggetto(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_cu_stati_oggetto(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
        R_S cu_types.vw_cu_stati_oggetto;
    	rt json;
    	idoggetto bigint;
    	n_ev bigint;
	begin
		proc_name:='cu.get_cu_stati_oggetto';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;
		idoggetto:= v_j->'id_cu_oggetto';
		
		n_ev = 0;
		
		select count(*) into n_ev from cu.vw_cu_evidenze 
		where id_cu_oggetto_cl in (
			select id_cu_oggetto_cl 
			from cu.vw_cu_oggetti_cl 
			where id_cu_oggetto = idoggetto)
		and id_cu_classe_evidenza between 1 and 2;
	
		if n_ev>0 then n_ev:=1; end if;

		
			select json_agg(row_to_json(a.*)) into rt   from (
			select * , (evidenze = n_ev) selezionabile
			from cu_types.vw_cu_stati_oggetto order by ord) a;
		raise notice 'RT %',rt;
		ret.esito:=true;
	 	ret.info:='{"nuovi_stati":'||rt::varchar||'}';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.get_cu_stati_oggetto(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_dati(character varying, character varying, bigint, json); Type: PROCEDURE; Schema: cu; Owner: postgres
--

CREATE PROCEDURE cu.get_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json)
    LANGUAGE plpgsql
    AS $$

declare 	
	idtransazione bigint;
	proc_name varchar;
	id_op bigint;  
	id_risorsa bigint;
	ret cu_types.result_type;
	ret_2 cu_types.result_type;
	ret_3 cu_types.result_type;
	ret_eventi cu_types.result_type;
	retj json;
	text_msg1 varchar;	
	text_msg2 varchar;	
	text_msg3 varchar;	
	text_msg4 varchar;
	str_conf varchar;
	ts timestamp;
	id bigint;
	fallito bool;
	j_user_info json;
begin 
	ts:=CLOCK_TIMESTAMP();
	proc_name:='cu.get_dati';
	idtransazione:= cu_log.get_id_transazione(idutente,proc_name);
	id_op:=cu_log.op(proc_name,idtransazione,v,null,ts,-1,operazione);

	--idutente è rbac.id_utente_struttura_ruolo
	select row_to_json(a.*) into j_user_info from
	(	
		select *,id_struttura as id_struttura_root from public.get_utente_info_3(idutente)
	) a;
 
	--j_user_info:='{"livello":3}';
	if j_user_info is not null then
		if v is null or v='' or v='{}' then
			v:= '{"user_info":'||j_user_info||'}';
		else
			v:= substring(v,1,length(v)-1)||',"user_info":'||j_user_info||'}';
		end if;
	end if;
	raise notice 'USER_DATA %', v;
	id_op:=cu_log.op(proc_name,idtransazione,v,null,ts,-1,operazione);
 
	begin 
	fallito:=false;
  raise info 'operazione%', operazione; 
	case operazione
		when 'get_user_info' then
			if v is not null then
				ret.esito = true;
				ret.info := v;
			end if;
		when 'get_tariffario_per_attivita' then
			ret:=trf.get_tariffario_per_attivita(v::json, idtransazione);	
		when 'get_cu_tipo_oggetti' then
			ret:=cu_conf.get_cu_tipo_oggetti(v::json, idtransazione);
		when 'get_cu_tipo_oggetti_validi' then
			ret:=cu_conf.get_cu_tipo_oggetti_validi(v::json, idtransazione);
		when 'get_cu_tipo_oggetti_requisiti' then
			ret:=cu_conf.get_cu_tipo_oggetti_requisiti(v::json, idtransazione);
		when 'get_cu_tipo_oggetti_requisiti_validi' then
			ret:=cu_conf.get_cu_tipo_oggetti_requisiti_validi(v::json, idtransazione);
		when 'get_cu' then
			ret:=cu.get_cu(v::json, idtransazione);
		when 'get_cu_info' then
			ret:=cu.get_cu_info(v::json, idtransazione);
		when 'get_cu_singolo' then
			ret:=cu.get_cu_singolo(v::json, idtransazione);
		when 'get_cu_oggetti' then
			ret:=cu.get_cu_oggetti(v::json, idtransazione);
		when 'get_cu_linee' then
			ret:=cu.get_cu_linee(v::json, idtransazione);
		when 'get_cu_tipo_linee' then
			ret:=cu_anag.get_cu_tipo_linee(v::json, idtransazione);
		when 'get_cu_linee_associate' then
			ret:=cu.get_cu_linee_associate(v::json, idtransazione);
		when 'get_cu_linee_stabilimenti' then
			ret:=cu_anag.get_cu_linee_stabilimenti(v::json, idtransazione);
		when 'get_cu_stabilimenti_linea_singolo' then
			ret:=cu_anag.get_cu_stabilimenti_linea_singolo(v::json, idtransazione);
		when 'get_cu_personale' then
			ret:=cu.get_cu_personale(v::json, idtransazione);
		when 'get_cu_ni' then
			ret:=cu.get_cu_nucleo(v::json, idtransazione);
		when 'get_cu_esterni' then
			ret:=cu.get_cu_esterni(v::json, idtransazione);
		when 'get_cu_piani' then
			ret:=cu.get_cu_piani(v::json, idtransazione);
		when 'get_piani' then
			ret:=cu.get_piani(v::json, idtransazione);
		when 'get_asl' then
			ret:=cu.get_asl(v::json, idtransazione);
		when 'get_cu_oggetti_cl' then
			ret:=cu.get_cu_oggetti_cl(v::json, idtransazione);
		when 'get_cu_evidenze' then
			ret:=cu.get_cu_evidenze(v::json, idtransazione);
		when 'get_cu_evidenze_by_norma' then
			ret:=cu.get_cu_evidenze_by_norma(v::json, idtransazione);
		when 'get_cu_norme_violate' then
			ret:=cu.get_cu_norme_violate(v::json, idtransazione);
		when 'get_cu_provv' then
			ret:=cu.get_cu_provv(v::json, idtransazione);
		when 'get_cu_classe_evidenze' then
			ret:=cu_types.get_cu_classe_evidenze(v::json, idtransazione);	
		when 'get_cu_grado_evidenze' then
			ret:=cu_types.get_cu_grado_evidenze(v::json, idtransazione);
		when 'get_cu_tipi_provv' then
			ret:=cu_types.get_cu_tipi_provv(v::json, idtransazione);
		when 'get_cu_tipi_provv_sopralluogo' then
			ret:=cu_types.get_cu_tipi_provv_sopralluogo(v::json, idtransazione);
		when 'get_cu_imprese' then
			ret:=cu_anag.get_cu_imprese(v::json, idtransazione);	
		when 'get_cu_imprese_by_sel' then
			ret:=cu_anag.get_cu_imprese_by_sel(v::json, idtransazione);	
		when 'get_cu_pratiche_by_sel' then
			ret:=cu_anag.get_cu_pratiche_by_sel(v::json, idtransazione);	
		when 'get_cu_pratica_singolo' then
			ret:=cu_anag.get_cu_pratica_singolo(v::json, idtransazione);	
		when 'get_cu_pratica_storico' then
			ret:=cu_anag.get_cu_pratica_storico(v::json, idtransazione);	
		when 'get_tipi_pratiche' then
			ret:=cu_types.get_tipi_pratiche(v::json, idtransazione);	
		when 'check_pratica' then
			ret:=cu_anag.check_pratica(v::json, idtransazione);	
		when 'get_cu_impresa_singolo' then
			ret:=cu_anag.get_cu_impresa_singolo(v::json, idtransazione);	
		when 'get_cu_stabilimenti' then
			ret:=cu_anag.get_cu_stabilimenti(v::json, idtransazione);
		when 'get_cu_stabilimento_singolo' then
			ret:=cu_anag.get_cu_stabilimento_singolo(v::json, idtransazione);
		when 'get_cu_stabilimenti_vigenti_by_sel' then
			ret:=cu_anag.get_cu_stabilimenti_vigenti_by_sel(v::json, idtransazione);
		when 'get_cu_stabilimenti_by_sel' then
			ret:=cu_anag.get_cu_stabilimenti_by_sel(v::json, idtransazione);
		when 'get_cu_linee_by_sel' then
			ret:=cu_anag.get_cu_linee_by_sel(v::json, idtransazione);
		when 'get_cu_stabilimenti_sedi' then
			ret:=cu_anag.get_cu_stabilimenti_sedi(v::json, idtransazione);
		when 'get_cu_imprese_sedi' then
			ret:=cu_anag.get_cu_imprese_sedi(v::json, idtransazione);
		when 'get_cu_imprese_sede_singolo' then
			ret:=cu_anag.get_cu_imprese_sede_singolo(v::json, idtransazione);
		when 'get_cu_stabilimenti_sede_singolo' then
			ret:=cu_anag.get_cu_stabilimenti_sede_singolo(v::json, idtransazione);
		when 'get_cu_stabilimenti_figura_singolo' then
			ret:=cu_anag.get_cu_stabilimenti_figura_singolo(v::json, idtransazione);
		when 'get_cu_stabilimenti_figure' then
			ret:=cu_anag.get_cu_stabilimenti_figure(v::json, idtransazione);
		when 'get_cu_imprese_figure' then
			ret:=cu_anag.get_cu_imprese_figure(v::json, idtransazione);
		when 'get_cu_imprese_figura_singolo' then
			ret:=cu_anag.get_cu_imprese_figura_singolo(v::json, idtransazione);
		when 'get_cu_stabilimenti_figure_by_impresa' then
			ret:=cu_anag.get_cu_stabilimenti_figure_by_impresa(v::json, idtransazione);
		when 'get_cu_stabilimenti_figure_by_f' then
			ret:=cu_anag.get_cu_stabilimenti_figure_by_f(v::json, idtransazione);
		when 'get_cu_soggetti_fisici' then
			ret:=cu_anag.get_soggetti_fisici(v::json, idtransazione);	
		when 'get_cu_soggetti_fisici_by_sel' then
			ret:=cu_anag.get_soggetti_fisici_by_sel(v::json, idtransazione);
		when 'get_soggetto_fisico_singolo' then
			ret:=cu_anag.get_soggetto_fisico_singolo(v::json, idtransazione);
		when 'get_cu_tipi_sede' then
			ret:=cu_types.get_cu_tipi_sede(v::json, idtransazione);
		when 'get_cu_tipo_imprese' then
			ret:=cu_types.get_cu_tipo_imprese(v::json, idtransazione);
		when 'get_tipologie_struttura_stabilimento' then
			ret:=cu.get_tipologie_struttura_stabilimento(v::json, idtransazione);
		when 'get_categorie_rischio_alberi' then
			ret:=cu.get_categorie_rischio_alberi(v::json, idtransazione);
		when 'get_cu_soggetto_figure_stabilimenti' then
			ret:=cu_anag.get_cu_soggetto_figure_stabilimenti(v::json, idtransazione);
		when 'get_cu_soggetto_figure_imprese' then
			ret:=cu_anag.get_cu_soggetto_figure_imprese(v::json, idtransazione);
		
		when 'get_cu_tipi_sede_impresa' then
			ret:=cu_types.get_cu_tipi_sede_impresa(v::json, idtransazione);
		when 'get_cu_tipi_figure_impresa' then
			ret:=cu_types.get_cu_tipi_figure_impresa(v::json, idtransazione);
		
		when 'get_cu_tipi_figure' then
			ret:=cu_types.get_cu_tipi_figure(v::json, idtransazione);
		when 'get_cu_cl_nuovi_stati' then
			ret:=cu.get_cu_cl_nuovi_stati(v::json, idtransazione);
		when 'get_cu_cl_nuovi_stati_massivo' then
			ret:=cu.get_cu_cl_nuovi_stati_massivo(v::json, idtransazione);
		when 'get_cu_stati_cu' then
			ret:=cu.get_cu_stati_cu(v::json, idtransazione);
		when 'get_cu_stati_oggetto' then
			ret:=cu.get_cu_stati_oggetto(v::json, idtransazione);
		when 'get_cu_info_per_verbale' then
			ret:=cu.get_cu_info_per_verbale(v::json, idtransazione);
		when 'get_cu_dichiarazione' then
			ret:=cu.get_cu_dichiarazione(v::json, idtransazione);
		when 'get_cu_tipi_oggetti_piano' then
			ret:=cu_conf.get_cu_tipi_oggetti_piano(v::json, idtransazione);
		when 'get_menu_old' then
			ret:=cu_ui.get_menu(v::json, idtransazione);
		when 'get_menu' then
			ret:=rbac_ui.get_menu(v::json, idtransazione);
		when 'get_form_definition' then
			ret:=cu_ui.get_ui_form_definition(v::json, idtransazione);
		when 'get_cu_tipi_isp' then
			ret:=cu_conf.get_cu_tipi_isp(v::json, idtransazione);
		when 'get_cu_tipi_per' then
			ret:=cu_conf.get_cu_tipi_per(v::json, idtransazione);
		when 'cu_check_stabilimento' then
			ret:=cu.cu_check_stabilimento(v::json, idtransazione);
		when 'cu_check_nuclei' then
			ret:=cu.cu_check_nuclei(v::json, idtransazione);
		when 'cu_check_oggetti' then
			ret:=cu.cu_check_oggetti(v::json, idtransazione);
		when 'cu_check_provvedimenti' then
			ret:=cu.cu_check_provvedimenti(v::json, idtransazione);
		when 'cu_check_automezzi' then
			ret:=cu.cu_check_automezzi(v::json, idtransazione);
		when 'cu_check_provvedimenti_fu' then
			ret:=cu.cu_check_provvedimenti_fu(v::json, idtransazione);
		when 'cu_check_categoria_rischio' then
			ret:=cu.cu_check_categoria_rischio(v::json, idtransazione);
		
		when 'get_cu_evidenze_linee_fu' then
			ret:=cu.get_cu_evidenze_linee_fu(v::json, idtransazione);
		when 'get_cu_nomi_pdf_evidenze' then
			ret:=cu.get_cu_nomi_pdf_evidenze(v::json, idtransazione);
		
		when 'get_cu_programmati' then
			ret:=cu_anag.get_cu_programmati(v::json, idtransazione);
		when 'get_cu_provv_in_corso' then
			ret:=cu_anag.get_cu_provv_in_corso(v::json, idtransazione);
		when 'get_cu_effettuati' then
			ret:=cu_anag.get_cu_effettuati(v::json, idtransazione);
		when 'get_cu_provv_fu' then
			ret:=cu.get_cu_provv_fu(v::json, idtransazione);
		when 'get_cu_nomi_pdf_controlli' then
			ret:=cu.get_cu_nomi_pdf_controlli(v::json, idtransazione);
		when 'get_categorie_rischio' then
			ret:=cu_types.get_categorie_rischio(v::json, idtransazione);
		when 'get_tipologie_struttura' then
			ret:=cu_types.get_tipologie_struttura(v::json, idtransazione);
		when 'get_tipologie_struttura_all' then
			ret:=cu_types.get_tipologie_struttura_all(v::json, idtransazione);
		when 'get_strutture_asl' then
			ret:=cu_anag.get_strutture_asl(v::json, idtransazione);
		when 'get_cu_indirizzi' then
			ret:=cu_anag.get_cu_indirizzi(v::json, idtransazione);
		when 'get_cu_indirizzi_trasportatori' then
			ret:=cu.get_cu_indirizzi_trasportatori(v::json, idtransazione);
		when 'get_cu_stabilimento_automezzi' then
			ret:=cu.get_cu_stabilimento_automezzi(v::json, idtransazione);
		when 'get_cu_automezzi' then
			ret:=cu.get_cu_automezzi(v::json, idtransazione);
		when 'check_esiste_cf' then
			ret:=cu_anag.check_esiste_cf(v::json, idtransazione);
		when 'check_esiste_impresa' then
			ret:=cu_anag.check_esiste_impresa(v::json, idtransazione);
		when 'get_categ_rischio' then --albero
			ret:=cu_conf.get_categ_rischio(v::json, idtransazione);
		when 'get_cu_categ_eval' then --albero con valori
			ret:=cu.get_cu_categ_eval(v::json, idtransazione);
		when 'get_tipo_import' then --albero con valori
		    ret:=cu_anag.get_tipo_import(v::json, idtransazione);
	    when 'get_elenco_import_anagrafica' then --albero con valori
			ret:=cu_anag.get_elenco_import_anagrafica(v::json, idtransazione);
		when 'get_import_file_anagrafica' then --albero con valori
			ret:=cu_anag.get_import_file_anagrafica(v::json, idtransazione);
		when 'get_import_file_sintesis' then --albero con valori
			ret:=cu_anag.get_import_file_sintesis(v::json, idtransazione);
	    when 'get_import_file_mangimifici' then
			ret:=cu_anag.get_import_file_mangimifici(v::json, idtransazione);
	    when 'get_cu_stabilimento_storico' then
			ret:=cu_anag.get_cu_stabilimento_storico(v::json, idtransazione);
	    when 'get_cu_provv_sopralluogo' then
			ret:=cu.get_cu_provv_sopralluogo(v::json, idtransazione);
	    when 'get_cu_provv_sopralluogo_fu' then
			ret:=cu.get_cu_provv_sopralluogo_fu(v::json, idtransazione);
	    when 'get_cu_piani_associati' then
			ret:=cu.get_cu_piani_associati(v::json, idtransazione);
		when 'get_cu_pratiche_by_stabilimento' then
			ret:=cu_anag.get_cu_pratiche_by_stabilimento(v::json, idtransazione);
		when 'get_esclusi_import_anagrafica' then
			ret:=cu_anag.get_esclusi_import_anagrafica(v::json, idtransazione);
	    when 'get_esclusi_import_sintesis' then
			ret:=cu_anag.get_esclusi_import_sintesis(v::json, idtransazione);
		when 'get_esclusi_import_mang' then
			ret:=cu_anag.get_esclusi_import_mang(v::json, idtransazione);
		when 'get_riepilogo_cu' then
			ret:=cu_his.get_riepilogo_cu(v::json, idtransazione);
		when 'get_cu_nominativo_provv' then
			ret:=cu.get_cu_nominativo_provv(v::json, idtransazione);
		when 'get_cu_automezzi_by_sel' then
			ret:=cu_anag.get_cu_automezzi_by_sel(v::json, idtransazione);
		when 'get_cu_automezzo_singolo' then
			ret:=cu_anag.get_cu_automezzo_singolo(v::json, idtransazione);
		when 'get_cu_stabilimenti_automezzi' then
			ret:=cu_anag.get_cu_stabilimenti_automezzi(v::json, idtransazione);
		when 'get_cu_automezzo_stabilimento_singolo' then
			ret:=cu_anag.get_cu_automezzo_stabilimento_singolo(v::json, idtransazione);
		
 		else
 			ret.esito := false;
 			ret.info  := 'CASO NON PREVISTO';
 			raise notice 'ELSE CASE';
	end case;

	RAISE notice 'cu.get_dati ret.esito: %', ret.esito;
	   
	if ret.esito=false then 
		RAISE notice 'cu.get_dati if su ret.esito=false';
		fallito=true;
		RAISE notice 'cu.get_dati ROLLBACK a seguito di ret.esito=false';
	end if;
	str_conf:= cu_ui.get_ui_definition(''::varchar,'cu.'||operazione,((j_user_info->'id_struttura_root')::varchar)::int8/*999::varchar::int8*/,idtransazione);
if str_conf is not null and str_conf != '' then
	 	 ret.info:='{'||str_conf||','||right(ret.info,length(ret.info)-1);
	end if;

/*raise notice 'ID_NS %',j_user_info->'id_struttura_root';
	str_conf:= cu_ui.get_ui_definition(''::varchar,'cu.'||operazione,((j_user_info->'id_struttura_root')::varchar)::int8,idtransazione);
raise notice 'OPERAZIONE % STR_CONF=%',operazione,str_conf;
raise notice 'j_user_info=%',j_user_info;
	if str_conf is not null and str_conf != '' then
	 	 ret.info:='{'||str_conf||','||right(ret.info,length(ret.info)-1);
	end if;*/

	exception when others then
		fallito:=true;
		RAISE notice 'cu.get_dati ROLLBACK a seguito di exception';
		GET STACKED DIAGNOSTICS text_msg1 = MESSAGE_TEXT,
		                  			text_msg2 = PG_EXCEPTION_DETAIL,
		                  			text_msg3 = PG_EXCEPTION_HINT,
		                 			text_msg4 = PG_EXCEPTION_CONTEXT;
		ret.esito:=false;
		ret.valore:= null;
	if replace(upper(j_user_info->>'ambiente'),'"','') ='local' then
		ret.err_msg:=coalesce(ret.err_msg,'')||coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');
	else
		ret.err_msg:=coalesce(ret.err_msg,'')||coalesce(text_msg1,'');
	end if;
   end;
  
  	if fallito=true then 
		rollback;
	end if;

	joutput:=row_to_json(ret);
	id_op:=cu_log.op(proc_name,idtransazione,v,null,ts,-1,operazione);
--commit;
end;
$$;


ALTER PROCEDURE cu.get_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json) OWNER TO postgres;

--
-- Name: get_piani(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_piani(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	rt json;
	idcu bigint;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu.get_piani';
		ret.esito:=false;
		idcu=v->'id_cu';
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;

		select json_agg(row_to_json(a.*)) into rt   from (
			/*select * from matrix.vw_tree_nodes_up_piani
			where id not in (select id_piano from cu.cu_piani where id_cu=idcu) and anno=extract (year from  R_CU.dt)*/
			select vp.id_node id,vp.name_tree ,vp.id_node,vp.id_node_parent,
			coalesce(alias||' ','')||descrizione_breve descrizione_breve,
			coalesce(alias||' ','')||descrizione       descrizione,
			cp.id is null --and p.id is null selezionabile
			from matrix.vw_tree_nodes_up_piani vp 
			left join cu.cu_piani cp on cp.id_piano =vp.id_node and  id_cu=idcu
			left join (select distinct id_node_parent id from matrix.vw_tree_nodes_up_piani where anno=extract (year from  R_CU.dt) and data_scadenza is null) p
				on p.id=vp.id_node
			where /*id not in (select id_piano from cu.cu_piani where id_cu=idcu) and*/ anno=extract (year from  R_CU.dt) and data_scadenza is null
			order by path_ord 
			) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_piani(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tipologie_struttura_stabilimento(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_tipologie_struttura_stabilimento(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin 
		declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
    	rt json;
		begin
		proc_name:='cu.get_tipologie_struttura_stabilimento';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V=%', v;
	
		select json_agg(row_to_json(a.*)) into rt   from (
			select * 
			from cu_types.vw_tipologie_struttura vts ) a;
		
		raise notice 'RT %',rt;
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
 		return ret;
	end;
end;
$$;


ALTER FUNCTION cu.get_tipologie_struttura_stabilimento(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_utente_info(bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.get_utente_info(idutente bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
begin
	declare
	j_user_info json;
begin
	
	--SELECT j into j_user_info
    --FROM dblink('mdgm_fvg_foreign', format('select matrix.get_utente_info(%L)',idutente)) t(j json);
	j_user_info:= matrix.get_utente_info(idutente);
	return j_user_info;
end;
end;
$$;


ALTER FUNCTION cu.get_utente_info(idutente bigint) OWNER TO postgres;

--
-- Name: obs_cu_aggiorna_norme_violate(bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.obs_cu_aggiorna_norme_violate(idcu bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type;
	retl cu_types.result_type;
	id_op bigint;   
	proc_name varchar;
	R_NV cu.cu_norme_violate%ROWTYPE;
	R_E cu.vw_cu_evidenze%ROWTYPE;
	n bigint;
	rt json;
	begin
		proc_name:='cu.cu_aggiorna_norme_violate';
		ret.esito:=false;
	
		--16/04/2024 SL
		for R_NV in (select * from cu.cu_norme_violate 
					 where id_cu=idcu and id_norma 
					 not in (select distinct e.id_norma from cu.vw_cu_evidenze e where e.id_cu = idcu))
		loop
			retl:=cu.cu_del_provv_norme_violate(R_NV.id);
		end loop;
		

		for R_E in (select * from cu.vw_cu_evidenze e
					where e.id_cu = idcu and id_norma 
					not in (select id_norma from cu.cu_norme_violate where id_cu=idcu)
					and e.sigla_classe_evidenza ilike 'nc')
		loop 
			insert into cu.cu_norme_violate values(nextval('cu.cu_id_seq'),R_E.id_cu,R_E.id_norma) returning * into R_NV;
			n:=cu_log.upd_record('cu.cu_norme_violate',-1,R_NV,'I');
		end loop;
	
		raise notice 'RT %',rt;
	
		ret.esito:=true;
		--ret.info:='{"dati":'||coalesce(rt,'[]')::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.obs_cu_aggiorna_norme_violate(idcu bigint) OWNER TO postgres;

--
-- Name: upd_add_automezzi(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_add_automezzi(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcu bigint;
      	idautomezzo bigint;
      	n bigint;
      	r record;
        proc_name varchar; -- END
	begin
		proc_name:='cu.upd_add_automezzi';
		raise notice 'V_J=%', v_j;

		idcu:=v_j->'id_cu';

		for idautomezzo in select * from json_array_elements(v_j->'automezzi')
		loop
			insert into cu.cu_automezzi values (nextval('cu.cu_id_seq'),idcu,idautomezzo) returning * into r;
			n:=cu_log.upd_record('cu.cu_automezzi',idtransazione,r,'I');
		end loop;
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_add_automezzi(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_add_cu_oggetti(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_add_cu_oggetti(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        idnominativostruttura bigint;  
       	idsroot bigint;
		u json;
       	ordmax integer;
      	idcu bigint;
      	R_CU cu.vw_cu;
      	--idlinea bigint;
        proc_name varchar; -- END
	begin
		proc_name:='cu.upd_add_cu_oggetti';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idnominativostruttura:=v_j->'id_nominativo_struttura';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';
		idcu:=v_j->'id_cu';
	
	    --R_CU cu.cu;
		select * into R_CU from cu.vw_cu where id=idcu;
		if R_CU.chiuso then
			ret.esito:=false;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'cu_chiuso_modifica_non_possibile');
	    	return ret;
		end if;
		--idlinea:=v_j->'id_linea';
		select coalesce(max(ord),1)+1 into ordmax from cu.cu_oggetti
			where id_cu=idcu;
	
		/*delete from cu.cu_oggetti where id_cu=idcu and id_tipo_oggetto
 		not in (select (value::varchar)::bigint id_linea from
                        json_array_elements(v_j->'id_linee') );
        select coalesce(max(ord),0)+1 into ordmax from cu.cu_linee
			where id_cu=idcu;   */           
                       
		insert into cu.cu_oggetti select nextval('cu.cu_id_seq'),idcu,ordmax +row_number() over(),(value::varchar)::bigint
			from json_array_elements(v_j->'id_oggetti')
			where (value::varchar)::bigint not in (select id_tipo_oggetto from cu.cu_oggetti where id_cu=idcu);

		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_add_cu_oggetti(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_add_cu_piano(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_add_cu_piano(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        idnominativostruttura bigint;  
       	--idsroot bigint;
		--u json;
		n integer;
		R_CU cu.cu;
		R_P cu.cu_piani;
       	ordmax integer;
      	idcu bigint;
      	idpiano bigint;
     	idpercontodi bigint;
      	idtipooggetto bigint;
        proc_name varchar; -- end
        R_CO cu.cu_oggetti;
        R_CL cu.cu_oggetti_cl;
       	r record;
	begin
		proc_name:='cu.upd_add_cu_piano';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idnominativostruttura:=v_j->'id_nominativo_struttura';
       	--u:= v_j->'user_info';
		--idsroot:= u->'id_struttura_root';
		idcu:=v_j->'id_cu';
		idpiano:=v_j->'id_piano';
		idpercontodi:=v_j->'id_per_conto_di';
	
	
		
		select * into R_CU from cu.cu where id=idcu;
		if R_CU.chiuso then
			ret.esito:=false;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'cu_chiuso_modifica_non_possibile');
	    	return ret;
		end if;
	
	
		select coalesce(max(ord),1)+1 into ordmax from cu.cu_piani where id_cu=idcu;

		insert into cu.cu_piani values (nextval('cu.cu_id_seq'),idcu,idpiano,ordmax,idpercontodi) returning * into R_P;
		n:=cu_log.upd_record('cu.cu_piani',idtransazione,R_P,'I');
	
		select coalesce(max(ord),0) into n from cu.cu_oggetti where id_cu=idcu;
		
	/*  insert into cu.cu_oggetti 
		
		select nextval('cu.cu_id_seq'),idcu,n + row_number ()over (),op.id_tipo_oggetto,false from
				(select distinct op.id_tipo_oggetto 
		from cu.cu_piani p
		join cu_conf.vw_cu_tipo_oggetto_piani op on op.id_piano =p.id_piano
		left join cu.cu_oggetti o on o.id_cu =p.id_cu and o.id_tipo_oggetto =op.id_tipo_oggetto 
		where p.id_cu=idcu and o.id_cu is null) op;*/

		for R_CO in select nextval('cu.cu_id_seq'),idcu,n +row_number() over(),op.id_tipo_oggetto,false
			from (select distinct op.id_tipo_oggetto 
					from cu.cu_piani p
					join cu_conf.vw_cu_tipo_oggetto_piani op on op.id_piano =p.id_piano
					left join cu.cu_oggetti o on o.id_cu =p.id_cu and o.id_tipo_oggetto =op.id_tipo_oggetto 
					where p.id_cu=idcu and o.id_cu is null) op loop
			insert into cu.cu_oggetti values (R_CO.*);
			--log cu_oggetti
			n:=cu_log.upd_record('cu.cu_oggetti',idtransazione,R_CO,'I');
			/*
			insert into cu.cu_oggetti_cl
				select nextval('cu.cu_id_seq'),R_CO.id,r.id from cu_conf.cu_requisiti r
				where id_tipo_oggetto= R_CO.id_tipo_oggetto returning * into R_CL;
			*/
			--log cu_oggetti_cl
			for r in (select * from cu_conf.cu_requisiti where id_tipo_oggetto= R_CO.id_tipo_oggetto ) loop
				insert into cu.cu_oggetti_cl select nextval('cu.cu_id_seq'),R_CO.id,r.id returning * into R_CL;
				n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'I');
			end loop;
			
		end loop;	
	
	
	

		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_add_cu_piano(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_add_indirizzi_trasportatori(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_add_indirizzi_trasportatori(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcu bigint;
      	idindirizzo bigint;
      	n bigint;
      	r record;
        proc_name varchar; -- END
	begin
		proc_name:='cu.upd_add_indirizzi_trasportatori';
		raise notice 'V_J=%', v_j;

		idcu:=v_j->'id_cu';
		
		ret := cu_anag.upsert_indirizzi(v_j,idtransazione);
		idindirizzo = ret.info;

		select count(*) into n from cu.cu_indirizzi
		where id_cu = idcu;

		if n > 0 then
			ret.esito:=true;
		    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
		    ret.info = '0';
	 		return ret;
		end if;

		insert into cu.cu_indirizzi values (nextval('cu.cu_id_seq'),idcu,idindirizzo) returning * into r;
		n:=cu_log.upd_record('cu.cu_indirizzi',idtransazione,r,'I');
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_add_indirizzi_trasportatori(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_categorie_rischio_alberi(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_categorie_rischio_alberi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        id_op bigint;  
        idtipostruttura bigint;
       	idcategorizzazionerischio bigint;
        proc_name varchar; -- END
        v_j json;
        begin
		proc_name:='agenda.upd_tipologia_controllo_piani';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		idtipostruttura:=v_j->'id_tipo_struttura';
		idcategorizzazionerischio:= json_array_elements(v_j->'id_categorizzazione_rischio');
		
		raise notice 'v%', v_j;
		raise notice 'id_categorizzazione_rischio %', v_j->'id_categorizzazione_rischio';
		delete from cu.categorizzazione_rischio_tipo_stabilimento where id_categorizzazione_rischio not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_categorizzazione_rischio'))
			and id_tipo_stabilimento = idtipostruttura;
	
		--insert into cu.categorizzazione_rischio_tipo_stabilimento (id_categorizzazione_rischio, id_tipo_stabilimento) values (idcategorizzazionerischio,idtipostruttura);

		insert into cu.categorizzazione_rischio_tipo_stabilimento (id_categorizzazione_rischio, id_tipo_stabilimento)
		select (value::varchar)::bigint, idtipostruttura from json_array_elements(v_j->'id_categorizzazione_rischio')
		where (value::varchar)::bigint
		not in (select id_categorizzazione_rischio from cu.categorizzazione_rischio_tipo_stabilimento 
						where id_tipo_stabilimento = idtipostruttura);
	
	
	
	
	
	
    	ret.esito:=true;	
        --ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_categorie_rischio_alberi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_dichiarazione(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_add_dichiarazione(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
		R_D cu.cu_dichiarazioni;
		R_CU cu.cu;
		R_CUN cu.cu_nucleo;
		n bigint;
	begin
		proc_name:='cu.upd_cu_add_dichiarazione';
		raise notice 'V_J=%', v_j;
		ret.esito:=false;
		
		R_D.id_cu_nucleo:= v_j->'id_cu_nucleo';
	
		select * into R_CUN from cu.cu_nucleo where id=R_D.id_cu_nucleo;
	
		select * into R_CU from cu.cu where id=R_CUN.id_cu;
		if R_CU.chiuso then
			ret.esito:=fasse;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'cu_chiuso_modifica_non possibile');
	    	return ret;
		end if;		
	
		select * into R_D from cu.cu_dichiarazioni where id_cu_nucleo = R_D.id_cu_nucleo;
		delete from cu.cu_dichiarazioni where id_cu_nucleo = R_D.id_cu_nucleo;
		n:=cu_log.upd_record('cu.cu_dichiarazioni',idtransazione,R_D,'D');
	
		if R_D.id_cu_nucleo is null then
			R_D.id_cu_nucleo:= v_j->'id_cu_nucleo';
		end if;
		
		R_D.dichiarazione:= v_j->>'dichiarazione';
		R_D.id:=nextval('cu.cu_provv_id_seq');
		
		insert into cu.cu_dichiarazioni values(R_D.*) returning * into R_D;
		n:=cu_log.upd_record('cu.cu_dichiarazioni',idtransazione,R_D,'I');
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_add_dichiarazione(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_esterno(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_add_esterno(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcu  bigint;
      	idns bigint;
     	ini timestamp;
     	fin timestamp;
        proc_name varchar; -- end
        R_N  cu.cu_nucleo;
       	R_NP cu.cu_nucleo_periodi;
        n integer;
       	nome varchar;
		cognome varchar;
		dt_nascita date;
		comune_nascita varchar;
		c_f varchar;
		ruolo varchar;
		R_A cu.cu_altri;		    
		R_CU cu.cu;
	begin
		proc_name:='cu.upd_cu_add_esterno';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idcu:=v_j->'id_cu';
	
	

		select * into R_CU from cu.cu where id=idcu;
		if R_CU.chiuso then
			ret.esito:=false;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'cu_chiuso_modifica_non_possibile');
	    	return ret;
		end if;
	
		if v_j->'inizio' is null or (v_j->'inizio')::varchar = 'null' then
			ini:= null;
		else
			ini :=v_j->'inizio';
		end if;
		if v_j->'fine' is null or  (v_j->'fine')::varchar = 'null' then
			fin:= null;
		else
			fin :=v_j->'fine';
		end if;	
	
	
		nome:=v_j->>'nome';
		cognome:=v_j->>'cognome';
		dt_nascita:=v_j->>'dt_nascita';
		comune_nascita:=v_j->>'comune_nascita';
		c_f:=upper(v_j->>'cf');
		ruolo:=v_j->>'ruolo';

		select * into R_A from cu.cu_altri where cf=c_f;

		if R_A.id is null then
		--R_A.id:=nextval('cu.cu_id_seq');
			--insert into cu.cu_altri values(R_A.id,nome,cognome,comune_nascita,dt_nascita ,c_f);
			R_A.id:=nextval('cu.cu_altri_id_seq');
			insert into cu.cu_altri values(R_A.id,nome,cognome,comune_nascita,dt_nascita ,c_f) returning * into R_A;
			--log add cu_altri
			n:=cu_log.upd_record('cu.cu_altri',idtransazione,R_A,'I');
		end if;
	
		R_NP.periodo:=tsrange(ini,fin,'[)');
		select * into R_N from cu.cu_nucleo where id_nominativo=R_A.id  and id_cu=idcu and id_tipo_nucleo=2;
		if R_N.id is null then
			select coalesce(max(ord::bigint),0)+1 into R_N.ord from cu.cu_nucleo where id_cu=idcu;
			R_N.id:=nextval('cu.cu_id_seq');
			R_N.id_cu:=idcu;
			R_N.ruolo:=ruolo;
			R_N.id_tipo_nucleo:=2;
			R_N.id_nominativo:=R_A.id;
			--insert into cu.cu_nucleo values(nextval('cu.cu_id_seq'),idcu,idns,R_N.ord);
			insert into cu.cu_nucleo values(R_N.*) returning * into R_N;
			--log add cu_nucleo
			n:=cu_log.upd_record('cu.cu_nucleo',idtransazione,R_N,'I');
		else
			select count(*) into n from cu.cu_nucleo_periodi
				where id_cu_nucleo=R_N.id and periodo && R_NP.periodo;
			if n> 0 then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'periodo_non_compatibile');
			end if;
		end if;
		R_NP.id:=nextval('cu.cu_id_seq');
		R_NP.id_cu_nucleo:=R_N.id;
		insert into cu.cu_nucleo_periodi values(R_NP.*) returning * into R_NP;
		--log add cu_nucleo_periodi
		n:=cu_log.upd_record('cu.cu_nucleo_periodi',idtransazione,R_NP,'I');
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_add_esterno(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_evidenza(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_add_evidenza(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- start
	    ret1 cu_types.result_type; -- START
        proc_name varchar; -- end
		R_E cu.cu_evidenze;
		R_EL cu.cu_evidenza_linee;
		idlinea bigint;
		n bigint;
		R_OCL cu.vw_cu_oggetti_cl;

	begin
		proc_name:='cu.upd_cu_add_evidenza';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;
		ret.esito:=false;
		R_E.id_cu_oggetto_cl:=v_j->>'id_cu_oggetto_cl';
		select * into R_OCL from cu.vw_cu_oggetti_cl where id_cu_oggetto_cl=R_E.id_cu_oggetto_cl;
		--R_E.id_cu_linea :=v_j->>'id_cu_linea';
		R_E.id_cu_grado_evidenza :=v_j->>'id_cu_grado_evidenza';
		R_E.id_cu_classe_evidenza :=v_j->>'id_cu_classe_evidenza';
		R_E.evidenza :=v_j->>'evidenza';
		R_E.risultanza :=v_j->>'risultanza';
		R_E.id:=nextval('cu.cu_id_seq');
		select coalesce(max(ord),0) +1 into R_E.ord from cu.cu_evidenze
			where id_cu_oggetto_cl=R_E.id_cu_oggetto_cl;

		insert into cu.cu_evidenze values(R_E.*);
		n:=cu_log.upd_record('cu.cu_evidenze',idtransazione,R_E,'I');
		/*
		insert into cu.cu_evidenza_linee
			select nextval('cu.cu_id_seq'),R_E.id,(value::varchar)::bigint id
			from json_array_elements(v_j->'id_cu_linee') ;
		*/
		for idlinea in (select * from json_array_elements(v_j->'id_cu_linee'))
		loop
			insert into cu.cu_evidenza_linee
			select nextval('cu.cu_id_seq'),R_E.id,idlinea returning * into R_EL;
			n:=cu_log.upd_record('cu.cu_evidenza_linee',idtransazione,R_EL,'I');
		end loop;
		
		
		ret1:=cu.cu_aggiorna_norme_violate(R_OCL.id_cu, idtransazione);
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
	   
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_add_evidenza(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_nucleo(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_add_nucleo(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcu  bigint;
      	idnominativo bigint;
      idstruttura bigint;
     	ini timestamp;
     	fin timestamp;
        proc_name varchar; -- end
        R_N  cu.cu_nucleo;
       	R_NP cu.cu_nucleo_periodi;
        R_CP cu.vw_cu_periodo%ROWTYPE;
        n integer;
	begin
		proc_name:='cu.upd_cu_add_nucleo';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idcu:=v_j->'id_cu';
		idnominativo:=v_j->'id_nominativo';
		idstruttura:=v_j->'id_struttura';

		if v_j->'inizio' is null or (v_j->'inizio')::varchar = 'null' then
			select min(inizio) into ini from cu.vw_cu_nucleo_ni vcnn where id_cu=idcu and sigla_tipo_isp='resp';
			--ini:= null;
		else
			ini :=v_j->'inizio';
		end if;
		if v_j->'fine' is null or  (v_j->'fine')::varchar = 'null' then
			select max(fine) into fin from cu.vw_cu_nucleo_ni vcnn where id_cu=idcu and sigla_tipo_isp='resp';
			--fin:= null;
		else
			fin :=v_j->'fine'; 
		end if;	
		R_NP.periodo:=tsrange(ini,fin,'[)');
		select * into R_N from cu.cu_nucleo where id_cu=idcu and id_nominativo=idnominativo /*and per_conto_di=idstruttura */and id_tipo_nucleo=1;
		if R_N.id is null then
			select coalesce(max(ord::bigint),0)+1 into R_N.ord from cu.cu_nucleo where id_cu=idcu;
			R_N.id:=nextval('cu.cu_id_seq');
			R_N.id_cu:=idcu;
			R_N.id_nominativo:=idnominativo;
			R_N.per_conto_di:=idstruttura;
			R_N.id_tipo_nucleo:=1;
			R_N.id_tipo_isp:=v_j->'id_tipo_isp';
			--insert into cu.cu_nucleo values(nextval('cu.cu_id_seq'),idcu,idns,R_N.ord);
			insert into cu.cu_nucleo values(R_N.*) returning * into R_N;
			--log cu_nucleo
			n:=cu_log.upd_record('cu.cu_nucleo',idtransazione,R_N,'I');
		else
			select count(*) into n from cu.cu_nucleo_periodi
				where id_cu_nucleo=R_N.id and periodo && R_NP.periodo;
			if n> 0 then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'periodo_non_compatibile');
	    		return ret;
			end if; 
		end if;
		R_NP.id:=nextval('cu.cu_id_seq');
		R_NP.id_cu_nucleo:=R_N.id;
		R_NP.id_cu_piano:=v_j->'id_cu_piano';
		insert into cu.cu_nucleo_periodi values(R_NP.*) returning * into R_NP;
		--log cu_nucleo_periodi
		n:=cu_log.upd_record('cu.cu_nucleo_periodi',idtransazione,R_NP,'I');
	
		-- issue #11566
	
		select * into R_CP from cu.vw_cu_periodo where id_cu = idcu;
	
		update agenda.eventi
		set inizio = R_CP.cu_inizio,
		fine = R_CP.cu_fine
		where id = (select id_evento from cu.cu where id = idcu);
	
		update cu.cu 
		set dt = R_CP.cu_inizio
		where id = idcu;
	
		-- fine
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_add_nucleo(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_personale(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_add_personale(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcu  bigint;
      	idns bigint;
     	ini timestamp;
     	fin timestamp;
        proc_name varchar; -- end
        R_N  cu.cu_nucleo;
       	R_NP cu.cu_nucleo_periodi;
        n integer;
       	nome varchar;
		cognome varchar;
		dt_nascita date;
		comune_nascita varchar;
		c_f varchar;
		ruolo varchar;
		R_A cu.cu_altri;
	begin
		proc_name:='cu.upd_cu_add_personale';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;
		idcu:=v_j->'id_cu';
	
		if v_j->'inizio' is null or (v_j->'inizio')::varchar = 'null' then
			ini:= null;
		else
			ini :=v_j->'inizio';
		end if;
		if v_j->'fine' is null or  (v_j->'fine')::varchar = 'null' then
			fin:= null;
		else
			fin :=v_j->'fine';
		end if;	
	
	
		nome:=upper(v_j->>'nome');
		cognome:=upper(v_j->>'cognome');
		dt_nascita:=v_j->'dt_nascita';
		comune_nascita:=v_j->>'comune_nascita';
		c_f:=upper(v_j->>'cf');
		ruolo:=v_j->>'ruolo';

		select * into R_A from cu.cu_altri where cf=c_f;

		if R_A.id is null then
			--R_A.id:=nextval('cu.cu_id_seq');
			--insert into cu.cu_altri values(R_A.id,nome,cognome,comune_nascita,dt_nascita ,c_f);
			R_A.id:=nextval('cu.cu_altri_id_seq');
			insert into cu.cu_altri values(R_A.id,nome,cognome,comune_nascita,dt_nascita ,c_f) returning * into R_A;
			--log add cu_altri
			n:=cu_log.upd_record('cu.cu_altri',idtransazione,R_A,'I');
		end if;
	
		R_NP.periodo:=tsrange(ini,fin,'[)');
		select * into R_N from cu.cu_nucleo where id_nominativo=R_A.id  and id_cu=idcu and id_tipo_nucleo=3;
		if R_N.id is null then
			select coalesce(max(ord::bigint),0)+1 into R_N.ord from cu.cu_nucleo where id_cu=idcu;
			R_N.id:=nextval('cu.cu_id_seq');
			R_N.id_cu:=idcu;
			R_N.id_tipo_per:=ruolo;
			R_N.id_tipo_nucleo:=3;
			R_N.id_nominativo:=R_A.id;
			--insert into cu.cu_nucleo values(nextval('cu.cu_id_seq'),idcu,idns,R_N.ord);
			select count(*) into n from cu.vw_cu_nucleo_p where id_cu = idcu and custode_verbale;
			if n > 0 then
				R_N.custode_verbale = false;
			else
				R_N.custode_verbale = true;
			end if;
			insert into cu.cu_nucleo values(R_N.*) returning * into R_N;
			--log add cu_nucleo
			n:=cu_log.upd_record('cu.cu_nucleo',idtransazione,R_N,'I');
		else
			select count(*) into n from cu.cu_nucleo_periodi
				where id_cu_nucleo=R_N.id and periodo && R_NP.periodo;
			if n> 0 then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'periodo_non_compatibile');
			end if;
		end if;
		R_NP.id:=nextval('cu.cu_id_seq');
		R_NP.id_cu_nucleo:=R_N.id;
	
		insert into cu.cu_nucleo_periodi values(R_NP.*) returning * into R_NP;
		--log add cu_nucleo_periodi
		n:=cu_log.upd_record('cu.cu_nucleo_periodi',idtransazione,R_NP,'I');
		
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_add_personale(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_provv(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_add_provv(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
		R_P cu.cu_provv;
		R_NV cu.vw_cu_norme_violate;
		n bigint;

	begin
		proc_name:='cu.upd_cu_add_provv';
		raise notice 'V_J=%', v_j;
		ret.esito:=false;
		R_P.id_norma_violata:=v_j->>'id_norma_violata';
		select *  into R_NV from cu.vw_cu_norme_violate where id_norma_violata=R_P.id_norma_violata;
		if R_NV.id is null then
			ret.esito:=false;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'norma_violata_inesistente');
	 		return ret;
		end if;
		if R_NV.cu_chiuso then
			ret.esito:=false;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'cu_chiuso');
	 		return ret;
		end if;
		R_P.azione:=v_j->>'azione';
		R_P.id_tipo_provv:=v_j->>'id_tipo_provv';
		select coalesce(max(ord),1) +1 into R_P.ord from cu.cu_provv
		where id_norma_violata=R_P.id_norma_violata;
		
		R_P.dt:=v_j->>'dt';
		R_P.id:=nextval('cu.cu_provv_id_seq');
		R_P.chiuso:= false;

		insert into cu.cu_provv values(R_P.*);
		n:=cu_log.upd_record('cu.cu_provv',idtransazione,R_P,'I');

		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_add_provv(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_provv_sopralluogo(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_add_provv_sopralluogo(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- start
	    ret1 cu_types.result_type; -- START
        proc_name varchar; -- end
        R_CU cu.vw_cu%ROWTYPE;
		R_PS cu.cu_provv_sopralluogo;
		R record;
		idcu bigint;
		n bigint;
		id_linea int;
		id_piano int;

	begin
		proc_name:='cu.upd_cu_add_provv_sopralluogo';
		raise notice 'V_J=%', v_j;
		ret.esito:=false;
	
		idcu=v_j->'id_cu';
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
	
		R_PS.id_cu:=v_j->>'id_cu';
		R_PS.id_cu_grado_evidenza :=v_j->>'id_cu_grado_evidenza';
		R_PS.id_cu_classe_evidenza :=v_j->>'id_cu_classe_evidenza';
		R_PS.evidenza :=v_j->>'evidenza';
		R_PS.id_tipo_provv:=v_j->>'id_tipo_provv';
		R_PS.dt:=v_j->>'dt';
		R_PS.id_nominativo:=R_CU.id_responsabile; --default responsabile CU
	
		/*
		insert into cu.cu_provv_sopralluogo values(R_PS.*);
		insert into cu.cu_provv_sopralluogo
			select nextval('cu.cu_id_seq'),R_PS.id,(value::varchar)::bigint id
			from json_array_elements(v_j->'id_cu_linee') ;
		*/
	
		for id_linea in select json_array_elements(v_j->'id_cu_linee')
		loop
			for id_piano in select json_array_elements(v_j->'id_cu_piani')
			loop
				R_PS.id:=nextval('cu.cu_provv_sopralluogo_id_seq');
				R_PS.id_cu_linea:=id_linea;
				R_PS.id_piano:=id_piano;
				insert into cu.cu_provv_sopralluogo values(R_PS.*) returning * into R;
				n:=cu_log.upd_record('cu.cu_provv_sopralluogo',idtransazione,R,'I');
			end loop;
		end loop;
		
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
	   
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_add_provv_sopralluogo(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_requisiti(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_add_requisiti(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
		R_Q cu_conf.cu_requisiti;

	begin
		proc_name:='cu.upd_cu_add_requisiti';
		raise notice 'V_J=%', v_j;
		ret.esito:=false;
		R_Q.id_tipo_oggetto:=v_j->>'id_tipo_oggetto';
		R_Q.descr:=v_j->>'descr';
		R_Q.norma:=v_j->>'norma';
		R_Q.cl:=v_j->>'cl';
		R_Q.validita:=tsrange(current_date,null,'[)');
		R_Q.ord:=coalesce((select max(ord)+1 from cu_conf.cu_requisiti where id_tipo_oggetto = R_Q.id_tipo_oggetto),0);
		R_Q.id:=nextval('cu_conf.cu_requisiti_id_seq');

		insert into cu_conf.cu_requisiti values(R_Q.*);
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
end
$$;


ALTER FUNCTION cu.upd_cu_add_requisiti(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_tipo_oggetto(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_add_tipo_oggetto(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
		R_O cu_conf.cu_tipo_oggetti;
		n bigint = 0;

	begin
		proc_name:='cu.upd_cu_add_tipo_oggetto';
		raise notice 'V_J=%', v_j;
		ret.esito:=false;
		R_O.sigla:=v_j->>'sigla';
		R_O.descr:=v_j->>'descr';
		R_O.cod:=v_j->>'cod';
	
		R_O.sigla:=trim(R_O.sigla);
		R_O.descr:=trim(R_O.descr);
		R_O.cod:=trim(R_O.cod);

		ret.esito:=false;

		R_O.validita:=(SELECT tsrange(current_date - interval '1 day', null, '[)'));
		R_O.ord:=(select max(ord)+1 from cu_conf.cu_tipo_oggetti);
		R_O.id:=nextval('cu_conf.cu_oggetti_id_seq');
	
		select count(*) into n from cu_conf.vw_cu_tipo_oggetti c where c.cod = R_O.cod and c.validita @> localtimestamp;
		if n > 0 then
		ret:=cu_ui.build_ret(ret,proc_name,'cod_oggetto_gia_inserito');
			return ret;
		end if;	
	
		select count(*) into n from cu_conf.vw_cu_tipo_oggetti c where c.sigla = R_O.sigla and c.validita @> localtimestamp;	
		if n > 0 then
		ret:=cu_ui.build_ret(ret,proc_name,'sigla_oggetto_gia_inserita');
			return ret;
		end if;
	
		select count(*) into n from cu_conf.vw_cu_tipo_oggetti c where c.descr = R_O.descr and c.validita @> localtimestamp;
		if n > 0 then
		ret:=cu_ui.build_ret(ret,proc_name,'descr_oggetto_gia_inserita');
			return ret;
		end if;
	
		insert into cu_conf.cu_tipo_oggetti  values(R_O.*);
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
end

$$;


ALTER FUNCTION cu.upd_cu_add_tipo_oggetto(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_categ(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_categ(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	R_CU_CATEG cu_conf.vw_cu_categ_nodes%ROWTYPE;
	rt json;
	idcu bigint;
	idcateg bigint;
	val numeric;
	R_E cu_conf.vw_cu_categ_esiti;
	R_STAB cu_anag.stabilimenti;
	begin
		proc_name:='cu.upd_cu_categ';
		ret.esito:=false;
		idcu=v->'id_cu';
	
		ret.esito:= false;
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;
	
		ret:=cu.cu_check_categoria_rischio(v, idtransazione);
		if not ret.esito then
			return ret;
		end if;
	
		select e.* into R_E
			from cu_conf.vw_cu_categ_nodes_up_descr n join
			(select n.id_node_ref,sum(peso*coalesce(e.valore,0)) valore
			from cu_conf.vw_cu_categ_nodes_down n left join cu.vw_cu_categ_evals e on n.id_node=e.id_categ and id_cu=idcu
			group by 1) v on n.id_node =v.id_node_ref
			left join cu.vw_cu_categ_evals ev on n.id_node=ev.id_categ and id_cu=idcu
			left join cu_conf.vw_cu_categ_esiti e on n.id_node_parent is null and  e.rng  @> v.valore
			where n.id_node_parent is null;
		
		update cu_anag.stabilimenti set categoria_rischio= R_E.valore where id =R_CU.id_az_sede returning * into R_STAB;
		update cu_anag.stabilimento_categorizzazioni set validita=tsrange(lower(validita),R_CU.dt_chiusura,'[)')
			where id_stabilimento =R_CU.id_az_sede and upper_inf(validita);
		insert into cu_anag.stabilimento_catgorizzazioni values (nextval('cu_anag.cu_anag_id_seq'),
				R_CU.id_az_sede,tsrange(R_CU.dt_chiusura,null,'[)'),R_E.valore);
	
		ret.esito:=true;
	    --ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    --ret.info = '0';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.upd_cu_categ(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_categ_eval(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_categ_eval(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	R_CU_CATEG cu_conf.vw_cu_categ_nodes%ROWTYPE;
	rt json;
	idcu bigint;
	idcateg bigint;
	val numeric;
	R_CE cu.cu_categ_evals;
	r record;
	begin
		proc_name:='cu.upd_cu_categ_eval';
		ret.esito:=false;
		idcu=v->'id_cu';
		idcateg=v->'id_categ';
		val:=v->'valore';
		
		ret.esito:= false;
		select * into R_CU from cu.vw_cu where id_cu=idcu;
		if R_CU.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'cu_non_trovato');
			return ret;
		end if;

		select * into R_CU_CATEG from cu_conf.vw_cu_categ_nodes where id_node=idcateg;--id_categ=idcateg;
		if R_CU_CATEG.id_node is null then
			ret:=cu_ui.build_ret(ret,proc_name,'categoria_rischio_non_trovata');
			return ret;
		end if;

		--214 e 226 saranno ricavati da tebella conf in cui viene salvato il padre, quindi
		-- select id_figli da tabella_nodi where id_node_parent = (nodo_tabella_conf)
		if(R_CU_CATEG.id_node_parent in (select id from cu_conf.cu_categ_nodes where id_node_parent in (select id_node from cu_conf.cu_categ_nodes_speciali)))	then
			for r in (select * from cu.vw_cu_categ_evals 
						where id_cu = idcu
						and id_nodo_padre in (select id from cu_conf.cu_categ_nodes where id_node_parent in (select id_node from cu_conf.cu_categ_nodes_speciali))) loop
			delete from cu.cu_categ_evals e
			where r.id_categ_eval = e.id;
			end loop;
		else
			delete from cu.cu_categ_evals
			where id_cu=idcu and id_categ in (select n.id_node from cu_conf.vw_cu_categ_nodes  n where n.id_node_parent=R_CU_CATEG.id_node_parent);
			raise notice 'R_CU_CATEG.id_node_parent %',R_CU_CATEG.id_node_parent;
		end if;

		R_CE.id:=nextval('cu.cu_categ_eval_id_seq');
		R_CE.id_cu=idcu;
		R_CE.id_categ:=idcateg;
		R_CE.valore:=coalesce(val,1);

		insert into cu.cu_categ_evals values (R_CE.*);
		
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	    --ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    --ret.info = '0';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.upd_cu_categ_eval(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_chiudi_cu(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_chiudi_cu(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	ret_check cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idcu bigint;
	inviapec boolean;
	pec_ varchar;
	dtchiusura timestamp;
	idstatocu bigint;
	valore_categ real;
	idroot bigint;
	albero_cs json;
	n_giorni_fs bigint;
	R_CU cu.cu;
	R_VW_CU cu.vw_cu%rowtype;
	R_EV agenda.eventi;
	R_FU agenda.eventi;
	R_CS agenda.eventi;
	R_S cu_anag.stabilimenti;
	R record;
	d_diff interval;
	cmd_j varchar;
	R_TIPO_ISP ag_types.ag_tipo_eventi;
	n bigint;
	user_info json;
	R_STAB record;
	_n_check_piani bigint;
	_n_check_categ_storico bigint;
	_latest_categ timestamp;
	_latest_linea timestamp;
	begin
		proc_name:='cu.upd_cu_chiudi_cu';
		ret.esito:=false;
		user_info :=v->'user_info';
		idcu=v->'id_cu';
		/*
		inviapec=v->'invia_pec';
		pec_=v->>'pec';
		*/
		dtchiusura=v->'dt';
		idstatocu=v->'id_stato_cu';
		
		select *  into R_CU from cu.cu where id=idcu;
		if R_CU.id is null then
			ret.esito:=false;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'cu_inesistente');
	    	return ret;
		end if;
		if R_CU.chiuso then
			ret.esito:=false;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'cu_gia_chiuso_chiusura_non_possibile');
	    	return ret;
		end if;
		if inviapec = true then
			--invio mail
		end if;
		ret_check:=cu.cu_check_nuclei(v, idtransazione);
		if not ret_check.esito then
			ret.esito:=false;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'informazioni_sui_nuclei_non_complete');
	    	return ret;
		end if;
		/*ret_check:=cu.cu_check_oggetti(v, idtransazione);
		if not ret_check.esito then
			ret.esito:=false;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'informazioni_sugli_oggetti_non_complete');
	    	return ret;
		end if;
		*/
		update cu.cu set chiuso = true /*,pec = pec_ */
		, dt_chiusura = dtchiusura
		, id_stato_cu = idstatocu
		where id = idcu returning * into R_CU;
		n:=cu_log.upd_record('cu.cu',idtransazione,R_CU,'U');
		
		select value::int into n_giorni_fs from cu_conf.cu_conf where cod = 'fs_giorni';
	
		--28/05/2024 upd categoria rischio stab
		select id_categorizzazione_rischio into idroot from cu_anag.stabilimenti s 
		join cu.categorizzazione_rischio_tipo_stabilimento c on s.id_tipologia_struttura = c.id_tipo_stabilimento 
		where s.id = R_CU.id_az_sede;
	
		--15/07/2024 issue #11980
		if idroot > 0 then
			if (select count(*) from cu.vw_cu_piani p where p.id_cu = idcu and p.alias ilike '%A61_A%') = 0 then
			
				select * into R_STAB from cu_anag.vw_stabilimenti_all s where s.id_stabilimento = R_CU.id_az_sede;
				select count(*) into _n_check_piani from cu.vw_cu_piani p
				where p.id_cu = idcu 
				and p.descrizione_piano ilike '%audit%' and R_STAB.cod_tipologia_struttura in ('852','853');
			
				raise notice 'AUDIT _n_check_piani %',_n_check_piani;
					
				--852 categ_null
				select dt_storico into _latest_categ from cu.cu_categ_evals_storico
				where id_stabilimento = R_STAB.id_stabilimento
				and R_STAB.cod_tipologia_struttura in ('852')--,'853') 
				order by dt_storico desc
				limit 1;
			
				select la.inizio_validita into _latest_linea from cu.vw_cu_linee cl
				join cu_anag.vw_linee_all la on la.id_linea = cl.id_linea 
				where cl.id_cu = R_CU.id
				order by la.inizio_validita desc
				limit 1;
			
				if (_latest_categ is null or _latest_categ < _latest_linea) and R_STAB.cod_tipologia_struttura != '853' then
					_n_check_categ_storico := 1;
				else
					_n_check_categ_storico := 0;
				end if;
			
				if _n_check_piani <= 0 and _n_check_categ_storico <= 0 	then
					idroot:= 0;
				end if;
		
			end if;
		
		end if;
	
		if idroot > 0 then
		
			select a.valore	into valore_categ from (
					select v.valore, id_node_parent 
					from cu_conf.vw_cu_categ_nodes_up_descr n join
					(select n.id_node_ref,sum(peso*coalesce(e.valore,0)) valore
					from cu_conf.vw_cu_categ_nodes_down n left join cu.vw_cu_categ_evals e on n.id_node=e.id_categ and id_cu=idcu
					group by 1) v on n.id_node =v.id_node_ref
					left join cu.vw_cu_categ_evals ev on n.id_node=ev.id_categ and id_cu=idcu
					left join cu_conf.vw_cu_categ_esiti e on n.id_node_parent is null and  e.rng  @> v.valore
					order by id_node ) a
			where a.id_node_parent is null;
			
			select json_agg(row_to_json(c.*)) into albero_cs from (
				select n.descr ||
				case when v.valore != 0 then ' ('||v.valore ||')' else '' end ||
				case when n.peso   != 0 then ' ('||n.peso||')'    else '' end ||
				case when n.fattore!= 1 then ' x'||n.fattore else '' end || coalesce(' '||e.descr,'') descrizione_breve 
				,case when n.id_node = idroot then null else n.id_node_parent end id_node_parent
				,n.id,n.cod,n.sigla,n.descr,n.fattore,n.peso,n.id_node
				,n.path,n.path_ord,n.path_descr
				,n.lv,n.node_descr,n.ordinamento
				,v.valore
				,ev.id is not null selezionato
				,e.descr
				from cu_conf.vw_cu_categ_nodes_up_descr n join
				(select n.id_node_ref,sum(peso*coalesce(e.valore,0)) valore
				from cu_conf.vw_cu_categ_nodes_down n left join cu.vw_cu_categ_evals e on n.id_node=e.id_categ and id_cu=idcu
				group by 1) v on n.id_node =v.id_node_ref
				left join cu.vw_cu_categ_evals ev on n.id_node=ev.id_categ and id_cu=idcu
				left join cu_conf.vw_cu_categ_esiti e on n.id_node_parent is null and  e.rng  @> v.valore
				join cu_conf.vw_cu_categ_nodes_down down on n.id_node = down.id_node 
				where down.id_node_ref = idroot
				order by n.id_node
			) c ;
		
			insert into cu.cu_categ_evals_storico(id_cu, id_stabilimento, valore, dt_storico, albero_cs)
			values(R_CU.id, R_CU.id_az_sede, valore_categ, localtimestamp, albero_cs);
		
		end if;
		
		raise notice 'id_evento %',R_CU.id_evento;
		select *  into R_EV from agenda.eventi where id=R_CU.id_evento;
	
		select * into R_VW_CU from cu.vw_cu where id_cu = R_CU.id;
		
		R_FU:=R_EV;
		R_FU.id_cu:=null;
	
		R_CS:=R_FU;
		select p.cu_inizio,p.cu_fine into R_EV.inizio,R_EV.fine from cu.vw_cu_con_periodo p  where id_cu=idcu;
		select id into R_FU.id_tipo_evento from ag_types.ag_tipo_eventi where sigla ilike 'FU';
		select * into R_TIPO_ISP from ag_types.ag_tipo_eventi where sigla ilike 'CU';
		select id_piano into R_FU.id_piano from cu_conf.vw_cu_piani_speciali vcps 
		where sigla='FU_PIANO_DEF';
		if R_FU.id_linea is null then
			select id_cu_linea into R_FU.id_linea from cu.vw_cu_linee where id_cu=idcu order by ord limit 1;
		end if;
		if R_FU.per_conto is null then
			select per_conto into R_FU.per_conto from cu.vw_cu_piani where id_cu=idcu order by ord limit 1;
		end if;
		/*
		if R_FU.id_nominativo is null then
			select id_nominativo into R_FU.id_nominativo from cu.vw_cu_nucleo_ni
			where id_cu=idcu and sigla_tipo_isp='ref' order by ord limit 1;
		end if;
		*/
		select * into R from cu.vw_cu_nominativo_provv nv
		where nv.id_cu = idcu;
	
		if R.id_cu is not null then
			R_FU.id_nominativo:=R.id_nominativo;
		end if;
	
		raise notice 'CREAZIONE FU';
		for R in select distinct date_trunc('day',dt) dt from cu.vw_cu_provv p 
		where id_cu=idcu and p.fu_richiesto loop
			R_FU.id:=nextval('agenda.agenda_id_seq');
			--d_diff:= R.dt-date_trunc('day',R_FU.inizio);
			--R_FU.inizio:=R.dt +(interval '1 hour') * 9 ;--R_EV.inizio+d_diff;
			R_FU.inizio:=coalesce(R.dt, (dtchiusura)::date + (interval '1 day') * n_giorni_fs) + (interval '1 hour') * 9 ;
			R_FU.validita_interna:=true;
			R_FU.effettuata:=false;
			R_FU.fine:=R_FU.inizio +interval '3 hours';
			R_FU.id_user_create :=user_info->'id_utente';
		   	R_FU.ts_create:=current_timestamp;
			insert into agenda.eventi values (R_FU.*);
			--log eventi ??
			raise notice 'CREATO FU: ID % INIZIO % PIANO %',R_FU.id,R_FU.inizio,R_FU.id_piano;
		end loop;
	
		raise notice 'UPDATE PROVV';
		/*
		 	update cu.cu_provv set chiuso=true,id_fu=idcu where id in 
			(select id_provv from cu.cu_provv_fu where id_cu=idcu and risolta);
		*/
		for R in select * from cu.cu_provv where id in 
			(select id_provv from cu.cu_provv_fu where id_cu=idcu and risolta)
		loop 
			update cu.cu_provv set chiuso=true,id_fu=idcu where id = R.id;
			n:=cu_log.upd_record('cu.cu_provv',idtransazione,R,'U');
		end loop;
			
		raise notice 'R_EV.id_tipo_evento % =R_TIPO_ISP.id %',R_EV.id_tipo_evento,R_TIPO_ISP.id;
		if R_EV.id_tipo_evento=R_TIPO_ISP.id then
			raise notice 'dtchiusura %',dtchiusura;
			/*
			update cu_anag.linee set data_ultima_visita=dtchiusura where
				id in (select l.id_linea from cu.cu_linee l where id_cu=idcu);
			*/
			for R in select * from cu_anag.linee where id in 
				(select l.id_linea from cu.cu_linee l where id_cu=idcu)
			loop 
				update cu_anag.linee set data_ultima_visita=dtchiusura where id = R.id;
				n:=cu_log.upd_record('cu_anag.linee',idtransazione,R,'U');
			end loop;
			
		end if;
	
		if idstatocu = 3 then
			raise notice 'CREAZIONE CS';
			select id into R_CS.id_tipo_evento from ag_types.ag_tipo_eventi where sigla ilike 'CS';
		
			R_CS.id:=nextval('agenda.agenda_id_seq');
			R_CS.inizio:=current_timestamp +(interval '1 day');
			R_CS.validita_interna:=true;
			R_CS.effettuata:=false;
			R_CS.fine:=R_CS.inizio + interval '3 hours';
			R_CS.id_user_create :=user_info->'id_utente';
		   	R_CS.ts_create:=current_timestamp;
			insert into agenda.eventi values (R_CS.*);
			--log agenda ??
		end if;
	
	
		--chiusura 
		if R_VW_CU.sigla_tecnica = 'AS' then
		
			raise notice 'CHIUSA AS id %', R_VW_CU.id_cu;
		
			if R_FU.id_linea is null then
				select id_cu_linea into R_FU.id_linea from cu.vw_cu_linee where id_cu=idcu order by ord limit 1;
			end if;
			if R_FU.per_conto is null then
				select per_conto into R_FU.per_conto from cu.vw_cu_piani where id_cu=idcu order by ord limit 1;
			end if;
			
			select id into R_FU.id_tipo_evento from ag_types.ag_tipo_eventi where sigla ilike 'FS';
		
			--select value::int into n_giorni_fs from cu_conf.cu_conf where cod = 'fs_giorni';
		
			for R in select * from cu.cu_provv_sopralluogo where id_cu = R_VW_CU.id_cu loop
				raise notice 'PROVV_SOP %', R.id;
			
				R_FU.id_nominativo:= R.id_nominativo;
				R_FU.id_piano:= R.id_piano;
			
				R_FU.id:=nextval('agenda.agenda_id_seq');
				--d_diff:= R.dt-date_trunc('day',R_FU.inizio);
				R_FU.inizio:=coalesce(R.dt, (dtchiusura)::date + (interval '1 day') * n_giorni_fs) + (interval '1 hour') * 9 ;
				R_FU.validita_interna:=true;
				R_FU.effettuata:=false;
				R_FU.fine:=R_FU.inizio +interval '3 hours';
				R_FU.id_user_create :=user_info->'id_utente';
			   	R_FU.ts_create:=current_timestamp;
				insert into agenda.eventi values (R_FU.*);
				--log agenda ??
				raise notice 'CREATO FU: ID % INIZIO % PIANO %',R_FU.id,R_FU.inizio,R_FU.id_piano;
			
				insert into cu.cu_provv_sopralluogo_fu values(nextval('cu.cu_id_seq'), R_FU.id /*id_evento*/, R.id);
				--log provv sopralluogo
				n:=cu_log.upd_record('cu.cu_provv_sopralluogo',idtransazione,R,'I');
			end loop;
			
		end if;
	
		cmd_j:='{"id":'||R_EV.id||',"start":"'||R_EV.inizio||'","end":"'||R_EV.fine||'","id_cu":'||idcu||
				',"extendedProps":{"effettuata":true}}';
			
		raise notice 'CMD_J %',cmd_j;
		ret:=agenda.upd_evento(cmd_j,idtransazione);
		
		ret.esito:=true;
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu.upd_cu_chiudi_cu(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_cl_apri(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_cl_apri(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcu  bigint;
      	idns bigint;
     	ini timestamp;
     	fin timestamp;
        proc_name varchar; -- end
        R_CL cu.vw_cu_oggetti_cl;
        R_ cu.cu_oggetti_cl;
        n bigint;
       	chiudi boolean;
       nuovostato varchar;
      idcuoggettocl bigint;
     n_ev integer;
    	rt json;
	begin
		proc_name:='cu.up_cu_cl_apri';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idcuoggettocl:=v_j->'id_cu_oggetto_cl';

	
		select * into R_CL from cu.vw_cu_oggetti_cl where id_cu_oggetto_cl=idcuoggettocl;
		if R_CL.id is null then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'oggetto_cl_non_esiste');
	    		return ret;
		end if;
		if not R_CL.chiuso  then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'oggetto_cl_gia_aperto');
	    		return ret;
		end if;
		update cu.cu_oggetti_cl set chiuso=false , id_stato_cl=null where id=idcuoggettocl returning * into R_;
		n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_,'U');
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_cl_apri(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_cl_chiudi(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_cl_chiudi(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcu  bigint;
      	idns bigint;
     	ini timestamp;
     	fin timestamp;
        proc_name varchar; -- end
        R_CL cu.vw_cu_oggetti_cl;
      	idcuoggettocl bigint;
      	idnuovostato bigint;
     	n_ev integer;
     	n integer;
    	rt json;
	begin
		proc_name:='cu.upd_cu_cl_chiudi';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;
		idcuoggettocl:=v_j->'id_cu_oggetto_cl';
		idnuovostato:=v_j->'id_nuovo_stato';
		select * into R_CL from cu.vw_cu_oggetti_cl where id_cu_oggetto_cl=idcuoggettocl;
		if R_CL.id is null then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'oggetto_cl_non_esiste');
	    		return ret;
		end if;
		if R_CL.chiuso  then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'oggetto_cl_gia_chiuso');
	    		return ret;
		end if;
		select count(*) into n_ev from cu.cu_evidenze where id_cu_oggetto_cl=idcuoggettocl;
		raise notice 'N_EV %', n_ev;
		if n_ev>0 then n_ev:=1; end if;
	
		select count(*) into n  from cu_types.vw_cu_stati_cl where evidenze  >= n_ev and id_stato_cl = idnuovostato;
		raise notice 'N %', n;
		if n <= 0  then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'oggetto_stato_non_ammissibile');
	    		return ret;
		end if;
		update cu.cu_oggetti_cl set chiuso=true,id_stato_cl=idnuovostato where id=idcuoggettocl;
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_cl_chiudi(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_cl_chiudi_massivo(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_cl_chiudi_massivo(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcu  bigint;
      	idns bigint;
     	ini timestamp;
     	fin timestamp;
        proc_name varchar; -- end
        R_CL cu.cu_oggetti_cl;
	    R_SCL cu_types.vw_cu_stati_cl;
      	idcuoggettocl bigint;
      	idnuovostato bigint;
     	n_ev integer;
     	n integer;
    	rt json;
	begin
		proc_name:='cu.upd_cu_cl_chiudi_massivo';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;
		--idcuoggettocl:=v_j->'id_cu_oggetto_cl';
		idnuovostato:=v_j->'id_nuovo_stato';
	
		select * from cu_types.vw_cu_stati_cl into R_SCL where id_stato_cl = idnuovostato;
		
		for idcuoggettocl in select (value::varchar)::bigint id
			from json_array_elements(v_j->'id_cu_oggetto_cl') loop
				
				--stato NC
				if R_SCL.id_stato_cl = 3 then
					
					select count(*) into n_ev from cu.vw_cu_evidenze
					where id_cu_oggetto_cl = idcuoggettocl
					and id_cu_classe_evidenza between 1 and 2; --nc e NC
				
					if n_ev > 0 then
						--con evidenze nc/NC
						update cu.cu_oggetti_cl set 
						chiuso=true,
						id_stato_cl=idnuovostato 
						where id=idcuoggettocl 
						and chiuso != true returning * into R_CL;
						n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
					end if;
				
					select count(*) into n_ev from cu.vw_cu_evidenze
					where id_cu_oggetto_cl = idcuoggettocl
					and id_cu_classe_evidenza = 6; --C
				
					if n_ev > 0 then
						--con evidenze C
						update cu.cu_oggetti_cl set 
						chiuso=true,
						id_stato_cl=2 
						where id=idcuoggettocl
						and chiuso != true returning * into R_CL;
						n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
					else
						
						select count(*) into n_ev from cu.vw_cu_evidenze
						where id_cu_oggetto_cl = idcuoggettocl
						and id_cu_classe_evidenza = 5; --S
					
						if n_ev > 0 then
							--con evidenze S
							update cu.cu_oggetti_cl set 
							chiuso=true,
							id_stato_cl=4 
							where id=idcuoggettocl
							and chiuso != true returning * into R_CL;
						n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
						else
							--qualsiasi altro
							update cu.cu_oggetti_cl set 
							chiuso=true,
							id_stato_cl=2 
							where id=idcuoggettocl
							and chiuso != true returning * into R_CL;
						n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
						end if;
					end if;
				
					
				else 
					--stato C
					if R_SCL.id_stato_cl = 2 then
						--con evidenze S
						select count(*) into n_ev from cu.vw_cu_evidenze
						where id_cu_oggetto_cl = idcuoggettocl
						and id_cu_classe_evidenza = 5; --S
					
						if n_ev > 0 then
							--con evidenze S
							update cu.cu_oggetti_cl set 
							chiuso=true,
							id_stato_cl=4 
							where id=idcuoggettocl
							and chiuso != true returning * into R_CL;
						n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
						else
							--qualsiasi altro
							update cu.cu_oggetti_cl set 
							chiuso=true,
							id_stato_cl=2 
							where id=idcuoggettocl
							and chiuso != true returning * into R_CL;
						n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
						end if;
					
					else	
						--stato S
						if R_SCL.id_stato_cl = 4 then
							--con evidenze S
							select count(*) into n_ev from cu.vw_cu_evidenze
							where id_cu_oggetto_cl = idcuoggettocl
							and id_cu_classe_evidenza = 5; --S
						
							if n_ev > 0 then
								--con evidenze S
								update cu.cu_oggetti_cl set 
								chiuso=true,
								id_stato_cl=4 
								where id=idcuoggettocl
								and chiuso != true returning * into R_CL;
								n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
							else
								--qualsiasi altro
								update cu.cu_oggetti_cl set 
								chiuso=true,
								id_stato_cl=2 
								where id=idcuoggettocl
								and chiuso != true returning * into R_CL;
								n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
							end if;
						
						else	
							--stato NA
							select count(*) into n_ev from cu.vw_cu_evidenze
							where id_cu_oggetto_cl = idcuoggettocl
							and id_cu_classe_evidenza = 6; --C
						
							if n_ev > 0 then
								--con evidenze C
								update cu.cu_oggetti_cl set 
								chiuso=true,
								id_stato_cl=2 
								where id=idcuoggettocl
								and chiuso != true returning * into R_CL;
								n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
							end if;
						
						
							select count(*) into n_ev from cu.vw_cu_evidenze
							where id_cu_oggetto_cl = idcuoggettocl
							and id_cu_classe_evidenza = 5; --S
						
							if n_ev > 0 then
								--con evidenze S
								update cu.cu_oggetti_cl set 
								chiuso=true,
								id_stato_cl=4 
								where id=idcuoggettocl
								and chiuso != true returning * into R_CL;
								n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
							else
								--qualsiasi altro
								update cu.cu_oggetti_cl set 
								chiuso=true,
								id_stato_cl=idnuovostato 
								where id=idcuoggettocl
								and chiuso != true returning * into R_CL;
								n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
							end if;
						end if;
					end if;
				end if;
			end loop;
			
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_cl_chiudi_massivo(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_esterno(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_del_esterno(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcuesterno bigint;
        proc_name varchar; -- end
        R_P cu.cu_nucleo_periodi;
        R_N cu.cu_nucleo;
        n integer;
	begin
		proc_name:='cu.upd_cu_del_esterno';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idcuesterno:=v_j->'id_cu_nucleo_periodo';
		select * into R_P from cu.cu_nucleo_periodi where id=idcuesterno;	
		if R_P.id is null then
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'nucleo_periodo inesistente');
		end if;
		delete from cu.cu_nucleo_periodi where id=idcuesterno;
		n:=cu_log.upd_record('cu.cu_nucleo_periodi',idtransazione,R_P,'D');
	
		select count(*) into n from cu.cu_nucleo_periodi where id_cu_nucleo=R_P.id_cu_nucleo;
		if n <= 0 then
			select * into R_N from cu.cu_nucleo where id=R_P.id_cu_nucleo;
			delete from cu.cu_nucleo where id=R_P.id_cu_nucleo;
			n:=cu_log.upd_record('cu.cu_nucleo',idtransazione,R_N,'D');
		end if;

		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_del_esterno(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_evidenze(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_del_evidenze(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- start
	    ret1 cu_types.result_type; -- START
        proc_name varchar; -- end
        R_P cu.cu_nucleo_periodi;
        R_E cu.cu_evidenze;
        idcuevidenze bigint;
        idcu bigint;
        n integer;
        R_OCL cu.vw_cu_oggetti_cl;
	begin
		proc_name:='cu.upd_cu_del_evidenze';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;
	
		--recupera idcu
		for idcu in
			select distinct id_cu from cu.vw_cu_evidenze where id_evidenza in (select (value::varchar)::bigint id
				from json_array_elements(v_j->'id_cu_evidenze')) loop
		end loop;

		--elimina
		for idcuevidenze in select (value::varchar)::bigint id
			from json_array_elements(v_j->'id_cu_evidenze') loop
			raise notice 'ID_CU_EVIDENZE %',idcuevidenze;
			delete from cu.cu_evidenze where id =idcuevidenze returning * into R_E;
			n:=cu_log.upd_record('cu.cu_evidenze',idtransazione,R_E,'D');
		end loop;
		
		--aggiorna
		ret1:=cu.cu_aggiorna_norme_violate(idcu,idtransazione);		
				

		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_del_evidenze(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_nucleo(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_del_nucleo(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcunucleoperiodo bigint;
      	idcunucleo bigint;
        proc_name varchar; -- end
        R_P cu.cu_nucleo_periodi;
        R_N cu.cu_nucleo;
        R_CP cu.vw_cu_periodo%ROWTYPE;
        idcu bigint;
        id_op bigint;
       n integer;
	begin
		proc_name:='cu.upd_cu_del_nucleo';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idcunucleoperiodo:=v_j->'id_cu_nucleo_periodo';
		idcunucleo:=v_j->'id_cu_nucleo';
		
		select id_cu into idcu from cu.cu_nucleo cn
		where cn.id = idcunucleo;
	
		select * into R_P from cu.cu_nucleo_periodi where id=idcunucleoperiodo;	
		if R_P.id is null then
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'nucleo_periodo inesistente');
		end if;
		delete from cu.cu_nucleo_periodi where id=idcunucleoperiodo;
		--log del cu.cu_nucleo_periodi
		n:=cu_log.upd_record('cu.cu_nucleo_periodi',idtransazione,R_P,'D');
	
		select count(*) into n from cu.cu_nucleo_periodi where id_cu_nucleo=R_P.id_cu_nucleo;
		if n <= 0 then
			select * into R_N from cu.cu_nucleo where id=R_P.id_cu_nucleo;
			delete from cu.cu_nucleo where id=R_P.id_cu_nucleo;
			--log del cu.cu_nucleo
			n:=cu_log.upd_record('cu.cu_nucleo',idtransazione,R_N,'D');
		end if;
	
		-- issue #11566
	
		select * into R_CP from cu.vw_cu_periodo where id_cu = idcu;
	
		if R_CP.id_cu is not null then
			update agenda.eventi
			set inizio = R_CP.cu_inizio,
			fine = R_CP.cu_fine
			where id = (select id_evento from cu.cu where id = idcu);
		
			update cu.cu 
			set dt = R_CP.cu_inizio
			where id = idcu;
		end if;
	
		-- fine

		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_del_nucleo(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_pdf_controlli(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_del_pdf_controlli(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	declare
		ret cu_types.result_type; 
		proc_name varchar;
		rt json;
		idpdf bigint;
		begin 
			proc_name:='cu.upd_cu_del_pdf_controlli';
			ret.esito:=false;
			idpdf=v->'id';
		
			update cu.nomi_file_pdf_controlli set validita= tsrange(lower(validita),current_timestamp::timestamp,'(]')
			where id=idpdf;
	
		ret.esito:=true;	
        ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
		return ret;
		
	END;
$$;


ALTER FUNCTION cu.upd_cu_del_pdf_controlli(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_pdf_evidenze(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_del_pdf_evidenze(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	declare
		ret cu_types.result_type; 
		proc_name varchar;
		rt json;
		idpdf bigint;
		begin 
			proc_name:='cu.upd_cu_del_pdf_controlli';
			ret.esito:=false;
			idpdf=v->'id';
		
			update cu.nomi_file_pdf_evidenze set validita= tsrange(lower(validita),current_timestamp::timestamp,'(]')
			where id=idpdf;
	
		ret.esito:=true;	
        ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
		return ret;
		
	END;
$$;


ALTER FUNCTION cu.upd_cu_del_pdf_evidenze(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_personale(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_del_personale(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcupersonale bigint;
        proc_name varchar; -- end
        R_P cu.cu_nucleo_periodi;
        R_N cu.cu_nucleo;
        n integer;
	begin
		proc_name:='cu.upd_cu_del_personale';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idcupersonale:=v_j->'id_cu_nucleo_periodo';
		select * into R_P from cu.cu_nucleo_periodi where id=idcupersonale;	
		if R_P.id is null then
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'nucleo_periodo inesistente');
		end if;
		delete from cu.cu_nucleo_periodi where id=idcupersonale;
		n:=cu_log.upd_record('cu.cu_nucleo_periodi',idtransazione,R_P,'D');
		
		select count(*) into n from cu.cu_nucleo_periodi where id_cu_nucleo=R_P.id_cu_nucleo;
		if n <= 0 then
			select * into R_N from cu.cu_nucleo where id=R_P.id_cu_nucleo;
			delete from cu.cu_nucleo where id=R_P.id_cu_nucleo;
			n:=cu_log.upd_record('cu.cu_nucleo',idtransazione,R_N,'D');
		end if;

		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_del_personale(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_provv(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_del_provv(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
        idprovv bigint;
       	R_P cu.cu_provv;
        n integer;
	begin
		proc_name:='cu.upd_cu_del_provv';
		raise notice 'V_J=%', v_j;

		for idprovv in select (value::varchar)::bigint id
			from json_array_elements(v_j->'id_provv') loop
			raise notice 'ID_PROVV%',idprovv;
			delete from cu.cu_provv where id =idprovv returning * into R_P;
			n:=cu_log.upd_record('cu.cu_provv',idtransazione,R_P,'D');
		end loop;

		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_del_provv(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_provv_sopralluogo(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_del_provv_sopralluogo(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
        idprovv bigint;
        n integer;
       	r record;
	begin
		proc_name:='cu.upd_cu_del_provv_sopralluogo';
		raise notice 'V_J=%', v_j;

		for idprovv in select (value::varchar)::bigint id
			from json_array_elements(v_j->'id') loop
			raise notice 'ID_PROVV%',idprovv;
			delete from cu.cu_provv_sopralluogo where id =idprovv returning * into R;
			n:=cu_log.upd_record('cu.cu_provv_sopralluogo',idtransazione,R,'D');
		end loop;

		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_del_provv_sopralluogo(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_requisiti(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_del_requisiti(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
        idrequisito bigint;
        n integer;
	begin
		proc_name:='cu.upd_cu_del_requisiti';
		raise notice 'V_J=%', v_j;

		for idrequisito in select (value::varchar)::bigint id
			from json_array_elements(v_j->'id_requisito') loop
			raise notice 'ID_REQ%',idrequisito;
		
			update cu_conf.cu_requisiti 
			set validita = tsrange(lower(validita),current_date,'[)')
			where id =idrequisito;
		end loop;

		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_del_requisiti(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_tipo_oggetto(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_del_tipo_oggetto(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
        idtipooggetto bigint;
        n integer;
	begin
		proc_name:='cu.upd_cu_del_tipo_oggetto';
		raise notice 'V_J=%', v_j;

		for idtipooggetto in select (value::varchar)::bigint id
			from json_array_elements(v_j->'id_tipo_oggetto') loop
			raise notice 'ID_TIPO_OGG%',idtipooggetto;
		
			--delete from cu_conf.cu_tipo_oggetti  where id =idtipooggetto;
			update cu_conf.cu_tipo_oggetti 
			set validita = tsrange(lower(validita),localtimestamp,'[)')
			where id =idtipooggetto;
		end loop;

		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_del_tipo_oggetto(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_firmatario_verbale(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_firmatario_verbale(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	v_id bigint;
	idcunucleo bigint;
	idcu bigint;
	R_N cu.cu_nucleo;
	n integer;
	begin
		proc_name:='cu.upd_cu_firmatario_verbale';
		
		idcunucleo := v->'id_cu_nucleo';
		ret.esito:=false;
	
		select id_cu into idcu from cu.vw_cu_nucleo_p where id_cu_nucleo = idcunucleo;
		
		for v_id in
			select id from cu.cu_nucleo cn
			where id_cu = idcu and custode_verbale loop
				update cu.cu_nucleo
				set custode_verbale = false
				where id =v_id returning * into R_N;
				n:=cu_log.upd_record('cu.cu_nucleo',idtransazione,R_N,'U');
		end loop;
	
		update cu.cu_nucleo
		set custode_verbale = true
		where id = idcunucleo returning * into R_N;
		n:=cu_log.upd_record('cu.cu_nucleo',idtransazione,R_N,'U');
		
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu.upd_cu_firmatario_verbale(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_info_generali(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_info_generali(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
		_idcu bigint;
		dtchiusura timestamp;
		dtpreavviso timestamp;
		kmaz numeric;
		kmpr numeric;
		R_CU cu.cu;
		n bigint;
		
	begin
		proc_name:='cu.upd_cu_info_generali';
		raise notice 'V_J=%', v_j;
		_idcu:= v_j->>'id_cu';
		raise notice 'id_cu=%', _idcu;
	
		--dtchiusura=v_j->'dt';
		dtpreavviso=v_j->>'dt_preavviso';
		if dtpreavviso::text = ''::text
		then dtpreavviso := null;
		end if;
		kmaz:=v_j->>'km_az';
		kmpr:=v_j->>'km_pr';
	
		ret.esito:=false;

		update cu.cu set
		preavviso = (v_j->>'preavviso')::bool,
		rilievi = (v_j->>'rilievi')::bool,
		pec = v_j->>'pec',
		mezzo_preavviso = v_j->>'mezzo_preavviso',
		dt_preavviso = dtpreavviso,
		km_az = kmaz,
		km_pr = kmpr
		--dt_chiusura = dtchiusura
		where id = _idcu returning * into R_CU;
		n:=cu_log.upd_record('cu.cu',idtransazione,R_CU,'U');
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_info_generali(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_linee(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_linee(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        idnominativostruttura bigint;  
       	idsroot bigint;
		u json;
       	ordmax integer;
      	idcu bigint;
      	idlinea bigint;
      	R_L cu.cu_linee;
        proc_name varchar; -- end
        n bigint;
	begin
		proc_name:='cu.upd_cu_linee';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idnominativostruttura:=v_j->'id_nominativo_struttura';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';
		idcu:=v_j->'id_cu';
		--idlinea:=v_j->'id_linea';
		/*select coalesce(max(ord),1)+1 into ordmax from cu.cu_linee
			where id_cu=idcu;*/
	
		for R_L in (select * from cu.cu_linee where id_cu=idcu and id_linea
 					not in (select (value::varchar)::bigint id_linea from json_array_elements(v_j->'id_linea') ) )
        loop 
        	delete from cu.cu_linee where id = R_L.id;
        	n:=cu_log.upd_record('cu.cu_linee',idtransazione,R_L,'D');
        end loop;
		
       	/*
		delete from cu.cu_linee where id_cu=idcu and id_linea
 		not in (select (value::varchar)::bigint id_linea from
                        json_array_elements(v_j->'id_linea') );  
        */
        select coalesce(max(ord),0)+1 into ordmax from cu.cu_linee
			where id_cu=idcu;            
		
		for idlinea in (select (value::varchar)::bigint id_linea from json_array_elements(v_j->'id_linea') where (value::varchar)::bigint not in (select id_linea from cu.cu_linee where id_cu=idcu))
		loop
			insert into cu.cu_linee select nextval('cu.cu_id_seq'),idcu, idlinea::bigint, 1 --ordmax +row_number()
			returning * into R_L;
			n:=cu_log.upd_record('cu.cu_linee',idtransazione,R_L,'I');
		end loop;
		
        /*               
		insert into cu.cu_linee select nextval('cu.cu_id_seq'),idcu,(value::varchar)::bigint,ordmax +row_number() over()
			from json_array_elements(v_j->'id_linea')
			where (value::varchar)::bigint not in (select id_linea from cu.cu_linee where id_cu=idcu);
		*/

		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_linee(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_nomi_pdf_controlli(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_nomi_pdf_controlli(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare
		ret cu_types.result_type; 
		proc_name varchar;
		idcu bigint;
		nomefile varchar;
		begin 
			proc_name:='cu.upd_cu_nomi_pdf_controlli';
			ret.esito:=false;
			idcu=v->'id_cu';
			nomefile=v->>'nome';
			
		insert into cu.nomi_file_pdf_controlli (nome,id_cu) values (nomefile,idcu);
		
	
	 	ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
 		end;
	END;
$$;


ALTER FUNCTION cu.upd_cu_nomi_pdf_controlli(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_nomi_pdf_evidenze(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_nomi_pdf_evidenze(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare
		ret cu_types.result_type; 
		proc_name varchar;
		idevidenza bigint;
		nomefile varchar;
		begin 
			proc_name:='cu.upd_cu_nomi_pdf_evidenze';
			ret.esito:=false;
			idevidenza=v->'id_evidenza';
			nomefile=v->>'nome';
			
		insert into cu.nomi_file_pdf_evidenze (nome,id_evidenza) values (nomefile,idevidenza);
		
	
	 	ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
 		end;
	END;
$$;


ALTER FUNCTION cu.upd_cu_nomi_pdf_evidenze(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_note_generali(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_note_generali(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
		_idcu bigint;
		dtchiusura timestamp;
		n bigint;
		R_CU_ cu.cu;
		
	begin
		proc_name:='cu.upd_cu_note_generali';
		raise notice 'V_J=%', v_j;
		_idcu:= v_j->>'id_cu';
		raise notice 'id_cu=%', _idcu;
	
		ret.esito:=false;

		update cu.cu set 
		note_generali = v_j->>'note' 
		where id = _idcu returning * into R_CU_;
		n:=cu_log.upd_record('cu.cu',idtransazione,R_CU_,'U');
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_note_generali(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_note_verbale(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_note_verbale(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
		_idcu bigint;
		dtchiusura timestamp;
		R_CU cu.vw_cu;
		R_CU_ cu.cu;
		n bigint;
		
	begin
		proc_name:='cu.upd_cu_note_verbale';
		raise notice 'V_J=%', v_j;
		_idcu:= v_j->>'id_cu';
		raise notice 'id_cu=%', _idcu;
	
		ret.esito:=false;
	
		select * into R_CU from cu.vw_cu where id=_idcu;
	
		if R_CU.chiuso then
			ret.esito:=false;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'cu_chiuso_non_modificabile');
	    	ret.info = '0';
 			return ret;
		end if;

		update cu.cu set 
		note_verbale = v_j->>'note' 
		where id = _idcu returning * into R_CU_;
		n:=cu_log.upd_record('cu.cu',idtransazione,R_CU_,'U');
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_note_verbale(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_oggetti(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_oggetti(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        idnominativostruttura bigint;  
       	idsroot bigint;
		u json;
       	ordmax integer;
      	idcu bigint;
      	n bigint;
      	r record;
      	R_CO cu.cu_oggetti;
      	R_CL cu.cu_oggetti_cl;
      	--idlinea bigint;
        proc_name varchar; -- END
	begin
		proc_name:='cu.upd_cu_oggetti';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idnominativostruttura:=v_j->'id_nominativo_struttura';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';
		idcu:=v_j->'id_cu';
		--idlinea:=v_j->'id_linea';
		/*
		delete from cu.cu_oggetti_cl where id_cu_oggetto in
			(select id from cu.cu_oggetti where id_cu=idcu and id_tipo_oggetto
	 		not in (select (value::varchar)::bigint id_linea from
	                        json_array_elements(v_j->'id_oggetti') ));
	    */
	
		for R_CL in (select * from cu.cu_oggetti_cl where id_cu_oggetto in
			(select id from cu.cu_oggetti where id_cu=idcu and id_tipo_oggetto
	 		not in (select (value::varchar)::bigint id_linea from
	                        json_array_elements(v_j->'id_oggetti') ))) 
		loop
			delete from cu.cu_oggetti_cl where id = R_CL.id;
			n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'D');
		end loop;
		
		/*
		delete from cu.cu_oggetti where id_cu=idcu and id_tipo_oggetto
 		not in (select (value::varchar)::bigint id_linea from
                        json_array_elements(v_j->'id_oggetti') );
        */
	
		for R_CO in (select * from cu.cu_oggetti where id_cu=idcu 
					and id_tipo_oggetto not in (select (value::varchar)::bigint id_linea from
                        json_array_elements(v_j->'id_oggetti') )) 
		loop
			delete from cu.cu_oggetti where id = R_CO.id;
			n:=cu_log.upd_record('cu.cu_oggetti',idtransazione,R_CO,'D');
		end loop;
		
        select coalesce(max(ord),0)+1 into ordmax from cu.cu_oggetti
			where id_cu=idcu;             
                       
		for R_CO in select nextval('cu.cu_id_seq'),idcu,ordmax +row_number() over(),(value::varchar)::bigint,false
			from json_array_elements(v_j->'id_oggetti')
			where (value::varchar)::bigint not in (select id_tipo_oggetto from cu.cu_oggetti where id_cu=idcu) loop
			insert into cu.cu_oggetti values (R_CO.*);
			n:=cu_log.upd_record('cu.cu_oggetti',idtransazione,R_CO,'I');
			/*
			insert into cu.cu_oggetti_cl
				select nextval('cu.cu_id_seq'),R_CO.id,r.id from cu_conf.cu_requisiti r
				where id_tipo_oggetto= R_CO.id_tipo_oggetto;
			*/
			for r in (select * from cu_conf.cu_requisiti where id_tipo_oggetto= R_CO.id_tipo_oggetto ) loop
				insert into cu.cu_oggetti_cl select nextval('cu.cu_id_seq'),R_CO.id,r.id returning * into R_CL;
				n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'I');
			end loop;
		end loop;
	
		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_oggetti(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_oggetto_apri(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_oggetto_apri(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
       	chiudi boolean;
      	idcuoggetto bigint;
      	n bigint;
      	R_CO cu.cu_oggetti;
    	rt json;
	begin
		proc_name:='cu.upd_cu_oggetto_apri';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idcuoggetto:=v_j->'id_cu_oggetto';

		update cu.cu_oggetti set chiuso=false , id_stato_oggetto=null where id=idcuoggetto returning * into R_CO;
		n:=cu_log.upd_record('cu.cu_oggetti',idtransazione,R_CO,'U');
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_oggetto_apri(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_oggetto_chiudi(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_oggetto_chiudi(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
        R_CO cu.cu_oggetti;
        R_CL cu.cu_oggetti_cl;
       	n bigint;
       	r record;
       	R_SO cu_types.vw_cu_stati_cl;
      	idcuoggetto bigint;
      	idnuovostato bigint;
    	rt json;
	begin
		proc_name:='cu.upd_cu_oggetto_chiudi';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;
		idcuoggetto:=v_j->'id_cu_oggetto';
		idnuovostato:=v_j->'id_nuovo_stato';
	
		select * from cu_types.vw_cu_stati_oggetto into R_SO where id_stato_oggetto = idnuovostato;
	
		if R_SO.sigla = 'NC' then
		--chiudi tutte le checklist senza evidenze con lo stato CONFORME
		/*
		update cu.cu_oggetti_cl 
		set chiuso = true, 
		id_stato_cl = (select id_stato_cl from cu_types.vw_cu_stati_cl where sigla = 'C') 
		where id_cu_oggetto = idcuoggetto 
		and id not in (select id_cu_oggetto_cl from cu.vw_cu_evidenze
										  where id_cu_oggetto = idcuoggetto )
										  --and id_cu_classe_evidenza between 1 and 2)
		and chiuso = false;
		*/
		for r in (select * from cu.cu_oggetti_cl where id_cu_oggetto = idcuoggetto 
					and id not in (select id_cu_oggetto_cl from cu.vw_cu_evidenze
													  where id_cu_oggetto = idcuoggetto )
													  --and id_cu_classe_evidenza between 1 and 2)
					and chiuso = false)
		loop 
			update cu.cu_oggetti_cl 
			set chiuso = true, 
			id_stato_cl = (select id_stato_cl from cu_types.vw_cu_stati_cl where sigla = 'C') 
			where id = r.id returning * into R_CL;
			n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
		end loop;
	
		else
		
			--chiudi tutte le checklist senza evidenze con lo stato selezionato
			if R_SO.sigla = 'NA' or R_SO.sigla = 'C' then
			/*
			update cu.cu_oggetti_cl 
			set chiuso = true, 
			id_stato_cl = (select id_stato_cl from cu_types.vw_cu_stati_cl where sigla = R_SO.sigla) 
			where id_cu_oggetto = idcuoggetto 
			and id not in (select id_cu_oggetto_cl from cu.vw_cu_evidenze
											  where id_cu_oggetto = idcuoggetto )
											  --and id_cu_classe_evidenza between 1 and 2)
			and chiuso = false;
			*/
				for r in (select * from cu.cu_oggetti_cl where id_cu_oggetto = idcuoggetto 
							and id not in (select id_cu_oggetto_cl from cu.vw_cu_evidenze
															  where id_cu_oggetto = idcuoggetto )
															  --and id_cu_classe_evidenza between 1 and 2)
							and chiuso = false)
				loop 
					update cu.cu_oggetti_cl 
					set chiuso = true, 
					id_stato_cl = (select id_stato_cl from cu_types.vw_cu_stati_cl where sigla = R_SO.sigla)
					where id = r.id returning * into R_CL;
					n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
				end loop;
			else
				/*
				update cu.cu_oggetti_cl 
				set chiuso = true, 
				id_stato_cl = (select id_stato_cl from cu_types.vw_cu_stati_cl where sigla = 'C') 
				where id_cu_oggetto = idcuoggetto 
				and id not in (select id_cu_oggetto_cl from cu.vw_cu_evidenze
												  where id_cu_oggetto = idcuoggetto )
												  --and id_cu_classe_evidenza between 1 and 2)
				and chiuso = false;
				*/
				for r in (select * from cu.cu_oggetti_cl where id_cu_oggetto = idcuoggetto 
							and id not in (select id_cu_oggetto_cl from cu.vw_cu_evidenze
															  where id_cu_oggetto = idcuoggetto )
															  --and id_cu_classe_evidenza between 1 and 2)
							and chiuso = false)
				loop 
					update cu.cu_oggetti_cl 
					set chiuso = true, 
					id_stato_cl = (select id_stato_cl from cu_types.vw_cu_stati_cl where sigla = 'C') 
					where id = r.id returning * into R_CL;
					n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
				end loop;
			end if;
	
		end if;
		--chiudi tutte le checklist con nc/NC	
		/*
		update cu.cu_oggetti_cl 
		set chiuso = true, 
		id_stato_cl = 3 
		where id_cu_oggetto = idcuoggetto 
		and id in (select id_cu_oggetto_cl from cu.vw_cu_evidenze
										  where id_cu_oggetto = idcuoggetto 
										  and id_cu_classe_evidenza between 1 and 2)
		and chiuso = false;
		*/
		for r in (select * from cu.cu_oggetti_cl where id_cu_oggetto = idcuoggetto 
					and id in (select id_cu_oggetto_cl from cu.vw_cu_evidenze
													  where id_cu_oggetto = idcuoggetto 
													  and id_cu_classe_evidenza between 1 and 2)
					and chiuso = false)
		loop 
			update cu.cu_oggetti_cl 
			set chiuso = true, 
			id_stato_cl = 3 
			where id = r.id returning * into R_CL;
			n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
		end loop;
	
		--chiudi tutte le checklist con S
		/*
		update cu.cu_oggetti_cl 
		set chiuso = true, 
		id_stato_cl = 4 --(select id_stato_cl from cu_types.vw_cu_stati_cl where sigla = R_SO.sigla) 
		where id_cu_oggetto = idcuoggetto 
		and id in (select id_cu_oggetto_cl from cu.vw_cu_evidenze  --cl con nc da escludere
										  where id_cu_oggetto = idcuoggetto 
										  and id_cu_classe_evidenza = 5)
		and chiuso = false;
		*/
		for r in (select * from cu.cu_oggetti_cl where id_cu_oggetto = idcuoggetto 
					and id in (select id_cu_oggetto_cl from cu.vw_cu_evidenze  --cl con nc da escludere
													  where id_cu_oggetto = idcuoggetto 
													  and id_cu_classe_evidenza = 5)
					and chiuso = false)
		loop 
			update cu.cu_oggetti_cl 
			set chiuso = true, 
			id_stato_cl = 4 
			where id = r.id returning * into R_CL;
			n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
		end loop;
	
		--chiudi tutte le checklist con C
		/*
		update cu.cu_oggetti_cl 
		set chiuso = true, 
		id_stato_cl = 2 --(select id_stato_cl from cu_types.vw_cu_stati_cl where sigla = R_SO.sigla) 
		where id_cu_oggetto = idcuoggetto 
		and id in (select id_cu_oggetto_cl from cu.vw_cu_evidenze  --cl con nc da escludere
										  where id_cu_oggetto = idcuoggetto 
										  and id_cu_classe_evidenza = 6)
		and chiuso = false;
		*/
		for r in (select * from cu.cu_oggetti_cl where id_cu_oggetto = idcuoggetto 
					and id in (select id_cu_oggetto_cl from cu.vw_cu_evidenze  --cl con nc da escludere
													  where id_cu_oggetto = idcuoggetto 
													  and id_cu_classe_evidenza = 6)
					and chiuso = false)
		loop 
			update cu.cu_oggetti_cl 
			set chiuso = true, 
			id_stato_cl = 2 
			where id = r.id returning * into R_CL;
			n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
		end loop;
	
		--chiudi tutte le altre checklist
		/*
		update cu.cu_oggetti_cl 
		set chiuso = true, 
		id_stato_cl = 1 --(select id_stato_cl from cu_types.vw_cu_stati_cl where sigla = R_SO.sigla) 
		where id_cu_oggetto = idcuoggetto 
		and id not in (select id_cu_oggetto_cl from cu.vw_cu_evidenze  --cl con nc da escludere
										  where id_cu_oggetto = idcuoggetto 
										  and id_cu_classe_evidenza between 1 and 2)
		and chiuso = false;
		*/
	
		for r in (select * from cu.cu_oggetti_cl where id_cu_oggetto = idcuoggetto 
						and id not in (select id_cu_oggetto_cl from cu.vw_cu_evidenze  --cl con nc da escludere
										  where id_cu_oggetto = idcuoggetto 
										  and id_cu_classe_evidenza between 1 and 2) and chiuso = false)
		loop 
			update cu.cu_oggetti_cl 
			set chiuso = true, 
			id_stato_cl = 1 --(select id_stato_cl from cu_types.vw_cu_stati_cl where sigla = R_SO.sigla) 
			where id = r.id returning * into R_CL;
			n:=cu_log.upd_record('cu.cu_oggetti_cl',idtransazione,R_CL,'U');
		end loop;
						
	
		--chiudi oggetto
		update cu.cu_oggetti set chiuso=true,id_stato_oggetto=idnuovostato where id=idcuoggetto
		returning * into R_CO;
		n:=cu_log.upd_record('cu.cu_oggetti',idtransazione,R_CO,'U');
		
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_oggetto_chiudi(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_provv_fu(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_provv_fu(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        idnominativostruttura bigint;  
       	idsroot bigint;
		u json;
       	ordmax integer;
      	idcu bigint;
      	R_PF cu.cu_provv_fu;
        proc_name varchar; -- end
        n bigint;
	begin
		proc_name:='cu.upd_cu_provv_fu';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idnominativostruttura:=v_j->'id_nominativo_struttura';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';
		idcu:=v_j->'id_cu';
		/*
		delete from cu.cu_provv_fu where id_cu=idcu and id_provv
	 		not in (select (value::varchar)::bigint id_linea from
	                        json_array_elements(v_j->'id_provv') );             
        */
		for R_PF in select * from cu.cu_provv_fu where id_cu=idcu and id_provv
	 		not in (select (value::varchar)::bigint id_linea from
	                        json_array_elements(v_j->'id_provv') )
		loop
			delete from cu.cu_provv_fu where id = R_PF.id;
			n:=cu_log.upd_record('cu.cu_provv_fu',idtransazione,R_PF,'D');
		end loop;
		
		select coalesce(max(ord),0)+1 into ordmax from cu.cu_oggetti
			where id_cu=idcu;
		
		for R_PF in select nextval('cu.cu_id_seq'),idcu,(value::varchar)::bigint,ordmax +row_number() over(),null
			from json_array_elements(v_j->'id_provv')
			where (value::varchar)::bigint not in (select id_provv from cu.cu_provv_fu where id_cu=idcu) 
		loop
			insert into cu.cu_provv_fu values (R_PF.*);
			n:=cu_log.upd_record('cu.cu_provv_fu',idtransazione,R_PF,'I');
		end loop;
	
		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_provv_fu(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_provv_fu_stato(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_provv_fu_stato(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcu  bigint;
      	idns bigint;
        proc_name varchar; -- end
		idcuprovv bigint;
      	nuovostato boolean;
    	rt json;
    	n bigint;
    	r record;
	begin
		proc_name:='cu.upd_cu_provv_fu_risolti';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;
		nuovostato:=v_j->'stato';
		idcuprovv :=v_j->'id_provv_fu';
		
		update cu.cu_provv_fu 
		set risolta=nuovostato 
		where id=idcuprovv returning * into R;
	
		n:=cu_log.upd_record('cu.cu_provv_fu',idtransazione,R,'U');
	
		/*
		for idcuprovv in select (value::varchar)::bigint id
			from json_array_elements(v_j->'id_cu_provv_fu') loop
				update cu.cu_provv_fu set risolta=nuovostato
				where id=idcuprovv;
		end loop;
	    */
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_provv_fu_stato(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_provv_sopralluogo_fu_stato(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_provv_sopralluogo_fu_stato(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcu  bigint;
      	idns bigint;
        proc_name varchar; -- end
		idcuprovv bigint;
      	nuovostato boolean;
      	r record;
      	n bigint;
    	rt json;
	begin
		proc_name:='cu.upd_cu_provv_sopralluogo_fu_stato';
		
		raise notice 'V_J=%', v_j;
		nuovostato:=v_j->'stato';
		idcuprovv :=v_j->'id_provv_fu';
		
		update cu.cu_provv_sopralluogo_fu
		set risolta=nuovostato 
		where id=idcuprovv returning * into R;
		n:=cu_log.upd_record('cu.cu_provv_sopralluogo_fu',idtransazione,R,'U');
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_provv_sopralluogo_fu_stato(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_upd_date_ce(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_upd_date_ce(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcunucleo  bigint;
     	ini timestamp;
     	fin timestamp;
     	v_ruolo varchar;
     	R_N cu.cu_nucleo;
     	R_P cu.cu_nucleo_periodi;
     	n bigint;
        proc_name varchar; -- end
	begin
		proc_name:='cu.upd_cu_upd_date_ce';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idcunucleo:=v_j->'id_cu_nucleo';
		ini :=v_j->'inizio';
		fin :=v_j->'fine';
		v_ruolo:= v_j->>'ruolo';
	
		update cu.cu_nucleo_periodi
		set periodo = tsrange(
			ini,
			fin,
			'[)'
		) 
		where id_cu_nucleo  = idcunucleo returning * into R_P;
	
		n:=cu_log.upd_record('cu.cu_nucleo_periodi',idtransazione,R_P,'U');
	
		update cu.cu_nucleo
		set ruolo = v_ruolo
		where id = idcunucleo returning * into R_N;
	
		n:=cu_log.upd_record('cu.cu_nucleo',idtransazione,R_N,'U');

		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
end;
$$;


ALTER FUNCTION cu.upd_cu_upd_date_ce(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_upd_date_ni(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_upd_date_ni(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcunucleoperiodo  bigint;
     	ini timestamp;
     	fin timestamp;
     	idcupiano bigint;
     	idcu bigint;
        proc_name varchar; -- end
        R_CP cu.vw_cu_periodo%ROWTYPE;
       	R_P cu.cu_nucleo_periodi;
        n integer;
	begin
		proc_name:='cu.upd_cu_upd_date';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idcunucleoperiodo:=v_j->'id_nucleo_periodo';
		ini :=v_j->'inizio';
		fin :=v_j->'fine';
		idcupiano:= v_j->'id_cu_piano';
	
		update cu.cu_nucleo_periodi
		set periodo = tsrange(
			ini,
			fin,
			'[)'
		), id_cu_piano = idcupiano
		where id  = idcunucleoperiodo returning * into R_P;
	
		--log upd cu.cu_nucleo_periodi
		n:=cu_log.upd_record('cu.cu_nucleo_periodi',idtransazione,R_P,'U');
	
		-- issue #11566
	
		select id_cu into idcu from cu.cu_nucleo_periodi np
		join cu.cu_nucleo cn on cn.id = np.id_cu_nucleo 
		where np.id = idcunucleoperiodo;
	
		select * into R_CP from cu.vw_cu_periodo where id_cu = idcu;
	
		update agenda.eventi
		set inizio = R_CP.cu_inizio,
		fine = R_CP.cu_fine
		where id = (select id_evento from cu.cu where id = idcu);
	
		update cu.cu 
		set dt = R_CP.cu_inizio
		where id = idcu;

		-- fine
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_upd_date_ni(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_upd_date_per(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_upd_date_per(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idcunucleo  bigint;
     	ini timestamp;
     	fin timestamp;
     	v_ruolo bigint;
     	R_N cu.cu_nucleo;
     	R_P cu.cu_nucleo_periodi;
     	n bigint;
        proc_name varchar; -- end
	begin
		proc_name:='cu.upd_cu_upd_date_per';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idcunucleo:=v_j->'id_cu_nucleo';
		ini :=v_j->'inizio';
		fin :=v_j->'fine';
		v_ruolo:= v_j->'ruolo';
	
		update cu.cu_nucleo_periodi
		set periodo = tsrange(
			ini,
			fin,
			'[)'
		) 
		where id_cu_nucleo  = idcunucleo returning * into R_P;
	
		n:=cu_log.upd_record('cu.cu_nucleo_periodi',idtransazione,R_P,'U');
	
		update cu.cu_nucleo
		set id_tipo_per = v_ruolo
		where id = idcunucleo returning * into R_N;
	
		n:=cu_log.upd_record('cu.cu_nucleo',idtransazione,R_N,'U');

		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
end;
$$;


ALTER FUNCTION cu.upd_cu_upd_date_per(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_upd_evidenza(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_upd_evidenza(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- start
	    ret1 cu_types.result_type; -- START
        proc_name varchar; -- end
		R_E cu.cu_evidenze;
		R_EL cu.cu_evidenza_linee;
		R_OCL cu.vw_cu_oggetti_cl;
		idlinea bigint;
		n bigint;

	begin
		proc_name:='cu.upd_cu_upd_evidenza';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;
		ret.esito:=false;
		--R_E.id_cu_oggetto_cl:=v_j->>'id_cu_oggetto_cl';
		--select * into R_OCL from cu.vw_cu_oggetti_cl where id_cu_oggetto_cl=R_E.id_cu_oggetto_cl;
		--R_E.id_cu_linea :=v_j->>'id_cu_linea';
		R_E.id_cu_grado_evidenza :=v_j->>'id_cu_grado_evidenza';
		R_E.id_cu_classe_evidenza :=v_j->>'id_cu_classe_evidenza';
		R_E.evidenza :=v_j->>'evidenza';
		R_E.risultanza :=v_j->>'risultanza';
		R_E.id:=v_j->>'id_evidenza';

		update cu.cu_evidenze
		set
		id_cu_grado_evidenza = R_E.id_cu_grado_evidenza,
		id_cu_classe_evidenza  = R_E.id_cu_classe_evidenza,
		evidenza = R_E.evidenza,
		risultanza = R_E.risultanza
		where id = R_E.id returning * into R_E;
		n:=cu_log.upd_record('cu.cu_evidenze',idtransazione,R_E,'U');
	
		/*
		delete from cu.cu_evidenza_linee
		where id_evidenza = R_E.id;
		*/
	
		for R_EL in (select * from cu.cu_evidenza_linee
					 where id_evidenza = R_E.id)
		loop
			delete from cu.cu_evidenza_linee
			where id = R_EL.id;
			n:=cu_log.upd_record('cu.cu_evidenza_linee',idtransazione,R_EL,'D');
		end loop;
	
		/*
		insert into cu.cu_evidenza_linee
			select nextval('cu.cu_id_seq'),R_E.id,(value::varchar)::bigint id
			from json_array_elements(v_j->'id_cu_linee') ;
		*/
		
		for idlinea in (select * from json_array_elements(v_j->'id_cu_linee'))
		loop
			insert into cu.cu_evidenza_linee
			select nextval('cu.cu_id_seq'),R_E.id,idlinea returning * into R_EL;
			n:=cu_log.upd_record('cu.cu_evidenza_linee',idtransazione,R_EL,'U');
		end loop;
		
		ret1:=cu.cu_aggiorna_norme_violate(R_OCL.id_cu,idtransazione);
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
	   
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_upd_evidenza(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_upd_nominativo_provv(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_upd_nominativo_provv(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- start
        proc_name varchar; -- end
        
		R_NP cu.vw_cu_nominativo_provv;
		idcu bigint;	
		idnominativo bigint;	
		R record;
		n bigint;
	
	begin
		proc_name:='cu.upd_cu_upd_nominativo_provv';
		raise notice 'V_J=%', v_j;
		ret.esito:=false;
	
		idcu=v_j->'id_cu';
		idnominativo=v_j->'id_nominativo';
		
		insert into cu.cu_nominativo_provv (id,id_cu, id_nominativo)
		values (nextval('cu.cu_id_seq'),idcu,idnominativo)
		on conflict (id_cu) do
		update set	id_nominativo = idnominativo returning * into R;
		n:=cu_log.upd_record('cu.cu_nominativo_provv',idtransazione,R,'U');
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
	   
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_upd_nominativo_provv(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_upd_provv(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_upd_provv(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
		R_P cu.cu_provv;
		idprovv bigint;
		
	begin
		proc_name:='cu.upd_cu_add_provv';
		raise notice 'V_J=%', v_j;
		idprovv:= v_j->>'id_provv';
		ret.esito:=false;
		R_P.id_evidenza:=v_j->>'id_evidenza';
		R_P.azione:=v_j->>'azione';
		R_P.id_tipo_provv:=v_j->>'id_tipo_provv';
		R_P.ord:=1;
		R_P.dt:=v_j->>'dt';
		R_P.id:=nextval('cu.cu_provv_id_seq');

		update cu.cu_provv set
		id_tipo_provv = R_P.id_tipo_provv,
		azione = R_P.azione,
		dt = R_P.dt
		where id = idprovv;
	
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_upd_provv(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_upd_requisiti(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_upd_requisiti(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
		R_Q cu_conf.cu_requisiti;
		idrequisito bigint;

	begin
		proc_name:='cu.upd_cu_upd_requisiti';
		raise notice 'V_J=%', v_j;
		ret.esito:=false;
		idrequisito:=v_j->>'id_requisito';
		R_Q.descr:=v_j->>'descr';
		R_Q.norma:=v_j->>'norma';
		R_Q.cl:=v_j->>'cl';
		R_Q.validita:=tsrange(current_date,null,'[)');
		R_Q.ord:=(select max(ord)+1 from cu_conf.cu_requisiti where id_tipo_oggetto = R_Q.id_tipo_oggetto);
		R_Q.id:=nextval('cu_conf.cu_requisiti_id_seq');
		
		update cu_conf.cu_requisiti set
		norma = R_Q.norma,
		descr = R_Q.descr,
		cl = R_Q.cl
		where id = idrequisito;
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
end

$$;


ALTER FUNCTION cu.upd_cu_upd_requisiti(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_upd_tipo_oggetto(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_upd_tipo_oggetto(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        proc_name varchar; -- end
		R_O cu_conf.cu_tipo_oggetti;
		idtipooggetto bigint;
		n bigint = 0;

	begin
		proc_name:='cu.upd_cu_upd_tipo_oggetto';
		raise notice 'V_J=%', v_j;
		ret.esito:=false;
		idtipooggetto:=v_j->>'id_tipo_oggetto';
		R_O.sigla:=v_j->>'sigla';
		R_O.descr:=v_j->>'descr';
		R_O.cod:=v_j->>'cod';
		
		R_O.sigla:=trim(R_O.sigla);
		R_O.descr:=trim(R_O.descr);
		R_O.cod:=trim(R_O.cod);
	
		select count(*) into n from cu_conf.vw_cu_tipo_oggetti c where c.cod = R_O.cod and c.validita @> localtimestamp 
		and c.id_tipo_oggetto != idtipooggetto;
		if n > 0 then
		ret:=cu_ui.build_ret(ret,proc_name,'cod_oggetto_gia_inserito');
			return ret;
		end if;	
	
		select count(*) into n from cu_conf.vw_cu_tipo_oggetti c where c.sigla = R_O.sigla and c.validita @> localtimestamp
		and c.id_tipo_oggetto != idtipooggetto;
		if n > 0 then
		ret:=cu_ui.build_ret(ret,proc_name,'sigla_oggetto_gia_inserita');
			return ret;
		end if;
	
		select count(*) into n from cu_conf.vw_cu_tipo_oggetti c where c.descr = R_O.descr and c.validita @> localtimestamp
		and c.id_tipo_oggetto != idtipooggetto;
		if n > 0 then
		ret:=cu_ui.build_ret(ret,proc_name,'descr_oggetto_gia_inserita');
			return ret;
		end if;
	
		update cu_conf.cu_tipo_oggetti set
		sigla = R_O.sigla,
		descr = R_O.descr,
		cod = R_O.cod
		where id = idtipooggetto;
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
end

$$;


ALTER FUNCTION cu.upd_cu_upd_tipo_oggetto(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_upd_vet_provv_sopralluogo(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_cu_upd_vet_provv_sopralluogo(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- start
        proc_name varchar; -- end
        
		R_PS cu.vw_cu_provv_sopralluogo%ROWTYPE;
		idprovv bigint;	
		R record;
		n bigint;
	
	begin
		proc_name:='cu.upd_cu_upd_vet_provv_sopralluogo';
		raise notice 'V_J=%', v_j;
		ret.esito:=false;
	
		idprovv=v_j->'id_provv';
		select * into R_PS from cu.vw_cu_provv_sopralluogo vcps  where id=idprovv;
		if R_PS.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'provv_non_trovato');
			return ret;
		end if;
	
		update cu.cu_provv_sopralluogo
		set	id_nominativo = (v_j->>'id_nominativo')::bigint
		where id = idprovv returning * into R;
		n:=cu_log.upd_record('cu.cu_provv_sopralluogo',idtransazione,R,'U');
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
	   
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_cu_upd_vet_provv_sopralluogo(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_dati(character varying, character varying, bigint, json); Type: PROCEDURE; Schema: cu; Owner: postgres
--

CREATE PROCEDURE cu.upd_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json)
    LANGUAGE plpgsql
    AS $$
declare 
	idtransazione bigint;
	proc_name varchar;
	id_op bigint;  
	ret cu_types.result_type;
	text_msg1 varchar;	
	text_msg2 varchar;	
	text_msg3 varchar;	
	text_msg4 varchar;
	ts timestamp;
	fallito bool;
	j_user_info json;
	n integer;
begin
	ts:=CLOCK_TIMESTAMP();
	proc_name:='cu.upd_dati';
	idtransazione:= cu_log.get_id_transazione(idutente,proc_name);
	--select row_to_json(public.get_utente_info_from_gisa(idutente)) into j_user_info;
	--select row_to_json(a.*) into j_user_info from (select u.*,a.n_livello  from public.get_utente_info_from_gisa_ext(idutente) u left join matrix.vw_tree_nodes_up_asl a on a.id_node=u.id_struttura_root) a;
	--select * into j_user_info from dblink('mdgm_fvg_foreign','select row_to_json(public.get_utente_info_from_gisa_ext('||'-1'||'))') as T(ret json);
	--j_user_info := row_to_json(public.get_utente_info_from_gisa_ext('-1'));

	--idutente è rbac.id_utente_struttura_ruolo
	select row_to_json(a.*) into j_user_info from
	(	
		select *,id_struttura as id_struttura_root from public.get_utente_info_3(idutente)
	) a;

	if j_user_info is not null then
		if v is null or v='' or v='{}' then
			v:= '{"user_info":'||j_user_info||'}';
		else
			v:= substring(v,1,length(v)-1)||',"user_info":'||j_user_info||'}';
		end if;
	end if;
	id_op:=cu_log.start_op(proc_name,idtransazione ,v);


commit;
 
   	begin
	   	fallito:=false;
	   	case operazione
	   		when 'upd_ins_cu_piano' then
	   			ret:=cu.upd_ins_cu_piano(v::json, idtransazione);
	   		when 'upd_cu_linee' then
	   			ret:=cu.upd_cu_linee(v::json, idtransazione);
	   		when 'upd_add_cu_oggetti' then
	   			ret:=cu.upd_add_cu_oggetti(v::json, idtransazione);
	   		when 'upd_cu_oggetti' then
	   			ret:=cu.upd_cu_oggetti(v::json, idtransazione);
	   		when 'upd_cu_conf' then
	   			ret:=cu_conf.upd_cu_conf(v::json, idtransazione);
	   		when 'upd_del_cu_piano' then
	   			ret:=cu.upd_del_cu_piano(v::json, idtransazione);
	   		when 'upd_add_cu_piano' then
	   			ret:=cu.upd_add_cu_piano(v::json, idtransazione);
	   		when 'upd_cu_del_nucleo' then
	   			ret:=cu.upd_cu_del_nucleo(v::json, idtransazione);	   		
	   		when 'upd_cu_del_esterno' then
	   			ret:=cu.upd_cu_del_esterno(v::json, idtransazione);	
	   		when 'upd_cu_del_personale' then
	   			ret:=cu.upd_cu_del_personale(v::json, idtransazione);
	   		when 'upd_cu_add_nucleo' then
	   			ret:=cu.upd_cu_add_nucleo(v::json, idtransazione);	
	   		when 'upd_cu_add_esterno' then
	   			ret:=cu.upd_cu_add_esterno(v::json, idtransazione);
	   		when 'upd_cu_add_personale' then
	   			ret:=cu.upd_cu_add_personale(v::json, idtransazione);
	   		when 'upd_cu_add_evidenza' then
	   			ret:=cu.upd_cu_add_evidenza(v::json, idtransazione);	
	   		when 'upd_cu_upd_evidenza' then
	   			ret:=cu.upd_cu_upd_evidenza(v::json, idtransazione);	
	   		when 'upd_cu_del_evidenze' then
	   			ret:=cu.upd_cu_del_evidenze(v::json, idtransazione);
	   		when 'upd_cu_add_provv' then
	   			ret:=cu.upd_cu_add_provv(v::json, idtransazione);	
	   		when 'upd_cu_del_provv' then
	   			ret:=cu.upd_cu_del_provv(v::json, idtransazione);
	   		when 'upd_cu_upd_provv' then
	   			ret:=cu.upd_cu_upd_provv(v::json, idtransazione);	
	   		when 'upd_cu_upd_nominativo_provv' then
	   			ret:=cu.upd_cu_upd_nominativo_provv(v::json, idtransazione);	
	   		when 'upd_cu_add_provv_sopralluogo' then
	   			ret:=cu.upd_cu_add_provv_sopralluogo(v::json, idtransazione);	
	   		when 'upd_cu_del_provv_sopralluogo' then
	   			ret:=cu.upd_cu_del_provv_sopralluogo(v::json, idtransazione);	
	   		when 'upd_cu_upd_vet_provv_sopralluogo' then
	   			ret:=cu.upd_cu_upd_vet_provv_sopralluogo(v::json, idtransazione);	
	   		when 'upd_cu_cl_apri' then
	   			ret:=cu.upd_cu_cl_apri(v::json, idtransazione);		   		
	   		when 'upd_cu_cl_chiudi' then
	   			ret:=cu.upd_cu_cl_chiudi(v::json, idtransazione);
	   		when 'upd_cu_cl_chiudi_massivo' then
	   			ret:=cu.upd_cu_cl_chiudi_massivo(v::json, idtransazione);
	   		when 'upd_cu_oggetto_chiudi' then
	   			ret:=cu.upd_cu_oggetto_chiudi(v::json, idtransazione);
	   		when 'upd_cu_oggetto_apri' then
	   			ret:=cu.upd_cu_oggetto_apri(v::json, idtransazione);
	   		when 'upd_cu_upd_date' then
	   			ret:=cu.upd_cu_upd_date(v::json, idtransazione);
	   		when 'upd_cu_upd_date_NI' then
	   			ret:=cu.upd_cu_upd_date_NI(v::json, idtransazione);
	   		when 'upd_cu_upd_date_per' then
	   			ret:=cu.upd_cu_upd_date_per(v::json, idtransazione);
	   		when 'upd_cu_upd_date_ce' then
	   			ret:=cu.upd_cu_upd_date_ce(v::json, idtransazione);
	   		when 'upd_cu_add_tipo_oggetto' then
	   			ret:=cu.upd_cu_add_tipo_oggetto(v::json, idtransazione);
	   		when 'upd_cu_del_tipo_oggetto' then
	   			ret:=cu.upd_cu_del_tipo_oggetto(v::json, idtransazione);
	   		when 'upd_cu_upd_tipo_oggetto' then
	   			ret:=cu.upd_cu_upd_tipo_oggetto(v::json, idtransazione);
	   		when 'upd_cu_add_requisiti' then
	   			ret:=cu.upd_cu_add_requisiti(v::json, idtransazione);
	   		when 'upd_cu_del_requisiti' then
	   			ret:=cu.upd_cu_del_requisiti(v::json, idtransazione);
	   		when 'upd_cu_upd_requisiti' then
	   			ret:=cu.upd_cu_upd_requisiti(v::json, idtransazione);
	   		when 'upd_cu_add_dichiarazione' then
	   			ret:=cu.upd_cu_add_dichiarazione(v::json, idtransazione);
	   		when 'upd_cu_tipi_oggetti_piano' then
	   			ret:=cu_conf.upd_cu_tipi_oggetti_piano(v::json, idtransazione);
	   		when 'upd_cu_chiudi_cu' then
	   			ret:=cu.upd_cu_chiudi_cu(v::json, idtransazione);
	   		when 'upd_cu_info_generali' then 
	   			ret:=cu.upd_cu_info_generali(v::json, idtransazione);
	   		when 'upd_cu_note_generali' then 
	   			ret:=cu.upd_cu_note_generali(v::json, idtransazione);
	   		when 'upd_cu_note_verbale' then 
	   			ret:=cu.upd_cu_note_verbale(v::json, idtransazione);
	   		when 'upd_cu_add_stabilimenti_sedi' then 
	   			ret:=cu_anag.upd_cu_add_stabilimenti_sedi(v::json, idtransazione);
	   		when 'upd_cu_add_stabilimenti_figure' then 
	   			ret:=cu_anag.upd_cu_add_stabilimenti_figure(v::json, idtransazione);
	   		when 'upd_cu_upd_stabilimenti_sedi' then 
	   			ret:=cu_anag.upd_cu_upd_stabilimenti_sedi(v::json, idtransazione);
	   		when 'upd_cu_upd_stabilimenti_figure' then 
	   			ret:=cu_anag.upd_cu_upd_stabilimenti_figure(v::json, idtransazione);
	   		when 'upd_cu_del_stabilimento_sedi' then 
	   			ret:=cu_anag.upd_cu_del_stabilimento_sedi(v::json, idtransazione);
	   		when 'upd_cu_del_stabilimento_figure' then 
	   			ret:=cu_anag.upd_cu_del_stabilimento_figure(v::json, idtransazione);
	   		when 'upd_cu_del_stabilimento_indirizzo_errato' then 
	   			ret:=cu_anag.upd_cu_del_stabilimento_indirizzo_errato(v::json, idtransazione);
	   		when 'upd_cu_del_stabilimento_figure_indirizzo_errato' then 
	   			ret:=cu_anag.upd_cu_del_stabilimento_figure_indirizzo_errato(v::json, idtransazione);
	   		when 'upd_cu_del_stabilimento_sedi_indirizzo_errato' then 
	   			ret:=cu_anag.upd_cu_del_stabilimento_sedi_indirizzo_errato(v::json, idtransazione);
	   		when 'upd_cu_del_soggetti_fisici_indirizzo_errato' then 
	   			ret:=cu_anag.upd_cu_del_soggetti_fisici_indirizzo_errato(v::json, idtransazione);
	   		when 'upd_cu_del_impresa_figure_indirizzo_errato' then 
	   			ret:=cu_anag.upd_cu_del_impresa_figure_indirizzo_errato(v::json, idtransazione);
	   		when 'upd_cu_del_impresa_sedi_indirizzo_errato' then 
	   			ret:=cu_anag.upd_cu_del_impresa_sedi_indirizzo_errato(v::json, idtransazione);
	   		when 'upd_cu_add_imprese_sedi' then 
	   			ret:=cu_anag.upd_cu_add_imprese_sedi(v::json, idtransazione);
	   		when 'upd_cu_add_imprese_figure' then 
	   			ret:=cu_anag.upd_cu_add_imprese_figure(v::json, idtransazione);
	   		when 'upd_cu_upd_imprese_sedi' then 
	   			ret:=cu_anag.upd_cu_upd_imprese_sedi(v::json, idtransazione);
	   		when 'upd_cu_upd_imprese_figure' then 
	   			ret:=cu_anag.upd_cu_upd_imprese_figure(v::json, idtransazione);
	   		when 'upd_cu_del_impresa_sedi' then 
	   			ret:=cu_anag.upd_cu_del_impresa_sedi(v::json, idtransazione);
	   		when 'upd_cu_del_impresa_figure' then 
	   			ret:=cu_anag.upd_cu_del_impresa_figure(v::json, idtransazione);
	   		when 'upd_set_codice_stabilimento' then 
	   			ret:=cu_anag.upd_set_codice_stabilimento(v::json, idtransazione);
	   		when 'upsert_indirizzi' then 
	   			ret:=cu_anag.upsert_indirizzi(v::json, idtransazione);
	   		when 'upd_categorie_rischio_alberi' then 
	   			ret:=cu.upd_categorie_rischio_alberi(v::json, idtransazione);
	   		when 'upd_add_automezzi' then 
	   			ret:=cu.upd_add_automezzi(v::json, idtransazione);	   		
	   		when 'upd_add_indirizzi_trasportatori' then 
	   			ret:=cu.upd_add_indirizzi_trasportatori(v::json, idtransazione);	   		
	   		when 'upd_del_automezzo' then 
	   			ret:=cu.upd_del_automezzo(v::json, idtransazione);	   		
	   		when 'upd_cu_nomi_pdf_evidenze' then 
	   			ret:=cu.upd_cu_nomi_pdf_evidenze(v::json, idtransazione);
	   		when 'upd_cu_nomi_pdf_controlli' then 
	   			ret:=cu.upd_cu_nomi_pdf_controlli(v::json, idtransazione);
	   		when 'upd_cu_provv_fu' then 
	   			ret:=cu.upd_cu_provv_fu(v::json, idtransazione);
	   		when 'upd_cu_provv_fu_stato' then 
	   			ret:=cu.upd_cu_provv_fu_stato(v::json, idtransazione);
	   		when 'upd_cu_provv_sopralluogo_fu_stato' then 
	   			ret:=cu.upd_cu_provv_sopralluogo_fu_stato(v::json, idtransazione);
	   		when 'upd_cu_imprese' then 
	   			ret:=cu_anag.upd_cu_imprese(v::json, idtransazione);
	   		when 'upd_cu_stabilimenti' then 
	   			ret:=cu_anag.upd_cu_stabilimenti(v::json, idtransazione);
	   		when 'upd_cu_soggetti_fisici' then 
	   			ret:=cu_anag.upd_cu_soggetti_fisici(v::json, idtransazione);
	   		when 'upd_cu_add_soggetti_fisici' then 
	   			ret:=cu_anag.upd_cu_add_soggetti_fisici(v::json, idtransazione);
	   		when 'upd_cu_add_soggetti_fisici_from_service' then 
	   			ret:=cu_anag.upd_cu_add_soggetti_fisici_from_service(v::json, idtransazione);	
	   		when 'upd_cu_indirizzi' then 
	   			ret:=cu_anag.upd_cu_indirizzi(v::json, idtransazione);
	   		when 'upd_cu_add_indirizzi' then 
	   			ret:=cu_anag.upd_cu_add_indirizzi(v::json, idtransazione);
	   		when 'upd_cu_del_pdf_controlli' then 
	   			ret:=cu.upd_cu_del_pdf_controlli(v::json, idtransazione);
	   		when 'upd_cu_del_pdf_evidenze' then 
	   			ret:=cu.upd_cu_del_pdf_evidenze(v::json, idtransazione);
	   		when 'upd_cu_add_impresa' then 
	   			ret:=cu_anag.upd_cu_add_impresa(v::json, idtransazione);
	   		when 'upd_cu_add_stabilimento' then 
	   			ret:=cu_anag.upd_cu_add_stabilimento(v::json, idtransazione);
	   		when 'upd_cu_del_impresa' then 
	   			ret:=cu_anag.upd_cu_del_impresa(v::json, idtransazione);
	   		when 'upd_cu_del_stabilimento' then 
	   			ret:=cu_anag.upd_cu_del_stabilimento(v::json, idtransazione);
	   		when 'upd_cu_stabilimento_subingresso' then 
	   			ret:=cu_anag.upd_cu_stabilimento_subingresso(v::json, idtransazione);
	   		when 'upd_cu_add_linea_stabilimenti' then 
	   			ret:=cu_anag.upd_cu_add_linea_stabilimenti(v::json, idtransazione);
	   		when 'upd_cu_linea_stabilimenti' then 
	   			ret:=cu_anag.upd_cu_linea_stabilimenti(v::json, idtransazione);
	   		when 'upd_cu_del_linea_stabilimenti' then 
	   			ret:=cu_anag.upd_cu_del_linea_stabilimenti(v::json, idtransazione);
	   		when 'upd_cu_stabilimenti_linea_principale' then 
	   			ret:=cu_anag.upd_cu_stabilimenti_linea_principale(v::json, idtransazione);
	   		when 'upd_cu_firmatario_verbale' then 
	   			ret:=cu.upd_cu_firmatario_verbale(v::json, idtransazione);
	   		when 'ins_upd_azienda' then 
	   			ret:=cu_anag.ins_upd_azienda(v::json, idtransazione);
	   		when 'upd_cu_categ_eval' then 
	   			ret:=cu.upd_cu_categ_eval(v::json, idtransazione);
	   		when 'load_import_anagrafica' then 
	   			ret:=cu_anag.load_import_anagrafica(v::json, idtransazione);
	   		
	   		when 'upd_cu_add_pratica' then 
	   			ret:=cu_anag.upd_cu_add_pratica(v::json, idtransazione);
	   		when 'upd_cu_upd_pratica' then 
	   			ret:=cu_anag.upd_cu_upd_pratica(v::json, idtransazione);
	   		when 'upd_cu_stato_pratica' then 
	   			ret:=cu_anag.upd_cu_stato_pratica(v::json, idtransazione);
	   		when 'ins_automezzo' then 
	   			ret:=cu_anag.ins_automezzo(v::json, idtransazione);
	   		when 'upd_automezzo' then 
	   			ret:=cu_anag.upd_automezzo(v::json, idtransazione);
	   		when 'ins_stabilimenti_automezzi' then 
	   			ret:=cu_anag.ins_stabilimenti_automezzi(v::json, idtransazione);
	   		when 'upd_stabilimenti_automezzi' then 
	   			ret:=cu_anag.upd_stabilimenti_automezzi(v::json, idtransazione);
	   
			when 'null' then
				ret.esito:=true;
			else
 				ret.esito := false;
 				ret.info  := 'CASO NON PREVISTO';
	   	end case;
		
	    RAISE notice 'cu.upd_evento ret.esito: %', ret.esito;
	   
   		if ret.esito=false then 
   			RAISE notice 'cu.upd_evento if su ret.esito=false';
   			fallito=true;
	   		RAISE notice 'cu.upd_evento ROLLBACK a seguito di ret.esito=false';
   		end if;

	/*if fallito=true then 
		rollback;
	end if;
	*/
	-- AF 20240513 joutput:=row_to_json(ret);
	-- AF 20240513 id_op:=cu_log.op(proc_name,idtransazione,v,joutput,ts,-1,operazione);

	exception when others then
		fallito:=true;
		RAISE notice 'gds.upd_dati ROLLBACK a seguito di exception';
		GET STACKED DIAGNOSTICS text_msg1 = MESSAGE_TEXT,
                          			text_msg2 = PG_EXCEPTION_DETAIL,
                          			text_msg3 = PG_EXCEPTION_HINT,
                         			text_msg4 = PG_EXCEPTION_CONTEXT;
			ret.esito:=false;
			ret.valore:= null;
		
			if replace(upper(j_user_info->>'ambiente'),'"','') = 'local' or replace(upper(j_user_info->>'ambiente'),'"','') = 'dev'  then
				ret.err_msg:=coalesce(ret.err_msg,'')||coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');
			else
				--ret.err_msg:=coalesce(text_msg1,'');
				ret.err_msg:=coalesce(ret.err_msg,'')||coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');

			end if;
			--ret.msg:=coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');
			RAISE notice '%', ret;
		rollback;
	end;
	--if ret.info is null then ret.valore = 0; end if;
	joutput:=row_to_json(ret);
	id_op:=cu_log.op(proc_name,idtransazione,v,joutput,ts,-1,operazione);
commit;

end;
$$;


ALTER PROCEDURE cu.upd_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json) OWNER TO postgres;

--
-- Name: upd_del_automezzo(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_del_automezzo(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
      	idautomezzo bigint;
      	n bigint;
      	r record;
        proc_name varchar; -- END
	begin
		proc_name:='cu.upd_del_automezzo';
		raise notice 'V_J=%', v_j;

		idautomezzo:=v_j->'id_automezzo';

		delete from cu.cu_automezzi where id_automezzo = idautomezzo returning * into r;

		n:=cu_log.upd_record('cu.cu_automezzi',idtransazione,r,'D');
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_del_automezzo(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_del_cu_piano(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_del_cu_piano(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        idnominativostruttura bigint;  
       	idsroot bigint;
		u json;
       	ordmax integer;
      	R_P cu.cu_piani;
      	n bigint;
      	idpiano bigint;
        proc_name varchar; -- END
	begin
		proc_name:='cu.upd_del_cu_piano';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idnominativostruttura:=v_j->'id_nominativo_struttura';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';
		--idcu:=v_j->'id_cu';
		--idcupiano:=v_j->'id_cu_piano';
		--idpercontodi:=v_j->'id_per_conto_di';
		--select coalesce(max(ord),1)+1 into ordmax from cu.cu_piani where id_cu=idcu;
	
		/*delete from cu.cu_piani where id in (select (value::varchar)::bigint
			from json_array_elements(v_j->'id_cu_piano'));
		*/
		
		for idpiano in (select (value::varchar)::bigint
			from json_array_elements(v_j->'id_cu_piano')) loop
				delete from cu.cu_piani where id = idpiano returning * into R_P;
				n:=cu_log.upd_record('cu.cu_piani',idtransazione,R_P,'D');
			end loop;
			
		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_del_cu_piano(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ins_cu_oggetto(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_ins_cu_oggetto(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        idnominativostruttura bigint;  
       	idsroot bigint;
		u json;
       	ordmax integer;
      	idcu bigint;
      	idtipooggetto bigint;
        proc_name varchar; -- END
	begin
		proc_name:='cu.upd_ins_cu_oggetto';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idnominativostruttura:=v_j->'id_nominativo_struttura';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';
		idcu:=v_j->'id_cu';
		idtipooggetto:=v_j->'id_tipo_oggetto';
		select coalesce(max(ord),1)+1 into ordmax from cu.cu_oggetti where id_cu=idcu;

		insert into cu.cu_oggetti values (nextval('cu.cu_id_seq'),idcu,ordmax,idtipooggetto);

		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_ins_cu_oggetto(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ins_cu_piano(json, bigint); Type: FUNCTION; Schema: cu; Owner: postgres
--

CREATE FUNCTION cu.upd_ins_cu_piano(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- START
        idnominativostruttura bigint;  
       	idsroot bigint;
		u json;
       	ordmax integer;
      	idcu bigint;
      	idpiano bigint;
      idpercontodi bigint;
        proc_name varchar; -- END
	begin
		proc_name:='cu.upd_ins_cu_piano';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		return cu.upd_add_cu_piano(v_j,idtransazione);

		idnominativostruttura:=v_j->'id_nominativo_struttura';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';
		idcu:=v_j->'id_cu';
		idpiano:=v_j->'id_piano';
		idpercontodi:=v_j->'id_perconto_di';
		select coalesce(max(ord),1)+1 into ordmax from cu.cu_piani
			where id_cu=idcu;

		insert into cu.cu_piani values (nextval('cu.cu_id_seq'),idcu,idpiano,ordmax,idpercontodi);

		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu.upd_ins_cu_piano(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: check_anagrafiche(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.check_anagrafiche() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	R_SOGG cu_anag.soggetti_fisici;
	j_info_cf json;
	dt varchar;

	begin
	 	--select * from cu_anag.indirizzi where istat_comune is not null and length(istat_comune) = 6 and comune is not null 
		--update cu_anag.indirizzi i
		--	set istat_comune=s.codice_istat,comune=null,stato_prov=null, nazione=null
		--	from (
		select count(*) into total_rows  from cu_anag.indirizzi i
		join conf_ext.vw_comuni_vigenti_attivi c on left(upper(translate(c.denominazione_it,' -''','')),13) =
			    left(upper(translate(i.comune,' -''','')),13)
			    where istat_comune!=c.codice_istat or comune is not null or stato_prov is not null or  nazione is not null;
 		--GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'Indirizzi da bonificare %',total_rows;
 	
 		--set istat_comune =lpad(istat_comune,6,'0')
 		select count(*) into total_rows from cu_anag.indirizzi  where istat_comune is not null and length(istat_comune)<=5;
  		raise notice 'Indirizzi da bonificare %',total_rows;	
 	
		--update cu_anag.indirizzi set comune = null,stato_prov=null, nazione=null
		select count(*) into total_rows from cu_anag.indirizzi
		where istat_comune  in (select codice_istat from conf_ext.vw_comuni_vigenti_attivi vcva)
		and comune is not null or stato_prov is not null or nazione is not null;
 		raise notice 'Indirizzi da bonificare %',total_rows;
 	
		--update cu_anag.indirizzi set comune = null,stato_prov=null, nazione=null,istat_comune =codice_istat
		select count(*) into total_rows from cu_anag.indirizzi i 
		where (comune is not null or stato_prov is not null or nazione is not null)
		and istat_comune
		in (select codice_istat from conf_ext.vw_comuni_vigenti_attivi);
 		raise notice 'Indirizzi da bonificare %',total_rows;
	
		select count(*) into total_rows from cu_anag.indirizzi
		where comune in (select denomtraslitterata from conf_ext.vw_comuni_vigenti_attivi) and istat_comune is null;
 		raise notice 'Indirizzi da bonificare %',	  total_rows;
 	
 		--set nazione=comune,istat_comune=null 
		select count(*) into total_rows from cu_anag.indirizzi
		where nazione is null and istat_comune='000000';
 		raise notice 'Indirizzi da bonificare %',total_rows;
 	
		select count(*) into total_rows
		from cu_anag.indirizzi  where cap='00000';
 		raise notice '	righe modificate %',total_rows;
 	
		select count(*) into total_rows
		from cu_anag.indirizzi where stato_prov='00'; 
 		raise notice 'Indirizzi da bonificare %',total_rows;
 	
		select count(*) into total_rows
		from cu_anag.indirizzi --set stato_prov=null
			where stato_prov is not null and istat_comune is not null and length(istat_comune)=6 and istat_comune !='000000'; 
 		raise notice '	righe modificate %',total_rows;
 	
 		select count(*) into total_rows 
 		from cu_anag.soggetti_fisici
 		where nome!=cu_anag.string_normalize(nome) or cognome!= cu_anag.string_normalize(cognome) or codice_fiscale !=cu_anag.string_normalize(codice_fiscale);
 		raise notice 'Soggetti fisici da bonificare %',total_rows; 	
 		
 		select  count(*)  into total_rows
 		from cu_anag.soggetti_fisici where  sesso !=
	 	CASE WHEN
           ( CASE "substring"(codice_fiscale::text, 10, 1)
                WHEN 'L'::text THEN '0'::text
                WHEN 'M'::text THEN '1'::text
                WHEN 'N'::text THEN '2'::text
                WHEN 'P'::text THEN '3'::text
                WHEN 'Q'::text THEN '4'::text
                WHEN 'R'::text THEN '5'::text
                WHEN 'S'::text THEN '6'::text
                WHEN 'T'::text THEN '7'::text
                WHEN 'U'::text THEN '8'::text
                WHEN 'V'::text THEN '9'::text
                ELSE "substring"(codice_fiscale::text, 10, 1)
            end)::integer > 3 THEN 'F'::varchar
            ELSE 'M'::varchar end or sesso is null;
          raise notice 'Soggetti fisici da bonificare %',total_rows; 	
           
     select  count(*)  into total_rows
     from cu_anag.soggetti_fisici t1 where  comune_nascita !=
(("substring"(t1.codice_fiscale::text, 12, 1) ||
        CASE "substring"(t1.codice_fiscale::text, 13, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            ELSE "substring"(t1.codice_fiscale::text, 13, 1)
        END) ||
        CASE "substring"(t1.codice_fiscale::text, 14, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            ELSE "substring"(t1.codice_fiscale::text, 14, 1)
        END) ||
        CASE "substring"(t1.codice_fiscale::text, 15, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            ELSE "substring"(t1.codice_fiscale::text, 15, 1) end
            or comune_nascita ='ZZZZ' or comune_nascita is null;
          raise notice 'Soggetti fisici da bonificare %',total_rows; 	
         
        select  count(*) into total_rows
       from cu_anag.soggetti_fisici where  length(codice_fiscale)!=16;
           raise notice 'Soggetti fisici da bonificare %',total_rows; 
          
          
      select  count(*) into total_rows
      from cu_anag.imprese sf2 
		where tipo_soggetto='F' and (cod_tipo_impresa!='P' or cod_tipo_impresa is null);
	  raise notice 'Imprese da bonificare %',total_rows; 
	 
      select  count(*) into total_rows
      from cu_anag.imprese sf2 
		where tipo_soggetto!='F' and (cod_tipo_impresa='P' or cod_tipo_impresa is null);
	  raise notice 'Imprese da bonificare %',total_rows; 
          
      select  count(*) into total_rows
      from cu_anag.stabilimento_figure x where id_indirizzo not in (select id from cu_anag.indirizzi i );
	 raise notice 'stabilimento_figure da bonificare %',total_rows; 

	      select  count(*) into total_rows
      from cu_anag.impresa_figure x where id_indirizzo not in (select id from cu_anag.indirizzi i );
	 raise notice 'Imprese_figure da bonificare %',total_rows; 
	
	      select  count(*) into total_rows
      from cu_anag.stabilimento_sedi x where id_indirizzo not in (select id from cu_anag.indirizzi i );
	 raise notice 'stabilimento_sedi da bonificare %',total_rows; 

	      select  count(*) into total_rows
      from cu_anag.impresa_sedi x where id_indirizzo not in (select id from cu_anag.indirizzi i );
	 raise notice 'Imprese_sedi da bonificare %',total_rows;
	
	  select  count(*) into total_rows
      from cu_anag.impresa_figure sf join cu_anag.imprese i on i.id=sf.id_soggetto
      where i.tipo_soggetto is null or  i.tipo_soggetto!='F';
     	 raise notice 'impresa_figure da bonificare %',total_rows; 

      select  count(*) into total_rows
      from cu_anag.stabilimento_figure sf join cu_anag.imprese i on i.id=sf.id_soggetto
      where i.tipo_soggetto is null or  i.tipo_soggetto!='F';
     	 raise notice 'stabilimento_figure da bonificare %',total_rows; 
     
	SELECT count(*)  into total_rows 
	FROM cu_anag.soggetti_fisici
	WHERE codice_fiscale IS NOT NULL and
 	not cu_anag.split_check_cf_bool(codice_fiscale, nome, cognome, data_nascita, sesso, comune_nascita);
	 raise notice 'soggetti_fisici da bonificare %',total_rows; 

	SELECT count(*)  into total_rows from (
 	select piva,count(*) from cu_anag.imprese
 		where piva is not null  and upper_inf(validita)
 	group by 1 having count(*)> 1) a;
 	raise notice 'piva da bonificare %',total_rows; 

 	SELECT count(*)  into total_rows from (
 	select cf,count(*) from cu_anag.imprese
 		where cf is not null and length(cf) != 16 and upper_inf(validita)
 	group by 1 having count(*)> 1) a;
 	raise notice 'cf imprese  da bonificare %',total_rows;  
 
  	SELECT count(*)  into total_rows from (
 	select cf,piva, count(*) from cu_anag.imprese
 		where cf is not null and length(cf) = 16 and upper_inf(validita)
 	group by 1,2 having count(*)> 1) a;
 	raise notice 'cf impresa piva da bonificare %',total_rows; 
 
   	SELECT count(*)  into total_rows from  cu_anag.imprese
 		where cf is not null and length(cf) != 16 and upper_inf(validita)
 		and piva is not null and cod_tipo_impresa='D';
 	raise notice 'cf impresa individuale da bonificare %',total_rows;  
 		 return 0;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.check_anagrafiche() OWNER TO postgres;

--
-- Name: check_cf(character varying); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.check_cf(cf character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
begin
	declare 
        Dispari hstore;
		Pari    hstore;
		Resto   hstore;
        n int;
        
    begin
	    Pari   :='0=>0, 1=>1, 2=>2, 3=>3, 4=>4, 5=>5, 6=>6, 7=>7, 8=>8, 9=>9, A=>0, B=>1, C=>2, D=>3, E=>4, F=>5, G=>6, H=>7, I=>8, J=>9, K=>10, L=>11, M=>12, N=>13, O=>14, P=>15, Q=>16, R=>17, S=>18, T=>19, U=>20, V=>21, W=>22, X=>23, Y=>24, Z=>25';
		Dispari:='0=>1, 1=>0, 2=>5, 3=>7, 4=>9, 5=>13, 6=>15, 7=>17, 8=>19, 9=>21, A=>1, B=>0, C=>5, D=>7, E=>9, F=>13, G=>15, H=>17, I=>19, J=>21, K=>2, L=>4, M=>18, N=>20, O=>11, P=>3, Q=>6, R=>8, S=>12, T=>14, U=>16, V=>10, W=>22, X=>25, Y=>24, Z=>23';
		Resto  :='0=>A, 1=>B, 2=>C, 3=>D, 4=>E, 5=>F, 6=>G, 7=>H, 8=>I, 9=>J, 10=>K, 11=>L, 12=>M, 13=>N, 14=>O, 15=>P, 16=>Q, 17=>R, 18=>S, 19=>T, 20=>U, 21=>V, 22=>W, 23=>X, 24=>Y, 25=>Z';

		cf:=upper(replace(cf,' ',''));
		if cf ~ '^[0-9]{11}$' then return true; end if;
	    --l:= length(cf);
	    --'^(?:[A-Z][AEIOU][AEIOUX]|[AEIOU]X{2}|[B-DF-HJ-NP-TV-Z]{2}[A-Z]){2}(?:[\dLMNP-V]{2}(?:[A-EHLMPR-T](?:[04LQ][1-9MNP-V]|[15MR][\dLMNP-V]|[26NS][0-8LMNP-U])|[DHPS][37PT][0L]|[ACELMRT][37PT][01LM]|[AC-EHLMPR-T][26NS][9V])|(?:[02468LNQSU][048LQU]|[13579MPRTV][26NS])B[26NS][9V])(?:[A-MZ][1-9MNP-V][\dLMNP-V]{2}|[A-M][0L](?:[1-9MNP-V][\dLMNP-V]|[0L][1-9MNP-V]))[A-Z]$'
	    --if cf !~ '^[A-Z]{6}[0-9L-NP-V]{2}[A-EHLMPRST][0-7L-NP-T][0-9L-NP-V][A-Z][0-9L-NP-V]{3}[A-Z]$' then
	    if cf !~ '^(?:[A-Z][AEIOU][AEIOUX]|[AEIOU]X{2}|[B-DF-HJ-NP-TV-Z]{2}[A-Z]){2}(?:[\dLMNP-V]{2}(?:[A-EHLMPR-T](?:[04LQ][1-9MNP-V]|[15MR][\dLMNP-V]|[26NS][0-8LMNP-U])|[DHPS][37PT][0L]|[ACELMRT][37PT][01LM]|[AC-EHLMPR-T][26NS][9V])|(?:[02468LNQSU][048LQU]|[13579MPRTV][26NS])B[26NS][9V])(?:[A-MZ][1-9MNP-V][\dLMNP-V]{2}|[A-M][0L](?:[1-9MNP-V][\dLMNP-V]|[0L][1-9MNP-V]))[A-Z]$' then
	    	return false;
	    end if;
	   	n:=0;
	    for I in 1 .. 15 by 2 loop
	    	--raise notice 'C=% %',substring( cf,I,1),(Dispari-> substring( cf,I,1))::integer;
	    	n:= n + (Dispari-> substring( cf,I,1))::integer;
	    end loop;
	   	for I in 2 .. 15 by 2 loop
	    	--raise notice 'C=% %',substring( cf,I,1),(Pari-> substring( cf,I,1))::integer;
	    	n:= n + (Pari-> substring( cf,I,1))::integer;
	    end loop;
	   	n:= n % 26;
	    --l:=l+1;
	    --raise notice 'N=% Resto->n=% sub=%',n,Resto->(n::varchar),substring( cf,16,1);
	    return Resto->(n::varchar) = substring( cf,16,1);
	end;
END
$_$;


ALTER FUNCTION cu_anag.check_cf(cf character varying) OWNER TO postgres;

--
-- Name: check_esiste_cf(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.check_esiste_cf(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		proc_name varchar;
		ret cu_types.result_type; 
		n integer;
		rt json;
		idstabilimento bigint;
		cf varchar;
		tipoimpresa varchar;
		idsoggettofisico bigint;
		
		begin 
			proc_name:='cu_anag.check_esiste_cf';
			ret.esito:=false;
			cf=v->>'cod_fis';
			tipoimpresa=v->>'tipo_impresa';
			idsoggettofisico=v->'id_soggetto_fisico';
			if tipoimpresa is null or tipoimpresa in ('P','D') then
				select count(*) into n from cu_anag.soggetti_fisici where codice_fiscale=cf and (idsoggettofisico is null or idsoggettofisico!=id);
				if n>0 then
				    ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_esistente');
	    	   		ret.esito:=false;
	    	   		return ret;
				end if;
				if not cu_anag.check_cf(cf) then
				    ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_non_valido');
	    	   		ret.esito:=false;
	    	   		return ret;			
				end if;
				ret.esito:=true;
				rt:=cu_anag.split_cf(cf);
				ret.info:=rt;
			else
				ret.esito:=true;
			end if;

	 		return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.check_esiste_cf(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: check_esiste_impresa(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.check_esiste_impresa(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		proc_name varchar;
		ret cu_types.result_type; 
		n integer;
		rt json;
		idstabilimento bigint;
		codfis varchar;
		partiva varchar;
		idimpresa bigint;
		tipoimpresa varchar;
		begin 
		proc_name:='cu_anag.check_esiste_impresa';
		ret.esito:=false;
		codfis=v->>'cod_fis';
		partiva=v->>'piva';
		partiva:= trim(partiva);
		idimpresa=v->'id_impresa';
		tipoimpresa=v->>'tipo_impresa';
		
		--if tipoimpresa is null or tipoimpresa in ('P','D') then
		
		
			if partiva is not null and partiva != '' then
				select count(*) into n from cu_anag.imprese where partiva=piva and (idimpresa is null or idimpresa!=id) and upper_inf(validita);
				if n>0 then
				    ret:=cu_ui.build_ret(ret,proc_name, 'partita_iva_esistente');
				   	ret.esito:=false;
	    	   		return ret;
				end if;
		
				if partiva ~ '^[0-9].*' then
					partiva='IT'||partiva;
				end if;
				raise notice 'partiva %', partiva;
				if not cu_anag.check_piva(partiva) then
				    ret:=cu_ui.build_ret(ret,proc_name, 'partita_iva_non_valido');
	    	   		ret.esito:=false;
	    	   		return ret;			
				end if;
				ret.esito:=true;
				return ret;
			end if;
			if codfis is not null and codfis != '' then
				if tipoimpresa is null or tipoimpresa in ('P','D') then
					if not cu_anag.check_cf(codfis) then
					    ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_di_persona_o_ditta_individuale_non_valido');
		    	   		ret.esito:=false;
		    	   		return ret;			
					end if;
				else
					select count(*) into n from cu_anag.imprese where cf=codfis and (idimpresa is null or idimpresa!=id) and upper_inf(validita);
					if n>0 then
					    ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_esistente');
					   	ret.esito:=false;
		    	   		return ret;
					end if;
					if not cu_anag.check_piva(codfis) then
					    ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_di_societa_non_valido');
		    	   		ret.esito:=false;
		    	   		return ret;			
					end if;

					ret.esito:=true;
					
					return ret;
				end if;
			end if;
		
				ret.esito:=true;
				ret.msg:=null;
				--ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_valido');-- (AF 20240313	--(GV-20240217)
	    	  	--ret.info:='0';-- (AF 20240313
				ret.info:= null;

	 		return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.check_esiste_impresa(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: check_impresa(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.check_impresa(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_nome varchar;
		v_az_cod_regionale varchar;
		v_piva varchar;
		v_pec varchar;
		v_email varchar;
		v_sdi varchar;
		v_split_payement varchar;
		v_cf varchar;
	    v_fonte varchar;
		v_az_cod_aziendale varchar;
		v_cod_tipo_impresa varchar;
		v_data_inizio_validita timestamp;
	v_data_fine_validita timestamp;
		v_id_asl integer;
		v_validita tsrange;
		idimpresa bigint;
		tiposoggetto varchar;
		act varchar;
		R_IMP cu_anag.imprese;
		n integer;
	
		v_j json;
		begin 
		proc_name:='cu_anag.check_impresa';
		v_j:=v::json;
		v_piva:=cu_anag.string_normalize(v_j->>'piva');
		v_pec:=cu_anag.string_normalize(v_j->>'pec');
		v_email:=cu_anag.string_normalize(v_j->>'email');
		v_nome:=cu_anag.string_normalize(v_j->>'nome');
		v_sdi:=cu_anag.string_normalize_upper(v_j->>'sdi');
		v_sdi:=replace (v_sdi,' ','');
		--v_sdi:=replace (v_sdi,'	','');
		idimpresa:=v_j->'id_impresa';
		v_split_payement:=cu_anag.string_normalize(v_j->>'split_payement');
		v_cf:=cu_anag.string_normalize_upper(v_j->>'cf');
		v_cf:=replace (v_cf,' ','');
		v_cf:=replace (v_cf,'	','');
		v_cod_tipo_impresa:=cu_anag.string_normalize(v_j->>'cod_tipo_impresa');
		v_data_inizio_validita:=v_j->>'data_inizio_validita';
		act:=v->>'action';
		ret.esito:=false;
	

		
		
		if v_j->>'data_fine_validita' is not null and v_j->>'data_fine_validita' !='' then
			v_data_fine_validita:=v_j->>'data_fine_validita';
		end if;
		--v_id_asl:=cu_anag.string_normalize(v_j->>'id_asl');
		v_fonte:=cu_anag.string_normalize(v_j->>'fonte');
		ret.info='0';



		if act is null or act !='delete' then
		
			if v_email is not null and v_email != '' and v_email !~ '.+@.+\..+' then
				ret:=cu_ui.build_ret(ret,proc_name,'e-mail_non_valida');
				return ret;
			end if;
			if v_fonte !~ '^BDN.*' then
				if v_pec is null or v_pec = '' then
					ret:=cu_ui.build_ret(ret,proc_name,'pec_non_specificata');
					return ret;
				end if;
				if  v_pec !~ '.+@.+\..+' then
					ret:=cu_ui.build_ret(ret,proc_name,'pec_non_valida');
					return ret;
				end if;
			end if;
			/*if v_sdi is null or v_sdi = '' then
				ret:=cu_ui.build_ret(ret,proc_name,'sdi_non_specificato');
				return ret;
			end if;*/
		
		
			/*if tiposoggetto is null or tiposoggetto = '' then	
	        		ret:=cu_ui.build_ret(ret,proc_name,'tipo_soggetto_non_inserito');
					return ret;
			end if;*/

			select tipo_soggetto into tiposoggetto from cu_types.vw_cu_tipo_imprese where cod=v_cod_tipo_impresa;
			if tiposoggetto is null then	
        		ret:=cu_ui.build_ret(ret,proc_name,'tipo_soggetto_non presente_in_tabella');
				return ret;
			end if;
		
			/*if v_cod_tipo_impresa = 'Z' then
				if v_sdi is not null and v_sdi != '' then
				    ret:=cu_ui.build_ret(ret,proc_name,'codice_sdi_per_pubblica_amministrazione_solo_per_uffici');
					return ret;
				end if;
			elsif v_cod_tipo_impresa = 'P' then
				if v_sdi is not null and v_sdi != '' then
				    ret:=cu_ui.build_ret(ret,proc_name,'codice_sdi_non_valido_per_persona_fisica');
					return ret;
				end if;
			else*/
			if v_cod_tipo_impresa != 'Z' and v_cod_tipo_impresa != 'P' then
				if v_sdi is not null and length(v_sdi) >0 and length(v_sdi) != 7 then
				    ret:=cu_ui.build_ret(ret,proc_name,'codice_sdi_non_valido_per_imprese_private');
					return ret;
				end if;
			end if;

			if v_cod_tipo_impresa = 'P' or  v_cod_tipo_impresa = 'D' then
				if  v_cf is null or v_cf ='' then
	        		ret:=cu_ui.build_ret(ret,proc_name,'codice_fiscale_non_inserito');
					return ret;
				end if;
				if length(v_cf) != 16 then
	        		ret:=cu_ui.build_ret(ret,proc_name,'codice_fiscale_non_di_persona_fisica');
					return ret;
				end if;
				if not cu_anag.check_cf(v_cf) then
					ret:=cu_ui.build_ret(ret,proc_name,'codice_fiscale_non_valido');
					return ret;
				end if;
			end if;
			if v_cod_tipo_impresa = 'P' then
				if  v_piva is not null and v_piva != '' then
	        		ret:=cu_ui.build_ret(ret,proc_name,'partita_iva_non_ammissibile_per_persona_fisica');
					return ret;
				end if;
				select * into R_IMP from cu_anag.imprese
				where cf=v_cf and tipo_soggetto=v_cod_tipo_impresa
					  and (id != idimpresa or idimpresa is null);
				if R_IMP.id is not null  then
	        		ret:=cu_ui.build_ret(ret,proc_name,'persona_gia_presente');
					return ret;
				end if;
			end if;
			if v_cod_tipo_impresa != 'P'  then

				if  v_piva is null or v_piva ='' then
	        		ret:=cu_ui.build_ret(ret,proc_name,'partita_iva_non_inserita');
					return ret;
				end if;
				if v_piva ~ '^IT' then
					v_piva:=substring(v_piva,3);
				end if;
				if not cu_anag.check_piva(v_piva) then
					ret:=cu_ui.build_ret(ret,proc_name,'partita_iva_non_valida');
					return ret;
				end if;
				select * into R_IMP from cu_anag.imprese where piva=v_piva and upper_inf(validita)
			 		and (id != idimpresa or idimpresa is null);
				if R_IMP.id is not null  then
	        		ret:=cu_ui.build_ret(ret,proc_name,'partita_iva_gia_presente');
					return ret;
				end if;
				if v_cod_tipo_impresa != 'D' and v_cf is not null and v_cf != '' then
					if not cu_anag.check_piva(v_cf) then
						ret:=cu_ui.build_ret(ret,proc_name,'codice_fiscale_per_impresa_non_valido');
						return ret;
					end if;
				end if;
			end if;
			/*select * into R_IMP from cu_anag.imprese where piva=v_piva;
			if R_IMP.id is not null  then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'partita_iva_gia_presente');
				ret.info='0';
				return ret;
			end if;*/
		end if;
		if idimpresa is not null then
			select * into R_IMP from cu_anag.imprese where id=idimpresa;
			
			v_validita := tsrange(coalesce(v_data_inizio_validita,lower(R_IMP.validita)),
			coalesce(v_data_fine_validita,upper(R_IMP.validita)),'[)');
			select count(*) into n from cu_anag.stabilimenti
				where id_impresa=idimpresa and (not (validita && v_validita));
			if n > 0 then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_incompatibile_con_stabilimento');
				ret.info='0';
				return ret;
			end if;
			select count(*) into n from cu_anag.stabilimento_sedi
				where id_stabilimento in (select id from cu_anag.stabilimenti where id_impresa=idimpresa)
					and (not (validita && v_validita));
			if n > 0 then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_incompatibile_con_stabilimento_sedi');
				ret.info='0';
				return ret;
			end if;
			select count(*) into n from cu_anag.stabilimento_figure
				where id_stabilimento in (select id from cu_anag.stabilimenti where id_impresa=idimpresa)
					and (not (validita && v_validita));
			if n > 0 then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_incompatibile_con_stabilimento_figure');
				ret.info='0';
				return ret;
			end if;
			select count(*) into n from cu_anag.linee
				where id_stabilimento in (select id from cu_anag.stabilimenti where id_impresa=idimpresa)
					and (not (validita && v_validita));
						if n > 0 then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_incompatibile_con_linee');
				ret.info='0';
				return ret;
			end if;
		end if;
	
	
	
		ret.esito:=true;	
		return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.check_impresa(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: check_impresa_valida(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.check_impresa_valida(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_id_impresa bigint;
		v_id_stabilimento bigint;
		v_id_asl integer;
		v_validita tsrange;
		R_IMP cu_anag.imprese;
		R_S cu_anag.stabilimenti;
		n integer;
		np integer;
		ns integer;
		begin 
			proc_name:='cu_anag.check_impresa_valida';
			raise notice 'v=%',v;
			v_id_impresa:=v->'id_impresa';

			select count(*) into np from (
				select id from cu_anag.vw_impresa_figure vif where id_impresa =v_id_impresa and 
							validita @> current_timestamp::timestamp
							and cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE'
			) a;
			raise notice 'NP %',np;
			select count(*) into ns from (
				select id from cu_anag.vw_impresa_sedi vif where id_impresa =v_id_impresa and 
							validita @> current_timestamp::timestamp
							and cod_tipo_sede ilike 'SL'
			) a;
			raise notice 'NS %',ns;
			if np> 0 and ns>0 then
				ret.esito:= true;
			else
				ret.esito := false;
			end if;
			if np > 0 then
				R_S.verificato:=true;
			else
				R_S.verificato:=false;
			end if;
			return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.check_impresa_valida(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: check_piva(character varying); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.check_piva(piva character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
	

DECLARE

x int;y int;z int;k int;t int;i int;

BEGIN
--return true;
piva:=upper(replace(piva,' ',''));
piva:=upper(replace(piva,'	',''));

/*if piva !~ '^[A-Z][A-Z]' then

return false;

end if;*/

--IF piva ~ '^[0-9]{11}$' then
IF piva ~ '^[0-9]' then
	piva:='IT'||piva;
end if;
raise notice 'PIVA %',piva;
--piva='IT'||piva;
if piva  ~ '^[A-Z]{6}.{9}' then /* CASO codice fiscale di persona fisica */
	return false;
end if;
if piva ~ '^IT' THEN
	raise notice 'PIVA 1 %',piva;

	IF piva !~ '^IT[0-9]{11}$' then
		raise notice 'PIVA 2 %',piva;
		return false;
	END IF;

	raise notice 'PIVA 3 %',piva;

	x:=0;y:=0;z:=0;
	
	for I in 3 .. 12 by 2 loop
	
	x:= x + substring( piva,I,1)::integer;
	
	end loop;
	
	for I in 4 .. 12 by 2 loop
	
	k:=substring( piva,I,1)::integer;
	
	y:= y + k *2;
	
	IF (k>= 5) THEN z:=z+1; END IF;
	
	end loop;
	
	t:= (x+y+z) % 10;
	
	return substring( piva,13,1)::integer = (10-t) % 10;

end if;

RETURN TRUE;



end;

$_$;


ALTER FUNCTION cu_anag.check_piva(piva character varying) OWNER TO postgres;

--
-- Name: check_pratica(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.check_pratica(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		proc_name varchar;
		ret cu_types.result_type; 
		n integer;
		rt json;
		v_n_pratica varchar;
		v_id_stabilimento bigint;
		begin 
			proc_name:='cu_anag.check_pratica';
			ret.esito:=false;	
			v_n_pratica:=v->>'n_pratica';
			v_id_stabilimento:=v->>'id_stabilimento';
			
			select count(*) into n from cu_anag.vw_pratiche p
			where p.n_pratica = v_n_pratica;
			
			if n != 1 then
				ret:=cu_ui.build_ret(ret,proc_name,'pratica_non_esiste');
				return ret;
			end if;

			if v_id_stabilimento is not null then
				select count(*) into n from cu_anag.vw_pratiche p
				where p.n_pratica = v_n_pratica and p.id_stabilimento = v_id_stabilimento;
				
				if n != 1 then
					ret:=cu_ui.build_ret(ret,proc_name,'pratica_non_associata_allo_stabilimento_corrente');
					return ret;
				end if;

				select count(*) into n from cu_anag.vw_pratiche p
				where p.n_pratica = v_n_pratica
				and ( (p.cod_tipo_pratica = 'NIA' and p.id_stabilimento = v_id_stabilimento) or 
					  (p.cod_tipo_pratica = 'VIA' and p.id_stabilimento is not null) )
				and p.cod_stato_pratica = '2';
				
				if n != 1 then
					ret:=cu_ui.build_ret(ret,proc_name,'pratica_via_non_valida');
					return ret;
				end if;

			else
				select count(*) into n from cu_anag.vw_pratiche p
				where p.n_pratica = v_n_pratica
				and (p.cod_tipo_pratica = 'NIA' and p.id_stabilimento is null)
				and p.cod_stato_pratica = '2';
				
				if n != 1 then
					ret:=cu_ui.build_ret(ret,proc_name,'pratica_nia_non_valida');
					return ret;
				end if;
			end if;

			ret.esito:=true;
			ret.msg:=null;
			ret.info:= null;

	 		return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.check_pratica(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: check_stabilimento(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.check_stabilimento(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_id_impresa bigint;
		v_nome varchar;
		v_cod_regionale varchar;
		v_cod_nazionale varchar;
		v_cod_tipologia_struttura varchar;
		v_pec varchar;
		v_telefono varchar;
		v_categoria_rischio bigint;
		idindirizzo bigint;
		v_data_fine_validita timestamp;
		v_j json;
		v_id_tipologia_struttura bigint;
		v_id_stabilimento bigint;
		v_id_asl integer;
		v_validita tsrange;
	    v_validita_a tsrange;
		R_IMP cu_anag.imprese;
		R_S cu_anag.stabilimenti;
		R_TS cu_types.vw_tipologie_struttura ;
		n integer;
		begin 
			proc_name:='cu_anag.check_stabilimento';
			v_j:=v::json;
			v_id_impresa:=v_j->'id_impresa';
			v_id_stabilimento:=v_j->'id_stabilimento';
			v_cod_regionale:=v_j->>'sd_cod_regionale';
			v_nome:=v_j->>'nome';
			--v_cod_tipologia_struttura:=v_j->>'cod_tipologia_struttura';
			v_cod_nazionale:=v_j->>'cod_nazionale';
			v_categoria_rischio:=v_j->>'categoria_rischio';
			if v_j->>'data_fine_validita' != '' then
				v_data_fine_validita:=v_j->>'data_fine_validita';
			end if;
			--v_id_tipologia_struttura:=v_j->>'id_tipologia_struttura';
			--v_id_asl:=v_j->'id_asl';
			v_pec:=v_j->>'pec';
			v_telefono:=v_j->>'telefono';

			/*select * into R_TS from cu_types.vw_tipologie_struttura vts where id=v_id_tipologia_struttura;
			if R_TS.id is null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'identificativo_tipologia_struttura_non_valido');
				ret.info='0';
				return ret;
			end if;*/
			raise notice 'v=%',v_j;
			/*if upper(R_TS.codice) != 'UTENTE' then
				if ((v_cod_regionale is null or v_cod_regionale='') and
				    (v_cod_nazionale    is null or v_cod_nazionale='')) then
				    ret.esito:=false;	
	        		ret:=cu_ui.build_ret(ret,proc_name,'non_presente_codice_nazionale_o_regionale');
					ret.info='0';
					return ret;
				end if;
			end if; */
			if v_cod_regionale is not null and  v_cod_regionale != '' then
				select count(*) into n from cu_anag.stabilimenti
				where cod_regionale=v_cod_regionale and 
					  (id != v_id_stabilimento or v_id_stabilimento is null);
				if n>0 then
				    ret.esito:=false;	
	        		ret:=cu_ui.build_ret(ret,proc_name,'codice_regionale_gia_presente');
					ret.info='0';
					return ret;
				end if;
			end if;
		

		/* ---------- PER ANTONIO
		   if not R_TS.modificabile  then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'identificativo_tipologia_struttura_non_accettabile');
				ret.info='0';
				return ret;
			end if;
			
			****/
		
			select * into R_IMP from cu_anag.imprese where id=v_id_impresa;
			--v_validita:=tsrange(v_data_inizio_validita,upper(R_IMP.validita),'[)');
			 if ((not upper_inf(R_IMP.validita)) and upper(R_IMP.validita) < v_data_fine_validita) then
				ret.esito:=false;	
	    		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_impresa');
				ret.info='0';
				return ret;
			end if;	
			if R_IMP.cod_tipo_impresa='Z' then
				/*if v_sdi is null or length(v_sdi) != 6 then
				    ret:=cu_ui.build_ret(ret,proc_name,'codice_sdi_non_valido_per_pubblica_amministrazione');
					return ret;
				end if; */
			end if;
		
		
			if v_id_stabilimento is not null then
				select * into R_S from cu_anag.stabilimenti s where id=v_id_stabilimento;
				
				select count(*) into n from cu_anag.stabilimento_sedi    where id_stabilimento=R_S.id and (not (validita && v_validita));
				if n > 0 then
					ret.esito:=false;	
	        		ret:=cu_ui.build_ret(ret,proc_name,'validita_incompatibile_con_sedi_stabilimento');
					ret.info='0';
					return ret;
				end if;
				select count(*) into n from cu_anag.stabilimento_figure  where id_stabilimento=R_S.id and (not (validita && v_validita));
				if n > 0 then
					ret.esito:=false;	
	        		ret:=cu_ui.build_ret(ret,proc_name,'validita_incompatibile_con_figure_stabilimento');
					ret.info='0';
					return ret;
				end if;
				select count(*) into n from cu_anag.linee                where id_stabilimento=R_S.id and (not (validita && v_validita));
				if n > 0 then
					ret.esito:=false;	
	        		ret:=cu_ui.build_ret(ret,proc_name,'validita_incompatibile_con_linee_stabilimento');
					ret.info='0';
					return ret;
				end if;
			end if;
			ret.esito:=true;	
			return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.check_stabilimento(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: check_stabilimento_deb(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.check_stabilimento_deb(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_id_impresa bigint;
		v_nome varchar;
		v_cod_regionale varchar;
		v_cod_nazionale varchar;
		v_cod_tipologia_struttura varchar;
		v_pec varchar;
		v_telefono varchar;
		v_categoria_rischio bigint;
		idindirizzo bigint;
		v_data_inizio_validita timestamp;
		v_j json;
		v_id_tipologia_struttura bigint;
		v_id_stabilimento bigint;
		v_id_asl integer;
		v_validita tsrange;
		R_IMP cu_anag.imprese;
		R_STAB cu_anag.stabilimenti;
		R_S cu_anag.stabilimenti;
		R_TS cu_types.vw_tipologie_struttura ;
		n integer;
		begin 
			proc_name:='cu_anag.check_stabilimento';
			v_j:=v::json;
			v_id_impresa:=v_j->'id_impresa';
			v_id_stabilimento:=v_j->'id_stabilimento';
			v_cod_regionale:=v_j->>'sd_cod_regionale';
			v_nome:=v_j->>'nome';
			--v_cod_tipologia_struttura:=v_j->>'cod_tipologia_struttura';
			v_cod_nazionale:=v_j->>'cod_nazionale';
			v_categoria_rischio:=v_j->>'categoria_rischio';
			v_data_inizio_validita:=v_j->>'data_inizio_validita';
			--v_id_tipologia_struttura:=v_j->>'id_tipologia_struttura';
			--v_id_asl:=v_j->'id_asl';
			v_pec:=v_j->>'pec';
			v_telefono:=v_j->>'telefono';

			/*select * into R_TS from cu_types.vw_tipologie_struttura vts where id=v_id_tipologia_struttura;
			if R_TS.id is null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'identificativo_tipologia_struttura_non_valido');
				ret.info='0';
				return ret;
			end if;*/
			raise notice 'v=%',v_j;
			/*if upper(R_TS.codice) != 'UTENTE' then
				if ((v_cod_regionale is null or v_cod_regionale='') and
				    (v_cod_nazionale    is null or v_cod_nazionale='')) then
				    ret.esito:=false;	
	        		ret:=cu_ui.build_ret(ret,proc_name,'non_presente_codice_nazionale_o_regionale');
					ret.info='0';
					return ret;
				end if;
			end if; */
			if v_cod_regionale is not null and  v_cod_regionale != '' then
				select count(*) into n from cu_anag.stabilimenti
				where cod_regionale=v_cod_regionale and 
					  (id != v_id_stabilimento or v_id_stabilimento is null);
				if n>0 then
				    ret.esito:=false;	
	        		ret:=cu_ui.build_ret(ret,proc_name,'codice_regionale_gia_presente');
					ret.info='0';
					return ret;
				end if;
			end if;
		

		/* ---------- PER ANTONIO
		   if not R_TS.modificabile  then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'identificativo_tipologia_struttura_non_accettabile');
				ret.info='0';
				return ret;
			end if;
			
			****/
		select * into R_STAB from cu_anag.stabilimenti where id=v_id_stabilimento;
		
			select * into R_IMP from cu_anag.imprese where id=R_STAB.id_impresa;
			v_validita:=tsrange(v_data_inizio_validita,upper(R_IMP.validita),'[)');
		raise notice 'IMP % v_%',R_IMP.validita,v_validita;
			if ((not upper_inf(R_IMP.validita)) and upper(R_IMP.validita) < v_validita) then
				ret.esito:=false;	
	    		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_impresa');
				ret.info='0';
				return ret;
			end if;	
			if R_IMP.cod_tipo_impresa='Z' then
				/*if v_sdi is null or length(v_sdi) != 6 then
				    ret:=cu_ui.build_ret(ret,proc_name,'codice_sdi_non_valido_per_pubblica_amministrazione');
					return ret;
				end if; */
			end if;
		
		
			if v_id_stabilimento is not null then
				select * into R_S from cu_anag.stabilimenti s where id=v_id_stabilimento;
				
				select count(*) into n from cu_anag.stabilimento_sedi    where id_stabilimento=R_S.id and (not (validita && v_validita));
				if n > 0 then
					ret.esito:=false;	
	        		ret:=cu_ui.build_ret(ret,proc_name,'validita_incompatibile_con_sedi_stabilimento');
					ret.info='0';
					return ret;
				end if;
				select count(*) into n from cu_anag.stabilimento_figure  where id_stabilimento=R_S.id and (not (validita && v_validita));
				if n > 0 then
					ret.esito:=false;	
	        		ret:=cu_ui.build_ret(ret,proc_name,'validita_incompatibile_con_figure_stabilimento');
					ret.info='0';
					return ret;
				end if;
				select count(*) into n from cu_anag.linee                where id_stabilimento=R_S.id and (not (validita && v_validita));
				if n > 0 then
					ret.esito:=false;	
	        		ret:=cu_ui.build_ret(ret,proc_name,'validita_incompatibile_con_linee_stabilimento');
					ret.info='0';
					return ret;
				end if;
			end if;
			ret.esito:=true;	
			return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.check_stabilimento_deb(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: check_stabilimento_valido(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.check_stabilimento_valido(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_id_impresa bigint;
		v_id_stabilimento bigint;
		v_id_asl integer;
		v_validita tsrange;
		R_TS cu_types.tipologie_struttura;
		R_S cu_anag.stabilimenti;
		n integer;
		np integer;
		ns integer;
		begin 
			proc_name:='cu_anag.check_stabilimento_valido';
			raise notice 'v=%',v;
			--v_id_impresa:=v->'id_impresa';
			v_id_stabilimento:=v->'id_stabilimento';
			if v_id_stabilimento is null then
				ret.esito := false;
				return ret;
			end if;

			select * into R_S from cu_anag.stabilimenti s where id=v_id_stabilimento;
			if R_S.fonte ilike 'BDN%' then
				ret.esito:= true;
				return ret;
			end if;

			select * into R_TS from cu_types.tipologie_struttura where id=R_S.id_tipologia_struttura;

			if not R_TS.richiede_legale then 
				np:=1;
			else 			

				select count(*) into np from (
					select id from cu_anag.vw_impresa_figure vif where id_impresa =R_S.id_impresa and 
								validita @> current_timestamp::timestamp
								and cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE'
					union
					select id from cu_anag.vw_stabilimento_figure vif where id_stabilimento =v_id_stabilimento and 
								validita @> current_timestamp::timestamp
								and cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE'
				) a;

			end if;
			
raise notice 'NP %',np;


			select count(*) into ns from (
				select id from cu_anag.vw_impresa_sedi vif where id_impresa =R_S.id_impresa and 
							validita @> current_timestamp::timestamp
							and cod_tipo_sede ilike 'SL'
				union
				select id from cu_anag.vw_stabilimento_sedi vif where id_stabilimento =v_id_stabilimento and 
							validita @> current_timestamp::timestamp
							and cod_tipo_sede ilike 'SL'
			) a;
			raise notice 'NS %',ns;
			if np> 0 and ns>0 then
				ret.esito:= true;
			else
				ret.esito := false;
			end if;
			/*if np > 0 then
				R_S.verificato:=true;
			else
				R_S.verificato:=false;
			end if;*/
			return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.check_stabilimento_valido(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: check_stabilimento_valido_bool(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.check_stabilimento_valido_bool(v json, idtransazione bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
	begin
			ret:=cu_anag.check_stabilimento_valido(v, idtransazione);
			return ret.esito;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.check_stabilimento_valido_bool(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_automezzi_by_sel(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_automezzi_by_sel(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_marca varchar;
	v_modello varchar;
	v_targa varchar;
	v_limite int;
	begin
		proc_name:='cu_anag.get_cu_automezzi_by_sel';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		--rag_sociale = replace('%'||trim(coalesce(v->>'rag_sociale',''))||'%';
		v_marca =         replace('%'||cu_anag.string_normalize_upper(v->>'marca')||'%',' ','%');
		v_modello = replace('%'||cu_anag.string_normalize_upper(v->>'modello')||'%',' ','%');
		v_targa = replace('%'||cu_anag.string_normalize_upper(v->>'targa')||'%',' ','%');
	
	
	
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
	
		if v->>'limite' is not null then
		v_limite:=v->>'limite';
		end if;
	
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
			select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_automezzi va 
			where  (marca ilike v_marca or (marca is null and v_marca = '%%'))
			and (modello ilike v_modello or (modello is null and v_modello = '%%')) 
			and (targa ilike v_targa or (targa is null and v_targa = '%%')) 
			order by targa limit v_limite)  g;
	
	
	
		raise notice 'ARRAY LEN %',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'automezzi_non_trovati');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_automezzi_by_sel(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_automezzo_singolo(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_automezzo_singolo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_id_automezzo bigint;
	v_responsabile bool;
	idasl bigint;
	begin
		proc_name:='cu_anag.get_cu_automezzo_singolo';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		--rag_sociale = replace('%'||trim(coalesce(v->>'rag_sociale',''))||'%';
		v_id_automezzo:=v->'id_automezzo';
		idasl:=v->'user_info'->'id_asl';
		v_responsabile:=v->'user_info'->'responsabile';
	
	
	
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
	
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
			select json_agg(row_to_json(g.*)) into rt from (
			select va.*,
			--(idasl=-1 or idasl=id_asl) and 
			upper_inf(validita) and v_responsabile is true as automezzo_modificabile,
			--(idasl=-1 or idasl=id_asl) and 
			upper_inf(validita) and v_responsabile is true as stabilimento_modificabile
			from cu_anag.vw_automezzi va 
			where va.id_automezzo = v_id_automezzo)  g;
	
	
	
		raise notice 'ARRAY LEN %',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'automezzo_non_trovato');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_automezzo_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_automezzo_stabilimento_singolo(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_automezzo_stabilimento_singolo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_id_stabilimento_automezzi bigint;
	begin
		proc_name:='cu_anag.get_cu_automezzo_singolo';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		--rag_sociale = replace('%'||trim(coalesce(v->>'rag_sociale',''))||'%';
		v_id_stabilimento_automezzi:=v->'id_stabilimento_automezzi';
	
	
	
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
	
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
			select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_stabilimento_automezzi vsa  
			where vsa.id_stabilimento_automezzi = v_id_stabilimento_automezzi)  g;
	
	
	
		raise notice 'ARRAY LEN %',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'automezzo_non_trovato');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_automezzo_stabilimento_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_effettuati(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_effettuati(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		proc_name varchar;
		ret cu_types.result_type; 
		rt json;
		idstabilimento bigint;
		begin 
			proc_name:='cu_anag.get_cu_effettuati';
			ret.esito:=false;
			idstabilimento=v->'id_stabilimento';
		select json_agg(row_to_json(g.*)) into rt from (
			select dt,descr_tecnica,'('||string_agg(c.alias,', ')||')' alias
			FROM cu.vw_cu_piani c
		    where id_az_sede=idstabilimento and chiuso 
		    and dt between current_timestamp -interval '2 years' and current_timestamp +interval '1 years' --dt < R_CU.dt
		    group by dt,descr_tecnica,c.id_cu
		   ) g;
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		--if json_array_length(rt) is null then
    	--   ret:=cu_ui.build_ret(ret,proc_name, 'cu_effettuati_non_trovati');
    	--   ret.esito:=false;
    	--else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		--end if;
	 	return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_effettuati(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_impresa_singolo(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_impresa_singolo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idimpresa bigint;
	v_responsabile bool;
	n_pratiche bigint;

	begin
		proc_name:='cu_anag.get_cu_impresa_singolo';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		ret.esito:=false;
	
		idimpresa := v->>'id_impresa';
		v_responsabile:=v->'user_info'->'responsabile';
	
		select count(*) into n_pratiche from cu_anag.vw_imprese_all i 
		join cu_anag.vw_pratiche p on p.id_impresa = i.id_impresa 
		where i.id_impresa =idimpresa and p.descr_stato_pratica = 'Aperto';
		
		select json_agg(row_to_json(a.*)) into rt   from (
			select *,
			v_responsabile and upper_inf(validita) and n_pratiche > 0 as impresa_modificabile,
			v_responsabile and upper_inf(validita) and n_pratiche > 0 as stabilimenti_modificabili,
			v_responsabile and upper_inf(validita) and n_pratiche > 0 as sedi_modificabili,
			v_responsabile and upper_inf(validita) and n_pratiche > 0 as figure_modificabili
			
			from cu_anag.vw_imprese_all where id_impresa = idimpresa) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_cu_impresa_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_imprese(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_imprese(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CO cu.vw_cu_oggetti%ROWTYPE;
	rt json;
	idcuoggetto bigint;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu.get_cu_imprese';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		ret.esito:=false;
		
		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu_anag.vw_imprese_all limit 1000) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_cu_imprese(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_imprese_by_sel(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_imprese_by_sel(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	rag_sociale varchar;
	p_iva varchar;
	comune varchar;
	v_cf varchar;
	v_limite int;
	v_vigenti boolean;
	begin
		proc_name:='cu_anag.get_cu_imprese_by_sel';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		rag_sociale = replace('%'||cu_anag.string_normalize(v->>'rag_sociale')||'%',' ','%');
		p_iva = '%'||cu_anag.string_normalize(v->>'p_iva')||'%';
		--comune = coalesce(v->>'comune','')||'%';
		v_cf = '%'||cu_anag.string_normalize(v->>'cf')||'%';
		v_vigenti = v->>'vigenti'; 
		
		if v->>'limite' is not null then
		v_limite:=v->>'limite';
		end if;
	
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		raise notice 'P IVA %',p_iva;
		raise notice 'rag_sociale %',rag_sociale;
		raise notice 'v_cf %',v_cf;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		/*
		if rag_sociale = '%%' and p_iva = '%%' and v_cf = '%%'
		then 
			select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_imprese_count order by fine_validita desc, nome asc limit v_limite)  g;
		
		else
		*/
			select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_imprese_count
			where (nome ilike rag_sociale or (nome is null and rag_sociale = '%%'))
				  and (piva ilike p_iva or (piva is null and p_iva = '%%')) 
				  /*and (comune_leg ilike comune)*/
				  and (v_vigenti = false or v_vigenti is null or (validita @> LOCALTIMESTAMP))
				  and (cf ilike v_cf or (cf is null and v_cf = '%%')) 
				  order by fine_validita desc, nome asc limit v_limite)  g;
		--end if;

	
	
		raise notice 'LENGTH %',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'imprese_non_trovate');
    	else
    		/*
    		if json_array_length(rt) = 1000 then
	    	    ret:=cu_ui.build_ret(ret,proc_name, 'troppe_imprese_visualizzazione_parziale');
	    	end if;
	    	*/
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_imprese_by_sel(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_imprese_figura_singolo(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_imprese_figura_singolo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_id_figura bigint;
	v_responsabile bool;
	n_pratiche bigint;

	begin
		proc_name:='cu_anag.get_cu_imprese_figura_singolo';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		v_responsabile:=v->'user_info'->'responsabile';
		v_id_figura = v->'id_figura';
		
		select count(*) into n_pratiche from cu_anag.vw_imprese_all i 
		join cu_anag.vw_pratiche p on p.id_impresa = i.id_impresa 
		where i.id_impresa =(select id_impresa from cu_anag.vw_impresa_figure_all where id_impresa_figura = v_id_figura) 
		and p.descr_stato_pratica = 'Aperto';
	
		select json_agg(row_to_json(g.*)) into rt from (
			select *
			,v_responsabile and upper_inf(validita) and n_pratiche > 0 as figure_modificabili 
			from cu_anag.vw_impresa_figure_all where id_impresa_figura = v_id_figura)  g;
		
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'figura_non_trovata');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_imprese_figura_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_imprese_figure(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_imprese_figure(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_id_impresa bigint;
	n_valide int = 0;
	begin
		proc_name:='cu_anag.get_cu_imprese_figure';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		v_id_impresa = v->'id_impresa';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_impresa_figure_all where id_impresa = v_id_impresa)  g;
		
		/*select count(*) into n_valide from cu_anag.vw_impresa_figure_all 
		where id_impresa = v_id_impresa;
		--and upper(validita) > LOCALTIMESTAMP; */
		
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		/*
		if json_array_length(rt) is null /*or n_valide = 0 */ then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'figure_non_trovate');
		end if;
	-- GV 2024-03-04 - Per rimuovere il messaggio a video*/
	
		ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';	--2024-03-04
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_imprese_figure(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_imprese_sede_singolo(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_imprese_sede_singolo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_id_sede bigint;
	v_responsabile bool;
	n_pratiche bigint;

	begin
		proc_name:='cu_anag.get_cu_imprese_sede_singolo';
		v_id_sede = v->'id_sede';
		v_responsabile:=v->'user_info'->'responsabile';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		
		select count(*) into n_pratiche from cu_anag.vw_imprese_all i 
		join cu_anag.vw_pratiche p on p.id_impresa = i.id_impresa 
		where i.id_impresa =(select id_impresa from cu_anag.vw_impresa_sedi_all where id_impresa_sedi = v_id_sede) 
		and p.descr_stato_pratica = 'Aperto';
	
		select json_agg(row_to_json(g.*)) into rt from (
			select *
			,v_responsabile and upper_inf(validita) and n_pratiche > 0 as sedi_modificabili 
		    from cu_anag.vw_impresa_sedi_all where id_impresa_sedi = v_id_sede)  g;
		
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'sede_non_trovata');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_imprese_sede_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_imprese_sedi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_imprese_sedi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_id_impresa bigint;
	n_valide int = 0;
	begin
		proc_name:='cu_anag.get_cu_imprese_sedi';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		v_id_impresa = v->'id_impresa';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_impresa_sedi_all where id_impresa = v_id_impresa)  g;
		
		/*select count(*) into n_valide from cu_anag.vw_stabilimento_sedi_all 
		where id_stabilimento = v_id_stabilimento
		and validita @> LOCALTIMESTAMP;*/
	
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		/*if json_array_length(rt) is null /*or n_valide = 0*/ then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'sedi_non_trovate');
		end if;
		--GV 2024-03-04 - Per rimuovere il messaggio a video*/
	
	
	
		ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';	--2024-03-04
	 	return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_imprese_sedi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_indirizzi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_indirizzi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin 
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	v_j json;
	idindirizzo bigint;
	begin
		proc_name:='cu_anag.get_cu_indirizzi';
		v_j:=v::json;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		idindirizzo:=v_j->'id_indirizzo';
		ret.esito:=false;
	
		raise notice 'id_indirizzo %',idindirizzo;
		select json_agg(row_to_json(a.*)) into rt from (
			select * from cu_anag.vw_indirizzi vi where vi.id_indirizzo = idindirizzo) a ;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'indirizzi_non_trovati');
    	end if;

	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_cu_indirizzi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_linee_by_sel(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_linee_by_sel(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	
	v_comune varchar;
	v_id_asl int;
	v_id_tipo_linea int[];
	v_limite int;
	v_denominazione_stabilimento varchar;
	begin
		proc_name:='cu_anag.get_cu_linee_by_sel';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
	
		v_comune = replace('%'||cu_anag.string_normalize(v->>'comune')||'%',' ','%');
		v_denominazione_stabilimento = replace('%'||cu_anag.string_normalize(v->>'denominazione_stabilimento')||'%',' ','%');
	
		/*
		if v->>'id_tipo_linea' is not null then
		v_id_tipo_linea:=json_array_elements(v->'id_tipo_linea');
		end if;
		*/
	
		if v->>'id_asl' is not null then
		v_id_asl:=v->>'id_asl';
		end if;
	
		if v->>'limite' is not null then
		v_limite:=v->>'limite';
		end if;
raise notice 'DENOM=%',v_denominazione_stabilimento;
		
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
	
			select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_linee_all l
			join cu_anag.vw_stabilimenti_all s on s.id_stabilimento = l.id_stabilimento
			where (s.comune ilike v_comune or (s.comune is null and v_comune = '%%')) 
			and (id_tipo_linea in (select (value::varchar)::bigint from json_array_elements(v->'id_tipo_linea')) or json_array_length(v->'id_tipo_linea')=0)
			and (l.id_asl = v_id_asl or (v_id_asl is null))
			and (s.nome ilike v_denominazione_stabilimento or (s.nome is null and v_denominazione_stabilimento = '%%')) 
			order by nome limit v_limite)  g;
	
		raise notice 'ARRAY LEN %',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'linee_non_trovate');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_linee_by_sel(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_linee_stabilimenti(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_linee_stabilimenti(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	rt_valide json;
	idstrutturaroot bigint;
	v_id_stabilimento bigint;
	n_valide int = 0;
	begin
		proc_name:='cu_anag.get_cu_linee_stabilimenti';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		v_id_stabilimento = v->'id_stabilimento';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (
			select *
			,(select to_char(inizio_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as inizio_validita_str
			,(select to_char(fine_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as fine_validita_str
			,(select to_char(data_ultima_visita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as data_ultima_visita_str
			from cu_anag.vw_linee_all where id_stabilimento = v_id_stabilimento
		order by pr desc)  g;
		
		select json_agg(row_to_json(g.*)) into rt_valide from( 
			select *
			,(select to_char(inizio_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as inizio_validita_str
			,(select to_char(fine_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as fine_validita_str
			,(select to_char(data_ultima_visita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as data_ultima_visita_str
			from cu_anag.vw_linee_all 
			where id_stabilimento = v_id_stabilimento
		and validita @> LOCALTIMESTAMP) g;
	
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		/*if json_array_length(rt) is null or n_valide = 0 then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'linee_non_trovate');	
		end if;
		--GV 2024-03-04 - Per rimuovere il messaggio a video*/
	
		--ret.info:='{"dati":'||rt::varchar||'}';
		ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||
				  ',"dati_validi":'||coalesce(rt_valide::varchar,'[]')
				  ||'}';	--2024-04-12

	 	return ret;
	end;


		
	
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_linee_stabilimenti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_pratica_singolo(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_pratica_singolo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idpratica bigint;
	v_responsabile bool;

	begin
		proc_name:='cu_anag.get_cu_pratica_singolo';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		ret.esito:=false;
	
		v_responsabile:=v->'user_info'->'responsabile';
		idpratica := v->>'id_pratica';
		
		select json_agg(row_to_json(a.*)) into rt   from (
			select *,
			v_responsabile is true as pratica_modificabile 
			from cu_anag.vw_pratiche where id_pratica = idpratica) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_cu_pratica_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_pratica_storico(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_pratica_storico(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idpratica bigint;

	begin
		proc_name:='cu_anag.get_cu_pratica_storico';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		ret.esito:=false;
	
		idpratica := v->>'id_pratica';
		
		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu_anag.vw_storico_pratiche where id_pratica = idpratica order by dt desc) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||coalesce(rt::varchar, '[]')||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_cu_pratica_storico(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_pratiche_by_sel(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_pratiche_by_sel(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_cod_regionale varchar;
	v_denominazione_stabilimento varchar;
	v_n_pratica varchar;
	v_id_tipo_pratica int;
	v_limite int;
	begin
		proc_name:='cu_anag.get_cu_pratiche_by_sel';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
	
		v_cod_regionale = '%'||cu_anag.string_normalize(v->>'cod_regionale')||'%';
		v_denominazione_stabilimento = replace('%'||cu_anag.string_normalize(v->>'denominazione_stabilimento')||'%',' ','%');
		v_n_pratica = '%'||cu_anag.string_normalize(v->>'n_pratica')||'%';
				
		if v->>'id_tipo_pratiche' is not null then
		v_id_tipo_pratica:=v->>'id_tipo_pratiche';
		end if;	

		if v->>'limite' is not null then
		v_limite:=v->>'limite';
		end if;
	
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
	
			select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_pratiche
			where (nome ilike v_denominazione_stabilimento or (nome is null and v_denominazione_stabilimento = '%%'))
				  and (cod_regionale_pratica ilike v_cod_regionale or (cod_regionale_pratica is null and v_cod_regionale = '%%')) 
				  and (n_pratica ilike v_n_pratica or (n_pratica is null and v_n_pratica = '%%'))
				  and (id_tipo_pratica = v_id_tipo_pratica or (v_id_tipo_pratica is null))
				  order by id_pratica desc, nome asc limit v_limite)  g;
		
	
	
		raise notice 'LENGTH %',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'pratiche_non_trovate');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_pratiche_by_sel(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_pratiche_by_stabilimento(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_pratiche_by_stabilimento(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_id_stabilimento int;
	begin
		proc_name:='cu_anag.get_cu_pratiche_by_sel';
		idstrutturaroot=v->'user_info'->'id_struttura_root';

		v_id_stabilimento:=v->>'id_stabilimento';
	
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
	
			select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_pratiche
			where id_stabilimento = v_id_stabilimento)  g;
		
	
	
		raise notice 'LENGTH %',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'pratiche_non_trovate');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_pratiche_by_stabilimento(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_programmati(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_programmati(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		proc_name varchar;
		ret cu_types.result_type; 
		rt json;
		idstabilimento bigint;
		begin 
			proc_name:='cu_anag.get_cu_programmati';
			ret.esito:=false;
			idstabilimento=v->'id_stabilimento';
		select json_agg(row_to_json(g.*)) into rt from (
			 /*select dt,descr_tecnica,'('||string_agg(c.alias,', ')||')' alias
			 FROM cu.vw_cu_piani c 
			 where id_az_sede=idstabilimento and not chiuso
			 and dt between current_timestamp -interval '2 years' and current_timestamp +interval '1 years' --and dt >= R_CU.dt  and c.id != R_CU.id 
			 group by dt,descr_tecnica,c.id_cu*/

--2024-08-19		#12243
			   select inizio /*date_trunc('day',inizio)*/ as dt, descr_tipo_evento as descr_tecnica, 
				'('||string_agg(c.alias,', ')||')' alias,id_az_sede
			   FROM agenda.vw_eventi_singoli c 
			    where id_az_sede=idstabilimento
			    and not effettuata 
				and date_trunc('day',inizio) between current_timestamp -interval '2 years' and current_timestamp +interval '1 years' 
				--and dt >= R_CU.dt  and c.id != R_CU.id 
			 group by /*date_trunc('day',inizio)*/ id, inizio, descr_tipo_evento, id_az_sede
			 
			) g;
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		--if json_array_length(rt) is null then
    	--    ret:=cu_ui.build_ret(ret,proc_name, 'cu_programmati_non_trovati');
    	--   	ret.esito:=false;
    	--else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		--end if;
	 	return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_programmati(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_provv_in_corso(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_provv_in_corso(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		proc_name varchar;
		ret cu_types.result_type; 
		rt json;
		idstabilimento bigint;
		begin 
			proc_name:='cu_anag.get_cu_provv_in_corso';
			ret.esito:=false;
			idstabilimento=v->'id_stabilimento';
		select json_agg(row_to_json(g.*)) into rt from (
			select * from cu.vw_cu_provv p 
			where p.id_az_sede = idstabilimento and p.id_provv 
			not in 
			(select id_provv  from cu.vw_cu_provv_fu pf where id_az_sede = idstabilimento and risolta)) g;
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		--if json_array_length(rt) is null then
    	   --ret:=cu_ui.build_ret(ret,proc_name, 'cu_provv_in_corso_non_trovati');
    	  -- ret.esito:=false;
    	--else
	 		ret.info:='{"dati":'||rt::varchar||'}';
	 		
		--end if;
	 	return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_provv_in_corso(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_soggetto_figure_imprese(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_soggetto_figure_imprese(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_cf varchar;
	idasl bigint;
	begin
		proc_name:='cu_anag.get_cu_stabilimenti_figura_singolo';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		v_cf = v->>'cf';
		idasl:=v->'user_info'->'id_asl';
		select json_agg(row_to_json(g.*)) into rt from (
			select *
			from cu_anag.vw_impresa_figure_all where cf_figura = v_cf)  g;
		
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'figura_non_trovata');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_soggetto_figure_imprese(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_soggetto_figure_stabilimenti(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_soggetto_figure_stabilimenti(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_cf varchar;
	idasl bigint;
	begin
		proc_name:='cu_anag.get_cu_stabilimenti_figura_singolo';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		v_cf = v->>'cf';
		idasl:=v->'user_info'->'id_asl';
		select json_agg(row_to_json(g.*)) into rt from (
			select *
			from cu_anag.vw_stabilimento_figure_all where codice_fiscale = v_cf)  g;
		
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'figura_non_trovata');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_soggetto_figure_stabilimenti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stabilimenti(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_stabilimenti(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_I cu_anag.vw_imprese%ROWTYPE;
	rt json;
	idimpresa bigint;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu.get_cu_stabilimenti';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		ret.esito:=false;
		idimpresa=v->'id_impresa';
		select * into R_I from cu_anag.vw_imprese_all where id_impresa=idimpresa;
		if R_I.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'impresa_non_trovata');
			return ret;
		end if;
		
		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu_anag.vw_stabilimenti_all
			where id_impresa=idimpresa
			order by fine_validita desc, nome asc) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	--ret.info:='{"dati":'||rt::varchar||',"inizio_validita":"'||coalesce(R_I.inizio_validita::timestamp::varchar,'')||'"}';
		ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||',"inizio_validita":"'||coalesce(R_I.inizio_validita::timestamp::varchar,'')||'"}';
		
	raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_cu_stabilimenti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stabilimenti_automezzi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_stabilimenti_automezzi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_id_automezzo bigint;
	begin
		proc_name:='cu_anag.get_cu_stabilimenti_automezzi';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		--rag_sociale = replace('%'||trim(coalesce(v->>'rag_sociale',''))||'%';
		v_id_automezzo:=v->'id_automezzo';
	
	
	
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
	
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
			select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_stabilimento_automezzi vsa  
			where vsa.id_automezzo = v_id_automezzo
			order by inizio_validita_stab_automezzi desc)  g;
	
	
	
		raise notice 'ARRAY LEN %',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'stabilimenti_automezzi_non_trovati');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_stabilimenti_automezzi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stabilimenti_by_sel(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_stabilimenti_by_sel(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	rag_sociale varchar;
	v_cod_regionale varchar;
	p_iva varchar;
	v_indirizzo_completo varchar;
	v_comune varchar;
	v_nome varchar;
	idtipologiastruttura int;
	v_limite int;
	begin
		proc_name:='cu_anag.get_cu_stabilimenti_by_sel';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		--rag_sociale = replace('%'||trim(coalesce(v->>'rag_sociale',''))||'%';
		p_iva =         replace('%'||cu_anag.string_normalize(v->>'p_iva')||'%',' ','%');
		v_cod_regionale = replace('%'||cu_anag.string_normalize(v->>'cod_regionale')||'%',' ','%');
		v_indirizzo_completo = replace('%'||cu_anag.string_normalize(v->>'indirizzo_completo')||'%',' ','%');
		v_comune =      replace('%'||cu_anag.string_normalize(v->>'comune')||'%',' ','%');	
		v_nome =        replace('%'||cu_anag.string_normalize(v->>'nome')||'%',' ','%');
	
	
	
	
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		raise notice 'N=% C=% I=%',v_nome,v_comune,p_iva;
		raise notice 'R=%',v_cod_regionale;
	
		if v->>'limite' is not null then
		v_limite:=v->>'limite';
		end if;
	
			
		if v->>'id_tipologia_struttura' is not null then
		idtipologiastruttura:=v->>'id_tipologia_struttura';
		end if;
		
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		/*
		if cod_regionale = '%%' and p_iva = '%%' and v_comune = '%%' and v_nome = '%%' --and rag_sociale = '%%'
		then 
			select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_stabilimenti_all
			order by nome,piva_impresa,comune,sd_cod_regionale  limit 1000)  g;
		else
		*/
			select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_stabilimenti_all -- (ragsoc ilike rag_sociale)
			where (sd_cod_regionale ilike v_cod_regionale or (sd_cod_regionale is null and v_cod_regionale = '%%'))
			and (piva_impresa ilike p_iva or (piva_impresa is null and p_iva = '%%'))
			and (comune ilike v_comune or (comune is null and v_comune = '%%')) 
			and (nome ilike v_nome or (nome is null and v_nome = '%%'))
			and (indirizzo_completo  ilike v_indirizzo_completo or (indirizzo_completo  is null and v_indirizzo_completo = '%%'))
			and (id_tipologia_struttura = idtipologiastruttura or (idtipologiastruttura is null))
			order by nome limit v_limite)  g;
		/*
		end if;
		*/
	
	
		raise notice 'ARRAY LEN %',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'stabilimenti_non_trovati');
    	else
    	/*
    		if json_array_length(rt) = 1000 then
	    	    ret:=cu_ui.build_ret(ret,proc_name, 'troppi_stabilimenti_visualizzazione_parziale');
	    	end if;
	    */
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_stabilimenti_by_sel(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stabilimenti_figura_singolo(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_stabilimenti_figura_singolo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_id_figura bigint;
	idasl bigint;
	v_responsabile bool;
	n_pratiche bigint;	

	begin
		proc_name:='cu_anag.get_cu_stabilimenti_figura_singolo';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		v_id_figura = v->'id_figura';
		idasl:=v->'user_info'->'id_asl';
		v_responsabile:=v->'user_info'->'responsabile';
	
		select count(*) into n_pratiche from cu_anag.vw_stabilimenti_all s 
		join cu_anag.vw_pratiche p on p.id_stabilimento  = s.id_stabilimento 
		where s.id_stabilimento  =(select id_stabilimento from cu_anag.vw_stabilimento_figure_all where id_stabilimento_figura = v_id_figura)
		and p.descr_stato_pratica = 'Aperto';
	
		select json_agg(row_to_json(g.*)) into rt from (
			select id_stabilimento_figura
			,id
			,id_stabilimento
			,id_soggetto_fisico
			,id_tipo_figura
			,id_indirizzo
			,nome
			,cognome
			,codice_fiscale
			,sigla_tipo_figura
			,descr_tipo_figura
			,toponimo
			,indirizzo_nome
			,comune
			,nome_stabilimento
			,ragsoc
			,email
			,telefono
			,data_nascita
			,comune_nascita
			,comune_residenza
			,cap
			,civico
			,cod_tipo_impresa
			,cf_impresa
			,piva_impresa
			,cf
			,istat_comune
			,fonte
			,istat_nascita
			,inizio_validita
			,fine_validita
			,validita
			,indirizzo_completo
			,soggetto_fisico_nome
			,id_impresa
			,cod_tipo_figura
			,old_id
			,descr
			,id_soggetto
			,figure_modificabili and (idasl=-1 or idasl=id_asl) and v_responsabile and n_pratiche > 0 as figure_modificabili
			,nome_figura
			,cognome_figura
			,nome_completo_figura
			,cf_figura
			,estero
			,domicilio
			from cu_anag.vw_stabilimento_figure_all where id_stabilimento_figura = v_id_figura)  g;
		
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'figura_non_trovata');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_stabilimenti_figura_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stabilimenti_figure(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_stabilimenti_figure(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	rt_valide json;
	idstrutturaroot bigint;
	v_id_stabilimento bigint;
	n_valide int = 0;
	begin
		proc_name:='cu_anag.get_cu_stabilimenti_figure';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		v_id_stabilimento = v->'id_stabilimento';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (
			select *
			,(select to_char(inizio_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as inizio_validita_str
			,(select to_char(fine_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as fine_validita_str
			from cu_anag.vw_stabilimento_figure_all where id_stabilimento = v_id_stabilimento)  g;
		
		select json_agg(row_to_json(g.*)) into rt_valide from( 
			select *
			,(select to_char(inizio_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as inizio_validita_str
			,(select to_char(fine_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as fine_validita_str
			from  cu_anag.vw_stabilimento_figure_all 
		where id_stabilimento = v_id_stabilimento
		and validita @> LOCALTIMESTAMP) g;
		
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		/*
		if json_array_length(rt) is null /*or n_valide = 0 */ then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'figure_non_trovate');
		end if;
	-- GV 2024-03-04 - Per rimuovere il messaggio a video*/
	
		ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||
				  ',"dati_validi":'||coalesce(rt_valide::varchar,'[]')
				  ||'}';	--2024-04-12
	 	return ret;
	

	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_stabilimenti_figure(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stabilimenti_figure_by_f(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_stabilimenti_figure_by_f(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	idsoggettofisico bigint;
	R_SF cu_anag.vw_soggetti_fisici ;
	begin
		proc_name:='cu_anag.get_cu_stabilimenti_figure_by_f';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		idsoggettofisico = v->'id_soggetto_fisico';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		select * into R_SF from cu_anag.vw_soggetti_fisici where id=idsoggettofisico;
		select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_stabilimento_figure_all where cf=R_SF.codice_fiscale)  g;
		
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'figure_non_trovate');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_stabilimenti_figure_by_f(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stabilimenti_figure_by_impresa(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_stabilimenti_figure_by_impresa(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	idimpresa bigint;
	begin
		proc_name:='cu_anag.get_cu_stabilimenti_figure';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		idimpresa = v->'id_impresa';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_stabilimento_figure_all where /*id_stabilimento in (
			select id_stabilimento from cu_anag.vw_stabilimenti_all where*/ id_impresa = idimpresa
		--)
		)  g;
		
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'figure_non_trovate');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_stabilimenti_figure_by_impresa(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stabilimenti_linea_singolo(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_stabilimenti_linea_singolo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_id_linea bigint;
	idasl bigint;
	v_responsabile bool;
	n_pratiche bigint;

	begin
		proc_name:='cu_anag.get_cu_stabilimenti_linea_singolo';
		v_id_linea = v->'id_linea';
		idasl:=v->'user_info'->'id_asl';
		v_responsabile:=v->'user_info'->'responsabile';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
	
		select count(*) into n_pratiche from cu_anag.vw_stabilimenti_all s 
		join cu_anag.vw_pratiche p on p.id_stabilimento  = s.id_stabilimento 
		where s.id_stabilimento  =(select id_stabilimento from cu_anag.vw_linee_all where id_linea = v_id_linea)
		and p.descr_stato_pratica = 'Aperto';
	
		select json_agg(row_to_json(g.*)) into rt from (
			select id_linea, 
			id,
			id_stabilimento,
			id_tipo_linea,
			validita,
			attivita_fissa,
			linea_principale,
			verificato,
			fonte,
			cod_tipo_linea,
			desc_tipo_linea,
			cod_tipo_linea_mod,
			data_ultima_visita,
			pr,
			id_esterno,
			inizio_validita,
			fine_validita,
			stab_inizio_validita,
			stab_fine_validita,
			sd_id,
			linee_modificabili and (idasl=-1 or idasl=id_asl) and v_responsabile and n_pratiche > 0 as linee_modificabili
			from cu_anag.vw_linee_all where id_linea = v_id_linea
		order by pr desc)  g;
		
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			--ret.esito:=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'linea_non_trovata');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
	 		ret.esito:=true;
		end if;
	 	return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_stabilimenti_linea_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stabilimenti_sede_singolo(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_stabilimenti_sede_singolo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_id_sede bigint;
	idasl bigint;
	v_responsabile bool;
	n_pratiche bigint;

	begin
		proc_name:='cu_anag.get_cu_stabilimenti_sede_singolo';
		v_id_sede = v->'id_sede';
		idasl:=v->'user_info'->'id_asl';
		v_responsabile:=v->'user_info'->'responsabile';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
	
		select count(*) into n_pratiche from cu_anag.vw_stabilimenti_all s 
		join cu_anag.vw_pratiche p on p.id_stabilimento  = s.id_stabilimento 
		where s.id_stabilimento  =(select id_stabilimento from cu_anag.vw_stabilimento_sedi_all where id_stabilimento_sedi = v_id_sede)
		and p.descr_stato_pratica = 'Aperto';
	
		select json_agg(row_to_json(g.*)) into rt from (
			select id_stabilimento_sedi
			,id
			,id_stabilimento
			,id_tipo_sede
			,id_indirizzo
			,sigla_tipo_sede
			,toponimo
			,indirizzo
			,cap
			,stato
			,nazione
			,comune
			,localita
			,descr_tipo_sede
			,civico
			,cod_tipo_impresa
			,ragsoc
			,istat_comune
			,cf_impresa
			,piva_impresa
			,cf
			,pec
			,email
			,split_payement
			,sdi
			,piva
			,inizio_validita
			,fine_validita
			,validita
			,indirizzo_completo
			,cod_tipo_sede
			,id_impresa
			,old_id
			,fonte
			,nome
			,sedi_modificabili and (idasl=-1 or idasl=id_asl) and v_responsabile and n_pratiche > 0  as sedi_modificabili
			,estero
			,id_asl
			,pec_impresa
			from cu_anag.vw_stabilimento_sedi_all where id_stabilimento_sedi = v_id_sede)  g;
		
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'sede_non_trovata');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_stabilimenti_sede_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stabilimenti_sedi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_stabilimenti_sedi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	rt_valide json;
	idstrutturaroot bigint;
	v_id_stabilimento bigint;
	n_valide int = 0;
	begin
		proc_name:='cu_anag.get_cu_stabilimenti_by_sel';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		v_id_stabilimento = v->'id_stabilimento';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(g.*)) into rt from (
			select *
			,(select to_char(inizio_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as inizio_validita_str
			,(select to_char(fine_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as fine_validita_str
			from cu_anag.vw_stabilimento_sedi_all where id_stabilimento = v_id_stabilimento)  g;
		
		select json_agg(row_to_json(g.*)) into rt_valide from( 
			select *
			,(select to_char(inizio_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as inizio_validita_str
			,(select to_char(fine_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as fine_validita_str
			from cu_anag.vw_stabilimento_sedi_all 
			where id_stabilimento = v_id_stabilimento
		and validita @> LOCALTIMESTAMP) g;
	
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		/*if json_array_length(rt) is null /*or n_valide = 0*/ then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'sedi_non_trovate');
		end if;
		--GV 2024-03-04 - Per rimuovere il messaggio a video*/
	
		--ret.info:='{"dati":'||rt::varchar||'}';
		ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||
				  ',"dati_validi":'||coalesce(rt_valide::varchar,'[]')
				  ||'}';	--2024-04-12
	
	 	return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_stabilimenti_sedi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stabilimenti_vigenti_by_sel(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_stabilimenti_vigenti_by_sel(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	rag_sociale varchar;
	cod_regionale varchar;
	p_iva varchar;
	v_comune varchar;
	v_nome varchar;
	begin
		proc_name:='cu_anag.get_cu_stabilimenti_by_sel';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		--rag_sociale = '%'||trim(coalesce(v->>'rag_sociale',''))||'%';
		p_iva =         '%'||cu_anag.string_normalize(v->>'p_iva','')||'%';
		cod_regionale = '%'||cu_anag.string_normalize(v->>'cod_regionale','')||'%';
		v_comune =      '%'||cu_anag.string_normalize(v->>'comune','')||'%';
		v_nome =        '%'||cu_anag.string_normalize(v->>'nome','')||'%';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		raise notice 'N=% C=% I=%',v_nome,v_comune,p_iva;
		raise notice 'R=%',cod_regionale;
	
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		if cod_regionale = '%%' and p_iva = '%%' and v_comune = '%%' and v_nome = '%%' --and rag_sociale = '%%'
		then 
			select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_stabilimenti
			order by nome,piva_impresa,comune,sd_cod_regionale  limit 1000)  g;
		else
			select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_stabilimenti -- (ragsoc ilike rag_sociale)
			where (sd_cod_regionale ilike cod_regionale)
		and (piva_impresa ilike p_iva) and (comune ilike v_comune) and (nome ilike v_nome)
			order by nome limit 1000)  g;
		end if;

	
	
		raise notice 'ARRAY LEN %',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'stabilimenti_non_trovati');
    	else
    		if json_array_length(rt) = 1000 then
	    	    ret:=cu_ui.build_ret(ret,proc_name, 'troppi_stabilimenti_visualizzazione_parziale');
	    	end if;
	 		ret.info:='{"dati":'||rt::varchar||'}';
		end if;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_stabilimenti_vigenti_by_sel(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stabilimento_singolo(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_stabilimento_singolo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	v_id_stabilimento bigint;
	idasl bigint;
	v_responsabile bool;
	n_pratiche bigint;
	begin
		proc_name:='cu_anag.get_cu_stabilimento_singolo';
		v_id_stabilimento = v->'id_stabilimento';
		raise notice 'id_stabilimento%',v_id_stabilimento;
		if v->'user_info'->>'id_asl' is null or v->'user_info'->>'id_asl' = 'null' then
			idasl = -1;
		else
			idasl:=v->'user_info'->>'id_asl';
		end if;
		
		v_responsabile:=v->'user_info'->'responsabile';
		raise notice 'v=%',v;
		
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
	
		select count(*) into n_pratiche from cu_anag.vw_stabilimenti_all s 
		join cu_anag.vw_pratiche p on p.id_stabilimento  = s.id_stabilimento 
		where s.id_stabilimento  =v_id_stabilimento and p.descr_stato_pratica = 'Aperto';
	
		select json_agg(row_to_json(g.*)) into rt from (
			select s.id_stabilimento, id, id_impresa, sd_id, nome, istat, comune, toponimo, indirizzo, civico,
			ragsoc, cf_impresa, piva_impresa, sd_cod_regionale, nazione, cap, cod_tipologia_struttura,
			fonte, az_cod_aziendale, az_cod_regionale, cod_tipo_impresa, siglaprovincia, indirizzo_luogo,
			valida, id_asl, verificato, categoria_rischio, id_indirizzo, cod_registrazione,
			stato_prov, istat_comune, inizio_validita,
			(select to_char(inizio_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as inizio_validita_str,
			fine_validita,
			(select to_char(fine_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as fine_validita_str,
			validita,
			indirizzo_completo, descr_cod_naz, descr_cod_reg, cod_nazionale, sigla_tipologia_struttura,
			id_tipologia_struttura, id_asl_stabilimento, id_asl_impresa, modificabile, id_comune, asl_descr,
			categoria_rischio_descr, pec, telefono, chiuso, split_payement, sdi, descrizione_tipologia_struttura,
			cod_regionale, verificato_str, verificato_descr, latest_storico,
			stabilimento_modificabile and (idasl=-1 or idasl=id_asl) and upper_inf(validita) and v_responsabile is true and n_pratiche > 0 stabilimento_modificabile,
			sedi_modificabili and (idasl=-1 or idasl=id_asl) and upper_inf(validita) and v_responsabile is true and n_pratiche > 0 sedi_modificabili,
			figure_modificabili and (idasl=-1 or idasl=id_asl) and upper_inf(validita) and v_responsabile is true and n_pratiche > 0 figure_modificabili,
			linee_modificabili and (idasl=-1 or idasl=id_asl) and upper_inf(validita) and v_responsabile is true and n_pratiche > 0 linee_modificabili,
			pec_impresa, 
			v.nominativo as veterinario_ufficiale,		-- #12027
			s.n_pratica 								-- #12128
			from cu_anag.vw_stabilimenti_all s
			left join cu_anag.vw_stabilimento_veterinario v on s.id_stabilimento = v.id_stabilimento
			where s.id_stabilimento = v_id_stabilimento)  g;
		
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'stabilimento_non_trovato');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
	 		ret.esito:=true;
		end if;
	 	return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_stabilimento_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_stabilimento_storico(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_stabilimento_storico(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstabilimento bigint;

	begin
		proc_name:='cu_anag.get_cu_stabilimento_storico';
		ret.esito:=false;
	
		idstabilimento=v->'id_stabilimento';
	
		select json_agg(row_to_json(a.*)) into rt   from (
			select *
			,(select to_char(fine_validita  at time zone 'Europe/Rome', 'DD/MM/YYYY')) as fine_validita_str
			from cu_anag.vw_stabilimenti_storico 
			where id_stabilimento = idstabilimento
			order by id_stabilimento_storico desc
		) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_cu_stabilimento_storico(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipo_linee(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_cu_tipo_linee(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	idstabilimento bigint;
	R_S cu_anag.vw_stabilimenti_all;
	R_N agenda.vw_ag_tree_nodes_up_tipo_linee;
	begin
		proc_name:='cu_anag.get_cu_tipo_linee';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		if v->>'id_stabilimento' is not null then
		idstabilimento=v->'id_stabilimento';
		end if;
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		if idstabilimento is null then
			select json_agg(row_to_json(x.*)) into rt from (
				select tl.name_tree,
					tl.id_node,
					tl.id_tree,
					tl.id_node_parent,
					tl.descr path ,
					tl.path_ord,
					tl.descr path_descr,
					tl.id,
					tl.descr cod,
					tl.descr descrizione_breve,
					case when tl.cod = tl.descr then tl.cod
					else tl.cod ||' - '||tl.descr end as descrizione
			 	from agenda.vw_ag_tree_nodes_up_tipo_linee tl
				order by tl.path_ord collate "POSIX"
			) x;
		else
			select * into R_S from cu_anag.vw_stabilimenti_all where id=idstabilimento;
			select * into R_N from agenda.vw_ag_tree_nodes_up_tipo_linee vtl
			where livello=1 and cod like R_S.sigla_tipologia_struttura||'%';
			raise notice 'R_N %',R_N;

			select json_agg(row_to_json(x.*)) into rt from (
			select tl.name_tree,
					tl.id_node,
					tl.id_tree,
					case when tl.id_node=R_N.id_node then null else tl.id_node_parent end id_node_parent,
					tl.descr path ,
					tl.path_ord,
					tl.descr path_descr,
					tl.id,
					tl.descr cod,
					tl.descr descrizione_breve,
					case when tl.cod = tl.descr then tl.cod
					else tl.cod ||' - '||tl.descr end as descrizione
			 	from agenda.vw_ag_tree_nodes_up_tipo_linee tl
			 	join agenda.vw_ag_tree_nodes_down nd on tl.id_node=nd.id_node
			 		and nd.id_node_ref = R_N.id_node
			 		and tl.id_node not in
				 		(select id_tipo_linea*10+4 from cu_anag.vw_linee
				 			where id_stabilimento=R_S.id and upper_inf(validita) and id_tipo_linea is not null)
			 	order by tl.path_ord collate "POSIX"
			 ) x;
		end if;
		
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito:=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'tipo_linee_non_trovate');
    	else
	 		ret.info:='{"dati":'||rt::varchar||'}';
	 		ret.esito:=true;
		end if;
	 	return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_anag.get_cu_tipo_linee(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_elenco_import_anagrafica(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_elenco_import_anagrafica(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	proc_name varchar;
	rt json; 
 

	begin
	proc_name:='cu_anag.get_elenco_import_anagraficae';
	
		select json_agg(row_to_json(c.*)) into rt  from (	  
			 	  select i.id, data_inserimento, i.data_estr_file,tia.descr tipo_descr,
	      tia.cod tipo_cod,case when i.esito is null or false then false else true end esito,
	      case when tipo !='183' then imp_detS.totali else imp_detM.totali end as totali,
	      case when tipo !='183' then imp_detS.non_associati else imp_detM.non_associati end as non_associati,
	      case when tipo !='183' then imp_detS.associati else imp_detM.associati end as associati 
		  from  cu_anag.import_anagrafica i
		  inner join cu_types.vw_tipo_import_anagrafica tia on tia.cod=i.tipo 
		  
		  left join (
		  	  select COUNT(1) AS totali,idimport,  
	 		  COUNT(1) FILTER (WHERE tl.id is null) AS non_associati,
	 		  COUNT(1) FILTER (WHERE tl.id is not null) AS associati
	 		  from 
 			  cu_anag.file_xls_mangimifici m
			  LEFT join cu_anag.stabilimenti stab on TRIM(stab.cod_nazionale) =TRIM(m.numero_di_registrazione_cun) and 
			                                        TRIM(stab.cod_regionale) =TRIM(m.numero_di_registrazione_riconoscimento)
			  left join agenda.vw_tipo_linee tl on  
			  upper(translate(regexp_replace(tl.descr,'\[[^[]*\]','') ,' -','')) =
 	 			 upper(translate(m.dettaglio_attivita||m.descrizione_attivita,' -',''))	
			  left join cu_anag.linee l on l.id_stabilimento  = stab.id  and tl.id_tipo_linea =l.id_tipo_linea 	
			  group by idimport   ) 
		   imp_detM on imp_detM.idimport=i.id		
		  
		   left join (
		  	  select COUNT(1) AS totali,idimport,  
	 		  COUNT(1) FILTER (WHERE tl.id is null) AS non_associati,
	 		  COUNT(1) FILTER (WHERE tl.id is not null) AS associati
	 		  from 
 		 	  cu_anag.file_xls_sintesis  s 
	 		  LEFT join cu_anag.stabilimenti stab on TRIM(stab.cod_nazionale) =TRIM(s.approval_number)
			   left join agenda.vw_tipo_linee tl on  	
			    case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP'
		  	                 then 'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
						     when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI'
							 then 'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
					         else upper(translate(tl.descr,' -','')) end=upper(translate(S.attivita||S.descrizione_sezione,' -',''))
	
			   left join cu_anag.linee l on l.id_stabilimento  = stab.id  and tl.id_tipo_linea =l.id_tipo_linea  
 	
			  group by idimport   ) 
		  imp_detS on imp_detS.idimport=i.id	
	      ORDER BY  data_inserimento desc,  tipo,data_estr_file desc  
	 
	      
	      
	      ) c;

		raise notice '%',rt;	
		if rt is null then
			ret.esito:=false;	
    	    ret:=cu_ui.build_ret(ret,proc_name, 'Valori non trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null; 		 		
 			ret.info:='{"dati":' || rt;
			ret.info:=ret.info || '}';

		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_elenco_import_anagrafica(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_esclusi_import_anagrafica(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_esclusi_import_anagrafica(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type;  
	proc_name varchar;
	rt json;
	tipoP  varchar;
	r5 record;
  
	begin
		proc_name:='cu_anag.get_esclusi_import_sintesis';
	 	tipoP:=v->>'tipo';
		raise info 'tipo%', tipoP;
	 	if(tipoP!='18') then  
 		select json_agg(row_to_json(a.*)) into rt from (  	  	 
 		     select   distinct   string_agg(id::text, ',')id from (
 	  	     select  distinct  s.id,approval_number codice, upper(translate(S.attivita||S.descrizione_sezione,' -',''))attivita ,idimport from 
		       cu_anag.file_xls_sintesis s
		       where  idimport =(v->>'id_import')  ::int		                 
		       except 					         
			   select  distinct  s.id, approval_number codice,  upper(translate(tl.descr,' -','')) attivita,idimport
			   from 
			   cu_anag.file_xls_sintesis s
			   inner join cu_anag.stabilimenti s2 on TRIM(s2.cod_nazionale) =TRIM(s.approval_number ) 
			   inner join cu_anag.linee l on l.id_stabilimento  = s2.id
			   inner join agenda.vw_tipo_linee tl on tl.id_tipo_linea =l.id_tipo_linea 
	 		   where  idimport =(v->>'id_import')  ::int
	 		 )aa
 	   ) a; 	
 	   
 	    
  	end if;
	    
       raise notice '%',json_array_length(rt);

       raise notice '%',rt;
      
	    ret.esito:=true;
 		ret.msg:=null;
		ret.info:='{"dati":'||rt||'}';
		--end if;
	 	return ret; 
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_esclusi_import_anagrafica(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_esclusi_import_mang(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_esclusi_import_mang(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type;  
	proc_name varchar;
	rt json;
	tipoP  varchar;
  
	begin
		proc_name:='cu_anag.get_esclusi_import_mang';
	 	tipoP:=v->>'tipo';
		raise info 'tipo%', tipoP;
	
 		  
 	 	 select json_agg(row_to_json(aa.*)) into rt from   (
 	 	 select 
 	 	  		settore ,
				ragione_sociale ,
				rappresentante_legale ,
				codice_fiscale ,
				partita_iva ,
				indirizzo_sede_legale ,
				asl_di_competenza ,
				indirizzo_sede_produttiva ,
				comune ,
				prov ,
				regione ,
				numero_di_registrazione_cun ,
				denominazione_sede ,
				to_char(data_inizio_attivita,'dd/mm/yyyy' ) data_inizio_attivita,
				to_char(data_fine_attivita,'dd/mm/yyyy' )data_fine_attivita,
				codice_norma ,
				riconosciuta_registrata ,
				numero_di_registrazione_riconoscimento , 
				to_char(data_notifica_registrazione,'dd/mm/yyyy' )data_notifica_registrazione,
				codice_sezione ,
				sezione ,
				codice_attivita ,
				descrizione_attivita ,
				dettaglio_attivita ,
				remarks ,
				stato ,				
				to_char(data_inizio,'dd/mm/yyyy' )data_inizio,
				attivita_principale ,
				vendita_diretta ,
				note 
 	 	 from    cu_anag.file_xls_mangimifici mm where id in (
    	 select   distinct   id   from (
		      select  distinct m.id,coalesce(numero_di_registrazione_riconoscimento,'') ||'-' || coalesce (numero_di_registrazione_cun,'') codice,  upper(translate(m.dettaglio_attivita||m.descrizione_attivita,' -','')) attivita, idimport from 
		      cu_anag.file_xls_mangimifici m
		      where  idimport =(v->>'id_import')  ::int		                 
		      except 					         
			  select  distinct   m.id,coalesce(cod_regionale,'') ||'-'||  coalesce(cod_nazionale,'')codice,upper(translate(regexp_replace(tl.descr,'\[[^[]*\]','') ,' -',''))attivita,idimport
			  from 
			  cu_anag.file_xls_mangimifici m
			   inner join cu_anag.stabilimenti s on TRIM(s.cod_nazionale) =TRIM(m.numero_di_registrazione_cun) and 
			                                        TRIM(s.cod_regionale) =TRIM(m.numero_di_registrazione_riconoscimento)
			   inner join cu_anag.linee l on l.id_stabilimento  = s.id
			   inner join agenda.vw_tipo_linee tl on tl.id_tipo_linea =l.id_tipo_linea 
	 		  where  idimport =(v->>'id_import')  ::int
	 		   )a
	 	   
	 		   
	 		) 
	 	   )aa;
	 	   
 	    
	    
      raise notice '%',json_array_length(rt);
      ret.esito:=true;
      ret.msg:=null;
	  ret.info:='{"dati":'||rt||'}';
		--end if;
	 return ret; 
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_esclusi_import_mang(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_esclusi_import_sintesis(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_esclusi_import_sintesis(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type;  
	proc_name varchar;
	rt json;
	tipoP  varchar;
	r5 record;
  
	begin
		proc_name:='cu_anag.get_esclusi_import_sintesis';
	 	tipoP:=v->>'tipo';
		raise info 'tipo%', tipoP;


	    select json_agg(row_to_json(ss.*)) into rt from   cu_anag.file_xls_sintesis ss where id in (
        select   distinct   id   from (
 	  	     select  distinct s.id,approval_number codice, upper(translate(S.attivita||S.descrizione_sezione,' -',''))
 	  	     attivita ,idimport from      cu_anag.file_xls_sintesis s
		      where  idimport =(v->>'id_import')  ::int	              
		     except 					         
			   select  distinct s.id,approval_number codice,  upper(translate(tl.descr,' -','')) attivita,idimport	
				from cu_anag.file_xls_sintesis  s 
	 			inner join cu_anag.stabilimenti s2 on TRIM(s2.cod_nazionale) =TRIM(s.approval_number)  
			     inner join agenda.vw_tipo_linee tl on  				  	
			     	    case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP'
		  	                 then 'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
						     when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI'
							 then 'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
					         else upper(translate(tl.descr,' -','')) end=upper(translate(S.attivita||S.descrizione_sezione,' -',''))
			    inner join cu_anag.linee l on l.id_stabilimento  = s2.id  and tl.id_tipo_linea =l.id_tipo_linea 
			    where idimport =(v->>'id_import')::int  

	 	) aa
	   );

 
 	    

	     
      raise notice '%',json_array_length(rt);
      ret.esito:=true;
      ret.msg:=null;
	  ret.info:='{"dati":'||rt||'}';
		--end if;
	 return ret; 
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_esclusi_import_sintesis(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_import_file_mangimifici(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_import_file_mangimifici(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type;  
	proc_name varchar;
	rt json;
	rt2 json;
	tipoP  varchar;
  
	begin
		proc_name:='cu_anag.get_import_file_mangimifici';
	 	tipoP:=v->>'tipo';
		raise info 'tipo%', tipoP;
	
 		select json_agg(row_to_json(a.*)) into rt from (  	  	 
 	  	    select
			    settore ,
				ragione_sociale ,
				rappresentante_legale ,
				codice_fiscale ,
				partita_iva ,
				indirizzo_sede_legale ,
				asl_di_competenza ,
				indirizzo_sede_produttiva ,
				comune ,
				prov ,
				regione ,
				numero_di_registrazione_cun ,
				denominazione_sede ,
				to_char(data_inizio_attivita,'dd/mm/yyyy' ) data_inizio_attivita,
				to_char(data_fine_attivita,'dd/mm/yyyy' )data_fine_attivita,
				codice_norma ,
				riconosciuta_registrata ,
				numero_di_registrazione_riconoscimento , 
				to_char(data_notifica_registrazione,'dd/mm/yyyy' )data_notifica_registrazione,
				codice_sezione ,
				sezione ,
				codice_attivita ,
				descrizione_attivita ,
				dettaglio_attivita ,
				remarks ,
				stato ,				
				to_char(data_inizio,'dd/mm/yyyy' )data_inizio,
				attivita_principale ,
				vendita_diretta ,
				note 
 	  		from 
 			   cu_anag.file_xls_mangimifici m
			   inner join cu_anag.stabilimenti s on TRIM(s.cod_nazionale) =TRIM(m.numero_di_registrazione_cun) and 
			                                        TRIM(s.cod_regionale) =TRIM(m.numero_di_registrazione_riconoscimento)
			   inner join agenda.vw_tipo_linee tl on  	 upper(translate(regexp_replace(tl.descr,'\[[^[]*\]','') ,' -','')) =
 	 			 upper(translate(m.dettaglio_attivita||m.descrizione_attivita,' -',''))	
			   inner join cu_anag.linee l on l.id_stabilimento  = s.id  and tl.id_tipo_linea =l.id_tipo_linea  
 		       where  idimport =(v->>'id_import')  ::int
 	    ) a; 	
		  
 
	
	    raise notice '%',json_array_length(rt);
	    ret.esito:=true;
 		ret.msg:=null;
 		if(rt is null )then
 			 ret.info:='{"dati":''''}';
 		else 
 			ret.info:='{"dati":'|| rt ||'}';	
 		end if;
		
		--end if;
	 	return ret; 
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_import_file_mangimifici(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_import_file_sintesis(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_import_file_sintesis(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type;  
	proc_name varchar;
	rt json;
	tipoP  varchar;
	lista  varchar;
  
	begin
		
		
		proc_name:='cu_anag.get_import_file_sintesis';
	 	tipoP:=v->>'tipo';
		raise info 'tipo%', tipoP;
	
	 	raise info 'primo if id_import%', v->>'id_import';
		    select json_agg(row_to_json(a.*)) into rt from (  	  	 
	 	  	    select  stato_sede_operativa ,
						approval_number ,
						denominazione_sede_operativa ,
						ragione_sociale_impresa ,
						partita_iva ,
						codice_fiscale ,
						indirizzo ,
						comune ,
						sigla_provincia ,
						provincia ,
						regione ,
						cod_ufficio_veterinario ,
						ufficio_veterinario ,
						attivita ,
						stato_attivita ,
						descrizione_sezione ,
						to_char(data_inizio_attivita,'dd/mm/yyyy' ) data_inizio_attivita,
						to_char(data_fine_attivita,'dd/mm/yyyy' )data_fine_attivita,
						tipo_autorizzazione ,
						imballaggio ,
						paesi_abilitati_export ,
						remark ,
						species ,
						informazion_aggiuntive 
	 	  		from
	 			cu_anag.file_xls_sintesis  s 
	 			inner join cu_anag.stabilimenti s2 on TRIM(s2.cod_nazionale) =TRIM(s.approval_number) 
			     inner join agenda.vw_tipo_linee tl on  				  	
			     	    case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP'
		  	                 then 'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
						     when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI'
							 then 'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
					         else upper(translate(tl.descr,' -','')) end=upper(translate(S.attivita||S.descrizione_sezione,' -',''))
			    inner join cu_anag.linee l on l.id_stabilimento  = s2.id  and tl.id_tipo_linea =l.id_tipo_linea 
			    where idimport =(v->>'id_import')::int  
	 	    ) a; 	
  	   
 
	    raise notice '%',json_array_length(rt);
	    ret.esito:=true;
 		ret.msg:=null;
 		if(rt is null )then
 			 ret.info:='{"dati":''''}';
 		else 
 			ret.info:='{"dati":'|| rt ||'}';	
 		end if;
		
		--end if;
	 	return ret; 
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_import_file_sintesis(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_nazioni(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_nazioni(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
	ret ag_types.result_type; 
	proc_name varchar;
	rt json;
		begin 
			proc_name:='conf_ext.get_nazioni';
			ret.esito:=false;
		select json_agg(row_to_json(a.*)) into rt from (
			--select sigla_estesa,descrizione_upper  from conf_ext.vw_nazioni
		select codice_3166_a3 as sigla_estesa, denom_upper as descrizione_upper  from conf_ext.vw_stati_esteri
			) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt::varchar||'}';
	 	return ret;
		end;
		
	END;
$$;


ALTER FUNCTION cu_anag.get_nazioni(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_soggetti_fisici(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_soggetti_fisici(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	--R_I cu_anag.vw_imprese%ROWTYPE;
	rt json;
	idimpresa bigint;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu_anag.get_soggetti_fisici';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		ret.esito:=false;
		/*idimpresa=v->'id_impresa';
		select * into R_I from cu_anag.vw_imprese where id_impresa=idimpresa;
		if R_I.id is null then
			ret:=cu_ui.build_ret(ret,proc_name,'impresa_non_trovata');
			return ret;
		end if;*/
		
		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu_anag.vw_soggetti_fisici order by nome,cognome,codice_fiscale limit 1000) a ;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'soggetti_fisici_non_trovati');
    	end if;
    	if json_array_length(rt) = 1000 then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'troppi_soggetti_fisici_visualizzazione_parziale');
    	end if;

	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_soggetti_fisici(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_soggetti_fisici_by_sel(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_soggetti_fisici_by_sel(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $_$
	begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	tr2 json;
	v_nome varchar;
	v_cognome varchar;
	v_cf varchar;
	v_comune_nascita varchar;
	v_data_nascita date;
	v_sesso varchar;
	v_limite bigint;

	query text;
	R_S cu_anag.vw_soggetti_fisici;
	begin
		proc_name:='cu_anag.get_soggetti_fisici_by_sel';
		v_nome = '%'||cu_anag.string_normalize(v->>'nome')||'%';
		v_cognome = '%'||cu_anag.string_normalize(v->>'cognome')||'%';
		if cu_anag.string_normalize(v->>'cf') ~ '^[0-9]{4}[0-9]*$' then
			ret.esito:=true;
			ret.info:='{"dati":[]}';
			return ret;
		end if;
		v_cf = '%'||cu_anag.string_normalize(v->>'cf')||'%';
		v_comune_nascita = '%'||cu_anag.string_normalize(v->>'comune_nascita')||'%';
		if v->>'data_nascita' != '' then
			v_data_nascita = v->>'data_nascita';
		end if;
		raise notice 'v=%',v;
		
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
	
		if v->>'limite' is not null then
		v_limite:=v->>'limite';
		end if;
		
	/*	
		if v_nome = '%%' and v_cognome = '%%' and v_cf = '%%' and v_comune_nascita = '%%' and v_data_nascita is null-- and v_sesso = '%%' 
		then 
			select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_anag.vw_soggetti_fisici 
			order by cognome, nome,codice_fiscale 
			limit 1000)  g;
		else */
			select json_agg(row_to_json(g.*)) into rt from (
				select * from cu_anag.vw_soggetti_fisici 
				where (nome ilike v_nome or (nome is null and v_nome = '%%')) 
				and (cognome ilike v_cognome or( cognome is null and v_cognome = '%%'))
				and (codice_fiscale ilike v_cf or (codice_fiscale is null and v_cf = '%%')) 
				and (comune_nascita_descr ilike v_comune_nascita or (comune_nascita_descr is null or v_comune_nascita = '%%') ) 
				and (data_nascita = v_data_nascita or v_data_nascita is null )
				--and (sesso  ilike v_sesso )  
				order by cognome,nome,codice_fiscale limit v_limite
			)  g;
		--end if;
	 	
		
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
			ret.esito=false;
    	    ret:=cu_ui.build_ret(ret,proc_name, 'soggetti_fisici_non_trovati');
    	    --ret.info = null;
    	else
    		/*
	    	if json_array_length(rt) = 1000 then
	    	    ret:=cu_ui.build_ret(ret,proc_name, 'troppi_soggetti_fisici_visualizzazione_parziale');
	    	end if;
	    	 */
    	
	 		ret.info:='{"dati":'||coalesce(rt::varchar, '[]')||'}';
		end if;
	 	return ret;
	end;
	END;
$_$;


ALTER FUNCTION cu_anag.get_soggetti_fisici_by_sel(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_soggetto_fisico_singolo(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_soggetto_fisico_singolo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idsoggetto bigint;
	v_responsabile bool;

	begin
		proc_name:='cu_anag.get_soggetto_fisico_singolo';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		ret.esito:=false;
	
		idsoggetto := v->>'id_soggetto_fisico';
		v_responsabile:=v->'user_info'->'responsabile';
	
		select json_agg(row_to_json(a.*)) into rt   from (
			select *, 
			v_responsabile as soggetto_fisico_modificabile
			from cu_anag.vw_soggetti_fisici where id_soggetto_fisico = idsoggetto) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_soggetto_fisico_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_strutture_asl(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_strutture_asl(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	idstrutturaroot bigint;
	proc_name varchar;
	R_CU cu.vw_cu_con_periodo%ROWTYPE;
	rt json;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='cu_anag.get_strutture_asl';
		ret.esito:=false;

		select json_agg(row_to_json(a.*)) into rt   from (select * from cu_types.vw_strutture_asl vsa  order by id_asl) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_strutture_asl(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tipo_import(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.get_tipo_import(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	proc_name varchar;
	rt json;
 

	begin
		proc_name:='cu_anag.get_tipo_import';
	
		select json_agg(row_to_json(c.*)) into rt  from (select * from cu_types.vw_tipo_import_anagrafica) c;

		raise notice 'rt%',rt;	
	
	
	
		if rt is null then
			ret.esito:=false;	
    	    ret:=cu_ui.build_ret(ret,proc_name, 'valori_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null; 		 		
 			ret.info:='{"dati":' || rt;
			ret.info:=ret.info || '}';

		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.get_tipo_import(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: import_anagrafica(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.import_anagrafica(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	proc_name varchar;
	ret cu_types.result_type; 
	R_IMP cu_anag.import_anagrafica;
	idImportI bigint;
	tipoP  varchar;
	data_estr_fileP date;
	esitoL boolean;
   	r5 record;
     
	begin
		  proc_name:='cu_anag.import_anagrafica';
		
		  tipoP:=v->>'tipo';
		  data_estr_fileP:=v->>'data_estr_file';
		  raise info 'tipo%', tipoP;
		 
		  INSERT INTO cu_anag.import_anagrafica ( data_inserimento, tipo,data_sintesis ) VALUES(now(),tipoP ::int,data_estr_fileP)   returning * into R_IMP;
		
		  idImportI:=R_IMP.id;
	 	  raise info 'idImport%', idImportI;
	 	
		 

		 if(tipoP = '1'  or tipoP = '2' or tipoP = '3'  )then
	
		--	  delete from cu_anag.file_xls_sintesis where file_xls_sintesis.id=idImportI;
	 
		 	  raise info 'primo if' ;
	          insert into cu_anag.file_xls_sintesis
	          (stato_sede_operativa, approval_number, denominazione_sede_operativa, ragione_sociale_impresa, partita_iva, codice_fiscale, indirizzo, comune, sigla_provincia, provincia, regione, cod_ufficio_veterinario, ufficio_veterinario, attivita, stato_attivita, descrizione_sezione, data_inizio_attivita, data_fine_attivita, tipo_autorizzazione, imballaggio, paesi_abilitati_export, remark, species, informazion_aggiuntive,idimport,tipo,id )
			  select  stato_sede_operativa, approval_number, denominazione_sede_operativa, ragione_sociale_impresa, partita_iva, codice_fiscale, indirizzo, comune, sigla_provincia, provincia, regione, cod_ufficio_veterinario, ufficio_veterinario, attivita, stato_attivita, descrizione_sezione, data_inizio_attivita, data_fine_attivita, tipo_autorizzazione, imballaggio, paesi_abilitati_export, remark, species, informazion_aggiuntive, idImportI,tipoP, nextval('cu_anag.import_id_seq')
		      from (
			 
			   select * from 
			   json_populate_recordset(null::record,v->'lista') as 
			   ( stato_sede_operativa varchar, approval_number varchar, denominazione_sede_operativa varchar, ragione_sociale_impresa varchar, partita_iva varchar, codice_fiscale varchar, indirizzo varchar, comune varchar, sigla_provincia varchar, provincia varchar, regione varchar, cod_ufficio_veterinario varchar, ufficio_veterinario varchar, attivita varchar, stato_attivita varchar, descrizione_sezione varchar, data_inizio_attivita varchar, data_fine_attivita varchar, tipo_autorizzazione varchar, imballaggio varchar, paesi_abilitati_export varchar, remark  varchar, species varchar, informazion_aggiuntive varchar)
			
			   
		 	  )b;
		 	
		 	  
	--	 	  select * into r5 from 	cu_anag.load_stabilimenti_sintesis(chiamata::json,id_transazione);
		 	 --esitoL=r5.esito;
	 		
		 else  
			--  delete from cu_anag.file_xls_mangimifici where file_xls_mangimifici.id=idImportI;
	
	          insert into cu_anag.file_xls_mangimifici
	          (stato_sede_operativa, approval_number, denominazione_sede_operativa, ragione_sociale_impresa, partita_iva, codice_fiscale, indirizzo, comune, sigla_provincia, provincia, regione, cod_ufficio_veterinario, ufficio_veterinario, attivita, stato_attivita, descrizione_sezione, data_inizio_attivita, data_fine_attivita, tipo_autorizzazione, imballaggio, paesi_abilitati_export, remark, species, informazion_aggiuntive,idimport,tipo,id )
			  select  stato_sede_operativa, approval_number, denominazione_sede_operativa, ragione_sociale_impresa, partita_iva, codice_fiscale, indirizzo, comune, sigla_provincia, provincia, regione, cod_ufficio_veterinario, ufficio_veterinario, attivita, stato_attivita, descrizione_sezione, data_inizio_attivita, data_fine_attivita, tipo_autorizzazione, imballaggio, paesi_abilitati_export, remark, species, informazion_aggiuntive, idImportI,tipoP, nextval('cu_anag.import_id_seq')
		      from (
			 
			   select * from 
			   json_populate_recordset(null::record,v->'lista') as 
			   ( stato_sede_operativa varchar, approval_number varchar, denominazione_sede_operativa varchar, ragione_sociale_impresa varchar, partita_iva varchar, codice_fiscale varchar, indirizzo varchar, comune varchar, sigla_provincia varchar, provincia varchar, regione varchar, cod_ufficio_veterinario varchar, ufficio_veterinario varchar, attivita varchar, stato_attivita varchar, descrizione_sezione varchar, data_inizio_attivita varchar, data_fine_attivita varchar, tipo_autorizzazione varchar, imballaggio varchar, paesi_abilitati_export varchar, remark  varchar, species varchar, informazion_aggiuntive varchar)
			
			   
		 	  )b;
		  
		 	  
	--	 	  select * into r5 from 	cu_anag.load_stabilimenti_mangimifici(chiamata::json,id_transazione);
		-- 	 esitoL=r5.esito;
		 	 
		 end if;
	 
	 	update     cu_anag.import_anagrafica  set esito=esitoL where id=idImportI;
	 

		 ret.esito:=esitoL;
	 	 return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.import_anagrafica(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: import_anagrafica_sintesis(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.import_anagrafica_sintesis(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	proc_name varchar;
	ret cu_types.result_type; 
	R_IMP cu_anag.import_anagrafica;
	idImport bigint;
	tipoP  varchar;
	esitoL boolean;
   	r5 record;
	begin
		  proc_name:='cu_anag.import_anagrafica_sintesis';
		
		  tipoP:=v->>'tipo';
		  raise info 'tipo%', tipoP;
		 
		  INSERT INTO cu_anag.import_anagrafica ( data_inserimento, tipo ) VALUES(now(),tipoP ::int)   returning * into R_IMP;
		
		  idImport:=R_IMP.id;
	 	  raise info 'idImport%', idImport;
	 	 
	 	 	  raise info 'tipo confronto%',  tipoP = '1' ;
		 

		 if(tipoP = '1'  or tipoP = '2' or tipoP = '3'  )then
	
			  delete from cu_anag.file_xls_sintesis where file_xls_sintesis.id=idImport;
	
	          insert into cu_anag.file_xls_sintesis
	          (stato_sede_operativa, approval_number, denominazione_sede_operativa, ragione_sociale_impresa, partita_iva, codice_fiscale, indirizzo, comune, sigla_provincia, provincia, regione, cod_ufficio_veterinario, ufficio_veterinario, attività, stato_attività, descrizione_sezione, data_inizio_attività, data_fine_attività, tipo_autorizzazione, imballaggio, paesi_abilitati_export, remark, species, informazion_aggiuntive,idimport,tipo,id )
			  select  stato_sede_operativa, approval_number, denominazione_sede_operativa, ragione_sociale_impresa, partita_iva, codice_fiscale, indirizzo, comune, sigla_provincia, provincia, regione, cod_ufficio_veterinario, ufficio_veterinario, attività, stato_attività, descrizione_sezione, data_inizio_attività, data_fine_attività, tipo_autorizzazione, imballaggio, paesi_abilitati_export, remark, species, informazion_aggiuntive, idImport,tipoP, nextval('cu_anag.import_id_seq')
		      from (
			 
			   select * from 
			   json_populate_recordset(null::record,v->'import') as 
			   ( stato_sede_operativa varchar, approval_number varchar, denominazione_sede_operativa varchar, ragione_sociale_impresa varchar, partita_iva varchar, codice_fiscale varchar, indirizzo varchar, comune varchar, sigla_provincia varchar, provincia varchar, regione varchar, cod_ufficio_veterinario varchar, ufficio_veterinario varchar, attività varchar, stato_attività varchar, descrizione_sezione varchar, data_inizio_attività varchar, data_fine_attività varchar, tipo_autorizzazione varchar, imballaggio varchar, paesi_abilitati_export varchar, remark  varchar, species varchar, informazion_aggiuntive varchar)
			
			   
		 	  )b;
		 	
		 	  
	--	 	  select * into r5 from 	cu_anag.load_stabilimenti_sintesis(chiamata::json,id_transazione);
	 		
		 else  
			  delete from cu_anag.file_xls_mangimifici where file_xls_mangimifici.id=idImport;
	
	          insert into cu_anag.file_xls_mangimifici
	          (stato_sede_operativa, approval_number, denominazione_sede_operativa, ragione_sociale_impresa, partita_iva, codice_fiscale, indirizzo, comune, sigla_provincia, provincia, regione, cod_ufficio_veterinario, ufficio_veterinario, attività, stato_attività, descrizione_sezione, data_inizio_attività, data_fine_attività, tipo_autorizzazione, imballaggio, paesi_abilitati_export, remark, species, informazion_aggiuntive,idimport,tipo,id )
			  select  stato_sede_operativa, approval_number, denominazione_sede_operativa, ragione_sociale_impresa, partita_iva, codice_fiscale, indirizzo, comune, sigla_provincia, provincia, regione, cod_ufficio_veterinario, ufficio_veterinario, attività, stato_attività, descrizione_sezione, data_inizio_attività, data_fine_attività, tipo_autorizzazione, imballaggio, paesi_abilitati_export, remark, species, informazion_aggiuntive, idImport,tipoP, nextval('cu_anag.import_id_seq')
		      from (
			 
			   select * from 
			   json_populate_recordset(null::record,v->'import') as 
			   ( stato_sede_operativa varchar, approval_number varchar, denominazione_sede_operativa varchar, ragione_sociale_impresa varchar, partita_iva varchar, codice_fiscale varchar, indirizzo varchar, comune varchar, sigla_provincia varchar, provincia varchar, regione varchar, cod_ufficio_veterinario varchar, ufficio_veterinario varchar, attività varchar, stato_attività varchar, descrizione_sezione varchar, data_inizio_attività varchar, data_fine_attività varchar, tipo_autorizzazione varchar, imballaggio varchar, paesi_abilitati_export varchar, remark  varchar, species varchar, informazion_aggiuntive varchar)
			
			   
		 	  )b;
		  
		 	  
	--	 	  select * into r5 from 	cu_anag.load_stabilimenti_mangimifici(chiamata::json,id_transazione);
		 end if;
	 
		update     cu_anag.import_anagrafica  set esito=r5.esito where id=idImport;
	 

		 ret.esito:=r5.esito;
	 	 return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.import_anagrafica_sintesis(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: import_bdn_to_mdgm(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.import_bdn_to_mdgm() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	DECLARE
		ret cu_types.result_type; 
	    rec  record;
	    r5  record;
	    r4  record;
	   
   		chiamata   character varying; 
		 
	    LOG_FILE varchar;
   	    log_string varchar;
   	    FUNZ varchar;
   	    total_rows INTEGER;
   	    i INTEGER;
		BEGIN
 
   	    LOG_FILE:='/tmp/loadAziende_BDN_'||CURRENT_DATE ;
   	   
   	    FUNZ:='-- FUNCTION cu_anag.import_BDN_to_MDGM --';
	 	raise info 'LOG_FILE%',LOG_FILE;
	 
	   	log_string:= FUNZ ||  'FUNCTION cu_anag.import_BDN_to_MDGM'  ;
		raise info '%',log_string;		  	
		execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_STRING|| '>>' || LOG_FILE ||'''';  
	
	
		SELECT  * INTO total_rows 
	    from dblink('bdn_fvg','select COUNT(distinct account_number) NUM from  bdn.vw_allevamenti va
								left JOIN bdn.vw_get_id_linea vgil ON vgil.riferimento_id = va.id_allevamento_bdn
								where vgil.riferimento_id is null  ' )T( NUM varchar);
	
	 	--GET DIAGNOSTICS total_rows := ROW_COUNT; 
 		log_string:= FUNZ ||  '******* INIZIO NUMERO AZIENDE DA CARICARE:'||total_rows;
		raise info '%',log_string;		  	
		execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	

	    i:=1;
        for  r4	in
		select  *
	    from dblink('bdn_fvg','select distinct account_number from  bdn.vw_allevamenti va
								left JOIN bdn.vw_get_id_linea vgil ON vgil.riferimento_id = va.id_allevamento_bdn
								where vgil.riferimento_id is null and account_number not in (''001GO001'',''001GO011'') ' )T( account_number varchar)
	 	 loop
  
		     raise notice 'account_number% ',r4.account_number;
		     
		     log_string :=  FUNZ || 'AZIENDA DA CARICARE NEL DB MDGM :'||r4.account_number || 'CONTATORE :'|| i ;
			 raise info '%',log_string;		  	
		
			 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_STRING|| '>>' || LOG_FILE ||'''';   
		  
	 
		 	
			chiamata := '{"codice_azienda":"'||r4.account_number|| '"} ';
 		    raise notice 'chiamata% ',chiamata;
		    log_string:= FUNZ ||  'CHIAMATA cu_anag.ins_upd_azienda:'|| chiamata;
 			raise info '%',log_string;		  	
			execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_STRING|| '>>' || LOG_FILE ||'''';
		
         	select * into r5 from 	cu_anag.ins_upd_azienda(chiamata::json,'10');
            raise info 'r5.esito%',r5.esito;
            if ( r5.esito is false )then
                   	 log_string:= FUNZ ||  '******* PROBLEMA CON AZIENDA '|| r4.account_number ||' MSG ERR'|| r5.msg   ;
			
	  				 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
            end if;
            raise info 'fine loop';
            i:=i+1;
	    end loop;
	
	  raise info 'fine';
	  ret.esito:=true;	
    
	  ret.info='operazione_conclusa';
	 
 	  log_string:= FUNZ ||  '******* FINE'  ;
	  raise info '%',log_string;		  	
	  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	  return ret;
	 END;
 
$$;


ALTER FUNCTION cu_anag.import_bdn_to_mdgm() OWNER TO postgres;

--
-- Name: import_bdn_to_mdgm_proc(); Type: PROCEDURE; Schema: cu_anag; Owner: postgres
--

CREATE PROCEDURE cu_anag.import_bdn_to_mdgm_proc()
    LANGUAGE plpgsql
    AS $$
declare 
	 
		ret cu_types.result_type; 
	    rec  record;
	    r5  record;
	    r4  record;
	   
   		chiamata   character varying; 
		 
	    LOG_FILE varchar;
   	    log_string varchar;
   	    FUNZ varchar;
   	    total_rows INTEGER;
   	    i INTEGER;
		BEGIN
 
   	    LOG_FILE:='/tmp/loadAziende_BDN_'||CURRENT_DATE ;
   	   
   	    FUNZ:='-- FUNCTION cu_anag.import_BDN_to_MDGM --';
	 	raise info 'LOG_FILE%',LOG_FILE;
	 
	   	log_string:= FUNZ ||  'FUNCTION cu_anag.import_BDN_to_MDGM'  ;
		raise info '%',log_string;		  	
		execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_STRING|| '>>' || LOG_FILE ||'''';  
	
	
		SELECT  * INTO total_rows 
	    from dblink('bdn_fvg','select COUNT(distinct account_number) NUM from  bdn.vw_allevamenti_all va
								left JOIN bdn.vw_get_id_linea vgil ON vgil.riferimento_id = va.id_allevamento_bdn
								where vgil.riferimento_id is null 
						 ' )T( NUM varchar);
	
	 	--GET DIAGNOSTICS total_rows := ROW_COUNT; 
 		log_string:= FUNZ ||  '******* INIZIO NUMERO AZIENDE DA CARICARE:'||total_rows;
		raise info '%',log_string;		  	
		execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	

	    i:=1;
        for  r4	in
		select  *
	    from dblink('bdn_fvg','select distinct account_number from  bdn.vw_allevamenti_all va
								left JOIN bdn.vw_get_id_linea vgil ON vgil.riferimento_id = va.id_allevamento_bdn
								where vgil.riferimento_id is null  ' )T( account_number varchar)
	 	 loop
  
		     raise notice 'account_number% ',r4.account_number;
		     
		     log_string :=  FUNZ || 'AZIENDA DA CARICARE NEL DB MDGM :'||r4.account_number || 'CONTATORE :'|| i ;
			 raise info '%',log_string;		  	
		
			 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_STRING|| '>>' || LOG_FILE ||'''';   
		  
	 
		 	
			chiamata := '{"codice_azienda":"'||r4.account_number|| '"} ';
 		    raise notice 'chiamata% ',chiamata;
		    log_string:= FUNZ ||  'CHIAMATA cu_anag.ins_upd_azienda:'|| chiamata;
 			raise info '%',log_string;		  	
			execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_STRING|| '>>' || LOG_FILE ||'''';
		
         	select * into r5 from 	cu_anag.ins_upd_azienda(chiamata::json,'10');
            raise info 'r5.esito%',r5.esito;
            if ( r5.esito is false )then
                   	 log_string:= FUNZ ||  '******* PROBLEMA CON AZIENDA '|| r4.account_number ||' MSG ERR'|| r5.msg   ;
			         
	  				 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	  				 rollback;
	  		else 
	  			COMMIT;
            end if;
            raise info 'fine loop';
            i:=i+1;
	    end loop;
	 
	 
 	  log_string:= FUNZ ||  '******* FINE operazione_conclusa'  ;
	  raise info '%',log_string;		  	
	  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	  
	 END;
 
$$;


ALTER PROCEDURE cu_anag.import_bdn_to_mdgm_proc() OWNER TO postgres;

--
-- Name: ins_automezzo(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.ins_automezzo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_marca varchar;
		v_modello varchar;
		v_targa varchar;
		n integer;
		R_A cu_anag.automezzi;
		checkTarga varchar;
	
		v_j json;
		begin 
			proc_name:='cu_anag.ins_automezzo';
			v_j:=v::json;
			v_marca:=cu_anag.string_normalize_upper(v_j->>'marca');
			v_modello:=cu_anag.string_normalize_upper(v_j->>'modello');
			v_targa:=cu_anag.string_normalize_upper(v_j->>'targa');
			
			select targa into checkTarga from cu_anag.automezzi a where targa = v_targa;
			if checkTarga is not null then
				ret.esito:=false;
				ret:=cu_ui.build_ret(ret,proc_name,'automezzo_già_presente');
				return ret;
			end if;
			
			insert into cu_anag.automezzi (id, marca, modello, targa, validita) 
			values (nextval('cu_anag.automezzi_id_seq'), v_marca, v_modello, v_targa, tsrange(null, null, '[)'))
			returning * into R_A;
			n:=cu_log.upd_record('cu_anag.ins_automezzo',idtransazione,R_A,'I');
			
			
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info=R_A.id;
			return ret;
		end;
		

	END;
$$;


ALTER FUNCTION cu_anag.ins_automezzo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: ins_impresa(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.ins_impresa(v json, id_transazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	DECLARE
		ret cu_types.result_type; 
	    rec  record;
	    rec2  record;
	    rec3  record;
	    recF record;
		cf_parametro varchar; 
	    cap_parametro  varchar ; 
		cod_timpo_impresa  varchar ; 
		tiposoggetto varchar; 
		id_impresa_parametro bigint; 
		id_stab_parametro integer; 
		id_tipo_figura_parametro integer; 
	    fonteSTABFIG varchar;
	    fonteIMP varchar;
	    fonteSOGGFIS varchar;
	    indirizzo_parametro  varchar;
	    codistat_parametro  varchar;
	    nominativo  varchar;
	    cf  varchar;
	    piva  varchar;
	   	nome varchar;
	    indir_id integer;    
	    chiamata TEXT;
	    chiamata_j json;
	    v2 json;
	    R_SF cu_anag.soggetti_fisici;
	    R_STABF cu_anag.stabilimento_figure;
	    R_IMP cu_anag.imprese;
	    n integer;
	    LOG_FILE varchar;
   	    log_string varchar;
   	       FUNZ varchar;
		BEGIN
			cf_parametro	:=v->>'cf';	
			id_tipo_figura_parametro	:=v->>'id_tipo_figura';	
			id_stab_parametro	:=v->>'id_stabilimento';	
			nominativo	:=v->>'nominativo';	
		  	indirizzo_parametro 	:=v->>'indirizzo';	
	   		codistat_parametro  	:=v->>'codice_istat';	
	        cap_parametro:=v->>'cap';	
	   	
	   	    LOG_FILE:='/tmp/loadAziende_BDN_'||CURRENT_DATE ;
	   	   
	   	    FUNZ:='-- FUNCTION cu_anag.ins_impresa --';
  		   --	LOG_FILE:=REPLACE(LOG_FILE, ' ', '_');
		 	raise info 'LOG_FILE%',LOG_FILE;
			raise info 'id_tipo_figura_parametro%',v->>'id_tipo_figura';	
			raise info 'id_stab_parametro%',v->>'id_stabilimento';	
			raise info 'nominativo%',v->>'nominativo';	
		  	raise info 'indirizzo_parametro%',v->>'indirizzo';	
	   		raise info 'codistat_parametro%',v->>'codice_istat';	
	   		raise info 'cap_parametro%',v->>'cap';	
	   		fonteIMP:='BDN_AZ_UPD';
	        if(id_tipo_figura_parametro=6) then 
	       	   fonteSTABFIG:='BDN_PROP_UPD';
	        else
	    	   fonteSTABFIG:='BDN_DET_UPD';
	        END IF;
	      
	  	 	fonteSOGGFIS:='BDN_SOGGFIS_UPD';
	   	
		    select * into rec  from cu_anag.imprese i 
	     --   where ( (i.cf =cf_parametro AND I.piva IS NULL ) or i.piva =cf_parametro) ;--and i.fonte ilike '%BDN%';
	         where (i.cf =cf_parametro AND (I.piva IS NULL or  trim(coalesce (i.piva,''))='')  
	                or i.piva =cf_parametro
	              ) ;

	       
	        raise info ' VERIFICHIAMO SE ESISTE IMPRESA PER CF %',rec;
	       	log_string:= FUNZ ||  ' VERIFICHIAMO SE ESISTE IMPRESA PER CF :'||cf_parametro ||'id_tipo_figura_parametro:'|| id_tipo_figura_parametro;
			execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			
	        
	        id_impresa_parametro=rec.id ;
	       
	       
	       
	       
	       raise info 'id_impresa_parametro%',id_impresa_parametro;	
	       
	       if(id_impresa_parametro is null) then  -- SE NON PRESENTE NELLA TABELLA DELLE IMPRESE
	                 
			    IF( length(cf_parametro) =16 ) THEN -- SE E' UN CF
					cod_timpo_impresa='P';
					tiposoggetto='F';			
					cf=cf_parametro;
					piva=' ';
				    nome=' ';
				else
					cod_timpo_impresa='S';
					tiposoggetto='G';	
					cf=' ';
					piva=cf_parametro;
				    nome=cf_parametro;
				end if;	
		        raise info 'cod_timpo_impresa%',cod_timpo_impresa;	
	      
	     
	            log_string:='   insert into cu_anag.imprese (id,nome,piva,pec,email,sdi,split_payement,
						cf,cod_tipo_impresa,validita,verificato,fonte,tipo_soggetto) 
					values (nextval(''cu_anag.cu_anag_id_seq''),'||nome||','||piva||',NULL,NULL,NULL,NULL,
					'||cf||', '||cod_timpo_impresa||',tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, ''()''::text),false,'||fonteSTABFIG||','||tiposoggetto||')';
				raise info 'QUERY%',log_string;	
	     
	     
				insert into cu_anag.imprese (id,nome,piva,pec,email,sdi,split_payement,
						cf,cod_tipo_impresa,validita,verificato,fonte,tipo_soggetto) 
					values (nextval('cu_anag.cu_anag_id_seq'),nome,piva,NULL,NULL,NULL,NULL,
					cf,cod_timpo_impresa,tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text),true,fonteSTABFIG,tiposoggetto) 
				  
					
				returning * into R_IMP;
				n:=cu_log.upd_record('cu_anag.imprese',id_transazione,R_IMP,'I');
				id_impresa_parametro:=R_IMP.id;
		 
	      
		  end if;
	       
	       
	     
	
	        
		   SELECT  * INTO REC2
		   FROM  cu_anag.indirizzi i 
		   WHERE indirizzo = trim( indirizzo_parametro) and  istat_comune=codistat_parametro  ;
	 	  
		   indir_id:=rec2.ID;
		   raise info 'indir_id%',indir_id;	
		   IF (indir_id IS NULL) THEN  -- SE INDIRIZZO NON PRESENTE
				raise notice ' INDIRIZZO DEL PROPRIETARIO/DTENTORE NON ESISTE , INSERISCO NELLA TABELLA INDIRIZZI' ; 
				--chiamata :=  '{"fonte":"BDN_IND_PROP_DET_UPD","latitudine":null, "longitudine":null,"id_indirizzo":-1,"nazione":null,"stato_provincia":null,"comune":null,"toponimo":null,"indirizzo":"'||  indirizzo_parametro||'","civico":null,"cap":null,"istat_comune":"'||codistat_parametro||'"} ';
				
			    select row_to_json(a.*) into chiamata_j from
				   (select 'BDN_IND_PROP_DET_UPD' fonte,null latitudine,null longitudine,  -1 id_indirizzo,
				   null nazione,null stato_provincia,null comune,null toponimo,indirizzo_parametro indirizzo,null civico,cap_parametro cap,codistat_parametro istat_comune) a;
    
		
			    raise info 'PARAMETRI CHIAMATA upd_cu_add_indirizzi % ',chiamata_j;	 
			   
		        log_string:= FUNZ ||'PARAMETRI CHIAMATA upd_cu_add_indirizzi'|| chiamata_j;
		          raise info 'PARAMETRI CHIAMATA upd_cu_add_indirizzi log_string % ',log_string;	 
			    select * into rec3 from cu_anag.upd_cu_add_indirizzi( chiamata_j   ,  id_transazione);	
			   
			    raise info 'rec3.info %',rec3.msg;
			    if(rec3.esito is false )then
		 		    	   ret.esito:=rec3.esito;	
		 				   ret.info=rec3.info;
		 				   ret:=rec3;
		 				  -- RAISE EXCEPTION 'PROBLEMA cu_anag.upd_cu_add_indirizzi,%',rec3.msg ;
		 				   log_string:= FUNZ ||  'PROBLEMA cu_anag.upd_cu_add_indirizzi:'||rec3.msg;
				  		   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
						   return ret; 
						
				else
				    v2 := rec3.info;
				    indir_id:= v2->>'indirizzo_id';
				  
				   
				    raise info 'indir_id id %',indir_id;
				   
		       		log_string:= FUNZ ||  'INDIRIZZO DEL PROPRIETARIO/DTENTORE NON ESISTE , INSERISCO NELLA TABELLA INDIRIZZI imdirizzo_id||'indir_id;
				    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			    end if;
			   
		   END IF; 
		  
		   IF( length(cf_parametro) =16 ) THEN -- SE E' UN CF
		  
		 	 SELECT  sf.id id_sogg, sf.indirizzo_id into rec3
		  	 FROM  cu_anag.soggetti_fisici sf 
		  	 WHERE SF.codice_fiscale  = cf_parametro  ;
		  
		   	 raise info 'VERIFICHIAMO SE CF   ESISTE NELLA TAB_SOGGETTI FISICI. SE ID_SOGGETTO_FISICO  E'' NULL INSERISCI. ID_SOGG: %  ', rec3.id_sogg;
		   	
	 
		
		   	 IF (rec3.id_sogg IS  NULL) then 

		   	  
	   			log_string:= FUNZ ||  ' VERIFICHIAMO SE CF   ESISTE NELLA TAB_SOGGETTI FISICI.ID_SOGG_FISICO IS NULL' ;
			    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			
				raise info 'INSERISCE NELLA TAB DEI SOGGETTI FISICI ';
			
				insert into   cu_anag.soggetti_fisici
				 	(id,indirizzo_id,nome,titolo,cognome,pec,email,	comune_nascita,
					sesso,codice_fiscale,telefono,telefono2,data_nascita,documento_identita,fonte) values
					(nextval('cu_anag.cu_anag_id_seq'),indir_id, nominativo,null,  nominativo,null,null,
					null,null, cf_parametro,null,null,null,null,fonteSOGGFIS)  
				returning * into R_SF;
				n:=cu_log.upd_record('cu_anag.soggetti_fisici',id_transazione,R_SF,'I');
			
			 end if;       
		   END IF;--  IF( length(cf_parametro) =16 ) THEN -- SE E' UN CF
		  
	       
		   raise info '  VERIFICO  - SE NON PRESENTE NELLA TABELLA DELLE STAB FIGURE ';	
		   select *  into recF   from cu_anag.stabilimento_figure  
		   where   id_stabilimento=id_stab_parametro and id_tipo_figura=id_tipo_figura_parametro   ;

	      
	       raise info '  VERIFICO  - SE NON PRESENTE NELLA TABELLA DELLE STAB FIGURE ';		
	       raise info ' recF id%',recF.id;	
	      
	      	log_string:= FUNZ ||  ' select *  into rec   from cu_anag.stabilimento_figure  
		    where  id_stabilimento='||id_stab_parametro|| 'and id_tipo_figura='||id_tipo_figura_parametro;
 
		     raise info ' log_string%',log_string;	
		   
		   
	--		execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	
	      
	      
	      
	       if(recF.id is null) then  -- SE NON PRESENTE NELLA TABELLA DELLE STAB FIGURE
	    	raise info 'INSERISCO   NELLA TABELLA DELLE STAB FIGURE. id_impresa_parametro %',id_impresa_parametro;
	    
	    	raise info 'INSERISCO RIF NELLA TABELLA DELLE STAB FIGURE. id_stabilimento %',id_stab_parametro;
	    
	    	raise info 'INSERISCO RIF NELLA TABELLA DELLE STAB FIGURE. id_tipo_figura %',id_tipo_figura_parametro;
  
	       
	       INSERT INTO cu_anag.stabilimento_figure
			(id, id_stabilimento,id_soggetto, id_tipo_figura, id_indirizzo, old_id, fonte, descr, validita)
			VALUES(nextval('cu_anag.cu_anag_id_seq'), id_stab_parametro, id_impresa_parametro, id_tipo_figura_parametro,indir_id , NULL, fonteSTABFIG, NULL, '(,)'::tsrange)
			returning * into R_STABF;
			n:=cu_log.upd_record('cu_anag.stabilimento_figure',id_transazione,R_STABF,'I');
		   	log_string:= FUNZ ||  'INSERISCO RIF NELLA TABELLA DELLE STAB FIGURE. PER ID_SOGGETTO'||id_impresa_parametro||',id_stabilimento='||id_stab_parametro||'id_tipo_figura='||id_tipo_figura_parametro ;
			execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	
			
	       else
	           raise info '  AGGIORNO ID_INDIRIZZO NELLA TABELLA DEI SOGGETTI FISICI SE DIVERSO recF.id_indirizzo  %',recF.id_indirizzo  ;		  
	          
	           raise info '  AGGIORNO ID_INDIRIZZO NELLA TABELLA DEI SOGGETTI FISICI SE DIVERSO   indir_id %', indir_id ;	
	          
	           raise info '  AGGIORNO ID_INDIRIZZO NELLA TABELLA DEI SOGGETTI FISICI SE DIVERSO   rec.id %', recF.id ;	
			   if(recF.id_indirizzo!=indir_id)then
		  	    UPDATE cu_anag.stabilimento_figure	   set id_indirizzo=indir_id		   where id=recF.id 
		  	    returning R_STABF INTO rec ;
		  	   raise info 'R_STABF%',R_STABF;
			   n:=cu_log.upd_record('cu_anag.stabilimento_figure',id_transazione,R_STABF,'U');
			   log_string:= FUNZ ||  'AGGIORNO ID_INDIRIZZO ID :'||indir_id||'  NELLA TABELLA DELLE STAB FIGURE. PER ID_SOGGETTO'||id_impresa_parametro||',id_stabilimento='||id_stab_parametro||'id_tipo_figura='||id_tipo_figura_parametro ;
			   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	
	           end if;
	       end if;
	       raise info 'fine';
			ret.esito:=true;	
      --ret:=cu_ui.build_ret(ret,proc_name,'operazione_conclusa');
		  ret.info='operazione_conclusa';
		  return ret;
	      
	 	 END;
	$$;


ALTER FUNCTION cu_anag.ins_impresa(v json, id_transazione bigint) OWNER TO postgres;

--
-- Name: ins_stabilimenti_automezzi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.ins_stabilimenti_automezzi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_id_automezzo bigint;
		v_id_stabilimento bigint;
		v_data_inizio_validita timestamp;
		v_data_fine_validita timestamp;
		n integer;
		R_SA cu_anag.stabilimento_automezzi;
		v_validita tsrange;
		r record;
		v_j json;
		begin 
			proc_name:='cu_anag.ins_stabilimenti_automezzi';
			v_j:=v::json;
			v_data_inizio_validita:=cu_anag.string_normalize(v_j->>'data_inizio_validita');
			v_id_automezzo:=v_j->'id_automezzo';
			v_id_stabilimento:=v_j->'id_stabilimento';
			if v_j->>'data_fine_validita' is not null and v_j->>'data_fine_validita' != '' then
				v_data_fine_validita:=cu_anag.string_normalize(v_j->>'data_fine_validita');
				if v_data_inizio_validita = v_data_fine_validita then 
					v_data_fine_validita:=(v_j->>'data_fine_validita')::date + interval '1 day';
				end if;
				if v_data_inizio_validita > v_data_fine_validita then
					ret.esito:=false;	
	        		ret:=cu_ui.build_ret(ret,proc_name,'inizio_validità_maggiore_di_fine_validità');
					ret.info='0';
					return ret;
				end if;
			end if;
		
			-- Controllo di tutte le validità degli stabilimenti che non coincidano con la validità che ho inserito
			/*for r in select id from cu_anag.stabilimento_automezzi sa where id_automezzo = v_id_automezzo
				loop
					select * into R_SA from cu_anag.stabilimento_automezzi sa where id = r.id;
					v_validita:=tsrange(v_data_inizio_validita,v_data_fine_validita,'[)');
					raise notice 'R_SA:%',R_SA;
					raise notice 'v_validita=%', v_validita;
					if R_SA.id_stabilimento is not null and (v_validita @> R_SA.validita) then
						ret.esito:=false;	
		        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile');
						ret.info='0';
						return ret;
					end if;
				end loop; */
		
			select count(*) into n from cu_anag.stabilimento_automezzi sa 
			where sa.id_automezzo = v_id_automezzo and validita && tsrange(v_data_inizio_validita,v_data_fine_validita,'[)');
		
			if n > 0 then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile');
				ret.info='0';
				return ret;
			end if;
		
			insert into cu_anag.stabilimento_automezzi (id, id_stabilimento, id_automezzo, validita) values
			(nextval('cu_anag.stabilimento_automezzi_id_seq'), v_id_stabilimento, v_id_automezzo, 
			tsrange(v_data_inizio_validita::timestamp without time zone, v_data_fine_validita::timestamp without time zone, '[)'))
			returning * into R_SA;
			n:=cu_log.upd_record('cu_anag.ins_stabilimenti_automezzi',idtransazione,R_SA,'I');
			
			
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		end;
		

	END;
$$;


ALTER FUNCTION cu_anag.ins_stabilimenti_automezzi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: ins_upd_allevamento(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.ins_upd_allevamento(v json, id_transazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$

	
DECLARE
    rec  record;
    rec_l record;
    rec2  record;
    rec3  record;
    chiamata TEXT; 
    chiamata_j json; 
   
    total_rows integer;
    specie_allev varchar; 
    tipologia_strutt varchar; 
    orientamento_prod varchar; 
    descrizione_tipo_produzione varchar; 
    cod_gruppo_specie varchar;
	date1  varchar; 
	date2 varchar; 
	date11  timestamp; 
	date22 timestamp; 
    codice_azienda varchar; 
    name_ varchar; 
    partita_iva varchar; 
    id_allevamento_bdn integer;
    indir_id integer;
    id_impresa integer;
    id_stabilimento_p bigint;
   
    id_sogg_fisico integer;
    indirizzo_id_azienda integer;
    n integer;
    cod_timpo_impresa varchar;
    tiposoggetto varchar ;
	v_fonte varchar;
    v_validita tsrange;
    R_S cu_anag.stabilimenti;
	ret cu_types.result_type; 
    v_id_stab_impresa bigint;
    LOG_FILE varchar;
    FUNZ varchar;
    query varchar;
    log_string varchar;
	 BEGIN 
		LOG_FILE:='/tmp/loadAziende_BDN_'||CURRENT_DATE ;
		raise info 'LOG_FILE%',LOG_FILE;
	
	    FUNZ:='-- FUNCTION cu_anag.ins_upd_allevamento --';
	
 		cod_gruppo_specie=v->>'cod_gruppo_specie';	
     	specie_allev=v->>'specie_allev';	
	    tipologia_strutt=v->>'tipologia_strutt';	
     	orientamento_prod=v->>'orientamento_prod';	
	    descrizione_tipo_produzione=v->>'descrizione_tipo_produzione';	
	    date1:=v->>'date1';	
	    date2:=v->>'date2';	
		codice_azienda:=v->>'codice_azienda';		
		id_impresa:=v->>'id_impresa';		
		id_allevamento_bdn:=v->>'id_allevamento_bdn';	
		name_:=v->>'name';
		partita_iva:=v->>'partita_iva';
		indirizzo_id_azienda:=v->>'indirizzo_id_azienda';	
		v_id_stab_impresa:=v->>'id_stab_impresa';	
	
	
		raise info ' id_stab_impresa % ', v_id_stab_impresa; 
		raise info ' cod_gruppo_specie % ', cod_gruppo_specie; 
        raise info ' id_allevamento_bdn % ', id_allevamento_bdn; 
        raise info ' codice_azienda% ',   codice_azienda; 
    	raise info ' id_impresa% ',   id_impresa;
  	    raise info ' id_allevamento_bdn% ',   id_allevamento_bdn;
		raise info ' name% ',   name_;
 	    raise info ' partita_iva% ',   partita_iva;
		raise info ' indirizzo_id_azienda% ',   indirizzo_id_azienda;
 		raise info 'date1:% ',   v->>'date1';
		 raise info 'date2:% ',   v->>'date2';
		if v->>'date2' != 'null' and v->>'date2' is not null then
				date22:=v->>'date2';
			end if;
		if v->>'date1' != 'null' and v->>'date1' is not null then
				date11:=v->>'date1';
		end if;
	
	
	 	if(date22<date11) then
	 	  ret.esito:='false';	
		  ret.info='';
		  ret.msg='data fine inferiore a data inizio';
	 	return ret;
	 	end if;
		v_validita:=tsrange(date11 ,date22,'[)');
	
 	  
        SELECT  * into  rec  FROM cu_anag.stabilimenti s 
        inner join cu_anag.imprese i on i.id =s.id_impresa 
 	    where cod_nazionale =codice_azienda and s.nome =name_ and id_tipologia_struttura =17;
   
       
 	    id_stabilimento_p=rec.id;
 	    raise info ' LO STAB NON ESISTE. rec.id%',rec.id;
        
 	    if(id_stabilimento_p is null) then -- LO STAB NON ESISTE 
 	   
 	     
 	      --log_string := FUNZ ||  'LO STAB NON ESISTE  CON id_tipologia_struttura =17 ,indirizzo_id_azienda:'||indirizzo_id_azienda ||',id_impresa:'||id_impresa ||',cod_nazionale:'||codice_azienda  ||',nome:'||name_ ;
 		--  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
          
		  INSERT INTO cu_anag.stabilimenti
          (id, id_impresa, nome, sd_id, id_indirizzo,  cod_regionale,   verificato, fonte,   categoria_rischio, validita, cod_nazionale, id_tipologia_struttura, pec, telefono)
          VALUES(
           (select nextval('cu_anag.cu_anag_id_seq') ), id_impresa, name_, null, indirizzo_id_azienda, NULL,   true, 'BDN_ALL_UPD',
            2, v_validita, codice_azienda, 17, NULL, NULL)
        	returning * into R_S ;
    
            id_stabilimento_p:= R_S.id;
		    raise notice 'id_stabilimento id% ',id_stabilimento_p;

			n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_S,'U');
		
		    log_string:= FUNZ ||   'INS STAB cu_anag.stabilimenti CON FONTE BDN_ALL_UPD id_stabilimento'||id_stabilimento_p ;
			raise info '%',log_string;		  	
			execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
        
 	    ELSE 
 	     raise info ' LO STAB ESISTE ';
 	     log_string:= FUNZ || 'LO STAB ESISTE. AGGIORNIAMO ,SE DIVERSO, id_indirizzo PER ID ='||id_stabilimento_p;
		 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
   
 	    
 	     if(indirizzo_id_azienda!=rec.id_indirizzo)then
 	      update cu_anag.stabilimenti      set id_indirizzo=indirizzo_id_azienda      where id=id_stabilimento_p
 	       returning * into R_S;
		   n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_S,'U');
 	     end if;
 	    END IF;
 	    
        raise info ' VERIFICHIAMO SE ESISTE ALLEV. NELLE LINEE';
      
       -- chiamata :=  '{ "id_stab_impresa": "'||v_id_stab_impresa||'","cod_gruppo_specie": "'||cod_gruppo_specie||'",  "codice_azienda": "'||codice_azienda||'", "id_stabilimento": "'||id_stabilimento_p||'" ,  "id_allevamento_bdn": "'||id_allevamento_bdn||'" ,"date1": "'|| date1||'","date2": "'|| date2||'"} ';
  	   
        		
		 select row_to_json(a.*) into chiamata_j from
				   (select id_impresa ,  v_id_stab_impresa id_stab_impresa,cod_gruppo_specie cod_gruppo_specie,codice_azienda codice_azienda, id_stabilimento_p id_stabilimento,
				   id_allevamento_bdn id_allevamento_bdn,date1 date1,date2 date2 ) a;
    
		
        raise notice 'PARAMETRI CHIAMATA cu_anag.ins_upd_linea % ',chiamata_j;	 
		select* into rec_l  from cu_anag.ins_upd_linea( chiamata_j ,  id_transazione); 
	 
 	   log_string:= FUNZ ||  ' ESEGUIAMO FUNZIONE u_anag.ins_upd_linea chiamata:'||chiamata_j;
		execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
 		 
       if(rec_l.esito is true ) then
	        select T.*,c1.codice_istat	prop_codice_istat, c2.codice_istat	det_codice_istat 
			from dblink('bdn_fvg','	select   cf_proprietario , cf_detentore ,
	        prop.nominativo  prop_nominativo ,prop.indirizzo prop_indirizzo ,prop.cap  prop_cap,prop.comune prop_comune,prop.prov prop_prov   ,
	        det.nominativo  det_nominativo ,det.indirizzo det_indirizzo ,det.cap  det_cap, det.comune det_comune, det.prov det_prov     
	        from bdn.vw_allevamenti_az_all o
	        left JOIN public.operatori_allevamenti prop ON     
	         (case when length( o.cf_proprietario)=16  then  o.cf_proprietario end =prop.cf  or 
	         case when length( o.cf_proprietario)!=16 then  lpad( o.cf_proprietario,11,''00000000000'') end =lpad( prop.cf ,11,''00000000000'')
	         )
	        left JOIN public.operatori_allevamenti det ON 
	         (case when length( o.cf_detentore)=16  then  o.cf_detentore end =det.cf  or 
	         case  when length( o.cf_detentore)!=16 then  lpad( o.cf_detentore,11,''00000000000'') end =lpad( det.cf ,11,''00000000000'')
	         ) 			where account_number ='''|| codice_azienda||''' AND id_allevamento_bdn='''|| id_allevamento_bdn||''''    )
			into rec
			T(cf_proprietario varchar,cf_detentore varchar,	prop_nominativo varchar,prop_indirizzo varchar,prop_cap varchar,prop_comune varchar,prop_prov varchar,
		    det_nominativo varchar,det_indirizzo varchar,det_cap varchar,det_comune varchar,det_prov varchar) 
	        left join conf_ext.vw_comuni_vigenti_attivi c1 on c1.denominazione_composta =trim( prop_comune) and c1.siglaprovincia=trim( prop_prov)	
	        left join conf_ext.vw_comuni_vigenti_attivi c2 on c2.denominazione_composta =trim( det_comune) and c2.siglaprovincia=trim( det_prov)	;
 
	
	       
	        raise notice 'QUERY% ',query;	
	        raise notice 'PARAMETRI CHIAMATA id_stabilimento cu_anag.ins_impresa PER PROPRIETARIO% ',id_stabilimento_p;	
	       
	        raise notice 'PARAMETRI CHIAMATA nominativo cu_anag.ins_impresa PER PROPRIETARIO% ',rec.prop_nominativo;	
	       
	        raise notice 'PARAMETRI CHIAMATA coalesce(rec.prop_codice_istat,'') cu_anag.ins_impresa PER PROPRIETARIO% ',coalesce(rec.prop_codice_istat,'');	
	       
	       
	        raise notice 'PARAMETRI CHIAMATAindirizzo cu_anag.ins_impresa PER PROPRIETARIO% ',rec.prop_indirizzo;	
	   
	        
	     --   chiamata :=  '{ "cf": "'||rec.cf_proprietario||'","id_tipo_figura":"6","id_stabilimento": "'||id_stabilimento_p||'","nominativo":"'||rec.prop_nominativo||'","codice_istat":"'||coalesce(rec.prop_codice_istat,'')||'","indirizzo":"'||rec.prop_indirizzo||'"} ';
	       
	       
	        select row_to_json(a.*) into chiamata_j from
            (select rec.cf_proprietario cf,6 id_tipo_figura,
            id_stabilimento_p id_stabilimento,rec.prop_nominativo nominativo,
            coalesce(rec.prop_codice_istat,'') codice_istat,rec.prop_indirizzo indirizzo ,rec.prop_cap cap ) a;
		   
	
	        raise notice 'PARAMETRI CHIAMATA cu_anag.ins_impresa PER PROPRIETARIO% ', chiamata_j;	 
	  --      log_string:= FUNZ ||  ' ESEGUIAMO FUNZIONE cu_anag.ins_impresa PER PROPRIETARIO:'||jsonb_set(chiamata_j,'''','');
		--	execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		
			select* INTO rec2 from cu_anag.ins_impresa( chiamata_j   ,  id_transazione); 
	 
		    if(rec2.esito is true ) then 		         
	       --  chiamata :=  '{ "cf": "'||rec.cf_detentore||'","id_tipo_figura":"16","id_stabilimento": "'||id_stabilimento_p||'","nominativo":"'||rec.det_nominativo||'","codice_istat":"'||coalesce(rec.det_codice_istat,'')||'","indirizzo":"'||rec.prop_indirizzo||'"} ';
	         select row_to_json(a.*) into chiamata_j from
            (select rec.cf_detentore cf,16 id_tipo_figura,
            id_stabilimento_p id_stabilimento,rec.det_nominativo nominativo,
            coalesce(rec.det_codice_istat,'') codice_istat,rec.det_indirizzo indirizzo,rec.det_cap cap) a;
	        
	            raise notice 'PARAMETRI CHIAMATA cu_anag.ins_impresa PER DETENTORE% ',chiamata_j;	 
				select* INTO rec3 from cu_anag.ins_impresa( chiamata_j   ,  id_transazione); 
		
			--	log_string := ' ESEGUIAMO FUNZIONE u_anag.ins_impresa PER DETENTORE:'||chiamata_j;
			--	execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			
				raise info 'fine DETENTORE';
			  
		  	   	 if(rec3.esito is false)then
			      ret.esito:=rec3.esito;	
				  ret.info=rec3.info;
				  ret:=rec3;
		       --	  RAISE EXCEPTION 'PROBLEMA cu_anag.ins_impresa %', now();
		       	 
		 		  log_string:= FUNZ ||  'PROBLEMA cu_anag.ins_impresa:'||rec3.msg;
				  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				  return ret; 
		  	   end if;
		   	else 
				raise info 'fine cu_anag.ins_upd_allevamento';
			    ret.esito:=rec2.esito;	
			    ret.info=rec2.info;
		   	--	RAISE EXCEPTION 'PROBLEMA PER DETENTORE cu_anag.ins_impresa %', now();
		   		log_string:= FUNZ ||  'PROBLEMA cu_anag.ins_impresa'||rec2.msg;
				execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				
			    return ret;
			end if; --    if(rec2.esito is true ) then
		
	    else
	        ret.esito:=rec_l.esito;	
 		    ret.info=rec_l.info;	 
	    --    RAISE EXCEPTION 'PROBLEMA PER PROPRIETARIO cu_anag.ins_impresa %', now();
	        log_string:= FUNZ ||  'PROBLEMA cu_anag.ins_impresa'||rec_l.msg;
			execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		    return ret;
	    end if;--if(rec_l.esito is true ) then
	   
	   
	   -- select min(lower(validita)) minval, max(upper(validita)) maxval into rec from  cu_anag.linee
  	    --where id_stabilimento =id_stabilimento_p --AND FONTE='BDN_LIN_UPD';
	    
	    select case when count(li)  filter (where li is true) >0 then null else min(lower(validita))end as minval, case when count(ui)  filter (where ui is true) >0 then null else max(upper(validita))end as  maxval 
	    into rec from (
        select  lower_inf (validita) li,upper_inf(validita) ui,validita  
        from  cu_anag.linee
        where id_stabilimento =id_stabilimento_p --AND FONTE='BDN_LIN_UPD';
        )A;
		
  	    raise info 'MINIMO VALORE E MAX VALORE TRA LE VALIDITA DEGLI ALLEVAMENTI %', rec;
		 
		v_validita:=tsrange(rec.minval ,rec.maxval,'[)');
		update cu_anag.stabilimenti 
		set  validita=v_validita
		where id  =id_stabilimento_p AND id_tipologia_struttura =17 
		returning * into R_S;
		n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_S,'U');
	   
	   	log_string := 'AGGIORNIAMO VALIDITA SU STAB CON MINIMO VALORE E MAX VALORE TRA LE VALIDITA DEGLI ALLEVAMENTI ';
		execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		
	   
 	    return ret;
END;
$$;


ALTER FUNCTION cu_anag.ins_upd_allevamento(v json, id_transazione bigint) OWNER TO postgres;

--
-- Name: ins_upd_azienda(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.ins_upd_azienda(v json, id_transazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	
 	azienda_presente bigint;
    total_rows integer;
    r1 record;
    r2 record;
    r3 record;
    r4 record;
    r5 record;
    chiamata   character varying; 
    _id_ind bigint; 
    v_id_impresa bigint; 
    codice_azienda varchar; 
    v_id_indirizzo bigint; 
    v_id_stab bigint;
    id_stab_impresa bigint; 
    v2 json;
    vv json;
    date1 varchar; 
    date2 varchar; 
    data_chiusura_azienda character varying;
    R_S cu_anag.stabilimenti;
 	n integer;
    LOG_FILE varchar;
    log_string varchar;
    part_iva varchar;
    id_fiscalep varchar;
    FUNZ varchar;
    chiamata_j json;
	BEGIN
 	    raise info 'VERIFICHIAMO SE L''AZIENDA ESISTE NEL DB MDGM';
	    codice_azienda:=v->>'codice_azienda';
		raise info 'codice_azienda%',codice_azienda ;
	
	    LOG_FILE:='/tmp/loadAziende_BDN_'|| CURRENT_DATE ;
  	    FUNZ:='-- FUNCTION cu_anag.ins_upd_azienda --';
     --	LOG_FILE:=REPLACE(LOG_FILE, ' ', '_');
	 	raise info 'LOG_FILE%',LOG_FILE;
	
	    
		/*create table shell (res varchar)  fa creare su ongi db

		COPY shell FROM PROGRAM 'echo stampa prova  >/tmp/pippo.txt '*/

		raise info 'codice_azienda%',codice_azienda ;
	
  		log_string:= FUNZ ||  '  AZIENDA DA ALLINEARE codice_azienda :'||codice_azienda ;
		raise info '%',log_string;		  	
		execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	
	    select  * into r1 FROM cu_anag.stabilimenti s 
	    inner join cu_anag.imprese i on i.id =s.id_impresa 
		where id_tipologia_struttura =16 
		and cod_nazionale  = codice_azienda  ;
	
		GET DIAGNOSTICS azienda_presente := ROW_COUNT;
 
	   
	    raise info 'NUMERO AZIENDE PRESENTI NEL DB MDGM %', azienda_presente;
	 	
  		log_string:= FUNZ || ' AZIENDA '|| codice_azienda ||' PRESENTE NEL DB MDGM :'||azienda_presente ;
		raise info '%',log_string;		  	
		execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		  	
	  	if(azienda_presente =0) then -- SEL'AZIENDA NON E' PRESENTE IN MDGM
	 	
	  		 	     
		 	-- VERIFICHIAMO SE E' PRESENTE NEL DB DI BDN
	  		select  data_chius_azienda  into data_chiusura_azienda  
			from dblink('bdn_fvg','select cod_azienda,data_chius_azienda
			from bdn.vw_aziende_all WHERE cod_azienda= '''||codice_azienda::TEXT||''' '    )
		    T(cod_azienda varchar,data_chius_azienda timestamp)  ;
		    
 			GET DIAGNOSTICS total_rows := ROW_COUNT;
 			raise info 'VERIFICHIAMO SE E'' PRESENTE NEL DB DI BDN' ;
	  
 			raise info 'AZIENDA PRESENTE NEL DB BDN %',total_rows;
 		
	 	
  			log_string:= FUNZ || ' AZIENDA '|| codice_azienda ||' PRESENTE NEL DB BDN :'||total_rows ;
			raise info '%',log_string;		  	
			execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
 		 
	 	    IF(total_rows=0)THEN
	 	       ret.esito:=false;	
     		--ret:=cu_ui.build_ret(ret,proc_name,'azienda_non_presente_nel_db_bdn');
			  ret.info='azienda_non_presente_nel_db_bdn';
			  return ret;
	 	    else
	 	       raise info 'data_chiusura_azienda %',data_chiusura_azienda;
 		
 

	 	      
	 	      
	 	 	   	raise info 'INSERIAMO AZIENDA  NELLE IMPRESE SE NON PRESENTE' ;				   	   
 			 		 
			 
				select  i.id,
				id_fiscale_prop,t.cf,T.piva,
				case when length(T.cf)=16 then 'P' else 'S' end cod_timpo_impresa,
				(-id_azienda)*10-1 sdi, 
				'BDN_AZ_UPD' fonte ,dat_apertura_azienda,data_chius_azienda,lower(i.validita) lval, upper(i.validita)uval into r5
				from dblink('bdn_fvg','select id_fiscale_prop,
				case when length(id_fiscale_prop) =16 then id_fiscale_prop else null end cf,
				case when length(id_fiscale_prop)!=16 then id_fiscale_prop else null end piva,min(id_azienda::bigint) id_azienda,dat_apertura_azienda	,data_chius_azienda		
				from bdn.vw_aziende_all 	 where cod_azienda = '''||codice_azienda||'''   group by  id_fiscale_prop, dat_apertura_azienda,data_chius_azienda')
				T(    id_fiscale_prop varchar,cf varchar,piva varchar,id_azienda bigint,dat_apertura_azienda timestamp,data_chius_azienda timestamp)	
	     	--	left join cu_anag.vw_imprese i on i.cf=id_fiscale_prop	  
				--inner join cu_anag.vw_imprese i on i.piva =id_fiscale_prop
	
			   left JOIN cu_anag.imprese i ON     
	           (case when length( id_fiscale_prop)=16  then  id_fiscale_prop end =i.cf  or 
	            case when length( id_fiscale_prop)!=16 then  lpad( id_fiscale_prop,11,'00000000000') end =lpad( i.piva ,11, '00000000000')
	           );		 
	     	
			    raise info 'nome  % ',r5.id_fiscale_prop ;	 
		 	 
			    raise info 'cf  % ', coalesce(r5.cf,'');
			    raise info 'cf  % ', coalesce(r5.cf,'');
			   	raise info 'cod_tipo_impresa  % ', r5.cod_timpo_impresa;
		        raise info 'data_inizio_validita  % ', r5.dat_apertura_azienda ;
               
			    if(r5.id is not null) then --IMPRESA PRESENTE
			      v_id_impresa:=r5.id;
			      if(r5.lval > r5.dat_apertura_azienda) then 
			     	 update cu_anag.imprese 
			    	  set validita =tsrange(r5.dat_apertura_azienda,r5.uval,'[)')
			   	 	  where id=r5.id;
				  end if; 
			   	else
			   	    part_iva:= coalesce( r5.piva,'');
			   	    IF(length(part_iva) >0 ) THEN
	     		 	   part_iva:= lpad( part_iva,11,'00000000000');
				    ELSE
				  	   part_iva:= part_iva;
				    END IF;
				   
				   
				    id_fiscalep:=coalesce(r5.id_fiscale_prop,'');
          		    if(length(id_fiscalep) >0 AND length(id_fiscalep) !=16) then
          			  -- SE E' UN PIVA MA MANCA LO ZERO
			 		   id_fiscalep:= lpad( id_fiscalep,11,'00000000000');
				    ELSE
			  	  		id_fiscalep:=id_fiscalep;
			  	  	end if;
				   
				   
				     raise info 'piva  % ', coalesce(r5.piva,'') ;	 
				--    chiamata:=  '{"fonte":"BDN_AZ_UPD","nome":"'||id_fiscalep||'", "piva":"'||part_iva||'", "pec":null,"email":null,"sdi":null,"split_payement":null,"cf":"'||coalesce(r5.cf,'')||'","cod_tipo_impresa":"'||r5.cod_timpo_impresa||'","data_inizio_validita":"'|| r5.dat_apertura_azienda ||'","id_asl":null} ';
				   
				     select row_to_json(a.*) into chiamata_j from
				    (select 'BDN_AZ_UPD' fonte,id_fiscalep nome,part_iva piva,null pec,null email,null sdi,null split_payement, coalesce(r5.cf,'') cf,
          			 r5.cod_timpo_impresa cod_tipo_impresa,r5.dat_apertura_azienda data_inizio_validita,null id_asl) a;
    
				    raise info 'PARAMETRI PER CHIAMATA upd_cu_add_impresa  % ',chiamata_j ;		 
				
				    log_string:= FUNZ ||  'INSERIAMO IMPRESA upd_cu_add_impresa :'||replace(chiamata_j::text, '''', '')::jsonb;
				   
		         
					raise info '%',log_string;		  	
					execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				
				   select* into r3 from cu_anag.upd_cu_add_impresa(chiamata_j,id_transazione);
				    raise info 'esito%',r3.esito;
			 		if(r3.esito is false )then
		 		    	   ret.esito:=r3.esito;	
		 				   ret.info=r3.info;
		 				   ret:=r3;
						 
		 				--   RAISE EXCEPTION 'PROBLEMA cu_anag.upd_cu_add_impresa,%',r3.msg ;
		 				  
				    	   log_string:= FUNZ ||  'PROBLEMA cu_anag.upd_cu_add_impresa :'||r3.msg ;		
				  		   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				  		   raise info 'ret.esito% ' ,ret.esito;
						   return ret; 
					else
						v_id_impresa:=r3.info;
			 		end if; --if(r3.esito is false )then
			    end if; -- if(r5.id is not null) then
			   
		 	    raise info 'RECUPERA ID_IMPRESA DALLA FUNZIONE CALL %', v_id_impresa;
		        raise info 'INSERISCE STABILIMENTI PER AZ CON INDIRIZZO_ID E ID_IMPRESA,cod_regionale=CODICE AZIENDA,cod_tipologia_struttura=ZTC,id_tipologia_struttura=16';
			 -- chiamata:=  '{"fonte":"BDN_AZ_UPD","id_impresa":'|| v_id_impresa||', "cod_regionale":"'||codice_azienda||'", "nome":"'||codice_azienda||'","cod_tipologia_struttura":"ZTC","cod_nazionale":"'||codice_azienda||'","categoria_rischio":"2","cf":"'||coalesce(r5.cf,'')||'","id_tipologia_struttura":"16","data_inizio_validita":"'||r5.dat_apertura_azienda ||'","id_asl":null} ';
	 
			 
			    select row_to_json(a.*) into chiamata_j from
				   (select 'BDN_AZ_UPD' fonte,v_id_impresa id_impresa,codice_azienda cod_regionale,
				   codice_azienda nome,'ZTC' cod_tipologia_struttura,codice_azienda cod_nazionale,'2' categoria_rischio, coalesce(r5.cf,'') cf,
          		 16 id_tipologia_struttura,r5.dat_apertura_azienda data_inizio_validita,null id_asl) a;
    
			   
			    raise notice 'PARAMETRI PER CHIAMATA  upd_cu_add_stabilimento % ',chiamata_j ;	 
			 	
	  	        log_string:= FUNZ ||  'INSERIAMO STAB PER IMPRESA upd_cu_add_stabilimento :'||replace(chiamata_j::text, '''', '')::jsonb;
				raise info '%',log_string;		  	
				execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	  	       
	  	        select* into r4 from cu_anag.upd_cu_add_stabilimento(chiamata_j,-1);
			    raise info 'esito upd_cu_add_stabilimento  %',r4.info;
			
			   if(r4.esito is false) then
			    	ret.esito:=r4.esito;	
	 				ret.info=r4.info;
			        ret:=r4;
			 --   	RAISE EXCEPTION 'PROBLEMA cu_anag.upd_cu_add_stabilimento %', now();
			    	
			    	log_string:= FUNZ ||  'PROBLEMA cu_anag.upd_cu_add_stabilimento '||r4.msg ;
				  	execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
					return ret; 
		 	    else 
			 	       raise notice ' VERIFICHIAMO SE ESISTE L''INDIRIZZO DELLA AZIENDA NELLA TABELLA INDIRIZZI ';
				 	 	SELECT T.indirizzo_azienda  , T.cap_azienda  ,c.codice_istat  ,T.latitudine   ,T.longitudine     into r1
						from dblink('bdn_fvg','select cod_azienda,indirizzo_azienda,cap_azienda,cod_comune_azienda,
						case when prov_sede_azienda is null then substring(cod_azienda,4,2) else prov_sede_azienda end prov_sede_azienda, 
						latitudine,longitudine
						from bdn.vw_aziende_all where cod_azienda = '''   ||  codice_azienda||''' '    )
					    T(cod_azienda varchar, indirizzo_azienda varchar,cap_azienda varchar,cod_comune_azienda varchar,prov_sede_azienda varchar ,latitudine float8,longitudine float8) 
			 			left join conf_ext.vw_comuni_vigenti_attivi c on right(lpad(c.codistat::varchar,6,'0'),3)=T.cod_comune_azienda and c.siglaprovincia=prov_sede_azienda;
			 
		 
				 	    raise info ' SI INSERISCE IL NUOVO INDIRIZZO';
					--	v_id_indirizzo:= r4.info; 
				 	     raise info 'esito upd_cu_add_stabilimento da nupovo indirizzo %',r4.info;
						vv := r4.info;
			  			v_id_indirizzo:= vv->'id_indirizzo';
			  		
			  			raise info 'r1.indirizzo_azienda %',r1.indirizzo_azienda;
					 	raise info 'chiamata  r1.codicestat %',r1.codice_istat;
						raise info 'chiamata  cap %',r1.cap_azienda;
						raise info 'chiamata  v_id_indirizzo %',v_id_indirizzo; 
				 
					
					
					  --	chiamata :=  '{"id_indirizzo":'||v_id_indirizzo||', "civico":null,"indirizzo":"'||r1.indirizzo_azienda||'","nazione":null,"stato_provincia":null,"comune":null,"toponimo":null, "civico":null,"cap":"'||r1.cap_azienda||'","istat_comune":"'||r1.codice_istat||'"} ';
					    select row_to_json(a.*) into chiamata_j from
					   (select v_id_indirizzo id_indirizzo,null civico,r1.indirizzo_azienda indirizzo,
				  		 null nazione,null stato_provincia,null comune,null toponimo, null civico,r1.cap_azienda cap,r1.codice_istat istat_comune ) a;
    
					   
					    select* into r2 from cu_anag.upd_cu_indirizzi(  chiamata_j    ,  id_transazione);	
				 	    raise info 'esito  cu_anag.upd_cu_indirizzi%',r2.esito;
				 	   
					    log_string:= FUNZ ||  'INSERIAMO NUOVO INDIRIZZO AZIENDA upd_cu_indirizzi :'||replace(chiamata_j::text, '''', '')::jsonb;
			  	
				     	execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	  	  
				 	   
				 	    if(r2.esito)then
 				 				raise notice 'SI AGGIORNA INDIRIZZO ID FITTIZIO CON I DATI DEL NUOVO INDIRIZZO';
 				 				raise notice '    v_id_indirizzo%',v_id_indirizzo;
 				 				raise notice '   v_id_impresa%',v_id_indirizzo;
					 	    	update   cu_anag.stabilimenti s  set id_indirizzo =v_id_indirizzo	
					 	    	where  
					 	    	id_impresa = v_id_impresa    and 
					 	    	cod_regionale=codice_azienda and 
					 	    	nome=codice_azienda   and id_tipologia_struttura=16
								returning * into R_S;
					 	      
					 	        n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_S,'U');
					 	     
					 	        log_string:= FUNZ ||  'SI AGGIORNA INDIRIZZO ID STAB nome:'||codice_azienda ||', id_tipologia_struttura=16, v_id_indirizzo:'||v_id_indirizzo ||',v_id_impresa:'||v_id_impresa ;
								raise info '%',log_string;		  	
								execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	  	  
					 	    	raise notice '%',  'DOPO UPDATE';
					 	else
					 			ret.esito:=r2.esito;	
				 			    ret.info=r2.info;
				  	 	    --	RAISE EXCEPTION 'PROBLEMA cu_anag.upd_cu_indirizzi %', now();
				  	 	    
			    		    	log_string:= FUNZ ||  'PROBLEMA cu_anag.upd_cu_indirizzi '||r2.msg ;
				  		    	execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				  	 	        return ret;
				  	 	       
				  	 	       
					 	    	
					 	END IF; --if(!r2.esito) then
				   end if; --if(!r4.esito) then
		 
                 
          end if ; -- IF(total_rows=0)	
			
	 	else  -- else di  if(AZ_PRESENTE =0) then -- SEL'AZIENDA  E' PRESENTE IN MDGM		
	 		v_id_impresa:=r1.id_impresa;
       
			raise info 'SE AZIENDA PRESENTE, SI VERIFICA SE L''AZIENDA HA CAMBIATO INDIRIZZO' ;
		
		
		
			SELECT i.id indirizzo_id ,T.indirizzo_azienda  , T.cap_azienda  ,c.codice_istat  ,T.latitudine   ,T.longitudine  ,data_chius_azienda  into r1
			from dblink('bdn_fvg','select cod_azienda,indirizzo_azienda,cap_azienda,cod_comune_azienda,
			case when prov_sede_azienda is null then substring(cod_azienda,4,2) else prov_sede_azienda end prov_sede_azienda, 
			latitudine,longitudine,data_chius_azienda
			from bdn.vw_aziende_all where cod_azienda = '''   || codice_azienda ||''' '    )
		    T(cod_azienda varchar, indirizzo_azienda varchar,cap_azienda varchar,cod_comune_azienda varchar,prov_sede_azienda varchar ,latitudine float8,longitudine float8,data_chius_azienda timestamp) 
 			left join conf_ext.vw_comuni_vigenti_attivi c on right(lpad(c.codistat::varchar,6,'0'),3)=T.cod_comune_azienda and c.siglaprovincia=prov_sede_azienda
			left join cu_anag.indirizzi i on i.indirizzo=indirizzo_azienda
			--and i.latitudine::float8=t.latitudine and i.longitudine::float8=t.longitudine 
			and i.istat_comune ::integer= c.codistat and i.cap= t.cap_azienda
	 		left  join cu_anag.stabilimenti s on s.cod_nazionale =cod_azienda and   id_tipologia_struttura =16 and i.id =s.id_indirizzo ;
		
	 	 
			--	PERFORM QUERY;
			raise info '% (%) (%) (%) (%) (%) (%) ', r1.indirizzo_id,r1.indirizzo_azienda, r1.cap_azienda,r1.codice_istat,r1.latitudine, r1.longitudine,r1.data_chius_azienda;			 
			raise info 'VERIFICA INDIRIZZO ID SE E'' NULL, OSSIA NON PRESENTE. VALORE INDIRIZZO_ID %',r1.indirizzo_id ;		
	 	    if(r1.indirizzo_id  is not null) then
	 	      v_id_indirizzo:=r1.indirizzo_id;
	 	   	  raise notice '% ','INDIRIZZO AZIENDA UGUALE NON SI AGGIORNA';	
	 	     log_string:= FUNZ ||  'AZIENDA PRESENTE E INDIRIZZO AZIENDA UGUALE NON SI AGGIORNA IDNDIRIZZO DI CU_ANAG.STABILIMENTO';
			  raise info '%',log_string;		  	
			  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	  	  
	 	    else	 	     
	 	      raise notice '% ','INDIRIZZO AZIENDA NON UGUALE. SI INSERISCE INDIRIZZO E SI AGGIORNA INDIRIZZO_ID DEGLI STABILIMENTI';	
	 	      
			  --chiamata :=  '{"fonte":"BDN_IND_AZ_UPD","latitudine":"'||r1.latitudine||'", "longitudine":"'||r1.longitudine||'","id_indirizzo":-1,"nazione":null,"stato_provincia":null,"comune":null,"toponimo":null,"indirizzo":"'|| r1.indirizzo_azienda||'","civico":null,"cap":"'||r1.cap_azienda||'","istat_comune":"'||r1.codice_istat||'"} ';
			  
			  select row_to_json(a.*) into chiamata_j from
					   (select 'BDN_IND_AZ_UPD' fonte,r1.latitudine latitudine,r1.longitudine longitudine,-1 id_indirizzo,
				  		 null nazione,null stato_provincia,null comune,null toponimo, r1.indirizzo_azienda indirizzo, null civico,r1.cap_azienda cap,r1.codice_istat istat_comune ) a;
    
			 
			  raise info 'PARAMETRI CHIAMATA upd_cu_add_indirizzi % ',chiamata_j;	 
		  	  select* into r2 from cu_anag.upd_cu_add_indirizzi(  chiamata_j ,  id_transazione);	
		  	  v2 := r2.info;
			  v_id_indirizzo:= v2->>'indirizzo_id';
			 log_string:= FUNZ ||  'AZIENDA PRESENTE E INDIRIZZO AZIENDA NON UGUALE-SI INSERISCE INDIRIZZO E SI AGGIORNA INDIRIZZO_ID DEGLI STABILIMENTI v_id_indirizzo:'|| v_id_indirizzo;
			  raise info '%',log_string;		  	
			  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			 
			  if(r2.esito)then		
	 		     update   cu_anag.stabilimenti s      set id_indirizzo =v_id_indirizzo	where    cod_nazionale = codice_azienda	
	 		     and  nome=codice_azienda  and id_tipologia_struttura=16
	 		     returning * into R_S;
			     n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_S,'U');
			  else
			      ret.esito:=r2.esito;	
				  ret.info=r2.info;
				 
			     -- RAISE EXCEPTION 'PROBLEMA cu_anag.upd_cu_add_impresa %', now();
			     
		 		  log_string:= FUNZ ||  'PROBLEMA cu_anag.upd_cu_add_impresa'||r2.msg;
				  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				  return ret;
		      end if;
			end if;  -- if(rec.indirizzo_id  is not null) then	 	
	 	    raise notice 'VERIFICA LA DATA CHISURA AZIENDA, SE E'' VALORIZZATA  SI AGGIORNA.  DATA CHIUSURA:% ',r1.data_chius_azienda;	
 			IF(r1.data_chius_azienda IS NOT NULL) THEN 
   			   raise notice 'RECUPERA ID_IMPRESA DELL''AZIENDA % ', v_id_impresa;
			   raise notice 'CHIUDI AZIENDA , STABILIMENTI, LINEE ';	
		       --chiamata:='{"id_impresa":' || v_id_impresa  ||',"data_fine_validita":"'||r1.data_chius_azienda||'"} ';
		      
		      select row_to_json(a.*) into chiamata_j from
				    (select v_id_impresa id_impresa,r1.data_chius_azienda data_fine_validita ) a;
    
		       raise notice 'PARAMETRI PER CHIAMATA  upd_cu_del_impresa % ',chiamata_j ;	
		     
		       log_string:= FUNZ ||  'VERIFICA LA DATA CHISURA AZIENDA, SE E VALORIZZATA  SI AGGIORNA.:'|| chiamata_j;
 			   raise info '%',log_string;		  	
			   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		      
		       select * into r2   from cu_anag.upd_cu_del_impresa(chiamata_j,id_transazione);
		       raise notice 'PARAMETRI RESULT ESITO upd_cu_del_impresa % ',r2.esito ;
		       if(r2.esito is false)then
			      ret.esito:=r2.esito;	
				  ret.info=r2.info;
				  ret:=r2;
				 
		     --  	  RAISE EXCEPTION 'PROBLEMA cu_anag.upd_cu_del_impresa %', now();
		       	 
		 		  log_string:= FUNZ ||  'IPROBLEMA cu_anag.upd_cu_del_impresa'||r2.msg;
				  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
				  return ret; 
		  	   end if;
		 	 end if; --IF(rec.data_chius_azienda IS NOT NULL) THEN 
      end if ;	--  if(AZ_PRESENTE =0) then -- SEL'AZIENDA NON E' PRESENTE IN MDGM
	  
    
     
      select id into id_stab_impresa from cu_anag.stabilimenti s 
      where    cod_nazionale = codice_azienda  and  nome=codice_azienda   and id_tipologia_struttura=16;
     
      raise info 'RECUPERIAMO ID_STABILIMENTO DELLA IMPRESA%',id_stab_impresa;
    
      for  r4	in
		select *
	    from dblink('bdn_fvg','select distinct a.cod_gruppo_specie,a.name,a.partita_iva,a.id_allevamento_bdn , a.specie_allev,a.tipologia_strutt,
		a.orientamento_prod,a.descrizione_tipo_produzione, date1 date1, a.date2
	    from bdn.vw_allevamenti_all a where a.account_number =''' || codice_azienda ||''' ' )
		T( cod_gruppo_specie varchar,name varchar,partita_iva varchar, id_allevamento_bdn varchar,specie_allev varchar,tipologia_strutt varchar,orientamento_prod varchar, descrizione_tipo_produzione varchar, date1 timestamp ,  date2 timestamp)
	 	 loop
 
		 	 raise notice 'FUNZ cu_anag.ins_upd_azienda - id_allevamento_bdn% ',r4.id_allevamento_bdn;
		     raise notice 'id_allevamento_bdn% ',r4.id_allevamento_bdn;
		     date1:='null';
		     date2:='null';
		     if ( r4.date1 is not null )then
		    	 date1:=r4.date1;
		     end if;
		     if ( r4.date2 is not null )then
		    	 date2:=r4.date2;
		     end if;
		    raise notice 'id_stab_impresa%', id_stab_impresa;
		    raise notice 'indirizzo_id_azienda% ',v_id_indirizzo;
		    raise notice 'id_impresa% ',v_id_impresa;
		    raise notice 'date1% ',date1;
		    raise notice 'date2% ',date2;
		    raise notice 'descrizione_tipo_produzione% ',coalesce(r4.descrizione_tipo_produzione,'');
		    raise notice 'orientamento_prod% ',coalesce(r4.orientamento_prod,'');
		    raise notice 'specie_allev% ',coalesce(r4.specie_allev,'');
		    raise notice 'tipologia_strutt% ',coalesce(r4.tipologia_strutt,'');
		    raise notice 'name% ',coalesce(r4.name,'');
		    raise notice 'partita_iva% ',coalesce(r4.partita_iva,'');
		    raise notice 'cod_gruppo_specie% ',coalesce(r4.cod_gruppo_specie,'');
		    
		    part_iva:=coalesce(r4.partita_iva,'');
            if(length(part_iva) >0 AND length(part_iva) !=16) then
            -- SE E' UN PIVA MA MANCA LO ZERO
			 	   part_iva:= lpad( part_iva,11,'00000000000');
			ELSE
			  	  part_iva:=part_iva;
			 end if;
           
		    raise notice 'part_iva% ',part_iva;
		 --	chiamata := '{"id_stab_impresa":"'||id_stab_impresa||'","cod_gruppo_specie":"'||coalesce(r4.cod_gruppo_specie,'')||'","indirizzo_id_azienda":"'||v_id_indirizzo||'","id_impresa":"'||v_id_impresa||	'","date2":"'||date2||'","date1":"'||date1||'","descrizione_tipo_produzione":"'||coalesce(r4.descrizione_tipo_produzione,'')||'","orientamento_prod":"'||coalesce(r4.orientamento_prod,'')||'","tipologia_strutt":"'||coalesce(r4.tipologia_strutt,'')||'","specie_allev":"'||coalesce(r4.specie_allev,'')||'","codice_azienda":"'||codice_azienda||'","name":"'||coalesce(r4.name,'')||'", "partita_iva":"'||part_iva||'","id_allevamento_bdn":"'||r4.id_allevamento_bdn||'"} ';
            select row_to_json(a.*) into chiamata_j from
            (select id_stab_impresa id_stab_impresa,coalesce(r4.cod_gruppo_specie,'') cod_gruppo_specie,
            v_id_indirizzo indirizzo_id_azienda,v_id_impresa id_impresa,date2 date2,date1 date1,coalesce(r4.descrizione_tipo_produzione,'')descrizione_tipo_produzione,coalesce(r4.orientamento_prod,'') orientamento_prod,coalesce(r4.tipologia_strutt,'') tipologia_strutt, coalesce(r4.specie_allev,'') specie_allev,codice_azienda codice_azienda, coalesce(r4.name,'') name, part_iva partita_iva, r4.id_allevamento_bdn id_allevamento_bdn) a;
		   
            raise notice 'chiamata% ',chiamata_j;
            --raise info 'replace%',replace(chiamata_j::text, '''', '')::jsonb;	
		    log_string:= FUNZ ||  'INS.ALLEV. ins_upd_allevamento:'|| replace(chiamata_j::text, '''', '')::jsonb;
 			raise info '%',log_string;		  	
			execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';
		
         	select * into r5 from 	cu_anag.ins_upd_allevamento(chiamata_j,id_transazione);
            raise info 'r5.esito%',r5.esito;
        
            if ( r5.esito is false )then
			      ret.esito:=r5.esito;	
				  ret.info=r5.info;
				  ret:=r5;
		         RAISE info  'r5.msg %', r5.msg;
		       	 log_string:= FUNZ ||  'IPROBLEMA cu_anag.ins_upd_allevamento'||coalesce(r5.msg,'');
				 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
				 return ret; 
		  	 end if;
             raise info 'fine loop';
	    end loop;
	  
	  raise info 'fine';
	  ret.esito:=true;	
      --ret:=cu_ui.build_ret(ret,proc_name,'operazione_conclusa');
	  ret.info='operazione_conclusa';
	  return ret;
	 END;
END;
$$;


ALTER FUNCTION cu_anag.ins_upd_azienda(v json, id_transazione bigint) OWNER TO postgres;

--
-- Name: ins_upd_linea(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.ins_upd_linea(v json, id_transazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
DECLARE
    rec  record;
	codice_azienda varchar;
    id_allevamento_bdn integer;
    id_stabilimento_p integer;
    v_id_impresa varchar;
    cod_gruppo_specie varchar;
   	date1  varchar; 
	date2 varchar; 
	date11  timestamp; 
	date22 timestamp; 
    v_validita tsrange;
    id_linea bigint;
	ret cu_types.result_type; 
    R_L cu_anag.linee;
    n integer;
    total_rows bigint;
    v_id_stab_impresa bigint;
    LOG_FILE varchar;
    log_string varchar;
     FUNZ varchar;
    query varchar;
	BEGIN
		
			
	    LOG_FILE:='/tmp/loadAziende_BDN_'||CURRENT_DATE ;
     --	LOG_FILE:=REPLACE(LOG_FILE, ' ', '_');
	 	raise info 'LOG_FILE%',LOG_FILE;
	 
	    log_string:='-- FUNCTION cu_anag.ins_upd_linea --';
	    FUNZ:='-- FUNCTION cu_anag.ins_upd_linea --';
		codice_azienda 	:=v->>'codice_azienda';	
		id_stabilimento_p:=v->>'id_stabilimento';		
		id_allevamento_bdn:=v->>'id_allevamento_bdn';	
		cod_gruppo_specie:=v->>'cod_gruppo_specie';	
		v_id_stab_impresa:=v->>'id_stab_impresa';	
	
		v_id_impresa:=v->>'id_impresa';	
	    raise info 'v_id_stab_impresa% ',  v_id_stab_impresa;
	    raise info 'codice_azienda% ',  codice_azienda;
		raise info 'id_stabilimento% ',   id_stabilimento_p;
		raise info 'id_allevamento_bdn% ',   id_allevamento_bdn;
		raise info 'cod_gruppo_specie% ',   cod_gruppo_specie;
		raise info 'date1% ',   v->>'date1';
		raise info 'date2% ',   v->>'date2';
		if v->>'date2' != 'null' and v->>'date2' is not null then
				date22:=v->>'date2';
			end if;
		if v->>'date1' != 'null' and v->>'date1' is not null then
				date11:=v->>'date1';
		end if;
	    raise info ' prima';
		
		v_validita:=tsrange(date11 ,date22+ INTERVAL '1 DAY','[)');
	

	   
	    raise info '****VALIDITA****%',v_validita;
	   
	
	
	    ---------LINEA ALLEVAMENTO
        SELECT * into rec  FROM cu_anag.vw_linee_all    vl WHERE id_esterno =id_allevamento_bdn::text ;                 
 	     raise info 'rec INSERT LINEA %',rec;
 	     
 		 IF(rec.ID IS NULL) THEN
	 		  raise info 'ALLEVAMENTO NON PRESENTE. SI INSERISCE NELLA TAB. LINEE';
	 		 
	 		 log_string:= FUNZ ||  'ALLEVAMENTO NON PRESENTE. SI INSERISCE NELLA TAB. LINEE id_allevamento_bdn:'||id_allevamento_bdn ;
		   	 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_STRING|| '>>' || LOG_FILE ||'''';  
 		 
          
	 		 INSERT INTO cu_anag.linee
		        select nextval('cu_anag.cu_anag_id_seq')  ,id_stabilimento_p,tl.id_tipo_linea, v_validita,null,true,true,'BDN_LIN_UPD',null,T.id_allevamento_bdn
			     from dblink('bdn_fvg','select specie_allev,tipologia_strutt,orientamento_prod,descrizione_tipo_produzione,id_allevamento_bdn from bdn.vw_allevamenti_all where account_number =  '''   || codice_azienda ||''' AND id_allevamento_bdn=  '''   || id_allevamento_bdn ||'''  ')
				T(specie_allev varchar,tipologia_strutt varchar,orientamento_prod varchar,descrizione_tipo_produzione varchar,id_allevamento_bdn varchar)
				/*left AF 2024-09-25 eliminata la left perchè creava linee conid_tipo_linea a null*/
				join agenda.vw_tipo_linee tl on tl.cod=LTRIM(T.specie_allev,'0')||' - '||tipologia_strutt||' - '||coalesce(orientamento_prod,descrizione_tipo_produzione) returning *  into R_L;
		 		 
		      n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_L,'I');
		      id_linea:=R_L.id;
 		      raise info 'id_linea %',id_linea;
          
				
		 ELSE
		     raise info '  v_validita%',v_validita ;
		 
		 	 UPDATE  cu_anag.linee
			 SET   validita=    v_validita , fonte='BDN_LIN_UPD', data_ultima_visita=null
			 WHERE id=rec.ID 
			 returning * into R_L;
		     n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_L,'U');
			
		     --log_string:= FUNZ ||  'ALLEVAMENTO  PRESENTE. SI AGGIORNA VALIDITA NELLA TAB. LINEE v_validita:'||v_validita ;
		   	 --execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_STRING|| '>>' || LOG_FILE ||'''';  
 		 
			 
			 
 		  END IF; --   IF(rec.ID IS NULL)  
 		
 		---------LINEA PER IL GRUPPO SPECIE


 	    raise info 'LINEA PER IL GRUPPO SPECIE';
	
 	   
 	    raise info '  GRUPPO SPECIE%','GS-'||LTRIM(cod_gruppo_specie,'0');
 	   
	 	perform * from cu_anag.linee l 
		inner join  agenda.vw_tipo_linee tl on tl.cod ='GS-'||LTRIM(cod_gruppo_specie,'0')::text
		where l.id_stabilimento=v_id_stab_impresa   and id_esterno =codice_azienda   
	     and l.id_tipo_linea =tl.id_tipo_linea;
	
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 
 		  
 	    raise info 'NUMERO ALLEVAMENTI PRESENTI NEL DB MDGM CON LO SPECIFICO GRUPPO SPECIE %', total_rows;
 	    log_string:= FUNZ ||  'NUMERO ALLEVAMENTI PRESENTI NEL DB MDGM CON LO SPECIFICO GRUPPO SPECIE:'||total_rows ;
	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_STRING|| '>>' || LOG_FILE ||'''';  
 		
	   
	    IF(total_rows=0)then
	    	
 			INSERT INTO cu_anag.linee
			select nextval('cu_anag.cu_anag_id_seq') ,v_id_stab_impresa,a.id_tipo_linea, v_validita,null,true,true,
			 'BDN_LIN_GPR_UPD',null,codice_azienda from(
				select id_tipo_linea from  agenda.vw_tipo_linee tl 
	 			where  tl.cod='GS-'||LTRIM(cod_gruppo_specie,'0')::text
	 		) a
			returning * into R_L;
			n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_L,'I');
		
		else

	  
					   	 
			select case when count(li)  filter (where li is true) >0 then null else min(lower(validita))end as minval,
			case when count(ui)  filter (where ui is true) >0 then null else max(upper(validita))end as  maxval 
			into rec 
			from (		
			 	
			 select  lower_inf (l.validita) li,upper_inf(l.validita) ui,l.validita , codice,codice_gruppo_specie  
			 from 
			 cu_anag.linee l
			 inner join cu_anag.stabilimenti s on l.id_stabilimento =s.id 
			 inner join agenda.vw_tipo_linee vtl on l.id_tipo_linea =vtl.id_tipo_linea 
			 inner join  (
			  select 	*	from dblink('bdn_fvg','select codice, codice_gruppo_specie, descrizione_gruppo_specie from bdn_types.vw_specie vs  ')T 
			  (codice int,codice_gruppo_specie text,descrizione_gruppo_specie text) )grps
			 on LPAD(grps.codice::TEXT,4,'0')= LPAD(TRIM(split_part( vtl.cod  ,'-',1) ::TEXT),4,'0')
			 where s.id_impresa::text  =v_id_impresa and id_esterno !=codice_azienda  and    codice_gruppo_specie=trim(cod_gruppo_specie)
			 group by l.validita,codice, codice_gruppo_specie	
			--having codice_gruppo_specie='0126'
			 order by codice_gruppo_specie 
			 
			 )a;
			
			query:='
			select case when count(li)  filter (where li is true) >0 then null else min(lower(validita))end as minval,
			case when count(ui)  filter (where ui is true) >0 then null else max(upper(validita))end as  maxval 
			into rec 
			from (		
			 	
			 select  lower_inf (l.validita) li,upper_inf(l.validita) ui,l.validita , codice,codice_gruppo_specie  
			 from 
			 cu_anag.linee l
			 inner join cu_anag.stabilimenti s on l.id_stabilimento =s.id 
			 inner join agenda.vw_tipo_linee vtl on l.id_tipo_linea =vtl.id_tipo_linea 
			 inner join  (
			  select 	*	from dblink(''bdn_fvg'',''select codice, codice_gruppo_specie, descrizione_gruppo_specie from bdn_types.vw_specie vs  '')T 
			  (codice int,codice_gruppo_specie text,descrizione_gruppo_specie text) )grps
			 on LPAD(grps.codice::TEXT,4,''0'')= LPAD(TRIM(split_part( vtl.cod  ,''-'',1) ::TEXT),4,''0'')
			 where s.id_impresa::text  =v_id_impresa and id_esterno !=codice_azienda  and     codice_gruppo_specie=cod_gruppo_specie
			 group by l.validita,codice, codice_gruppo_specie	
			 order by codice_gruppo_specie ';
					
			raise info 'query%,',query;
					
			raise info 'MINIMO VALORE E MAX VALORE TRA LE VALIDITA DEGLI ALLEVAMENTI %', rec;
		
		/*	v_validita:=tsrange(rec.minval ,rec.maxval,'[)');
			update cu_anag.linee l
			set  validita=v_validita
			where l.id_stabilimento=id_stabilimento_p and id_esterno =codice_azienda 
			returning * into R_L;
		    n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_L,'U');
		    */
 
	
			v_validita:=tsrange(rec.minval ,rec.maxval,'[)');
		
		
			raise info 'v_validita%',v_validita;
		
			UPDATE cu_anag.linee l 
			set  validita=v_validita
			from (
			SELECT DISTINCT id_stabilimento,codice_gruppo_specie  ,L.id_tipo_linea  FROM
			cu_anag.linee l 
			inner join cu_anag.stabilimenti s on l.id_stabilimento =s.id 
			inner join agenda.vw_tipo_linee vtl on l.id_tipo_linea =vtl.id_tipo_linea 
			inner join  (
			  select 	*	from dblink('bdn_fvg','select   codice_gruppo_specie, descrizione_gruppo_specie from bdn_types.vw_specie vs  ')T 
			  (codice_gruppo_specie text,descrizione_gruppo_specie text) )
				grps on  'GS-'||LTRIM( grps.codice_gruppo_specie::TEXT,'0') =  vtl.cod
			where s.id  =v_id_stab_impresa  and id_esterno =codice_azienda  and    codice_gruppo_specie=trim(cod_gruppo_specie)
			) PP		
            where   l.id_stabilimento =PP.id_stabilimento AND L.id_tipo_linea =PP.id_tipo_linea
			returning * into R_L;
		    n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_L,'U');
		
 	    end if;  
 		  
 	    raise info 'fine';
	    ret.esito:=true;	
      --ret:=cu_ui.build_ret(ret,proc_name,'operazione_conclusa');
	    ret.info='0';
	    return ret;
	

END;
$$;


ALTER FUNCTION cu_anag.ins_upd_linea(v json, id_transazione bigint) OWNER TO postgres;

--
-- Name: load_import_anagrafica(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_import_anagrafica(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	proc_name varchar;
	ret cu_types.result_type; 
	R_IMP cu_anag.import_anagrafica;
	idImportI bigint;
	tipoP  text;
	data_estr_fileP date;
	esitoL boolean;
   	r5 record;
    v1 json;
    LOG_FILE varchar;
    log_string varchar;
     
	begin
		  proc_name:='cu_anag.load_import_anagrafica';
	      LOG_FILE:='/tmp/load_import_anagrafica'||CURRENT_DATE ;
	      LOG_FILE:=REPLACE(LOG_FILE, ' ', '_');
	 	  raise info 'LOG_FILE%',LOG_FILE;
	
	 			   
			
		 
		 
		 
		
		  tipoP:=v->>'tipo'::text;
		  data_estr_fileP:=v->>'data_estr_file';
		  raise info 'tipo%', tipoP;
		  raise info 'data_estr_fileP%', data_estr_fileP;
		 INSERT INTO cu_anag.import_anagrafica ( data_inserimento, tipo,data_estr_file ) VALUES(now(),tipoP ,data_estr_fileP)   returning * into R_IMP;
		
		  idImportI:=R_IMP.id;
	 	  raise info 'idImport%', idImportI;
	 	 
	 	 
	      log_string := 'id import :'||idImportI ;
		  raise info '%',log_string;
 	  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_STRING|| '>>' || LOG_FILE ||''''; 
	 
 		  
	 	  v1 :='{"id_import":'|| idImportI ||',"tipoStrCod":"'|| tipoP ||'"}';
	  	   log_string := 'v1'||v1 ;
		  raise info '%',log_string;
		  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_STRING|| '>>' || LOG_FILE ||''''; 

	
		 
		 if 	(tipoP = '852I' or tipoP = 'AAE'  or tipoP = '853' or tipoP = '1069')THEN
	--	 if(tipoP = '19' or tipoP = '20'  or tipoP = '21' or tipoP = '22'  )then
	
		 
	 
		 	  raise info 'primo if' ;
	          insert into cu_anag.file_xls_sintesis
	          (stato_sede_operativa, approval_number, denominazione_sede_operativa, ragione_sociale_impresa, partita_iva, codice_fiscale, indirizzo, comune, sigla_provincia, provincia, regione, cod_ufficio_veterinario, ufficio_veterinario, attivita, stato_attivita, descrizione_sezione, data_inizio_attivita, data_fine_attivita, tipo_autorizzazione, imballaggio, paesi_abilitati_export, remark, species, informazion_aggiuntive,idimport,id )
			  select  stato_sede_operativa, approval_number, denominazione_sede_operativa, ragione_sociale_impresa,
			  case when (partita_iva !=null and partita_iva='-' and codice_fiscale!=null and codice_fiscale!='-') 
			       then codice_fiscale else partita_iva end partita_iva,
			  case when (partita_iva !=null and partita_iva!='-' and codice_fiscale!=null and codice_fiscale='-') 
			       then partita_iva else codice_fiscale end codice_fiscale,
			  indirizzo, comune, sigla_provincia, provincia, regione, cod_ufficio_veterinario, ufficio_veterinario, attivita, 
			  stato_attivita, descrizione_sezione,     case when length(data_inizio_attivita) >0 then TO_TIMESTAMP(data_inizio_attivita, 'DD-MM-YYYY' )  else null end data_inizio_attivita  ,
	 		  case when length(data_fine_attivita) >0 then TO_TIMESTAMP(data_fine_attivita, 'DD-MM-YYYY' )  else null end data_fine_attivita, tipo_autorizzazione, imballaggio, paesi_abilitati_export, remark, species, informazion_aggiuntive, idImportI, nextval('cu_anag.import_id_seq')
		      from (
			 
			   select * from 
			   json_populate_recordset(null::record,v->'lista') as 
			   ( stato_sede_operativa varchar, approval_number varchar, denominazione_sede_operativa varchar, ragione_sociale_impresa varchar, partita_iva varchar,
			   codice_fiscale varchar, indirizzo varchar, comune varchar, sigla_provincia varchar, provincia varchar, regione varchar, cod_ufficio_veterinario varchar, 
			   ufficio_veterinario varchar, attivita varchar, stato_attivita varchar, descrizione_sezione varchar, data_inizio_attivita varchar ,
			   data_fine_attivita varchar , tipo_autorizzazione varchar, imballaggio varchar, paesi_abilitati_export varchar, remark  varchar, species varchar, informazion_aggiuntive varchar)
			
			   
		 	  )b;
		 	  raise info ' load_stabilimenti_sintesis' ;
		 	  
	     	  select * into r5 from 	cu_anag.load_stabilimenti_sintesis(  v1,idtransazione);
		  	  esitoL=r5.esito;
		 	  
		 else  
			 if(tipoP = '183' ) THEN
			--  delete from cu_anag.file_xls_mangimifici where file_xls_mangimifici.id=idImportI;
	
	 	
	          INSERT INTO cu_anag.file_xls_mangimifici
				( settore, ragione_sociale, rappresentante_legale, codice_fiscale, partita_iva, indirizzo_sede_legale, asl_di_competenza, indirizzo_sede_produttiva,
				comune, prov, regione, numero_di_registrazione_cun, denominazione_sede, data_inizio_attivita, data_fine_attivita, codice_norma, riconosciuta_registrata, 
				numero_di_registrazione_riconoscimento, data_notifica_registrazione, codice_sezione, sezione, codice_attivita, descrizione_attivita, dettaglio_attivita, 
				remarks, stato, data_inizio, attivita_principale, vendita_diretta, note,idimport,id )
	 		  select  settore, ragione_sociale, rappresentante_legale, 
			  case when (partita_iva !=null and partita_iva!='-' and codice_fiscale!=null and codice_fiscale='-') 
			       then partita_iva else codice_fiscale end codice_fiscale,
		      case when (partita_iva !=null and partita_iva='-' and codice_fiscale!=null and codice_fiscale!='-') 
			       then codice_fiscale else partita_iva end partita_iva,
	 		  indirizzo_sede_legale, asl_di_competenza, indirizzo_sede_produttiva, comune, prov, regione,
	 		  numero_di_registrazione_cun, denominazione_sede, case when length(data_inizio_attivita) >0 then TO_TIMESTAMP(data_inizio_attivita, 'DD-MM-YYYY' ) else null end data_inizio_attivita,
	 		  case when length(data_fine_attivita) >0 then TO_TIMESTAMP(data_fine_attivita, 'DD-MM-YYYY' ) else null end data_fine_attivita, codice_norma, riconosciuta_registrata, 
	 		  numero_di_registrazione_riconoscimento, TO_TIMESTAMP(data_notifica_registrazione, 'DD-MM-YYYY' ), codice_sezione, sezione, codice_attivita, descrizione_attivita, dettaglio_attivita, remarks, stato, 
	 		  case when length(data_inizio) >0 then  TO_TIMESTAMP(data_inizio, 'DD-MM-YYYY' )  else null end data_inizio, attivita_principale, 
	 		  vendita_diretta, note, idImportI, nextval('cu_anag.import_id_seq')
		      from (
			 
			   select * from 
			   json_populate_recordset(null::record,v->'lista') as 
		   	   (settore varchar ,ragione_sociale varchar ,rappresentante_legale varchar ,codice_fiscale varchar ,partita_iva varchar ,	indirizzo_sede_legale varchar ,	
		   	   asl_di_competenza varchar ,	indirizzo_sede_produttiva varchar ,	comune varchar ,prov varchar ,	regione varchar ,numero_di_registrazione_cun varchar ,	
		   	   denominazione_sede varchar ,data_inizio_attivita varchar  ,	data_fine_attivita varchar  ,codice_norma varchar ,	
		   	   riconosciuta_registrata varchar ,numero_di_registrazione_riconoscimento varchar ,	data_notifica_registrazione varchar ,codice_sezione varchar ,
		   	   sezione varchar ,codice_attivita varchar ,descrizione_attivita varchar ,dettaglio_attivita varchar ,remarks varchar ,stato varchar ,data_inizio varchar   ,
		   	   attivita_principale varchar ,	vendita_diretta varchar ,note varchar )
			   
		 	   )b;
		  
		 	  END IF;
		 	  	  raise info ' load_stabilimenti_mangimifici' ;
		 	  	 
		 	  	 
	 	 	     select * into r5 from 	cu_anag.load_stabilimenti_mangimifici(  v1,idtransazione);
		 	     esitoL=r5.esito;
		 	 
		 end if;
	 
	 	update     cu_anag.import_anagrafica  set esito=esitoL where id=idImportI;
	

		 ret.esito:=esitoL;
	 	 return ret;
	end;
end;
$$;


ALTER FUNCTION cu_anag.load_import_anagrafica(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: load_new_stabilimenti(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_new_stabilimenti() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $_$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	begin
		
		truncate table  cu_anag.imprese;
		truncate table  cu_anag.indirizzi;
		truncate table  cu_anag.linee;
		truncate table  cu_anag.soggetti_fisici;
		truncate table  cu_anag.stabilimenti;
		truncate table  cu_anag.stabilimento_figure;
		truncate table  cu_anag.stabilimento_sedi;
		truncate table  cu_anag.soggetti;
	
		/* SICER */
		raise notice '1 - Caricamento imprese chiave sd_id';
		insert into  cu_anag.imprese
		select nextval('cu_anag.cu_anag_id_seq') id ,
			 impresa_ragione_sociale,impresa_cf,impresa_piva,impresa_pec,
			impresa_email ,impresa_sdi ,impresa_split_payment ,
			impresa_tipo_persona ,impresa_id,impresa_cod_aziendale ,null az_cod_regionale,
			a.stabilimento_id as sd_id,tipo_ab='A','SICER_'||tipo_ab
							
			from cu_anag.vw_gisa_imprese_completa_ab a -- 15286
			--join cu_anag.vw_fvg_gisa_imprese_all i on a.stabilimento_id =i.sd_id
			where 
			upper(impresa_tipo_figura_descr) in ('SEDE LEGALE');
		
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '2 - Caricamento STABILIMENTI';

		insert into cu_anag.stabilimenti
			select  nextval('cu_anag.cu_anag_id_seq') ,ni.id,
					stabilimento_denominazione nome,
					stabilimento_id,0,stabilimento_codice_regionale,stabilimento_cod_tipologia_struttura,tipo_ab='A',tipo_ab
			 from cu_anag.vw_gisa_imprese_completa_ab a
			 join cu_anag.imprese ni on ni.sd_id=a.stabilimento_id
			 --join cu_anag.vw_fvg_gisa_imprese_all i on a.stabilimento_id =i.sd_id
			where upper(impresa_tipo_figura_descr) in ('SEDE LEGALE');
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	

		raise notice '3 - Caricamento STABILIMENTI-INDIRIZZO';
		insert into cu_anag.indirizzi 
		select  s.id id,stabilimento_indirizzo_toponimo toponimo,
			stabilimento_indirizzo indirizzo,
			'' cap,
			stabilimento_indirizzo_provincia prov_stato,
			'' nazione,
			stabilimento_indirizzo_istat_comune istat_comune,
			c.denominazione_it::varchar comune,
			'' localita,
			stabilimento_indirizzo_civico civico,
			stabilimento_latitudine latitudine,
			stabilimento_longitudine longitudine,
			c.id is not null verificato,'SICER_'||a.tipo_ab fonte
		from cu_anag.vw_gisa_imprese_completa_ab a 
		join cu_anag.stabilimenti s on a.stabilimento_id =s.sd_id 
		left join conf_ext.vw_comuni_vigenti_attivi c on c.codistat =a.stabilimento_indirizzo_istat_comune::integer ;


	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 				
		update cu_anag.stabilimenti set id_indirizzo=id;

 	
		raise notice '4 - tipi figura';
		delete from cu_types.tipi_figura;
		insert into  cu_types.tipi_figura
		select row_number() over()  , descr cod,descr sigla, descr from  
		(select distinct fg_tipo_figura_descr descr from cu_anag.vw_fvg_gisa_imprese_all
		where fg_tipo_figura_descr is not null and fg_tipo_figura_descr not ilike 'sede%') a;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '5 - tipi sede indirizzi';
	
	
		insert into cu_anag.indirizzi
			select distinct -i.id*10-1,fg_an_res_toponimo toponimo,		fg_an_res_indirizzo indirizzo,fg_an_res_cap,
			fg_an_res_provincia prov_stato, null nazione,	
			fg_an_res_istat comune,
			fg_an_res_comune comune, null localita,
			fg_an_res_civico civico ,null,null, s.verificato,s.fonte
		from cu_anag.vw_fvg_gisa_imprese_all i 
		join cu_types.tipi_sede ts on upper(ts.descr) =upper(i.fg_tipo_figura_descr)
		join cu_anag.stabilimenti s on s.sd_id =i.sd_id ;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '6 - stabilimento sedi';

		insert into cu_anag.stabilimento_sedi 
		select nextval('cu_anag.cu_anag_id_seq'),ns.id,ts.id,-i.id*10-1,		i.fg_an_cf cf,i.fg_an_iva piva,
		i.fg_an_pec pec,i.fg_an_email email,i.fg_an_sdi sdi,i.fg_an_split_payment split_payement,i.fg_an_tipo_persona cod_tipo_impresa,
		i.id old_id,ns.fonte
		from cu_anag.vw_fvg_gisa_imprese_all i
		join cu_anag.stabilimenti ns on ns.sd_id =i.sd_id 
		--join cu_anag.stabilimenti s on i.sd_id=s.sd_id
		join cu_types.tipi_sede ts on upper(ts.descr) =upper(i.fg_tipo_figura_descr);
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
	
		raise notice '7 - soggetti_fisici';

 	
 		insert into cu_anag.soggetti_fisici 
			select nextval('cu_anag.cu_anag_id_seq') id,null,cognome,nome, codice_catastale_nascita,codice_fiscale,sesso,telefono,email,pec,null,
			data_nascita_fiscale::date,documento,null,cu_anag.check_cf(codice_fiscale),'SICER' from conf_ext.vw_soggetti_fisici_fvg ;
			
		/*insert into cu_anag.soggetti_fisici 
			select nextval('cu_anag.cu_anag_id_seq') id, null,null,s.nome,s.comune_nascita,s.codice_fiscale,
				null sesso,null telefono,null email,null pec,null telefono2,s.data_nascita,null documento_identita,null indirizzo_id,
				from (
				select distinct on (upper(fg_an_cf)) fg_an_cf codice_fiscale,upper(fg_an_nome) nome,fg_an_data_nascita data_nascita,substr(fg_an_cf,12,4) comune_nascita
				from cu_anag.vw_fvg_gisa_imprese_all
				where length(fg_an_cf)=16 and fg_an_data_nascita is not null and fg_an_nome is not null and fg_an_data_nascita != '1900-01-01'
				order by upper(fg_an_cf),length(fg_an_nome),fg_an_data_nascita desc) s;*/

 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '8 - indirizzi';
		insert into cu_anag.indirizzi
			select distinct -i.id*10-2,fg_an_res_toponimo toponimo,		fg_an_res_indirizzo indirizzo,fg_an_res_cap,
			fg_an_res_provincia prov_stato, null nazione,	
			fg_an_res_istat comune,
			fg_an_res_comune comune, null localita,
			fg_an_res_civico civico ,null,null, s.verificato,s.fonte
		from cu_anag.vw_fvg_gisa_imprese_all i 
		join cu_anag.stabilimenti s on s.sd_id =i.sd_id 
		join cu_types.tipi_figura tf on upper(tf.descr) =upper(i.fg_tipo_figura_descr)
		join cu_anag.soggetti_fisici sf on sf.codice_fiscale =fg_an_cf
		where length(fg_an_cf)=16;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
		
		raise notice '9 - stabilimento figure';

		insert into cu_anag.stabilimento_figure  
			select i.id ,ns.id id_stabilimento,sf.id id_soggetto_fisico,tf.id id_tipo_figura,-i.id*10-2 id_indirizzo,i.id old_id,ns.fonte
			from cu_anag.vw_fvg_gisa_imprese_all i 
			join cu_anag.stabilimenti ns on ns.sd_id =i.sd_id 
			join cu_types.tipi_figura tf on upper(tf.descr) =upper(i.fg_tipo_figura_descr)
			join cu_anag.soggetti_fisici sf on sf.codice_fiscale =fg_an_cf
			join cu_anag.stabilimenti s on s.sd_id = i.sd_id
			where length(fg_an_cf)=16;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '10 - linee PRINCIPALI';

		insert into cu_anag.linee
		select nextval('cu_anag.cu_anag_id_seq') id,s.id id_stabilimento,tl.id id_tipo_linea ,tsrange(linea_data_inizio,linea_data_fine,'[)') validita,
		attivita_fissa,linea_principale=1 linea_principale,i.tipo_ab='A' verificato, 'SICER_'||i.tipo_ab as fonte --from cu_anag.linee
		from cu_anag.vw_gisa_imprese_completa_ab i 
		join cu_anag.stabilimenti s on s.sd_id=i.stabilimento_id
		join agenda.vw_tipo_linee tl ON tl.cod_mod  = i.linea_ateco ;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '11 - linee secondarie';
		insert into cu_anag.linee
			select nextval('cu_anag.cu_anag_id_seq') id,s.id id_stabilimento,tl.id id_tipo_linea ,tsrange(linea_data_inizio,linea_data_fine,'[)') validita,
		true,false linea_principale,true verificato, 'SICER_A' as fonte
		from conf_ext.vw_gisa_imprese_linee_secondarie_a i 
		join cu_anag.stabilimenti s on s.sd_id=i.stabilimento_id
		join agenda.vw_tipo_linee tl ON tl.cod_mod  = i.linea_ateco ;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
 		
 	
 		/* 852integratori853AAE */
		update cu_anag."852integratori853AAE" a
		set id=s.rn
		from 
		(select  approval_number ,attivita,descrizione_sezione,row_number() over () rn from cu_anag."852integratori853AAE") s
		where a.approval_number=s.approval_number and a.attivita=s.attivita and a.descrizione_sezione=s.descrizione_sezione;
		
		raise notice '12 - imprese 852integratori853AAE';
		insert into cu_anag.imprese
				select nextval('cu_anag.cu_anag_id_seq'),a.ragione_sociale_impresa,a.codice_fiscale,a.partita_iva,
	 	null,null,null,null,a.fg_an_tipo_persona,-a.az_id*10-4,null,null,-a.az_id*10-4,true,a.tipo 
	 	from(select distinct a.ragione_sociale_impresa,a.codice_fiscale,a.partita_iva,
	 	i.fg_an_tipo_persona,a.az_id,a.tipo
	 	from cu_anag.vw_852integratori853AAE_imprese a
	 	 	left join cu_anag.vw_fvg_gisa_imprese_all i on a.partita_iva  =i.az_an_iva and 
			upper(fg_tipo_figura_descr) in ('SEDE LEGALE')and az_cod_aziendale ilike 'CE%') a;
		--(select ragione_sociale_impresa,codice_fiscale,partita_iva,
	 	--tipo,approval_number,min(id) az_id from cu_anag."852integratori853AAE" group by 1,2,3,4,5) a;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;	 

	 	/*insert into cu_anag.soggetti select id,'I' from cu_anag.imprese
	 	where fonte in ('852integratori','853','AAEE');
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;	 */
	 

  
 	    raise notice '13 - stabilimenti 852integratori853AAE';
		insert into cu_anag.stabilimenti
		select nextval('cu_anag.cu_anag_id_seq'),id_impresa,denominazione_sede_operativa,-sd_id*10-4,-sd_id*10-4,approval_number,cod_tipologia_struttura,true, fonte
		from (
			select distinct on (a.approval_number) i.id id_impresa,a.denominazione_sede_operativa,a.approval_number,tipo fonte,/*min(a.id) */a.id sd_id,
			gi.sd_cod_tipologia_struttura cod_tipologia_struttura
			from cu_anag."852integratori853AAE" a
			left join cu_anag.imprese i  on i.nome=a.ragione_sociale_impresa and i.cf=a.codice_fiscale and i.piva=a.partita_iva
			left join cu_anag.vw_fvg_gisa_imprese_all gi on gi.az_cod_aziendale =a.approval_number 
			order by a.approval_number,a.id
		) t;
	 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
	
		 raise notice '14 - indirizzi 852integratori853AAE';
	 	insert into cu_anag.indirizzi
	 	select -id*10-4,null,a.indirizzo,null,a.sigla_provincia,null,a.codistat,a.comune,null,null,null,null,true,fonte from
	 	(select indirizzo,case when c.codistat is null then a.comune else null end comune,sigla_provincia,c.codistat,tipo fonte,min(a.id) id
	 	from cu_anag."852integratori853AAE" a 
		left join conf_ext.vw_comuni_vigenti_attivi  c on a.comune=c.denominazione_it 
		where a.id in (select (sd_id+4)/-10 from cu_anag.stabilimenti where fonte not like 'SICER%' )
		group by 1,2,3,4,5
		) a;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe   caricate %',total_rows;
	

 	
		raise notice '15 - linee 852integratori853AAE';
		insert into cu_anag.linee
			select nextval('cu_anag.cu_anag_id_seq') id,
			s.id id_stabilimento,tl.id id_tipo_linea ,
			tsrange(data_inizio_attivita::timestamp,
				case when replace(data_fine_attivita,'-','')='' then null::timestamp else replace(data_fine_attivita,'-','')::timestamp end,'[)') validita,
			true,false linea_principale,true,i.tipo
			from cu_anag."852integratori853AAE" i 
			join cu_anag.stabilimenti s on i.approval_number=s.sd_cod_regionale
			--join cu_anag.imprese im on im.id=s.id_impresa
			join agenda.vw_tipo_linee tl ON 
				case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP' then 
				'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
					when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI' then
				'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
					else upper(translate(tl.descr,' -','')) end=upper(translate(i.attivita||i.descrizione_sezione,' -',''));
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
 	 		/* MANGIMIFICI */
 		update cu_anag.mangimifici_reg a
		set id=s.rn
		from 
		(select  distinct cun ,dettaglio_attivita,num_ric_reg  , row_number() over () rn from cu_anag.mangimifici_reg) s
		where a.cun=s.cun and a.dettaglio_attivita=s.dettaglio_attivita and a.num_ric_reg=s.num_ric_reg;
		
		raise notice '24 - imprese mangimifici_reg';

		insert into cu_anag.imprese
		select nextval('cu_anag.cu_anag_id_seq'),a.ragione_sociale,a.cf,a.piva,
	 	null,null,null,null,case when piva=cf and length(piva)=16 then 'P' else 'D' end,
	 	-a.az_id*10-7,null,null,-a.az_id*10-7,true,'MANG'
	 	from cu_anag.vw_mangimifici_reg_imprese a;
		--(select ragione_sociale_impresa,codice_fiscale,partita_iva,
	 	--tipo,approval_number,min(id) az_id from cu_anag."852integratori853AAE" group by 1,2,3,4,5) a;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;	
 	
	 	/*raise notice '25 - soggetti mangimifici_reg';
	 	insert into cu_anag.soggetti select id,'I' from cu_anag.imprese
	 	where fonte in ('MANG');
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;	*/ 
	 

		raise notice '27 - stabilimenti mangimifici_reg';
		delete from cu_anag.stabilimenti where fonte='MANG';
	
		insert into cu_anag.stabilimenti
		select nextval('cu_anag.cu_anag_id_seq'),id_impresa,denominazione_sede,-sd_id*10-7,-sd_id*10-7,cun,cod_tipologia_struttura,true, 'MANG'
		from (
		select i.id id_impresa,case when a.denominazione_sede is null or trim(a.denominazione_sede) ='' then a.ragione_sociale
			else denominazione_sede  end denominazione_sede,a.cun,
			'MANG' fonte,gi.sd_cod_tipologia_struttura cod_tipologia_struttura,min(a.id) sd_id 
		from cu_anag.mangimifici_reg a left join cu_anag.imprese i  on (i.piva=a.piva and i.cf=a.cf and i.nome=a.ragione_sociale) and i.fonte='MANG'
		left join cu_anag.vw_fvg_gisa_imprese_all gi on gi.az_cod_aziendale =a.cun
		group by 1,2,3,4,5
		) t;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
 		 	raise notice '26 - indirizzi mangimifici_reg';
	 	insert into cu_anag.indirizzi
	 	select -id*10-7,null,a.indirizzo_sede_produttiva,null,null,null,null,null,null,null,null,null,true,'MANG' from
		cu_anag.mangimifici_reg a
		where id in (select (id+7)/-10 from cu_anag.stabilimenti where fonte='MANG');
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
 	
 	
		raise notice '28 - linee mangimifici_reg';
	
		insert into cu_anag.linee
			select nextval('cu_anag.cu_anag_id_seq') id,
			s.id id_stabilimento,tl.id id_tipo_linea,
			tsrange(
				case when m.data_inizio='' then null::timestamp else data_inizio::timestamp end,null::timestamp,'[)') validita,
			true,false linea_principale,true,'MANG'
			from cu_anag.mangimifici_reg m 
			join cu_anag.stabilimenti s on m.cun= s.sd_cod_regionale
			join cu_anag.imprese i on i.id=s.id_impresa and  (i.piva=m.piva and i.cf=m.cf) and i.fonte='MANG'
			join agenda.vw_tipo_linee tl ON 
				left(m.dettaglio_attivita,3) = substring(tl.descr from '^\[.*\] (M[0-9][0-9])')
				and tl.descr ~ '^\[.*\] M[0-9][0-9].*$';
			
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;	
 	
 	
 	
 		return ret;	
		/* BDN */
 		raise notice '16 - BDN_PROP_AZ';

		insert into cu_anag.imprese
		select nextval('cu_anag.cu_anag_id_seq') ,
		id_fiscale_prop,cf,piva,
		null,null,null,
		null,null,null,
		null,null,(-id_azienda)*10-1,true,
		'BDN_PROP_AZ'
		from dblink('bdn_fvg','select id_fiscale_prop,
		case when length(id_fiscale_prop) =16 then id_fiscale_prop else null end cf,
		case when length(id_fiscale_prop)!=16 then id_fiscale_prop else null end piva,min(id_azienda::bigint) id_azienda
		from bdn.vw_aziende group by 1,2,3')
		T(id_fiscale_prop varchar,cf varchar,piva varchar,id_azienda bigint);	
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '17 - BDN_PROP_ALL';


		insert into cu_anag.imprese
		select 
		nextval('cu_anag.cu_anag_id_seq') ,
		case when cf is null then piva else cf end name,cf,piva,
		null,null,null,
		null,case when length(cf)=16 then 'P' else 'S' end
		,null,
		null,null,(-id_allevamento*10)-2,true,
		'BDN_PROP_ALL'
		from dblink('bdn_fvg','select 
		case when length(trim(cf_proprietario))<16 then null								 else cf_proprietario end cf,
		case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else null end piva,
		min(id_allevamento::bigint) id_allevamento
		from bdn.vw_allevamenti group by 1,2')
		T(cf varchar,piva varchar,id_allevamento bigint);

 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '18 - BDN_DET_ALL Detentore'; --

		insert into cu_anag.imprese
		select nextval('cu_anag.cu_anag_id_seq') ,
		case when cf is null then piva else cf end name,cf,piva,
		null,null,null,
		null,null,null,
		null,null,(-id_allevamento)*10-3,true,
		'BDN_DET_ALL'
		from dblink('bdn_fvg','select 
		case when length(cf_detentore) =16 then cf_detentore else null end cf,
		case when length(cf_detentore) !=16 then cf_detentore else null end piva,min(id_allevamento::bigint) id_azienda
		from bdn.vw_allevamenti group by 1,2')
		T(cf varchar,piva varchar,id_allevamento bigint);

 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '19 - BDN_IND_AZ';

		insert into cu_anag.indirizzi
		select T.id,null,indirizzo_azienda,cap_azienda,null,null,c.codistat,null,null,null,
			latitudine,longitudine,true,'BDN_IND_AZ'
			from dblink('bdn_fvg','select -id*10-6 id,indirizzo_azienda,cap_azienda,cod_comune_azienda,
			case when prov_sede_azienda is null then substring(cod_azienda,4,2) else prov_sede_azienda end prov_sede_azienda, 
			latitudine,longitudine
			from bdn.vw_aziende')
		  T(id int8,indirizzo_azienda varchar,cap_azienda varchar,cod_comune_azienda varchar,prov_sede_azienda varchar ,latitudine float8,longitudine float8) 
		 left join conf_ext.vw_comuni_vigenti_attivi c on right(lpad(c.codistat::varchar,6,'0'),3)=T.cod_comune_azienda and c.siglaprovincia=prov_sede_azienda;

 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '20 - BDN_AZ';

		insert into cu_anag.stabilimenti
		select nextval('cu_anag.cu_anag_id_seq') , a.* from(
		select i.id,cod_azienda,T.id,(-T.id)*10-6,cod_azienda,'ZTC',true,'BDN_AZ'
			from dblink('bdn_fvg','select cod_azienda,-id*10-6 id,id_fiscale_prop from bdn.vw_aziende')
			T(cod_azienda varchar,id bigint,id_fiscale_prop varchar) join cu_anag.imprese i 
			on i.fonte='BDN_PROP_AZ' and (T.id_fiscale_prop=i.cf or T.id_fiscale_prop=i.piva)) a;
		

 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '21 - BDN_ALL';

		insert into cu_anag.stabilimenti
		select nextval('cu_anag.cu_anag_id_seq') , a.* from(
		select distinct
		 i.id,T.nome,(-T.id)*10-5,(-T.id)*10-5,account_number,gi.sd_cod_tipologia_struttura,true,'BDN_ALL'
			from dblink('bdn_fvg','select distinct min(name) nome,account_number,id,
				case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else cf_proprietario end piva
				from bdn.vw_allevamenti
				group by 2,3,4')
			T(nome varchar,account_number varchar,id bigint,cf_proprietario varchar)
			join cu_anag.imprese i 
			on i.fonte='BDN_PROP_ALL' and (T.cf_proprietario=i.cf or T.cf_proprietario=i.piva)
			left join cu_anag.vw_fvg_gisa_imprese_all gi on 
			gi.az_cod_aziendale =T.account_number and T.cf_proprietario=gi.sd_an_dato_fiscale
			and upper(fg_tipo_figura_descr) in ('SEDE LEGALE')) a;

 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '22 - BDN_DET Detentore';

		insert into cu_anag.stabilimento_figure
		select nextval('cu_anag.cu_anag_id_seq') ,
		 --i.id,T.nome,null,id_azienda*10+6,account_number,true,'BDN_ALL'
		s.id,sg.id,5,null,null,'BDN_DET'
			from dblink('bdn_fvg','select distinct min(name) nome,account_number,id_azienda,
				case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else cf_proprietario end piva_prop,
				case when length(trim(cf_detentore))   <16 then lpad(trim(cf_detentore),11,''0'')    else cf_detentore    end piva_det from bdn.vw_allevamenti
				group by 2,3,4,5')
			T(nome varchar,account_number varchar,id_azienda bigint,piva_prop varchar,piva_det varchar)
			join cu_anag.imprese i on i.cf=piva_prop or i.piva=piva_prop
			join cu_anag.stabilimenti s on s.fonte='BDN_ALL' and s.sd_cod_regionale=T.account_number and s.id_impresa=i.id
			join cu_anag.imprese sg on sg.piva=T.piva_det;

 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
	/*	raise notice '25 - BDN_DET Detentore';
		insert into cu_anag.stabilimento_figure
		select nextval('cu_anag.cu_anag_id_seq') ,
		 --i.id,T.nome,null,id_azienda*10+6,account_number,true,'BDN_ALL'
		s.id,sg.id,5,null,null,'BDN_DET'
			from dblink('bdn_fvg','select distinct min(name) nome,account_number,id_azienda,
				case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else cf_proprietario end piva_prop,
				case when length(trim(cf_detentore))   <16 then lpad(trim(cf_detentore),11,''0'')    else cf_detentore    end piva_det from bdn.vw_allevamenti
				group by 2,3,4,5')
			T(nome varchar,account_number varchar,id_azienda bigint,piva_prop varchar,piva_det varchar)
			join cu_anag.imprese i on i.cf=piva_prop or i.piva=piva_prop
			join cu_anag.stabilimenti s on s.fonte='BDN_ALL' and s.sd_cod_regionale=T.account_number and s.id_impresa=i.id
			join cu_anag.soggetti_fisici  sg on sg.codice_fiscale=T.piva_det;


 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;*/
 	
		raise notice '23 - BDN_LIN';

		insert into cu_anag.linee
		select nextval('cu_anag.cu_anag_id_seq') ,
		 --i.id,T.nome,null,id_azienda*10+6,account_number,true,'BDN_ALL'
		s.id id_stabilimento,tl.id_tipo_linea,tsrange(null::timestamp,null::timestamp,'()'),true,false,true,'BDN_LIN'
			from dblink('bdn_fvg','select account_number,
				case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else cf_proprietario end piva_prop,
		specie_allev,tipologia_strutt,orientamento_prod,descrizione_tipo_produzione
				from bdn.vw_allevamenti')
			T( account_number varchar, piva_prop varchar,specie_allev varchar,tipologia_strutt varchar,orientamento_prod varchar,descrizione_tipo_produzione varchar)
			left join agenda.vw_tipo_linee tl on tl.cod=LTRIM(T.specie_allev,'0')||' - '||tipologia_strutt||' - '||coalesce(orientamento_prod,descrizione_tipo_produzione)
			join cu_anag.stabilimenti s on s.sd_cod_regionale=T.account_number
			join cu_anag.imprese      i on s.id_impresa=i.id and (i.cf=T.piva_prop or i.piva=T.piva_prop) and i.fonte = 'BDN_PROP_ALL';
 	
 	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
 		--alter table cu_anag.mangimifici_reg add column id bigint;
 	

	
	
 	
		update cu_anag.indirizzi i
			set istat_comune=s.codistat
			from (
			select i.id,c.codistat from cu_anag.indirizzi i
			join conf_ext.vw_comuni_vigenti_attivi c on left(upper(translate(c.denominazione_it,' -''','')),13) =
													    left(upper(translate(i.comune,' -''','')),13) ) s
			where istat_comune is null and i.id=s.id;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set comune = null
		where lpad(istat_comune,6,'0')  in (select lpad(codistat::varchar,6,'0') from conf_ext.vw_comuni_vigenti_attivi vcva);
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set comune = null,istat_comune =lpad(codistat::varchar,6,'0')
		from (select codistat,denominazione_it from conf_ext.vw_comuni_vigenti_attivi) s
		where comune is not null and comune=s.denominazione_it;
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set comune = null,istat_comune =lpad(codistat::varchar,6,'0')
		from (select codistat,denomtraslitterata from conf_ext.vw_comuni_vigenti) s
		where comune is not null and comune=s.denomtraslitterata;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set nazione=comune,istat_comune=null where nazione is null and istat_comune='000000';
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set cap=null where cap='00000';
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set stato_prov=null where stato_prov='00'; 
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set stato_prov=null where istat_comune is not null; 
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
	 return ret;
	end;
	END;
$_$;


ALTER FUNCTION cu_anag.load_new_stabilimenti() OWNER TO postgres;

--
-- Name: load_new_stabilimenti_bdn(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_new_stabilimenti_bdn() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	begin
		
		delete from  cu_anag.imprese where fonte ilike 'BDN%';
		delete from  cu_anag.indirizzi where fonte ilike 'BDN%';
		delete from  cu_anag.linee where fonte ilike 'BDN%';
		delete from  cu_anag.soggetti_fisici where fonte ilike 'BDN%';
		delete from  cu_anag.stabilimenti where fonte ilike 'BDN%';
		delete from  cu_anag.stabilimento_figure where fonte ilike 'BDN%';
		delete from  cu_anag.stabilimento_sedi where fonte ilike 'BDN%';

		/* BDN */
 		raise notice 'BDN 1 - BDN_PROP_AZ Proprietario Azienda zootecnica';

		insert into cu_anag.imprese
		select nextval('cu_anag.cu_anag_id_seq') ,
		id_fiscale_prop,cf,piva,
		null,null,null,
		null,null,null,
		null,null,(-id_azienda)*10-1,true,
		'BDN_PROP_AZ'
		from dblink('bdn_fvg','select id_fiscale_prop,
		case when length(id_fiscale_prop) =16 then id_fiscale_prop else null end cf,
		case when length(id_fiscale_prop)!=16 then id_fiscale_prop else null end piva,min(id_azienda::bigint) id_azienda
		from bdn.vw_aziende group by 1,2,3')
		T(id_fiscale_prop varchar,cf varchar,piva varchar,id_azienda bigint);	
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice 'BDN 2 - BDN_PROP_ALL Proprietario Allevamento';


		insert into cu_anag.imprese
		select 
		nextval('cu_anag.cu_anag_id_seq') ,
		case when cf is null then piva else cf end name,cf,piva,
		null,null,null,
		null,case when length(cf)=16 then 'P' else 'S' end
		,null,
		null,null,(-id_allevamento*10)-2,true,
		'BDN_PROP_ALL'
		from dblink('bdn_fvg','select 
		case when length(trim(cf_proprietario))<16 then null								 else cf_proprietario end cf,
		case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else null end piva,
		min(id_allevamento::bigint) id_allevamento
		from bdn.vw_allevamenti group by 1,2')
		T(cf varchar,piva varchar,id_allevamento bigint);

 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice 'BDN 3 - BDN_DET_ALL Detentore Allevamento'; --

		insert into cu_anag.imprese
		select nextval('cu_anag.cu_anag_id_seq') ,
		case when cf is null then piva else cf end name,cf,piva,
		null,null,null,
		null,null,null,
		null,null,(-id_allevamento)*10-3,true,
		'BDN_DET_ALL'
		from dblink('bdn_fvg','select 
		case when length(cf_detentore) =16 then cf_detentore else null end cf,
		case when length(cf_detentore) !=16 then cf_detentore else null end piva,min(id_allevamento::bigint) id_azienda
		from bdn.vw_allevamenti group by 1,2')
		T(cf varchar,piva varchar,id_allevamento bigint);

 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice 'BDN 4 - BDN_IND_AZ Indirizzo Azienda Zootecnica';

		insert into cu_anag.indirizzi
		select T.id,null,indirizzo_azienda,cap_azienda,null,null,c.codistat,null,null,null,
			latitudine,longitudine,true,'BDN_IND_AZ'
			from dblink('bdn_fvg','select -id*10-6 id,indirizzo_azienda,cap_azienda,cod_comune_azienda,
			case when prov_sede_azienda is null then substring(cod_azienda,4,2) else prov_sede_azienda end prov_sede_azienda, 
			latitudine,longitudine
			from bdn.vw_aziende')
		  T(id int8,indirizzo_azienda varchar,cap_azienda varchar,cod_comune_azienda varchar,prov_sede_azienda varchar ,latitudine float8,longitudine float8) 
		 left join conf_ext.vw_comuni_vigenti_attivi c on right(lpad(c.codistat::varchar,6,'0'),3)=T.cod_comune_azienda and c.siglaprovincia=prov_sede_azienda;

 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice 'BDN 5 - BDN_AZ Azienda Zootecnica (stabilimento)';

		insert into cu_anag.stabilimenti
		select nextval('cu_anag.cu_anag_id_seq') , a.* from(
		select i.id,cod_azienda,T.id,T.id,cod_azienda,'ZTC',true,'BDN_AZ',null
			from dblink('bdn_fvg','select cod_azienda,-id*10-6 id,id_fiscale_prop from bdn.vw_aziende')
			T(cod_azienda varchar,id bigint,id_fiscale_prop varchar) join cu_anag.imprese i 
			on i.fonte='BDN_PROP_AZ' and (T.id_fiscale_prop=i.cf or T.id_fiscale_prop=i.piva)) a;
		

 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice 'BDN 6 - BDN_ALL  Allevamento (stabilimento presso azienda zootecnica)';
	


		insert into cu_anag.stabilimenti /* una stessa persona può avere più apiari nella stessa azienda zootecnica */
		select nextval('cu_anag.cu_anag_id_seq') , a.* from(
		select distinct
		 i.id,T.nome,(-T.id)*10-5,(-T.id)*10-5,null,gi.sd_cod_tipologia_struttura,true,'BDN_ALL',account_number
			from dblink('bdn_fvg','select name nome,account_number,min(id),
				case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else cf_proprietario end piva
				from bdn.vw_allevamenti
				group by 1,2,4')
			T(nome varchar,account_number varchar,id bigint,cf_proprietario varchar)
			join cu_anag.imprese i 
			on i.fonte='BDN_PROP_ALL' and (T.cf_proprietario=i.cf or T.cf_proprietario=i.piva)
			left join cu_anag.vw_fvg_gisa_imprese_all gi on 
			gi.az_cod_aziendale =T.account_number and T.cf_proprietario=gi.sd_an_dato_fiscale
			and fg_tipo_figura_descr = 'Sede Legale') a;

 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
 	update cu_anag.stabilimenti s set id_indirizzo =q.id_indirizzo
from
(select z.sd_cod_regionale,s.cod_registrazione,s.id s_id,z.id_indirizzo from cu_anag.stabilimenti z join cu_anag.stabilimenti s
on z.sd_cod_regionale=s.cod_registrazione
where  z.fonte='BDN_AZ' and s.fonte='BDN_ALL') q
where s.id=q.s_id;
  		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe aggiornate %',total_rows;	
 	
		raise notice 'BDN 7 - BDN_DET Detentore Allevamento';
	
	
			insert into cu_anag.stabilimento_figure
		select nextval('cu_anag.cu_anag_id_seq') ,
		 --i.id,T.nome,null,id_azienda*10+6,account_number,true,'BDN_ALL'
		s.id,null,16,null,null,'BDN_DET',cf_det
			from dblink('bdn_fvg','select  min(name) nome,account_number,id_azienda,
				case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else cf_proprietario end piva_prop,
				cf_detentore from bdn.vw_allevamenti where length(trim(cf_detentore))=16
				group by 2,3,4,5')
			T(nome varchar,account_number varchar,id_azienda bigint,piva_prop varchar,cf_det varchar) --8930
			join cu_anag.imprese i on (i.cf=piva_prop or i.piva=piva_prop) and i.fonte='BDN_PROP_ALL' --8930
			join cu_anag.stabilimenti s on s.id_impresa=i.id and s.cod_registrazione=T.account_number and s.fonte='BDN_ALL';
			--join cu_anag.imprese sg on (sg.cf=piva_det or sg.piva=piva_det) and sg.fonte='BDN_DET_ALL';
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate DET %',total_rows;
		
 	
 		insert into cu_anag.stabilimento_figure
		select nextval('cu_anag.cu_anag_id_seq') ,
		s.id,null,6,null,null,'BDN_PROP',cf_prop
			from dblink('bdn_fvg','select  min(name) nome,account_number,id_azienda,
				cf_proprietario cf_prop
				from bdn.vw_allevamenti where length(trim(cf_proprietario))=16
				group by 2,3,4')
			T(nome varchar,account_number varchar,id_azienda bigint,cf_prop varchar) --8930
			join cu_anag.imprese i on (i.cf=cf_prop ) and i.fonte='BDN_PROP_ALL' --8930
			join cu_anag.stabilimenti s on s.id_impresa=i.id and s.cod_registrazione=T.account_number and s.fonte='BDN_ALL';

		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate PROP %',total_rows;
 	
		update cu_anag.stabilimento_figure sf set id_indirizzo=q.indirizzo_id
			from (
			select sf.id,p.indirizzo_id  from cu_anag.stabilimento_figure sf
			join cu_anag.soggetti_fisici p on sf.cf = p.codice_fiscale 
			where sf.fonte ilike 'BDN%' and cf is not null and length(cf)=16) q
			where sf.id=q.id;
		
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe update %',total_rows;
		
		insert into cu_anag.stabilimento_figure 
			select nextval('cu_anag.cu_anag_id_seq'),s.id,i.id,6,s.id_indirizzo ,null,'BDN_PROP',null,null 
			/*i.*,s.* */from cu_anag.stabilimenti s  join cu_anag.imprese i on i.id=s.id_impresa --7253
			where i.fonte ilike 'BDN_PRO%' and (length(i.cf)!=16 or i.cf is  null);
		
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe insert prop imprese %',total_rows;
		/*

		insert into cu_anag.stabilimento_figure
		select nextval('cu_anag.cu_anag_id_seq') ,
		 --i.id,T.nome,null,id_azienda*10+6,account_number,true,'BDN_ALL'
		s.id,sg.id,16,null,null,'BDN_DET'
			from dblink('bdn_fvg','select  min(name) nome,account_number,id_azienda,
				case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else cf_proprietario end piva_prop,
				case when length(trim(cf_detentore))   <16 then lpad(trim(cf_detentore),11,''0'')    else cf_detentore    end piva_det from bdn.vw_allevamenti
				group by 2,3,4,5')
			T(nome varchar,account_number varchar,id_azienda bigint,piva_prop varchar,piva_det varchar) --8930
			join cu_anag.imprese i on (i.cf=piva_prop or i.piva=piva_prop) and i.fonte='BDN_PROP_ALL' --8930
			join cu_anag.stabilimenti s on s.id_impresa=i.id and s.cod_registrazione=T.account_number and s.fonte='BDN_ALL'
			join cu_anag.imprese sg on (sg.cf=piva_det or sg.piva=piva_det) and sg.fonte='BDN_DET_ALL';
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
		
 	
 		insert into cu_anag.stabilimento_figure
		select nextval('cu_anag.cu_anag_id_seq') ,
		s.id,i.id,6,null,null,'BDN_PROP'
			from dblink('bdn_fvg','select  min(name) nome,account_number,id_azienda,
				case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else cf_proprietario end piva_prop
				from bdn.vw_allevamenti
				group by 2,3,4')
			T(nome varchar,account_number varchar,id_azienda bigint,piva_prop varchar) --8930
			join cu_anag.imprese i on (i.cf=piva_prop or i.piva=piva_prop) and i.fonte='BDN_PROP_ALL' --8930
			join cu_anag.stabilimenti s on s.id_impresa=i.id and s.cod_registrazione=T.account_number and s.fonte='BDN_ALL';*/

 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
	/*	raise notice '25 - BDN_DET Detentore';
		insert into cu_anag.stabilimento_figure
		select nextval('cu_anag.cu_anag_id_seq') ,
		 --i.id,T.nome,null,id_azienda*10+6,account_number,true,'BDN_ALL'
		s.id,sg.id,5,null,null,'BDN_DET'
			from dblink('bdn_fvg','select distinct min(name) nome,account_number,id_azienda,
				case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else cf_proprietario end piva_prop,
				case when length(trim(cf_detentore))   <16 then lpad(trim(cf_detentore),11,''0'')    else cf_detentore    end piva_det from bdn.vw_allevamenti
				group by 2,3,4,5')
			T(nome varchar,account_number varchar,id_azienda bigint,piva_prop varchar,piva_det varchar)
			join cu_anag.imprese i on i.cf=piva_prop or i.piva=piva_prop
			join cu_anag.stabilimenti s on s.fonte='BDN_ALL' and s.sd_cod_regionale=T.account_number and s.id_impresa=i.id
			join cu_anag.soggetti_fisici  sg on sg.codice_fiscale=T.piva_det;


 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;*/
 	
		raise notice 'BDN 8 - BDN_LIN LINEE';

		/*insert into cu_anag.linee
		select nextval('cu_anag.cu_anag_id_seq') ,
		 --i.id,T.nome,null,id_azienda*10+6,account_number,true,'BDN_ALL'
		s.id id_stabilimento,tl.id_tipo_linea,tsrange(null::timestamp,null::timestamp,'()'),true,false,true,'BDN_LIN'
			from dblink('bdn_fvg','select account_number,
				case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else cf_proprietario end piva_prop,
		specie_allev,tipologia_strutt,orientamento_prod,descrizione_tipo_produzione
				from bdn.vw_allevamenti')
			T( account_number varchar, piva_prop varchar,specie_allev varchar,tipologia_strutt varchar,orientamento_prod varchar,descrizione_tipo_produzione varchar)
			left join agenda.vw_tipo_linee tl on tl.cod=LTRIM(T.specie_allev,'0')||' - '||tipologia_strutt||' - '||coalesce(orientamento_prod,descrizione_tipo_produzione)
			join cu_anag.stabilimenti s on s.cod_registrazione=T.account_number
			join cu_anag.imprese      i on s.id_impresa=i.id and (i.cf=T.piva_prop or i.piva=T.piva_prop) and i.fonte = 'BDN_PROP_ALL';*/
		
				insert into cu_anag.linee
		select nextval('cu_anag.cu_anag_id_seq') ,
		 --i.id,T.nome,null,id_azienda*10+6,account_number,true,'BDN_ALL'
	 s.id id_stabilimento,tl.id_tipo_linea,tsrange(null::timestamp,null::timestamp,'()'),true,true,true,'BDN_LIN','2020-01-01',T.id_allevamento_bdn
			from dblink('bdn_fvg','select account_number,
				case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else cf_proprietario end piva_prop,
		specie_allev,tipologia_strutt,orientamento_prod,descrizione_tipo_produzione,name nome,id_allevamento_bdn
				from bdn.vw_allevamenti')
			T( account_number varchar, piva_prop varchar,specie_allev varchar,tipologia_strutt varchar,orientamento_prod varchar,descrizione_tipo_produzione varchar,
			nome varchar,id_allevamento_bdn varchar)
			left join agenda.vw_tipo_linee tl on tl.cod=LTRIM(T.specie_allev,'0')||' - '||tipologia_strutt||' - '||coalesce(orientamento_prod,descrizione_tipo_produzione)
			join cu_anag.stabilimenti s on s.cod_registrazione=T.account_number and T.nome=s.nome
			join cu_anag.imprese      i on s.id_impresa=i.id and (i.cf=T.piva_prop or i.piva=T.piva_prop) and i.fonte = 'BDN_PROP_ALL' 
			
			where id_tipo_linea is not null;
		
		  insert into cu_anag.linee
select nextval('cu_anag.cu_anag_id_seq'),s.id,-b.id_gruppo_specie-1000000,tsrange(null,null,'()'),true,true,s.verificato,'BDN_AZ','2020-01-01',null from dblink('bdn_fvg','select distinct account_number,id_gruppo_specie from bdn.vw_allevamenti')
	as b(account_number varchar,id_gruppo_specie bigint) 
	join cu_anag.stabilimenti s on b.account_number=s.cod_nazionale and s.id_tipologia_struttura=16;
 	
 	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 		ret:=cu_anag.load_new_stabilimenti_upd_indirizzi();
 	
 		--alter table cu_anag.mangimifici_reg add column id bigint;
 
 		 return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.load_new_stabilimenti_bdn() OWNER TO postgres;

--
-- Name: load_new_stabilimenti_mangimifici(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_new_stabilimenti_mangimifici() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	begin
		
		delete from  cu_anag.imprese where fonte ='MANG' ;
		delete from  cu_anag.indirizzi where fonte ='MANG' ;
		delete from  cu_anag.linee where fonte ='MANG' ;
		delete from  cu_anag.soggetti_fisici where fonte ='MANG' ;
		delete from  cu_anag.stabilimenti where fonte ='MANG' ;
		delete from  cu_anag.stabilimento_figure where fonte ='MANG' ;
		delete from  cu_anag.stabilimento_sedi where fonte ='MANG' ;



	
 	 		/* MANGIMIFICI */
 		update cu_anag.mangimifici_reg a
		set id=s.rn
		from 
		(select  distinct cun ,dettaglio_attivita,num_ric_reg  , row_number() over () rn from cu_anag.mangimifici_reg) s
		where a.cun=s.cun and a.dettaglio_attivita=s.dettaglio_attivita and a.num_ric_reg=s.num_ric_reg;
		
		raise notice 'MANG 1 - imprese mangimifici_reg';

		insert into cu_anag.imprese
		select nextval('cu_anag.cu_anag_id_seq'),a.ragione_sociale,a.cf,a.piva,
	 	null,null,null,null,case when piva=cf and length(piva)=16 then 'P' else 'D' end,
	 	-a.az_id*10-7,null,null,-a.az_id*10-7,true,'MANG',tsrange(null,null,'()'),'G'
	 	from cu_anag.vw_mangimifici_reg_imprese a;
		--(select ragione_sociale_impresa,codice_fiscale,partita_iva,
	 	--tipo,approval_number,min(id) az_id from cu_anag."852integratori853AAE" group by 1,2,3,4,5) a;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;	
 	
	 	/*raise notice '25 - soggetti mangimifici_reg';
	 	insert into cu_anag.soggetti select id,'I' from cu_anag.imprese
	 	where fonte in ('MANG');
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;	*/ 
	 

		raise notice 'MANG 2 - stabilimenti mangimifici_reg';
		delete from cu_anag.stabilimenti where fonte='MANG';
		insert into cu_anag.stabilimenti
		select nextval('cu_anag.cu_anag_id_seq'),id_impresa,--denominazione_sede,
		case when denominazione_sede = '' then ragione_sociale else denominazione_sede end,
		(-sd_id*10)-7,(-sd_id*10)-7,num_ric_reg,true, 'MANG',1,tsrange(null,null,'()'),cun,18,null,null,null from
		 	(select i.id id_impresa,ms.denominazione_sede,ms.cun,ms.num_ric_reg,ms.sd_id , ms.ric_reg,ragione_sociale
		 	from cu_anag.vw_mangimifici_reg_stabilimenti ms
	 		join cu_anag.imprese i on i.fonte='MANG' and ms.ragione_sociale=i.nome and ms.piva=i.piva and ms.cf=i.cf) a;
	
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
 		 	raise notice 'MANG 3 - indirizzi stabilimenti mangimifici_reg';
	 	insert into cu_anag.indirizzi
		 	select (-s.sd_id*10)-7,null,a.indirizzo_sede_produttiva,null,null,null,c.istat,coalesce(c.istat,a.comune),null,null,null,null,true,'MANG'
		 	from
			cu_anag.mangimifici_reg a join cu_anag.stabilimenti s on s.fonte='MANG' and s.sd_id=(-a.id*10)-7
			left join conf_ext.vw_comuni_vigenti_attivi c on c.denominazione_it =a.comune;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice 'MANG 4 - linee mangimifici_reg';
				
		insert into cu_anag.linee
			select nextval('cu_anag.cu_anag_id_seq') id,
			s.id id_stabilimento,tl.id id_tipo_linea,
			tsrange(
				case when m.data_inizio='' then null::timestamp else data_inizio::timestamp end,null::timestamp,'[)') validita,
			true,m.attivita_principale ilike 'SI' linea_principale,true,'MANG',null,null
			from cu_anag.mangimifici_reg m 
			join cu_anag.stabilimenti s on m.cun= s.cod_nazionale and m.num_ric_reg=s.cod_regionale
			join cu_anag.imprese i on i.id=s.id_impresa
			join agenda.vw_tipo_linee tl ON 
				left(m.dettaglio_attivita,3) = substring(tl.descr from '^\[.*\] (M[0-9][0-9])')
				where m.stato='ATTIVA';
			
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
 	 	
		raise notice 'MANG 5 - sede legale mangimifici_reg';
		/*		
		insert into cu_anag.stabilimento_sedi
		 	select nextval('cu_anag.cu_anag_id_seq') id,
		 	s.id id_stabilimento,(select id from cu_types.tipi_sede where descr ilike 'sede legale') id_tipo_sede,null,
		 	null cf,null piva,null pec,indirizzo_sede_legale email,null sdi,null split_payement,
			null cod_tipo_impresa,null old_id,'MANG' fonte
		from
			cu_anag.mangimifici_reg m join cu_anag.stabilimenti s on s.fonte='MANG' and s.sd_id=(-m.id*10)-7;
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;	
			
			insert into cu_anag.indirizzi 
			select id,null,email,
			null cap,null stato_prov,null nazione,null istat_comune,null comune,null localita,null civico,
			null latitudine,null longitudine,null verificato,'MANG' fonte from cu_anag.stabilimento_sedi
			where fonte='MANG';
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
			
		update cu_anag.stabilimento_sedi set email=null,id_indirizzo=id where fonte='MANG';
			
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;	
 		raise notice 'MANG 6 - Legale Rappresentante mangimifici_reg';
 		insert into cu_anag.stabilimento_figure
 			select nextval('cu_anag.cu_anag_id_seq') id,
		 	s.id id_stabilimento,null,(select id from cu_types.tipi_figura where descr ilike 'Legale Rappresentante') id_tipo_figura,null,
		 	null old_id,'MANG' fonte,case when length(cf)=16 then cf else null end,rappresentante_legale
			from cu_anag.mangimifici_reg m join cu_anag.stabilimenti s on s.fonte='MANG' and s.sd_id=(-m.id*10)-7;
  		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;	
 	
 		raise notice '	UPDATE INDIRIZZI';	*/
 	 	ret:=cu_anag.load_new_stabilimenti_upd_indirizzi();
 		return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.load_new_stabilimenti_mangimifici() OWNER TO postgres;

--
-- Name: load_new_stabilimenti_sicer(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_new_stabilimenti_sicer() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	begin
		
		delete from  cu_anag.imprese where fonte ilike 'SICER%';
		delete from  cu_anag.indirizzi where fonte ilike 'SICER%';
		delete from  cu_anag.linee where fonte ilike 'SICER%';
		delete from  cu_anag.soggetti_fisici where fonte ilike 'SICER%';
		delete from  cu_anag.stabilimenti where fonte ilike 'SICER%';
		delete from  cu_anag.stabilimento_figure where fonte ilike 'SICER%';
		delete from  cu_anag.stabilimento_sedi where fonte ilike 'SICER%';

	
		/* SICER */
		raise notice '1 - Caricamento imprese chiave sd_id';
		insert into  cu_anag.imprese (id,verificato,nome,cf,piva,pec,
				email,sdi,split_payement,cod_tipo_impresa,az_id,az_cod_aziendale,
				az_cod_regionale,sd_id,fonte)
		select nextval('cu_anag.cu_anag_id_seq') id ,case when tipo_ab='A' then true else false end,
			 impresa_ragione_sociale,impresa_cf,impresa_piva,impresa_pec,
			impresa_email ,impresa_sdi ,
			case when length(impresa_sdi) = 6 then 'S'
				 when length(impresa_sdi) = 7 then 
				 	case when coalesce(a.impresa_split_payment ,0) =0 then 'N' else 'S' end end,
			impresa_tipo_persona ,impresa_id,impresa_cod_aziendale ,null az_cod_regionale,
			a.stabilimento_id as sd_id,'SICER_'||tipo_ab
							
			from cu_anag.vw_gisa_imprese_completa_ab a -- 15286
			--join cu_anag.vw_fvg_gisa_imprese_all i on a.stabilimento_id =i.sd_id
			where 
			upper(impresa_tipo_figura_descr) in ('SEDE LEGALE');
		
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '2 - Caricamento STABILIMENTI';

		insert into cu_anag.stabilimenti
			select  nextval('cu_anag.cu_anag_id_seq') ,ni.id,
					stabilimento_denominazione nome,
					stabilimento_id,0,stabilimento_codice_regionale,tipo_ab='A','SICER_'||tipo_ab,1,
					tsrange(null::timestamp,null::timestamp,'()'),null,ts.id
			 from cu_anag.vw_gisa_imprese_completa_ab a
			 join cu_anag.imprese ni on ni.sd_id=a.stabilimento_id
			 left join cu_types.tipologie_struttura ts on upper(a.stabilimento_cod_tipologia_struttura)=upper(ts.descrizione)
			 --join cu_anag.vw_fvg_gisa_imprese_all i on a.stabilimento_id =i.sd_id
			where upper(impresa_tipo_figura_descr) in ('SEDE LEGALE');
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		delete from cu_anag.indirizzi where id in (select id from cu_anag.stabilimenti );
		raise notice '3 - Caricamento STABILIMENTI-INDIRIZZO';
		insert into cu_anag.indirizzi 
		select  distinct on (s.id) s.id id,stabilimento_indirizzo_toponimo toponimo,
			stabilimento_indirizzo indirizzo,
			stabilimento_indirizzo_cap cap,
			stabilimento_indirizzo_provincia prov_stato,
			'' nazione,
			stabilimento_indirizzo_istat_comune istat_comune,
			c.denominazione_it::varchar comune,
			'' localita,
			stabilimento_indirizzo_civico civico,
			stabilimento_latitudine latitudine,
			stabilimento_longitudine longitudine,
			c.id is not null verificato,'SICER_'||a.tipo_ab fonte
		from cu_anag.vw_gisa_imprese_completa_ab a 
		join cu_anag.stabilimenti s on a.stabilimento_id =s.sd_id 
		left join conf_ext.vw_comuni_vigenti_attivi c on c.codistat =a.stabilimento_indirizzo_istat_comune::integer ;


	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 				
		update cu_anag.stabilimenti set id_indirizzo=id;

 	
		raise notice '4 - tipi figura';
		delete from cu_types.tipi_figura;
		insert into  cu_types.tipi_figura
		select row_number() over()  , descr cod,descr sigla, descr from  
		(select distinct fg_tipo_figura_descr descr from cu_anag.vw_fvg_gisa_imprese_all
		where fg_tipo_figura_descr is not null and fg_tipo_figura_descr not ilike 'sede%') a;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '5 - tipi sede indirizzi';
	
	
		insert into cu_anag.indirizzi
			select distinct -i.id*10-1,fg_an_res_toponimo toponimo,		fg_an_res_indirizzo indirizzo,fg_an_res_cap,
			fg_an_res_provincia prov_stato, null nazione,	
			fg_an_res_istat comune,
			fg_an_res_comune comune, null localita,
			fg_an_res_civico civico ,null,null, s.verificato,s.fonte
		from cu_anag.vw_fvg_gisa_imprese_all i 
		join cu_types.tipi_sede ts on upper(ts.descr) =upper(i.fg_tipo_figura_descr)
		join cu_anag.stabilimenti s on s.sd_id =i.sd_id ;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '6 - stabilimento sedi';

		insert into cu_anag.stabilimento_sedi 
		select nextval('cu_anag.cu_anag_id_seq'),ns.id,ts.id,-i.id*10-1,
		i.fg_an_pec pec,i.fg_an_email email,i.id old_id,ns.fonte
		from cu_anag.vw_fvg_gisa_imprese_all i
		join cu_anag.stabilimenti ns on ns.sd_id =i.sd_id 
		--join cu_anag.stabilimenti s on i.sd_id=s.sd_id
		join cu_types.tipi_sede ts on upper(ts.descr) =upper(i.fg_tipo_figura_descr);
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
	
		raise notice '7 - soggetti_fisici';

 	
 		insert into cu_anag.soggetti_fisici 
			select nextval('cu_anag.cu_anag_id_seq') id,null,cognome,nome, codice_catastale_nascita,
			codice_fiscale,sesso,telefono,email,pec,null,
			(case when data_nascita_fiscale='1900-02-29' then '2000-02-29' else data_nascita_fiscale end)::date,documento,null,cu_anag.check_cf(codice_fiscale),
		   'SICER' from conf_ext.vw_soggetti_fisici_fvg ;
			
		/*insert into cu_anag.soggetti_fisici 
			select nextval('cu_anag.cu_anag_id_seq') id, null,null,s.nome,s.comune_nascita,s.codice_fiscale,
				null sesso,null telefono,null email,null pec,null telefono2,s.data_nascita,null documento_identita,null indirizzo_id,
				from (
				select distinct on (upper(fg_an_cf)) fg_an_cf codice_fiscale,upper(fg_an_nome) nome,fg_an_data_nascita data_nascita,substr(fg_an_cf,12,4) comune_nascita
				from cu_anag.vw_fvg_gisa_imprese_all
				where length(fg_an_cf)=16 and fg_an_data_nascita is not null and fg_an_nome is not null and fg_an_data_nascita != '1900-01-01'
				order by upper(fg_an_cf),length(fg_an_nome),fg_an_data_nascita desc) s;*/
		 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
 		delete from cu_anag.indirizzi where id in (select s.id from cu_anag.soggetti_fisici s);
		insert into cu_anag.indirizzi
		select s.id,null,res_indirizzo,res_cap,null,null,res_istat,null,null,res_civico,null,null,true,'SICER'
		from cu_anag.soggetti_fisici s join conf_ext.vw_soggetti_fisici_fvg sfvg on s.codice_fiscale =sfvg.codice_fiscale ;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
		update cu_anag.soggetti_fisici set indirizzo_id=id where indirizzo_id is null and fonte='SICER'
		and id in (select id from cu_anag.indirizzi);

 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '8 - indirizzi';
	
		delete from cu_anag.indirizzi where id < 0 and (mod(id*-1,10)=2);
		insert into cu_anag.indirizzi
			select distinct on (i.id) -i.id*10-2,fg_an_res_toponimo toponimo,		fg_an_res_indirizzo indirizzo,fg_an_res_cap,
			fg_an_res_provincia prov_stato, null nazione,	
			fg_an_res_istat comune,
			fg_an_res_comune comune, null localita,
			fg_an_res_civico civico ,null,null, s.verificato,s.fonte
		from cu_anag.vw_fvg_gisa_imprese_all i 
		join cu_anag.stabilimenti s on s.sd_id =i.sd_id 
		join cu_types.tipi_figura tf on upper(tf.descr) =upper(i.fg_tipo_figura_descr)
		join cu_anag.soggetti_fisici sf on sf.codice_fiscale =fg_an_cf
		where length(fg_an_cf)=16;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
		
		raise notice '9 - stabilimento figure';

		delete from cu_anag.stabilimento_figure  where id in (select i.id from cu_anag.vw_fvg_gisa_imprese_all i);
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	9.1 - stabilimento figure delete %',total_rows;

		insert into cu_anag.stabilimento_figure  
			select distinct on (ns.id,tf.id) i.id ,ns.id id_stabilimento,sf.id id_soggetto_fisico,tf.id id_tipo_figura,-i.id*10-2 id_indirizzo,i.id old_id,ns.fonte
			from cu_anag.vw_fvg_gisa_imprese_all i 
			join cu_anag.stabilimenti ns on ns.sd_id =i.sd_id 
			join cu_types.tipi_figura tf on upper(tf.descr) =upper(i.fg_tipo_figura_descr)
			join cu_anag.soggetti_fisici sf on sf.codice_fiscale =fg_an_cf
			join cu_anag.stabilimenti s on s.sd_id = i.sd_id
			where length(fg_an_cf)=16;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '10 - linee PRINCIPALI';

		insert into cu_anag.linee
		select nextval('cu_anag.cu_anag_id_seq') id,s.id id_stabilimento,tl.id id_tipo_linea ,tsrange(linea_data_inizio,linea_data_fine,'[)') validita,
		attivita_fissa,linea_principale=1 linea_principale,i.tipo_ab='A' verificato, 'SICER_'||i.tipo_ab as fonte --from cu_anag.linee
		from cu_anag.vw_gisa_imprese_completa_ab i 
		join cu_anag.stabilimenti s on s.sd_id=i.stabilimento_id
		join agenda.vw_tipo_linee tl ON tl.cod_mod  = i.linea_ateco ;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
		raise notice '11 - linee secondarie';
		insert into cu_anag.linee
			select nextval('cu_anag.cu_anag_id_seq') id,s.id id_stabilimento,tl.id id_tipo_linea ,tsrange(linea_data_inizio,linea_data_fine,'[)') validita,
		true,false linea_principale,true verificato, 'SICER_A' as fonte
		from conf_ext.vw_gisa_imprese_linee_secondarie_a i 
		join cu_anag.stabilimenti s on s.sd_id=i.stabilimento_id
		join agenda.vw_tipo_linee tl ON tl.cod_mod  = i.linea_ateco ;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
	 	insert into cu_anag.linee 
		select nextval('cu_anag.cu_anag_id_seq'),s.id , -10000000,tsrange(null,null,'()'),true,true,true,'SICER_FIX' from cu_anag.stabilimenti s
		left join cu_anag.linee l on s.id=l.id_stabilimento
		where l.id is null and s.fonte ilike 'SICER%';
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	insert linea fittizia %',total_rows; 
 	
 		update cu_anag.linee set data_ultima_visita='2000-01-01'::timestamp where data_ultima_visita is null;
 	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	data_ultima_visita is null %',total_rows;
 	
 		update cu_anag.stabilimenti set categoria_rischio =2 where categoria_rischio is null;
 	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	categoria rischio default %',total_rows; 	
 	
	
 	
 	 	ret:=cu_anag.load_new_stabilimenti_upd_indirizzi();
 	
	 return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.load_new_stabilimenti_sicer() OWNER TO postgres;

--
-- Name: load_new_stabilimenti_sintesis(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_new_stabilimenti_sintesis() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	begin
		
		delete from  cu_anag.imprese where fonte in ('AAEE','853','852Integratori') ;
		delete from  cu_anag.indirizzi where fonte in ('AAEE','853','852Integratori');
		delete from  cu_anag.linee where fonte  in ('AAEE','853','852Integratori');
		delete from  cu_anag.soggetti_fisici where fonte in ('AAEE','853','852Integratori');
		delete from  cu_anag.stabilimenti where fonte  in ('AAEE','853','852Integratori');
		delete from  cu_anag.stabilimento_figure where fonte  in ('AAEE','853','852Integratori');
		delete from  cu_anag.stabilimento_sedi where fonte  in ('AAEE','853','852Integratori');


 	
 		/* 852integratori853AAE */
		update cu_anag."852integratori853AAE" a
		set id=s.rn
		from 
		(select  approval_number ,attivita,descrizione_sezione,row_number() over () rn from cu_anag."852integratori853AAE") s
		where a.approval_number=s.approval_number and a.attivita=s.attivita and a.descrizione_sezione=s.descrizione_sezione;
		
		raise notice '12 - imprese 852integratori853AAE';
		insert into cu_anag.imprese
				select nextval('cu_anag.cu_anag_id_seq'),a.ragione_sociale_impresa,a.codice_fiscale,a.partita_iva,
	 	null,null,null,null,a.fg_an_tipo_persona,-a.az_id*10-4,null,null,-a.az_id*10-4,true,a.tipo 
	 	from(select distinct a.ragione_sociale_impresa,a.codice_fiscale,a.partita_iva,
	 	i.fg_an_tipo_persona,a.az_id,a.tipo
	 	from cu_anag.vw_852integratori853AAE_imprese a
	 	 	left join cu_anag.vw_fvg_gisa_imprese_all i on a.partita_iva  =i.az_an_iva and 
			upper(fg_tipo_figura_descr) in ('SEDE LEGALE')and az_cod_aziendale ilike 'CE%') a;
		--(select ragione_sociale_impresa,codice_fiscale,partita_iva,
	 	--tipo,approval_number,min(id) az_id from cu_anag."852integratori853AAE" group by 1,2,3,4,5) a;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;	 

	 	/*insert into cu_anag.soggetti select id,'I' from cu_anag.imprese
	 	where fonte in ('852integratori','853','AAEE');
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;	 */
	 

  
 	    raise notice '13 - stabilimenti 852integratori853AAE';
		insert into cu_anag.stabilimenti
		select nextval('cu_anag.cu_anag_id_seq'),id_impresa,denominazione_sede_operativa,-sd_id*10-4,-sd_id*10-4,approval_number,true,
		fonte,1,tsrange(null,null,'()'),approval_number,id_tipologia_struttura,null,null,null
		from (
			select distinct on (a.approval_number) i.id id_impresa,a.denominazione_sede_operativa,a.approval_number,tipo fonte,/*min(a.id) */a.id sd_id,
			gi.sd_cod_tipologia_struttura cod_tipologia_struttura,ts.id id_tipologia_struttura
			from cu_anag."852integratori853AAE" a
			left join cu_anag.imprese i  on i.nome=a.ragione_sociale_impresa and i.cf=a.codice_fiscale and i.piva=a.partita_iva
			left join cu_anag.vw_fvg_gisa_imprese_all gi on gi.az_cod_aziendale =a.approval_number 
			left join cu_types.tipologie_struttura ts on ts.codice=gi.sd_cod_tipologia_struttura
			order by a.approval_number,a.id
		) t;
	 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
	
		 raise notice '14 - indirizzi 852integratori853AAE';
	 /*	insert into cu_anag.indirizzi
	 	select -sd_id*10-4,null,a.indirizzo,null,a.sigla_provincia,null,a.codistat,a.comune,null,null,null,null,true,fonte from
	 	(select sd_id,indirizzo,case when c.codistat is null then a.comune else null end comune,sigla_provincia,
	 	case when c.codistat is null then null else codice_istat end codistat,tipo fonte,min(a.id) id
	 	from cu_anag."852integratori853AAE" a 
		left join conf_ext.vw_comuni_vigenti_attivi  c on a.comune=c.denominazione_it 
		join cu_anag.stabilimenti gi on gi.cod_regionale =a.approval_number 
		where a.id in (select (sd_id+4)/-10 from cu_anag.stabilimenti where fonte  in ('AAEE','853','852Integratori') )
		group by 1,2,3,4,5,6
		) a;
		--2024-03-25*/
		
		insert into cu_anag.indirizzi
	 	select ---sd_id*10-4
	 	sd_id,null,a.indirizzo,null,a.sigla_provincia,null,a.codistat,a.comune,null,null,null,null,true,fonte from
	 	(select sd_id,indirizzo,case when c.codistat is null then a.comune else null end comune,sigla_provincia,
	 	case when c.codistat is null then null else codice_istat end codistat,--gi.fonte al posto di fonte
	 	gi.fonte fonte,min(a.id) id
	 	from cu_anag."852integratori853AAE" a 
		left join conf_ext.vw_comuni_vigenti_attivi  c on a.comune=c.denominazione_it 
		join cu_anag.stabilimenti gi on gi.cod_regionale =a.approval_number 
		where gi.sd_id in (select sd_id from cu_anag.stabilimenti where fonte in ('AAE','853','852 Integratori') )
		--where a.id in (select (sd_id+4)/-10 from cu_anag.stabilimenti where fonte  in ('AAEE','853','852Integratori') )
		group by 1,2,3,4,5,6
		) a;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe   caricate %',total_rows;
	

 	
		raise notice '15 - linee 852integratori853AAE';
		insert into cu_anag.linee
			select nextval('cu_anag.cu_anag_id_seq') id,
			s.id id_stabilimento,tl.id id_tipo_linea ,
			tsrange(data_inizio_attivita::timestamp,
				case when replace(data_fine_attivita,'-','')='' then null::timestamp else replace(data_fine_attivita,'-','')::timestamp end,'[)') validita,
			true,false linea_principale,true,i.tipo
			from cu_anag."852integratori853AAE" i 
			join cu_anag.stabilimenti s on i.approval_number=s.cod_regionale
			--join cu_anag.imprese im on im.id=s.id_impresa
			join agenda.vw_tipo_linee tl ON 
				case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP' then 
				'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
					when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI' then
				'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
					else upper(translate(tl.descr,' -','')) end=upper(translate(i.attivita||i.descrizione_sezione,' -',''));
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
 	 		ret:=cu_anag.load_new_stabilimenti_upd_indirizzi();
 	
 		 return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.load_new_stabilimenti_sintesis() OWNER TO postgres;

--
-- Name: load_new_stabilimenti_upd_indirizzi(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_new_stabilimenti_upd_indirizzi() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	begin
	 	
		update cu_anag.indirizzi i
			set istat_comune=s.codistat
			from (
			select i.id,c.codistat from cu_anag.indirizzi i
			join conf_ext.vw_comuni_vigenti_attivi c on left(upper(translate(c.denominazione_it,' -''','')),13) =
													    left(upper(translate(i.comune,' -''','')),13) ) s
			where istat_comune is null and i.id=s.id;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set comune = null
		where lpad(istat_comune,6,'0')  in (select lpad(codistat::varchar,6,'0') from conf_ext.vw_comuni_vigenti_attivi vcva);
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set comune = null,istat_comune =lpad(codistat::varchar,6,'0')
		from (select codistat,denominazione_it from conf_ext.vw_comuni_vigenti_attivi) s
		where comune is not null and comune=s.denominazione_it;
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set comune = null,istat_comune =lpad(codistat::varchar,6,'0')
		from (select codistat,denomtraslitterata from conf_ext.vw_comuni_vigenti) s
		where comune is not null and comune=s.denomtraslitterata;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set nazione=comune,istat_comune=null where nazione is null and istat_comune='000000';
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set cap=null where cap='00000';
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set stato_prov=null where stato_prov='00'; 
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set stato_prov=null where istat_comune is not null; 
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
 		/*update cu_anag.stabilimento_figure f
		set cf=q.cf from 
		(select f.id,s.codice_fiscale cf
		from cu_anag.stabilimento_figure f join cu_anag.soggetti_fisici s on f.id_soggetto_fisico =s.id) q
		where f.id=q.id and f.cf is null and f.id_soggetto_fisico is not null;
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;*/
	
	 	/*update cu_anag.stabilimento_figure f
		set id_soggetto_fisico =null where cf is not null and length(cf)=16 and id_soggetto_fisico is not null;
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;*/
	
		update cu_anag.indirizzi  set istat_comune = lpad(istat_comune,6,'0')
		where istat_comune is not null and istat_comune != '' and length(istat_comune) <6;
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
 		update cu_anag.soggetti_fisici set nome=trim(nome),cognome=trim(cognome),codice_fiscale =trim(codice_fiscale);
 	
 				update cu_anag.soggetti_fisici set sesso =
	 CASE
           WHEN
           ( CASE "substring"(codice_fiscale::text, 10, 1)
                WHEN 'L'::text THEN '0'::text
                WHEN 'M'::text THEN '1'::text
                WHEN 'N'::text THEN '2'::text
                WHEN 'P'::text THEN '3'::text
                WHEN 'Q'::text THEN '4'::text
                WHEN 'R'::text THEN '5'::text
                WHEN 'S'::text THEN '6'::text
                WHEN 'T'::text THEN '7'::text
                WHEN 'U'::text THEN '8'::text
                WHEN 'V'::text THEN '9'::text
                ELSE "substring"(codice_fiscale::text, 10, 1)
            end)::integer > 3 THEN 'F'::varchar
            ELSE 'M'::varchar end where sesso is null; 
           
     update cu_anag.soggetti_fisici t1 set comune_nascita =
(("substring"(t1.codice_fiscale::text, 12, 1) ||
        CASE "substring"(t1.codice_fiscale::text, 13, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            ELSE "substring"(t1.codice_fiscale::text, 13, 1)
        END) ||
        CASE "substring"(t1.codice_fiscale::text, 14, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            ELSE "substring"(t1.codice_fiscale::text, 14, 1)
        END) ||
        CASE "substring"(t1.codice_fiscale::text, 15, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            ELSE "substring"(t1.codice_fiscale::text, 15, 1) end
            where comune_nascita ='ZZZZ';
           
       delete from cu_anag.soggetti_fisici where  length(codice_fiscale)!=16;
 	
 		--alter table cu_anag.mangimifici_reg add column id bigint;
 
 		 return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.load_new_stabilimenti_upd_indirizzi() OWNER TO postgres;

--
-- Name: load_stabilimenti(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_stabilimenti() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	begin

		truncate table cu_anag.imprese;
		raise notice '1';
		insert into  cu_anag.imprese
		select nextval('cu_anag.imprese_id_seq') id , fg_an_nome nome,
		fg_an_cf cf,fg_an_iva piva,
		fg_an_pec pec,fg_an_email email,fg_an_sdi sdi,fg_an_split_payment split_payement,
		fg_an_tipo_persona cod_tipo_impresa,az_id,az_cod_aziendale,az_cod_regionale from(
		select distinct on (az_id) az_id, fg_an_nome ,
		fg_an_cf ,fg_an_iva ,
		fg_an_pec ,fg_an_email ,fg_an_sdi ,fg_an_split_payment ,
		fg_an_tipo_persona ,az_cod_aziendale ,az_cod_aziendale az_cod_regionale
			from cu_anag.vw_fvg_gisa_imprese_all
			where upper(fg_tipo_figura_descr) in ('SEDE LEGALE','DETENTORE','PROPRIETARIO')
			order by az_id,az_data_inizio desc,sd_data_inizio desc) a
			;
			raise notice '2';
		
		truncate table cu_anag.stabilimenti;
		raise notice '3';
		insert into cu_anag.stabilimenti
		select nextval('cu_anag.stabilimenti_id_seq') id ,i.id as id_impresa,
		s.sd_id,s.sd_an_nome nome,
				sd_an_res_provincia,sd_an_res_istat,sd_an_res_comune,sd_an_res_toponimo, sd_an_res_indirizzo,sd_an_res_civico ,
				sd_an_cf cf,sd_an_iva piva,sd_cod_tipologia_struttura,sd_cod_regionale from
		(select distinct on (sd_id) sd_id,sd_an_nome,
				sd_an_res_provincia,sd_an_res_istat,sd_an_res_comune,sd_an_res_toponimo, sd_an_res_indirizzo,sd_an_res_civico ,
				sd_an_cf,sd_an_iva,sd_cod_tipologia_struttura,az_id,sd_cod_regionale
		from cu_anag.vw_fvg_gisa_imprese_all where upper(fg_tipo_figura_descr)='SEDE LEGALE'
			order by sd_id,sd_data_inizio desc,length(sd_an_iva) desc) s
		join cu_anag.imprese i on i.az_id=s.az_id;
		raise notice '4';
		delete from cu_types.tipi_figura;
		raise notice '5';
		insert into  cu_types.tipi_figura
		select row_number() over()  , descr cod,descr sigla, descr from  
		(select distinct fg_tipo_figura_descr descr from cu_anag.vw_fvg_gisa_imprese_all
		where fg_tipo_figura_descr is not null and fg_tipo_figura_descr not ilike 'sede%') a;
		raise notice '6';
		delete from cu_anag.indirizzi_all i where id not in (select indirizzo_id from cu_anag.soggetti_fisici sf where indirizzo_id is not null);
		delete from cu_anag.indirizzi;
		raise notice '7';
		insert into cu_anag.indirizzi select id,topon,via,cap,provincia,nazione,comune_testo,null,civico from cu_anag.indirizzi_all where id>=0;
		raise notice '8';
		insert into cu_anag.indirizzi
		select -i.id,fg_an_res_toponimo toponimo,		fg_an_res_indirizzo indirizzo,fg_an_res_cap,
			fg_an_res_provincia prov, null,	
			fg_an_res_comune comune, null,
			fg_an_res_civico civico 
		from cu_anag.vw_fvg_gisa_imprese_all i 
		join cu_types.tipi_sede ts on upper(ts.descr) =upper(i.fg_tipo_figura_descr);
		raise notice '9';
		delete from cu_anag.stabilimento_sedi ;
		insert into cu_anag.stabilimento_sedi 
		select nextval('cu_anag.stabilimento_sedi_id_seq'),s.id,ts.id,-i.id,		i.fg_an_cf cf,i.fg_an_iva piva,
		i.fg_an_pec pec,i.fg_an_email email,i.fg_an_sdi sdi,i.fg_an_split_payment split_payement,i.fg_an_tipo_persona cod_tipo_impresa,i.id old_id
		from cu_anag.vw_fvg_gisa_imprese_all i 
		join cu_anag.stabilimenti s on i.sd_id=s.sd_id
		join cu_types.tipi_sede ts on upper(ts.descr) =upper(i.fg_tipo_figura_descr);
		raise notice '10';
	
			insert into cu_anag.indirizzi 
						select -i.id,fg_an_res_toponimo toponimo,		fg_an_res_indirizzo indirizzo,fg_an_res_cap,
			fg_an_res_provincia prov, null,	
			fg_an_res_comune comune, null,
			fg_an_res_civico civico 
		from cu_anag.vw_fvg_gisa_imprese_all i 
		join cu_types.tipi_figura tf on upper(tf.descr) =upper(i.fg_tipo_figura_descr)
		join cu_anag.soggetti_fisici sf on sf.codice_fiscale =fg_an_cf
		where length(fg_an_cf)=16;
		
			raise notice '11';
				insert into cu_anag.stabilimento_figure  
						select i.id ,s.id id_stabilimento,sf.id id_soggetto_fisico,tf.id id_tipo_figura,-i.id id_indirizzo,i.id old_id
		from cu_anag.vw_fvg_gisa_imprese_all i 
		join cu_types.tipi_figura tf on upper(tf.descr) =upper(i.fg_tipo_figura_descr)
		join cu_anag.soggetti_fisici sf on sf.codice_fiscale =fg_an_cf
		join cu_anag.stabilimenti s on s.sd_id = i.sd_id
		where length(fg_an_cf)=16;
	 	return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.load_stabilimenti() OWNER TO postgres;

--
-- Name: load_stabilimenti_mangimifici(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_stabilimenti_mangimifici() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	num integer;
    tipoStrId  varchar;
    idImport  varchar;
 	rc record ;
	rec1 record ;
	rec2 record ;
	rec3 record;
	R_IMP cu_anag.imprese;
	R_IND cu_anag.indirizzi;
	R_STAB cu_anag.stabilimenti;
    R_LINEA  cu_anag.linee;
    id_transazione integer;
    log_string varchar;
	stampa varchar;
    LOG_FILE varchar;
	begin
	    idImport:=v->'id_import'; 
		tipoStrId:=v->'tipoStrId';
		id_transazione:=-1;



 
	

	
	/********************mettere le stampe nel file di log di antonio *************/
		 
     LOG_FILE:='/tmp/loadStabSintesis'+now;
	 
	
	 FOR rc IN (SELECT * FROM cu_anag.file_xls_mangimifici )    
		LOOP
		        log_string := 'VERIFICHIAMO SE ESISTE L''IMPRESA PARTITA IVA :'+rc.partita_iva;
		  		raise info 'VERIFICHIAMO SE ESISTE L''IMPRESA PARTITA IVA%',rc.partita_iva;
		  	    stampa:='echo '+log_STRING+ '>' + LOG_FILE;
		  	    raise info 'VERIFICHIAMO SE ESISTE L''IMPRESA PARTITA IVA%',stampa;
		  	   
  	   		--	COPY shell FROM PROGRAM stampa  ;
		  	
		  		SELECT  * INTO rec1 from cu_anag.imprese i  where  i.piva =rc.partita_iva ;
		  		GET DIAGNOSTICS total_rows := ROW_COUNT;
	 			raise notice 'numero imprese presenti %',total_rows;	 
	 			if(total_rows==0) then
	 			   raise info 'INSERIAMO IMPRESA';
		 		   INSERT INTO cu_anag.imprese
					select nextval('cu_anag.cu_anag_id_seq'), a.ragione_sociale_impresa, a.codice_fiscale, a.partita_iva, NULL, NULL, NULL, NULL, 'S',null,null,null,null,true,tipoP,
					'(,)'::tsrange, 'G' from (
			   			 select distinct a.ragione_sociale_impresa,a.codice_fiscale,a.partita_iva	 
			 			  from cu_anag.file_xls_mangimifici a where TRIM(rec1.partita_iva)=TRIM(a.partita_iva)
			 			)a returning * into R_IMP;
		 		   n:=cu_log.upd_record('cu_anag.imprese',id_transazione,R_IMP,'I');
			
		 		end if;
		 	
 
		 		raise info 'VERIFICHIAMO SE ESISTE STAB. PER NUMERO DI REGISTRAZIONE (CUN)%',rc.numero_di_registrazione_cun;
		  	
		  		SELECT  * INTO rec2 from cu_anag.stabilimenti s  where  TRIM(s.cod_nazionale) =TRIM(rc.numero_di_registrazione_cun) 
		  		and  TRIM(s.cod_regionale) =TRIM(rc.numero_di_registrazione_riconoscimento);
		  		GET DIAGNOSTICS total_rows := ROW_COUNT;
	 			raise notice 'numero stab presenti %',total_rows;	 
	 			if(total_rows==0) then
	 		
	 			   raise info 'LOSTAB DEVE ESSERE INSERITO';
	 			  
	 			   raise info 'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';
	 			   
	 			    INSERT INTO cu_anag.indirizzi
				    select   nextval('cu_anag.cu_anag_id_seq'),a.indirizzo_sede_produttiva indirizzo ,null,sigla_provincia,null,case when c.codistat is null then null else codice_istat end codistat,
				 	          case when c.codistat is null then a.comune else null end comune,null,null,null,null,true,
				 	ts.codice  fonte
				 	from cu_anag.file_xls_mangimifici a
				 	left join conf_ext.vw_comuni_vigenti_attivi  c on a.comune=c.denominazione_it 
				 	left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId
				 	where    TRIM(a.numero_di_registrazione_cun) =TRIM(rc.numero_di_registrazione_cun) 
				    and     TRIM(a.numero_di_registrazione_riconoscimento) =TRIM(rc.numero_di_registrazione_riconoscimento)
				 	returning  * into R_IND;
				    n:=cu_log.upd_record('cu_anag.indirizzi',id_transazione,R_IND,'I');
 	 	   		   
				    raise info 'INSERIAMO LO STAB NELLA TABELLA STABILIMENTI';
				    
				   
					INSERT INTO cu_anag.stabilimenti
					select nextval('cu_anag.cu_anag_id_seq'),rec1.id,
					case when a.denominazione_sede = '' then a.ragione_sociale else a.denominazione_sede end, 
					null,R_IND.id,a.numero_di_registrazione_riconoscimento ,true,
					ts.codice fonte,1,tsrange(null,null,'()'),numero_di_registrazione_cun,ts.id,null,null,null
			 		from cu_anag.file_xls_mangimifici a
					left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId
					where TRIM(rc.numero_di_registrazione_cun) = TRIM(a.numero_di_registrazione_cun) 		
					and TRIM(rc.numero_di_registrazione_riconoscimento) = TRIM(a.numero_di_registrazione_riconoscimento) 	
					returning  * into R_STAB;
				
				    n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_STAB,'I');
				    raise info 'INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';
				
		 	
		 		 else
		 		   
		 		 	raise info 'AGGIORNIAMO I VALORI DI ID_INDIRIZZO DELLO STAB , ID_INIDIRZZO%',rec2.id_indirizzo;
							 		    	
					UPDATE  cu_anag.indirizzi i
					SET indirizzo=subquery.indirizzo_sede_produttiva,
					    sigla_provincia=subquery.sigla_provincia,
					    codistat=subquery.codistat,
					    comune=subquery.comune
					FROM (select  
					     a.indirizzo_sede_produttiva, sigla_provincia, case when c.codistat is null then null else codice_istat end codistat,
						 case when c.codistat is null then a.comune else null end comune 
						 from cu_anag.file_xls_mangimifici a
					     left join conf_ext.vw_comuni_vigenti_attivi  c on a.comune=c.denominazione_it 		
						 left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId
						 where TRIM(rc.numero_di_registrazione_cun) = TRIM(a.numero_di_registrazione_cun) 		
							   and TRIM(rc.numero_di_registrazione_riconoscimento) = TRIM(a.numero_di_registrazione_riconoscimento) 	
						 ) AS subquery
					where i.id=rec2.id_indirizzo
					returning  * into R_IND;
		            n:=cu_log.upd_record('cu_anag.indirizzi',id_transazione,R_IND,'U');
 	 	   		  
	   
		 		 
        		 	update   cu_anag.stabilimenti  
        		 	set nome= case when a.denominazione_sede = '' then a.ragione_sociale else a.denominazione_sede end
 	 	   		--	where    cod_nazionale=rc.numero_di_registrazione_cun 	 	   		
 	 	   			where  TRIM(s.cod_nazionale) =TRIM(rc.numero_di_registrazione_cun) 
		  		           and  TRIM(s.cod_regionale) =TRIM(rc.numero_di_registrazione_riconoscimento)
 	 	   			returning  * into R_STAB;
				
				    n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_STAB,'U');
	
 	 	   		
 	 	   		
 	 	   		    raise info 'VERIFCICHIAMO SE LA LINEA DELLO ESITE NELLA TABELLA LINEE';
 	 	   		
 	 	   		   
 	 	   		    SELECT *  INTO rec3 FROM cu_anag.linee
					inner join agenda.vw_tipo_linee tl ON 
						left(rc.dettaglio_attivita,3) = substring(tl.descr from '^\[.*\] (M[0-9][0-9])')
	 				WHERE id_stabilimento =rec2.id ;   
	 			
 	 	   		
 	 	   		    GET DIAGNOSTICS num := ROW_COUNT;
	 				raise notice 'numero linee presenti %',n;	
	 			    if(num==0)then
	 			       raise info 'INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';
	 			       insert into cu_anag.linee
						select nextval('cu_anag.cu_anag_id_seq') id,
						s.id id_stabilimento,tl.id id_tipo_linea ,
						tsrange(case when m.data_inizio='' then null::timestamp else data_inizio::timestamp end,null::timestamp,'[)') validita,
						true,i.attivita_principale ilike 'SI' linea_principale,true,tl.cod 
						from cu_anag.file_xls_mangimifici  i 
						join cu_anag.stabilimenti s on 	TRIM(s.cod_nazionale) =TRIM(rc.numero_di_registrazione_cun) and  TRIM(s.cod_regionale) =TRIM(rc.numero_di_registrazione_riconoscimento)
						left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId
					 	join agenda.vw_tipo_linee tl ON 			
							 left(i.dettaglio_attivita,3) = substring(tl.descr from '^\[.*\] (M[0-9][0-9])')
				       	returning  * into R_LINEA;
						n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_LINEA,'I');
				
					  else
				 		 raise info 'AGGIORNIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';
				 		 update  cu_anag.linee l
				 		 
				 	   	/* set    validita= tsrange(data_inizio_attivita::timestamp,
						   		case when replace(data_fine_attivita,'-','')='' then null::timestamp else replace(data_fine_attivita,'-','')::timestamp end,'[)') 
			           */
						  set    validita= 	tsrange(
									case when m.data_inizio='' then null::timestamp else data_inizio::timestamp end,null::timestamp,'[)')          
						  where l.id=rec3.id 	returning  * into R_LINEA;
						n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_LINEA,'U');

				 	 end if;
			 	 	   			
 	 	   		 
 	 	   		
 	 	   	 end if;
        		 
		 /*VERIFICARE SE CI SONO STAB DA CHIUDERE SE HANNO TUTTE LE LINEE CHIUSE */

		 			  
		END LOOP ; 

 	

				
 		return ret;
	end;
	END;
	$$;


ALTER FUNCTION cu_anag.load_stabilimenti_mangimifici() OWNER TO postgres;

--
-- Name: load_stabilimenti_mangimifici(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_stabilimenti_mangimifici(v json, id_transazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	num integer;
    tipoStrCod  varchar;
    idImportP  varchar;
    id_impresa_new bigint;
    piva varchar;
 	rc record ;
	rec1 record ;
	rec2 record ;
	rec3 record;
	rcl record;
    recapp  record;
    recInd record;
    recImp record;
	R_IMP cu_anag.imprese;
	R_IND cu_anag.indirizzi;
	R_STAB cu_anag.stabilimenti;
	R_STABSEDE cu_anag.stabilimento_sedi;
	R_STABFIG cu_anag.stabilimento_figure;
    R_LINEA  cu_anag.linee;
    id_transazione integer;
    id_indirizzo_sede  integer;
    id_IND integer;
    R_S cu_anag.stabilimenti;
    R_SOGG_FIS cu_anag.soggetti_fisici;
    id_STAB integer;
    log_string varchar;
	stampa text;
    LOG_FILE varchar;
    QUERY TEXT;
    cont integer;
    numSogg integer;
    v_validita tsrange;
	cod_timpo_impresa varchar;
    chiamata_j json;
    id_impresa_sede integer;
    idSoggFis integer;
    inizio timestamp;
    fine timestamp;
    validita_da_file tsrange;
    validita_da_file_stab tsrange;
    tipo_soggetto varchar;
    validita_da_linee tsrange;
    ver bool;
    FONTE_ANAG varchar;
    impresa_new bool;
	begin
	    idImportP:=v->'id_import'; 
	   tipoStrCod:=v->>'tipoStrCod';
		id_transazione:=245161;
		impresa_new:=true;
		cont:=1;

 		ret.esito:=false;
		raise info 'idImportP%',idImportP;
		raise info 'tipoStrCod%',tipoStrCod;
	
	/********************mettere le stampe nel file di log di antonio *************/
		 
     LOG_FILE:='/tmp/loadStabMangimifici_'||CURRENT_DATE ;
     LOG_FILE:=REPLACE(LOG_FILE, ' ', '_');
	 raise info 'LOG_FILE%',LOG_FILE;
	
	 FOR rc IN (
 
	  
	  SELECT    *, ts.id ts_id, ts.codice  fonteINS,tl.id id_tipo_linea ,substring(m.indirizzo_sede_legale  from ' ([0-9]{5}) ') capSedeLegale,
      case when listacapSP.istat is not null then (caps)->>0   else ''   end as capSedeProd       ,
      case when c.codistat is null then null else c.codice_istat end codice_istatSedeProd,
	  case when c.codistat is not null then m.comune else null end comune  
	  FROM cu_anag.file_xls_mangimifici m   
	  left join cu_types.tipologie_struttura ts   on ts.codice=tipoStrCod
	  left join conf_ext.vw_comuni_vigenti_attivi  c on comune=c.denominazione_it 
	  left join conf_ext.vw_istat_lista_cap  listacapSP on listacapSP.istat=c.codice_istat::text
 	--  left join agenda.vw_tipo_linee tl ON left(m.dettaglio_attivita,3) = substring(tl.descr from '^\[.*\] (M[0-9][0-9])')
 	  inner join agenda.vw_tipo_linee tl ON upper(translate(regexp_replace(tl.descr,'\[[^[]*\]','') ,' -','')) =
 	  upper(translate(m.dettaglio_attivita||m.descrizione_attivita,' -',''))	
	  where m.idimport=idImportP::bigint)
	  
	  
		LOOP 
			    log_string := 'fonteINS :'||rc.fonteINS ;
			    FONTE_ANAG:=rc.fonteINS||'_UPD';
		  		raise info '%',log_string;
		  --		execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 	  			  
			
			    log_string := 'id import :'||idImportP || 	  'tipoStrCod '|| tipoStrCod;
		 		raise info '%',log_string;
		 	--	execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 	  			  	
	 			raise info 'i %',cont;
	 		 	log_string := 'CONTATORE RECORD PRIMA: ' ;
		  --  	execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  	  	
		  	   	cont:=cont+1;	   
		        log_string := 'VERIFICHIAMO SE ESISTE IMPRESA PARTITA IVA :'||rc.partita_iva  ;
		  --     	execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 		
		 
		  		--log_string:=  	'  CF ' ||trim(rc.codice_fiscale) ;
		  
	 		--  	execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		  	 		
		  	    
		  	    if  ( ( rc.partita_iva =''  and   rc.codice_fiscale='')  or  ( rc.partita_iva ='-'  and   rc.codice_fiscale='-') )    then 				   		       
		  	    
					log_string := 'PARTITA IVA /CF NON PRESENTE NEL FILE' ;
			 	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			 	    ------------ *************** SALTARE IL LOOP ******************** ------------------
			  
		  	    else -- record valido
				  	 
				  		/*SELECT  *,ts.id ts_id INTO rec1 from cu_anag.imprese i
				  		left join cu_types.tipologie_struttura ts  on ts.id=tipoStrCod::int
				  	    where ( (rc.partita_iva!='' and i.piva =rc.partita_iva)      or   (rc.codice_fiscale!='' and i.piva =rc.codice_fiscale )
				  	            or  (rc.codice_fiscale!='' and i.cf =rc.codice_fiscale  ) )
						   ;*/
						SELECT  *,ts.id ts_id INTO rec1    from cu_anag.imprese i
						left join cu_types.tipologie_struttura ts  on ts.codice=tipoStrCod
						where ( (rc.partita_iva!=''  and rc.codice_fiscale!='' and i.piva =rc.partita_iva)    
						 or     (rc.partita_iva=''   and rc.codice_fiscale!='' and i.piva =rc.codice_fiscale ) 
						 or     (rc.partita_iva=''   and rc.codice_fiscale!='' and i.cf =rc.codice_fiscale)
						 ) limit 1;
										  	 
				 -- 		GET DIAGNOSTICS total_rows := ROW_COUNT;				  	
			 		 --	raise notice 'numero imprese presenti rc.partita_iva %',rc.partita_iva;	 			 		 
			 		 --	raise notice 'numero imprese presenti rc.rc.codice_fiscale %',rc.codice_fiscale;	 
			 		-- 	raise notice 'numero imprese presenti %',total_rows;	 			 			
			 		    log_string :=   ' NUMERO IMPRESE PRESENTI:' || total_rows;	 				 		   
			 	--	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
 		   
			 		   
			 		   /** MODIFICATO PER ISSUE #11982 
 		   	           validita_da_file	=tsrange( case when rc.data_inizio is null then null else rc.data_inizio end   ,
							 case when rc.data_fine_attivita is null then null else  rc.data_fine_attivita::timestamp + INTERVAL '1 DAY'end,'[)');
						***/	
					   validita_da_file :=  tsrange(			  
								  case when  rc.data_inizio_attivita >replace(rc.data_fine_attivita::text,'-','')::timestamp then rc.data_fine_attivita::timestamp  - INTERVAL '1 DAY' else rc.data_inizio_attivita::timestamp end,
								  case when replace(rc.data_fine_attivita::text,'-','')='' then null::timestamp else rc.data_fine_attivita::timestamp  + INTERVAL '1 DAY' end,'[)'
							);
						 	
							
							
							
--------------------------------------IMPRESA -------------------------------------------------------------------------------------------			 	 			 		   
			 			if(rec1.id is null) then -- 'IF PRESENZA  IMPRESA DB ';
			 			       raise info 'INSERIAMO IMPRESA';				 			  
				 			   log_string :=   'INSERIAMO IMPRESA' ;			 			  
				 			   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				 		       piva=rc.partita_iva;				 		      
				 		       log_string :=     'INSERIAMO IMPRESA PIVA' ||piva;			 			  
				 			   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';   
			 		      	   
				 			   if(piva='' and cu_anag.check_piva(rc.codice_fiscale)) then -- IF CF E' COME PIVA
				 		 	 		  piva=rc.codice_fiscale;
					 		 	 	  log_string :=     'INSERIAMO IMPRESA PIVA COME CF' ||piva;			 			  
		 				 			  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				 	 
				 		 	   end if;  	-- IF CF E' COME PIVA
				 		 	   
							    log_string :=     'LUNGHEZZA SOGGFISICO'  ||length(rc.codice_fiscale);			 			  
		 				 		execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			 		 	 
				 		  
				 		   	  
				 		   	  
				 		   	 if( length(rc.codice_fiscale)=16  ) then --IF CODFISC E UN CF
		 					 	 cod_timpo_impresa:='P';	
		 			 			 tipo_soggetto:= 'F' ;
				 		     
							 else 				 			 	 	 	   
								 cod_timpo_impresa:='S';
								 tipo_soggetto:= 'G' ;
							 end if; ----IF CODFISC E UN CF
				 		 	 
				 		 	  INSERT INTO cu_anag.imprese
							(id, nome, cf, piva, pec, email, sdi, split_payement, cod_tipo_impresa, az_id, 
							az_cod_aziendale, az_cod_regionale, sd_id, verificato, fonte, validita, tipo_soggetto)
							VALUES(nextval('cu_anag.cu_anag_id_seq'), rc.ragione_sociale , rc.codice_fiscale,piva, NULL, NULL, NULL, 'N', cod_timpo_impresa,null,
							null,null,0,true,FONTE_ANAG,	tsrange(rc.data_inizio_attivita,null,'()'),tipo_soggetto)						 
					 		returning * into R_IMP;
				 		    n:=cu_log.upd_record('cu_anag.imprese',id_transazione,R_IMP,'I');
				 		    log_string :=    'INSERITA IMPRESA' || R_IMP.id ;
				 		    id_impresa_new:=R_IMP.id;		
				 	 	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
						    raise info 'INSERITA IMPRESA%',	R_IMP.id ;
			
 	 					   impresa_new:=true;
				 		 
				 	   else 
				 	        id_impresa_new:=rec1.id ;
				 	        impresa_new:=false;
		              
				 	   end if;   -- 'IF PRESENZA  IMPRESA DB ';
				 	  
----------------------END IMPRESA ---------------------------------------------------------------------------------------------------------			
				 	 
---------------------------STABILIMENTO ---------------------------------------------------------------------------------------------------				 	  
				  	   SELECT  * INTO rec2 from cu_anag.stabilimenti s 
				  	   where TRIM(s.cod_nazionale) =TRIM(rc.numero_di_registrazione_cun)
				  	   and  TRIM(s.cod_regionale) =TRIM(rc.numero_di_registrazione_riconoscimento) ;
				  	
				  	 -- GET DIAGNOSTICS total_rows := ROW_COUNT;
			 		
				        log_string :=    'PER CUN :'||COALESCE(Rc.numero_di_registrazione_cun,'') ;
			 		   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  			 		 
			 		   log_string :=   'PER NUMREG:' || '-'||COALESCE(rc.numero_di_registrazione_riconoscimento ,'');
			 		   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  			  	  
				  	--   log_string :=   'PNUM STAB PRESENTI:' || '-'||total_rows;
			 	--	   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				  	
			 		   if(rec2.ID IS NULL) then -- 'IF PRESENZA  STAB DB ';
			 		
			 		 	   log_string :=   'LO STAB DEVE ESSERE INSERITO' ;
			 	 		   raise info 'LO STAB DEVE ESSERE INSERITO';
			 	 	       execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			 	 	      
			 	 	      
			 	 	  	   select * INTO recInd from 
			 	 	  	   cu_anag.indirizzi	i  
			 	 	  	   where  rc.indirizzo_sede_produttiva= i.indirizzo 	and i.istat_comune = rc.codice_istatSedeProd
						   and i.comune =rc.comune;
						    
				  	  	 --  GET DIAGNOSTICS total_rows := ROW_COUNT;
			 	--	     
				  	 -- 	   log_string :=   'NUM RECORD PER INDIRIZZO PRESENTI' || total_rows;
				  	 -- 	   raise notice 'NUM RECORD PER INDIRIZZO PRESENTI%',total_rows;	 
			 			--   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			 	 	  	
			 		  /*     IF( recInd.id is null) THEN -- IF   INDIRIZZO PRESENTE
				 		        log_string :=   'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI PER SEDE PROD' ;
				 			    raise info 'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';
				 	  	  	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				 	  	*/  	   
			
							   
							    INSERT INTO cu_anag.indirizzi
								(id, toponimo, indirizzo, cap, stato_prov, nazione, istat_comune, comune, localita, civico, latitudine, longitudine, verificato, fonte)
								VALUES(nextval('cu_anag.cu_anag_id_seq'),null,rc.indirizzo_sede_produttiva,rc.capSedeProd, rc.prov ,null, 
								rc.codice_istatSedeProd, rc.comune,null,null,null,null,true,FONTE_ANAG   )
							    returning  * into R_IND;
							    n:=cu_log.upd_record('cu_anag.indirizzi',id_transazione,R_IND,'I');
							    id_IND:=R_IND.id;
							    log_string :=   'ID INDIRIZZO NELLA TABELLA INDIRIZZI'|| id_IND ;
				 			    raise info 'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';
				 	  	  	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
						   
			 	  	  	  /* else
			 	  	  		   id_IND:= recInd.id;
		 	 	   		   END IF; -- IF   INDIRIZZO PRESENTE
						   */
			 			   
	  				
			 	 	  	   INSERT INTO cu_anag.stabilimenti
							(id, id_impresa, nome, sd_id, id_indirizzo, cod_regionale, verificato, fonte, categoria_rischio, validita, cod_nazionale, id_tipologia_struttura, pec, telefono, sdi)
							VALUES( nextval('cu_anag.cu_anag_id_seq'), id_impresa_new, 
							case when rc.denominazione_sede = '' then rc.ragione_sociale else rc.denominazione_sede end,
							NULL, id_IND, rc.numero_di_registrazione_riconoscimento, false,FONTE_ANAG,1,tsrange(rc.data_inizio_attivita,null,'()'),
							rc.numero_di_registrazione_cun, rc.ts_id,null, null, NULL)
						   returning  * into R_STAB;

			 	 	  	  
				
						   n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_STAB,'I');
						   
						   
						   log_string :=   'STAB ID' ||R_STAB.id;
						   raise info  'STAB ID%,' ,R_STAB.id;
						   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
						   id_STAB:=R_STAB.id;
						 
				
						   
						   log_string :=   'INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE' ||left(rc.dettaglio_attivita,3);
						   raise info 'INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE%',left(rc.dettaglio_attivita,3)  ;
						   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
						 
					    
					 
							
						   if(rc.dettaglio_attivita !=null  or rc.dettaglio_attivita!='') then --IF ESISTE DETTAGLIO LINEA NEL FILE
				 		  	  INSERT INTO cu_anag.linee
								(id,id_stabilimento , id_tipo_linea, validita, attivita_fissa, linea_principale, verificato, 
								fonte, data_ultima_visita, id_esterno)
						      VALUES(nextval('cu_anag.cu_anag_id_seq'), id_STAB,rc.id_tipo_linea,	
						      validita_da_file , 
						      true,rc.attivita_principale ilike 'SI'  , true,FONTE_ANAG,(CURRENT_TIMESTAMP - '1 year'::interval)  , '')
							  returning  * into R_LINEA;
							 
							  log_string :=    'id_stabilimento ID' ||R_LINEA.id_stabilimento;
							  raise info  'LINEA ID%,' ,R_LINEA.id;
							  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
							
					 	      log_string :=   'LINEA ID' ||R_LINEA.id;
							  raise info  'LINEA ID%,' ,R_LINEA.id;
							  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
						   end if;
						 
				 	    else -- 'IF PRESENZA  STAB DB ';
				 		   
				 		    id_STAB:=rec2.id;
				 		-- 	raise info 'AGGIORNIAMO I VALORI DI ID_INDIRIZZO DELLO STAB , ID_INIDIRZZO%',rec2.id_indirizzo;
				 		  	raise info 'numero_di_registrazione_cun%',TRIM(rc.numero_di_registrazione_cun);
				 		   	raise info 'numero_di_registrazione_riconoscimento%', TRIM(rc.numero_di_registrazione_riconoscimento);
				 		  	raise info 'tipoStrCod%',tipoStrCod;
				 		    log_string :=  '**'|| 'AGGIORNIAMO VALORI DI ID_INDIRIZZO :'||rec2.id_indirizzo;
		           			execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				 		
		           		   /** commentato per issue 11982
		           		    UPDATE  cu_anag.indirizzi i
							SET indirizzo=rc.indirizzo_sede_produttiva,
							    stato_prov =rc.prov,
							    istat_comune =rc.codice_istatSedeProd,
							    comune=rc.comune
							where i.id=rec2.id_indirizzo::BIGINT
							returning  * into R_IND;
				            n:=cu_log.upd_record('cu_anag.indirizzi',id_transazione,R_IND,'U');
		 	 	   		  * ***/
		           		
			 			    raise info 'AGGIORNIAMO denominazione_sede STABILIMENTI';
			 			    log_string :=  '**'||  'AGGIORNIAMO DENOM_SEDE DI STAB';
			 			    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				 		 
		        		 	update   cu_anag.stabilimenti  s
		        		 	set nome= case when rc.denominazione_sede = '' 
		        		 	then rc.ragione_sociale else rc.denominazione_sede end
		        		 	where s.id=id_STAB		  		            
		 	 	   			returning  * into R_STAB;
						
						    n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_STAB,'U');
			
		 	 	   		    
		 	 	   		    raise info 'VERIFCICHIAMO SE LA LINEA DELLO STAB ESITE NELLA TABELLA LINEE';
		 	 	   			raise info ' STAB_ID%',rec2.id;
		 	 	   		    raise info ' dettaglio_attivita%',left(rc.dettaglio_attivita,3);		 	 	   		  
			 			    log_string :=  '**'||  'VERIFCICHIAMO SE LA LINEA DELLO STAB ESITE NELLA TABELLA LINEE';
			 			    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		 	 	   		   
		 	 	   		 
		 	 	   		    SELECT *  INTO rec3
		 	 	   		    FROM cu_anag.linee l
							inner join agenda.vw_tipo_linee tl ON l.id_tipo_linea =tl.id_tipo_linea 
							WHERE id_stabilimento =rec2.id AND
							 upper(translate(regexp_replace(tl.descr,'\[[^[]*\]','') ,' -','')) =
 	 						 upper(translate(rc.dettaglio_attivita||rc.descrizione_attivita,' -',''))		;
							--and left(rc.dettaglio_attivita,3) = substring(tl.descr from '^\[.*\] (M[0-9][0-9])');   
			 			
		 	 	   		
		 	 	   		--    GET DIAGNOSTICS num := ROW_COUNT;
			 			--	raise notice 'numero linee presenti %',num;	
			 			      
				 		   
				 	--	    log_string :=  '**'|| 'NUM LINEE PRESENTI '||num ||' PER STAB_ID E ATTIVITA:' ||rec2.id || '-'||left(rc.dettaglio_attivita,3);
			 			--    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				 		   
			 			    if(rec3.id is null)then -- 'IF PRESENZA  LINEA  DB ';
			 			       raise info 'INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';
			 			       raise info 'INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE%',left(rc.dettaglio_attivita,3)  ;
			 		
				 		      log_string := log_string || '**'|| 'INSERIAMO LA LINEA  ' ;
			 			      execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				 		
			 	 
						       INSERT INTO cu_anag.linee
								(id, id_stabilimento, id_tipo_linea, validita, attivita_fissa, linea_principale, verificato, fonte, data_ultima_visita, id_esterno)
							     VALUES(nextval('cu_anag.cu_anag_id_seq') , id_STAB, rc.id_tipo_linea, 
							   validita_da_file,
							    true, rc.attivita_principale ilike 'SI'  , true,FONTE_ANAG,  (CURRENT_TIMESTAMP - '1 year'::interval) ,'')
								returning  * into R_LINEA;
								n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_LINEA,'I');  
						 
					 
		
						
							 else -- 'IF PRESENZA  LINEA  DB ';
						 		 raise info 'AGGIORNIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';
						 		 raise info 'id linea %',rec3.id;
						 		 raise info 'rc.data_inizio %',rc.data_inizio;
						 	    
						  --      log_string := '**'|| 'AGGIORNIAMO LA LINEA linea: '|| rec3.id || ' data_inizio:'||rc.data_inizio ;
						    --     log_string := '**'|| 'AGGIORNIAMO LA LINEA linea: '|| rec3.id || '   data_fine_attivita:'||rc.data_fine_attivita ;
			 			         execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				 		       
			 			        
			 		              --Calcola inizio
			     			 /*	 if (lower_inf(rec3.validita) or lower_inf(validita_da_file)) then
			     				     inizio := null; 
			     				      log_string :=  'sono qui lower_inf rec3.validita ' ;
						              execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			     				 else 
			      				   --  inizio:= min(lower(rec1.validita),lower(v_validita));
					      		     if(lower(rec3.validita)<lower(validita_da_file)) then
					      				     inizio:=lower(rec3.validita);
					      				     log_string :=  'sono qui inizio:=lower rec3.validit  ' ;
						           			 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
					      			 else
					      				   	 inizio:=lower(validita_da_file);					      				   	
					      				     log_string :=  'sono qui  inizio:=lower validita_da_file  ' ;
						           			 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
					      			 end if;
			      				 end if;  */
			      		 
				 		
			      				 
								
							     inizio:=lower(rec3.validita);
							  
			 			    	
			 			    	
			 			    	
						       if ( lower_inf(validita_da_file) is false) then 
						          	  log_string := log_string || '**'|| ' lower_inf(validita_da_file.validita) is false    '   ;
			 			    	       execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
						           if( lower_inf(rec3.validita) is true ) then
						          	  inizio:=lower(validita_da_file);
						          	  log_string := log_string || '**'|| ' lower_inf(rec3.validita) is true    '   ;
			 			    	       execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
						           else
						             if( lower(validita_da_file)<lower(rec3.validita) ) then
			      		      		    inizio:=lower(validita_da_file);
			      		      		   	  log_string := log_string || '**'|| ' lower_inf(rec3.validita) is true    '   ;
			 			    	       execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
			 			    	        log_string := log_string || '**'|| ' lower(validita_da_file)<lower(rec3.validita)   '   ;
			 			    	       execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
			      			      	 end if;						             
						           end if;		       
						        end if;
						        
			 			    	
		 					   --Calcola fine
		      				   fine:=upper(rec3.validita);
						       if ( upper_inf(validita_da_file) is false) then 
						           if( upper_inf(rec3.validita) is true ) then
						          	  fine:=upper(validita_da_file);
						           else
						             if( upper(rec3.validita)<upper(validita_da_file)) then
			      		      		    fine:=upper(validita_da_file);
			      			      	 end if;						             
						           end if;		       
						        end if;
							   v_validita:=tsrange(inizio,fine);
								
								
								
							 
			  				--	 log_string :=   'sono qui  inizio ' ||coalesce(inizio,'');
						     --     execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
							 --   log_string :=   'sono qui  fine ' ||coalesce(fine,'');
						    --      execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
							    update  cu_anag.linee l
					  	  	    set    validita=v_validita
						 	    where l.id=rec3.id 	returning  * into R_LINEA;
							    n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_LINEA,'U');
			 	          		-- end if;
	 
			
		   		         
						 	 end if; -- 'IF PRESENZA  LINEA  DB ';
					 	 	   			
		 	 	   		 
		 	 	   		
		 	 	   	 end if; -- 'IF PRESENZA  STAB DB ';
		 	 	   	
	-----------------------------------------END STABILIMENTO----------------------------------------------------------------------------------------------	 
	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	

		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
	------------------------------ AGGIORNAMENTO PER TUTTI GLI SCENARI--------------------------------------------------------------------------------------					
			/*	select case when count(li)  filter (where li is true) >0 then null else min(lower(validita))end as minval,
				case when count(ui)  filter (where ui is true) >0 then null else max(upper(validita))end as  maxval 
				into rec1 from (
				    select  lower_inf (validita) li,upper_inf(validita) ui,validita  
				    from  cu_anag.linee
				    where id_stabilimento =id_STAB --AND FONTE='BDN_LIN_UPD';
				  )A;
				
				raise info 'MINIMO VALORE E MAX VALORE TRA LE VALIDITA DELLE LINEE%', rec1; 
				 
				v_validita:=tsrange(rec1.minval ,rec1.maxval,'[)');*/
		 	 	   	
		 	 	   	
		 	 			 	 	   	
/*  ***************** COMMENTATO PER ISSUE #11982	 	 	   	   	
		 	 	   	
		 	    SELECT * INTO rec3 FROM cu_anag.stabilimenti    WHERE id  =id_STAB ; 
		 	   
			    log_string :=   'STAB  rc.data_inizio_attivita  ' || rc.data_inizio_attivita ;  	
			    log_string :=   'STAB  rc.data_fine_attivita  ' || rc.data_fine_attivita ; 	
		 	    validita_da_file_stab	=tsrange( case when rc.data_inizio_attivita is null then null else rc.data_inizio_attivita end   ,
							 case when rc.data_fine_attivita is null then null else  rc.data_fine_attivita::timestamp + INTERVAL '1 DAY'end,'[)');   	
				   	
		 	 	 if( lower_inf(validita_da_file_stab) is false)then
					     if(  lower(rec3.validita)>lower(validita_da_file_stab) is true) then
		      				inizio:=lower(rec3.validita);
		      			    log_string :=   'stab  inizio:=lower rec3.validita  ' ;
			           	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
		      		     else
		      			    inizio:=lower(validita_da_file_stab);
		      			  	log_string :=   'stab  	 inizio:=lower validita_da_file  ' ;
			           	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
		      		     end if;
	      		 else
	      		    inizio:=lower(rec3.validita);
	      		   	log_string :=   'stab  inizio:=lowerinfo rec3.validita  ' ;
		            execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
			     end if;
							    
			 					 --Calcola fine
							   						  
				 if( upper_inf(validita_da_file_stab) is false)then
				     if(  upper(rec3.validita)>upper(validita_da_file_stab) is true) then
	      				fine:=upper(rec3.validita);
	      			    log_string :=   'stab fine:=upper rec3.validita  ' ;
		           	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
	      		     else
	      			    fine:=upper(validita_da_file_stab);
	      			  	log_string :=   'stab	 fine:=upper validita_da_file  ' ;
		           	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
	      		     end if;
	      		 else
	      		    fine:=upper(rec3.validita);
	      		    log_string :=   'stab  fine:=upperinfo rec3.validita  ' ;
		            execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
			     end if;
			     
			     
			     
			     fine:=null;
	             v_validita:=tsrange(inizio,fine,'[)');   
		 
		***************************/ 	 	   	
		 	 	   	
		
				
				-- VERIFICHIAMO SE IMPRESA DELLA SEDE ESISTE
		/*		log_string := 'VERIFICHIAMO SE IMPRESA DELLA SEDE ESISTE';
				execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			

			   select * INTO recInd from   cu_anag.indirizzi	i  
 	 	  	   where  rc.indirizzo_sede_legale= i.indirizzo 	and i.istat_comune = rc.capSedeLegale 
			   and i.comune =rc.comune;
			
	
 		       IF( recInd.id is null) THEN
 		        log_string :=   'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI' ;
 			    raise info 'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';
 	  	  	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
 	  	  	   

			   
			    INSERT INTO cu_anag.indirizzi
				(id, toponimo, indirizzo, cap, stato_prov, nazione, istat_comune, comune, localita, civico, latitudine, longitudine, verificato, fonte)
				VALUES(nextval('cu_anag.cu_anag_id_seq'),null,rc.indirizzo_sede_legale,rc.capSedeLegale, rc.prov ,null, 
				null, rc.comune,null,null,null,null,true,FONTE_ANAG   )
			    returning  * into R_IND;
			    n:=cu_log.upd_record('cu_anag.indirizzi',id_transazione,R_IND,'I');
			    id_indirizzo_sede:=R_IND.id;
			    log_string :=   'ID INDIRIZZO NELLA TABELLA INDIRIZZI'|| id_indirizzo_sede ;
 			    raise info 'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';
 	  	  	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			   
 	  	  	   else
 	  	  		   id_indirizzo_sede:= recInd.id;
 	   		   END IF;
			
			
			
			
			
			
			
			
			
     			-- AGGIORNIAMO INDIRIZZO SEDI 
			    SELECT * INTO rec1 FROM cu_anag.stabilimento_sedi    WHERE id_stabilimento  =id_STAB and 
					v_validita && v_validita
					and id_tipo_sede = (select id from cu_types.tipi_sede where cod = 'sl'); 
				
				
				  	
	  			IF (rec1.ID IS NULL) THEN -- IF PRESENZA  SEDI PER IMPRESA
			    --id_indirizzo_sede   VEDIAMO SE ESISTE ID_INDIRIZZO_SEDE_LEGALE NELLA TAB.   INDIRIZZO,SE NON ESISTE LO INSERIAMO ALTEIMENTI LO RECUPERIAMO
 
	  			 	   
	 	 	   		  INSERT INTO cu_anag.stabilimento_sedi
					  (id, id_stabilimento, id_tipo_sede, id_indirizzo,  fonte,validita)
					   VALUES(nextval('cu_anag.cu_anag_id_seq'), id_STAB, 1, id_indirizzo_sede,FONTE_ANAG,v_validita)
 	  			       returning  * into R_STABSEDE;
					   n:=cu_log.upd_record('cu_anag.stabilimento_sedi',id_transazione,R_STABSEDE,'I');
					    
					   log_string :=   'ID   NELLA TABELLA STAB SEDI'|| R_STABSEDE.id ;
		 			   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	  			
	  	 
		 	    ELSE
		 	
                 --     IF(id_indirizzo_sede!=rec1.id_indirizzo  or ) THEN
                      
                            UPDATE  cu_anag.stabilimento_sedi i
							SET id_indirizzo=id_indirizzo_sede,
							validita =v_validita
					 		where i.id_indirizzo =rec1.id_indirizzo AND id_stabilimento =id_STAB
							returning  * into R_STABSEDE;
				            n:=cu_log.upd_record('cu_anag.stabilimento_sedi',id_transazione,R_STABSEDE,'U');                   
   
                  --    END IF;
                      
                      
		 	    END IF;  -- IF PRESENZA INDIRIZZO SEDI PER IMPRESA
			 	*/
		 
              /* COMMENTATO PER RICHIESTA DEL CLIENTE   10/06/2024 */
 /*
		 	   select validita @> v_validita as contiene ,* into recapp  from cu_anag.stabilimento_figure sf where id_stabilimento  =id_STAB
			               and id_tipo_figura =12  AND validita && v_validita  ;
			              
			              
	
			   if (recapp.id is null ) then  ---- IF numSogg=0 SOGGETTI FISICI 		 		     
					  -------------INSERIAMO IN STAB FIGURE
			         --  log_string :=   '**'|| 'INSERITO STAB FIGURE' || R_STABFIG.id ;						 		     	
			 	-- 	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
					 		     
			 		  INSERT INTO cu_anag.stabilimento_figure
							(id, id_stabilimento, id_soggetto, id_tipo_figura,    fonte,validita)
						VALUES(nextval('cu_anag.cu_anag_id_seq'),id_STAB,id_impresa_new, 12, FONTE_ANAG,v_validita)						 
				 		returning * into R_STABFIG;
			 		    n:=cu_log.upd_record('cu_anag.stabilimento_figure',id_transazione,R_STABFIG,'I');
			 		    log_string :=   '**'|| 'INSERITO STAB FIGURE' || R_STABFIG.id ;						 		     	
			 	 	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			   
			   else
			 	     
				
		 	           
		 	         
                    UPDATE  cu_anag.stabilimento_figure f
					SET validita =v_validita
			 		where f.id=recapp.id
					returning  * into R_STABFIG;
		            n:=cu_log.upd_record('cu_anag.stabilimento_figure',id_transazione,R_STABFIG,'U');             
		           
		           
		           
		 	         
		 	         
		 	  end if;       
		 	         
		 	  select row_to_json(a.*) into chiamata_j from  (select id_impresa_new id_impresa,id_STAB id_stabilimento) a;
			  select * into ver from cu_anag.check_stabilimento_valido_bool(chiamata_j,id_transazione);
	          log_string:=    'verificato:'||ver;
		      execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	       
		--      log_string := 'AGGIORNIAMO id_STAB '||id_STAB;
		 --  	  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		   	 
		   	   log_string := 'AGGIORNIAMO rc.ts_id  '||rc.ts_id ;
		   	  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		    
		   	 
		   	 
		   	 
		   	 
		      update cu_anag.stabilimenti 
					set  validita=v_validita  , verificato =ver 
					where id  =id_STAB AND id_tipologia_struttura =rc.ts_id 
					returning * into R_S;
					n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_S,'U');
					   
			  log_string := 'AGGIORNIAMO VALIDITA SU STAB VALIDITA E VERIFICATO ';
			  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		 	 */
		 	 
		 	 	   	
		 	
	------------------------------ AGGIORNAMENTO PER TUTTI GLI SCENARI--------------------------------------------------------------------------------------					
				select case when count(li)  filter (where li is true) >0 then null else min(lower(validita))end as minval,
				case when count(ui)  filter (where ui is true) >0 then null else max(upper(validita))end as  maxval 
				into rec1 from (
				    select  lower_inf (validita) li,upper_inf(validita) ui,validita  
				    from  cu_anag.linee
				    where id_stabilimento =id_STAB --AND FONTE='BDN_LIN_UPD';
				  )A;
				
				raise info 'MINIMO VALORE E MAX VALORE TRA LE VALIDITA DELLE LINEE %', rec1;
				 
				validita_da_linee:=tsrange(rec1.minval ,rec1.maxval,'[)');
			
			    	   	
		 	    SELECT * INTO rec3 FROM cu_anag.stabilimenti    WHERE id  =id_STAB ;  
		 	   
		 	    if ( lower_inf(validita_da_linee)) then
		     	  	  inizio := lower(rec3.validita); 
		        else 
		     	      if( lower_inf(rec3.validita) is true )then
		            	 inizio:=lower(validita_da_linee);
		              else 
			              if(lower(rec3.validita)>lower(validita_da_linee)) then
					      	 inizio:=lower(validita_da_linee);
					      else
					      	 inizio:=lower(rec3.validita);
			              end if;
		         	  end if;
		            	 
		       end if;  
		 					   --Calcola fine
		      
		      /**COMMENTATO PER ISSUE 11982
			  if  upper_inf(validita_da_linee) then 
			    	fine := upper(rec3.validita);
			  else 
		           if( upper_inf(rec3.validita) is true )then
		                 fine:=upper(validita_da_linee);
		           else 
		              if(upper(rec3.validita)<upper(validita_da_linee)) then
				      	 fine:=upper(validita_da_linee);
				      else
				      	 fine:=upper(rec3.validita);
		              end if;
		           end if;
		      end if;
		      
		      ***/ 
		     fine:=null;
             v_validita:=tsrange(inizio,fine,'[)');  
						 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
		 	 	   	
            /************ VERIFICATO A FALSE PER RICHIESTA DEL CLIENTE 10/06/2024 *****/
			    update cu_anag.stabilimenti 
			set  validita=v_validita , verificato =FALSE
			where id  =id_STAB AND id_tipologia_struttura =rc.ts_id
			returning * into R_S;
			n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_S,'U');
		
			if(impresa_new)  then
			    update cu_anag.imprese  
				set  validita=v_validita  
				where id  =id_impresa_new  
				returning * into R_IMP;
				n:=cu_log.upd_record('cu_anag.imprese',id_transazione,R_IMP,'U'); 
			end if;
		 	 
-------------------------END AGGIORNAMENTO PER TUTTI GLI SCENARI--------------------------------------------------------------------------------------			  
		end if; 
	    
	 	END LOOP ; 
	 	log_string :=  '**'|| 'ESCO DAL LOOP: ' ;
		execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  

 		ret.esito:=true;
		log_string :=  '**'|| 'ESITO: '|| ret.esito;
		execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	 	return ret;
				 
	end;
	END;
	$$;


ALTER FUNCTION cu_anag.load_stabilimenti_mangimifici(v json, id_transazione bigint) OWNER TO postgres;

--
-- Name: load_stabilimenti_sintesis(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_stabilimenti_sintesis() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	num integer;
    tipoStrId  varchar;
    idImport  varchar;
 	rc record ;
	rec1 record ;
	rec2 record ;
	rec3 record;
	R_IMP cu_anag.imprese;
	R_IND cu_anag.indirizzi;
	R_STAB cu_anag.stabilimenti;
    R_LINEA  cu_anag.linee;
    id_transazione integer;
    log_string varchar;
	stampa varchar;
    LOG_FILE varchar;
	begin
	    idImport:=v->'id_import'; 
		tipoStrId:=v->'tipoStrId';
		id_transazione:=-1;



 
	

	
	/********************mettere le stampe nel file di log di antonio *************/
		 
     LOG_FILE:='/tmp/loadStabSintesis'+now;
	 
	
	 FOR rc IN (SELECT * FROM cu_anag.file_xls_sintesis )    
		LOOP
		        log_string := 'VERIFICHIAMO SE ESISTE L''IMPRESA PARTITA IVA :'+rc.partita_iva;
		  		raise info 'VERIFICHIAMO SE ESISTE L''IMPRESA PARTITA IVA%',rc.partita_iva;
		  	    stampa:='echo '+log_STRING+ '>' + LOG_FILE;
		  	    raise info 'VERIFICHIAMO SE ESISTE L''IMPRESA PARTITA IVA%',stampa;
		  	   
  	   		--	COPY shell FROM PROGRAM stampa  ;
		  	     
     	 
		  		SELECT  * INTO rec1 from cu_anag.imprese i  where  i.piva =rc.partita_iva ;
		  		GET DIAGNOSTICS total_rows := ROW_COUNT;
	 			raise notice 'numero imprese presenti %',total_rows;	 
	 			if(total_rows==0) then
	 			   raise info 'INSERIAMO IMPRESA';
		 		   INSERT INTO cu_anag.imprese
					select nextval('cu_anag.cu_anag_id_seq'), a.ragione_sociale_impresa, a.codice_fiscale, a.partita_iva, NULL, NULL, NULL, NULL, 'S',null,null,null,null,true,tipoP,
					'(,)'::tsrange, 'G' from (
			   			 select distinct a.ragione_sociale_impresa,a.codice_fiscale,a.partita_iva	 
			 			  from cu_anag.file_xls_sintesis a where TRIM(rec1.partita_iva)=TRIM(a.partita_iva)
			 			)a returning * into R_IMP;
		 		   n:=cu_log.upd_record('cu_anag.imprese',id_transazione,R_IMP,'I');
			
		 		end if;
		 	
		 		raise info 'VERIFICHIAMO SE ESISTE STAB. PER APPROVAL NUMBER%',rc.approval_number;
		  	
		  		SELECT  * INTO rec2 from cu_anag.stabilimenti s  where  TRIM(s.cod_nazionale) =TRIM(rc.approval_number) ;
		  		GET DIAGNOSTICS total_rows := ROW_COUNT;
	 			raise notice 'numero stab presenti %',total_rows;	 
	 			if(total_rows==0) then
	 		
	 			   raise info 'LOSTAB DEVE ESSERE INSERITO';
	 			  
	 			   raise info 'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';
	 			   
	 			    INSERT INTO cu_anag.indirizzi
				    select   nextval('cu_anag.cu_anag_id_seq'),indirizzo,null,sigla_provincia,null,case when c.codistat is null then null else codice_istat end codistat,
				 	          case when c.codistat is null then a.comune else null end comune,null,null,null,null,true,
				 	ts.codice  fonte
				 	from cu_anag.file_xls_sintesis a
				 	left join conf_ext.vw_comuni_vigenti_attivi  c on a.comune=c.denominazione_it 
				 	left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId
				 	where TRIM(rc.approval_number) = TRIM(a.approval_number) 
				 	returning  * into R_IND;
				    n:=cu_log.upd_record('cu_anag.indirizzi',id_transazione,R_IND,'I');
 	 	   		   
				    raise info 'INSERIAMO LO STAB NELLA TABELLA STABILIMENTI';
				    
					INSERT INTO cu_anag.stabilimenti
					select nextval('cu_anag.cu_anag_id_seq'),rec1.id,denominazione_sede_operativa,null,R_IND.id,approval_number,true,
					ts.codice fonte,1,tsrange(null,null,'()'),approval_number,ts.id,null,null,null
			 		from cu_anag.file_xls_sintesis a
					left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId
					where TRIM(rc.approval_number) = TRIM(a.approval_number) 				
					returning  * into R_STAB;
				
				    n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_STAB,'I');
				    raise info 'INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';
				
		 	
		 		 else
		 		   
		 		 	raise info 'AGGIORNIAMO I VALORI DI ID_INDIRIZZO DELLO STAB , ID_INIDIRZZO%',rec2.id_indirizzo;
							 		    	
					UPDATE  cu_anag.indirizzi i
					SET indirizzo=subquery.indirizzo,
					    sigla_provincia=subquery.sigla_provincia,
					    codistat=subquery.codistat,
					    comune=subquery.comune
					FROM (select  
					     indirizzo, sigla_provincia, case when c.codistat is null then null else codice_istat end codistat,
						 case when c.codistat is null then a.comune else null end comune 
						 from cu_anag.file_xls_sintesis a
					     left join conf_ext.vw_comuni_vigenti_attivi  c on a.comune=c.denominazione_it 		
						 left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId) AS subquery
					where i.id=rec2.id_indirizzo
					returning  * into R_IND;
		            n:=cu_log.upd_record('cu_anag.indirizzi',id_transazione,R_IND,'U');
 	 	   		  
	   
		 		 
        		 	update   cu_anag.stabilimenti  set nome= rec.denominazione_sede 
 	 	   			where    cod_nazionale=rc.approval_number 	 	   		
 	 	   			returning  * into R_STAB;
				
				    n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_STAB,'U');
	
 	 	   		
 	 	   		
 	 	   		    raise info 'VERIFCICHIAMO SE LA LINEA DELLO ESITE NELLA TABELLA LINEE';
 	 	   		
 	 	   		   
 	 	   		    SELECT *  INTO rec3 FROM cu_anag.linee
					inner join agenda.vw_tipo_linee tl ON 
						case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP' then 
						'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
						when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI' then
						'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
						else upper(translate(tl.descr,' -','')) end=upper(translate(rc.attivita||rc.descrizione_sezione,' -',''))
	 				WHERE id_stabilimento =rec2.id ;   
	 			
 	 	   		
 	 	   		    GET DIAGNOSTICS num := ROW_COUNT;
	 				raise notice 'numero linee presenti %',n;	
	 			    if(num==0)then
	 			       raise info 'INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';
	 			       insert into cu_anag.linee
						select nextval('cu_anag.cu_anag_id_seq') id,
						s.id id_stabilimento,tl.id id_tipo_linea ,
						tsrange(data_inizio_attivita::timestamp,
							case when replace(data_fine_attivita,'-','')='' then null::timestamp else replace(data_fine_attivita,'-','')::timestamp end,'[)') validita,
						true,false linea_principale,true,tl.cod 
						from cu_anag.file_xls_sintesis  i 
						join cu_anag.stabilimenti s on i.approval_number=s.cod_regionale
						left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId
					 	join agenda.vw_tipo_linee tl ON 					
							case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP' then 
							'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
								when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI' then
							'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
								else upper(translate(tl.descr,' -','')) end=upper(translate(i.attivita||i.descrizione_sezione,' -',''))
				       	returning  * into R_LINEA;
						n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_LINEA,'I');
				
					  else
				 		 raise info 'AGGIORNIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';
				 		 update  cu_anag.linee l
				 	   	 set    validita= tsrange(data_inizio_attivita::timestamp,
						   		case when replace(data_fine_attivita,'-','')='' then null::timestamp else replace(data_fine_attivita,'-','')::timestamp end,'[)') 
			             where l.id=rec3.id 	returning  * into R_LINEA;
						n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_LINEA,'U');

				 	 end if;
			 	 	   			
 	 	   		 
 	 	   		
 	 	   	 end if;
        		 
		 /*VERIFICARE SE CI SONO STAB DA CHIUDERE SE HANNO TUTTE LE LINEE CHIUSE */

		 			  
		END LOOP ; 
	
	 /*   SELECT  * into  rec1  FROM cu_anag.file_xls_sintesis s
        left join  cu_anag.imprese i  on i.piva =s.partita_iva ;
       
        if(rec1.id==null)then
        
    
	        INSERT INTO cu_anag.imprese
			select nextval('cu_anag.cu_anag_id_seq'), a.ragione_sociale_impresa, a.codice_fiscale, a.partita_iva, NULL, NULL, NULL, NULL, 'S',null,null,null,null,true,tipoP,
			'(,)'::tsrange, 'G' from (
		    select distinct a.ragione_sociale_impresa,a.codice_fiscale,a.partita_iva	 
		 	from cu_anag.file_xls_sintesis a where rec1.partita_iva=a.partita_iva
		 	)a;
	 		GET DIAGNOSTICS total_rows := ROW_COUNT;
	 		raise notice '	righe caricate %',total_rows;	 
        
        end if;
   
	
	    SELECT  * into  rec2  FROM cu_anag.file_xls_sintesis 
        left join  cu_anag.stabilimenti stab  on stab.cod_nazionale =approval_number;
   
	
 	 	if(rec.cod_nazionale!=null )then
 	 		
 	 		
 	 		
 	 		update   cu_anag.stabilimenti  set nome= rec.denominazione_sede,id_tipologia_struttura=tipoP
 	 	    where cod_nazionale=rec.approval_number;
 	 	   
 	 	   --verificare se id_indirizzo esiste , se esiste non si aggiorna altrimenti si fa un aggiornamento dei valori sulla tabella degli indirizzi
 	 	 
 	 	   -- nel caso fare update indirizzi
 	 	
 	 	end if;
 	 	
 	 	
 	 	/* 852integratori853AAE */
		update cu_anag.file_xls_sintesis a
		set id=s.rn
		from 
		(select  approval_number ,attivita,descrizione_sezione,row_number() over () rn from cu_anag.file_xls_sintesis where tipo =tipoP) s
		where a.approval_number=s.approval_number and a.attivita=s.attivita and a.descrizione_sezione=s.descrizione_sezione;
		
		raise notice '12 - imprese 852integratori853AAE';
		insert into cu_anag.imprese
				select nextval('cu_anag.cu_anag_id_seq'),a.ragione_sociale_impresa,a.codice_fiscale,a.partita_iva,
	 	null,null,null,null,a.fg_an_tipo_persona,-a.az_id*10-4,null,null,-a.az_id*10-4,true,a.tipo 
	 	from(select distinct a.ragione_sociale_impresa,a.codice_fiscale,a.partita_iva,
	 	i.fg_an_tipo_persona,a.az_id,a.tipo
	 	from cu_anag.file_xls_sintesis a
	 	 	left join cu_anag.vw_fvg_gisa_imprese_all i on a.partita_iva  =i.az_an_iva and 
			upper(fg_tipo_figura_descr) in ('SEDE LEGALE')and az_cod_aziendale ilike 'CE%') a
  	    where a.tipo =tipoP;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;	 

	 

  
 	    raise notice '13 - stabilimenti 852integratori853AAE';
		insert into cu_anag.stabilimenti
		select nextval('cu_anag.cu_anag_id_seq'),id_impresa,denominazione_sede_operativa,-sd_id*10-4,-sd_id*10-4,approval_number,true,
		fonte,1,tsrange(null,null,'()'),approval_number,id_tipologia_struttura,null,null,null
		from (
			select distinct on (a.approval_number) i.id id_impresa,a.denominazione_sede_operativa,a.approval_number,tipo fonte,/*min(a.id) */a.id sd_id,
			gi.sd_cod_tipologia_struttura cod_tipologia_struttura,ts.id id_tipologia_struttura
			from cu_anag.file_xls_sintesis a
			left join cu_anag.imprese i  on i.nome=a.ragione_sociale_impresa and i.cf=a.codice_fiscale and i.piva=a.partita_iva
			left join cu_anag.vw_fvg_gisa_imprese_all gi on gi.az_cod_aziendale =a.approval_number 
			left join cu_types.tipologie_struttura ts on ts.codice=gi.sd_cod_tipologia_struttura
			where a.tipo =tipoP
			order by a.approval_number,a.id
		) t;
	 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
	
        raise notice '14 - indirizzi 852integratori853AAE';
		
		insert into cu_anag.indirizzi
	 	select ---sd_id*10-4
	 	sd_id,null,a.indirizzo,null,a.sigla_provincia,null,a.codistat,a.comune,null,null,null,null,true,fonte from
	 	(select sd_id,indirizzo,case when c.codistat is null then a.comune else null end comune,sigla_provincia,
	 	case when c.codistat is null then null else codice_istat end codistat,--gi.fonte al posto di fonte
	 	gi.fonte fonte,min(a.id) id
	 	from cu_anag.file_xls_sintesis a
		left join conf_ext.vw_comuni_vigenti_attivi  c on a.comune=c.denominazione_it 
		join cu_anag.stabilimenti gi on gi.cod_regionale =a.approval_number 
		where a.tipo =tipoP and  gi.sd_id in (
	  		select sd_id from cu_anag.stabilimenti
			inner join cu_anag.tipo_import_anagrafica ta on upper(ta.descr) =upper(fonte)
			where ta.cod = tipoP )


		group by 1,2,3,4,5,6
		) a;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe   caricate %',total_rows;
	

 	
		raise notice '15 - linee 852integratori853AAE';
		insert into cu_anag.linee
			select nextval('cu_anag.cu_anag_id_seq') id,
			s.id id_stabilimento,tl.id id_tipo_linea ,
			tsrange(data_inizio_attivita::timestamp,
				case when replace(data_fine_attivita,'-','')='' then null::timestamp else replace(data_fine_attivita,'-','')::timestamp end,'[)') validita,
			true,false linea_principale,true,i.tipo
			from cu_anag.file_xls_sintesis  i 
			join cu_anag.stabilimenti s on i.approval_number=s.cod_regionale
			--join cu_anag.imprese im on im.id=s.id_impresa
			join agenda.vw_tipo_linee tl ON 
				case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP' then 
				'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
					when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI' then
				'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
					else upper(translate(tl.descr,' -','')) end=upper(translate(i.attivita||i.descrizione_sezione,' -',''))
		   where i.tipo =tipoP ;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
 	 	ret:=cu_anag.load_new_stabilimenti_upd_indirizzi();
 	 	*/
 		return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.load_stabilimenti_sintesis() OWNER TO postgres;

--
-- Name: load_stabilimenti_sintesis(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_stabilimenti_sintesis(v json, id_transazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	num integer;
    tipoStrCod  varchar;
    idImportP  varchar;
 	rc record ;
	rec1 record ;
	rec2 record ;
	rec3 record;
	rec4 record;
    recapp record;
    recInd record;
	R_IMP cu_anag.imprese;
	R_IND cu_anag.indirizzi;
	R_STAB cu_anag.stabilimenti;
    R_LINEA  cu_anag.linee;
    R_SOGG_FIS cu_anag.soggetti_fisici;
    R_STABFIG cu_anag.stabilimento_figure;
    R_S cu_anag.stabilimenti;
    id_IND integer;
    id_transazione integer;
    log_string varchar;
	stampa varchar;
    LOG_FILE varchar;
   	cod_timpo_impresa varchar;
   tipo_soggetto varchar;
    id_impresa_new bigint;
    piva varchar;
    chiamata_j json;
    id_STAB integer;
    v_validita tsrange;
    validita_da_file tsrange;
    validita_da_linee tsrange;
    idSoggFis integer;
    inizio timestamp;
    fine timestamp;
    ver bool;
    FONTE_ANAG varchar;
    impresa_new bool;
	begin
	    idImportP:=v->'id_import'; 
		tipoStrCod:=v->>'tipoStrCod';
  
	
	/********************mettere le stampe nel file di log di antonio *************/
		 
      LOG_FILE:='/tmp/loadStabSintesis_'||CURRENT_DATE ;
     
      log_string := 'test log :' ; 
 	  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
 		
	 log_string := 'tipoStrCod' || tipoStrCod ; 
	
	 FOR rc IN (--SELECT * FROM cu_anag.file_xls_sintesis s   where s.idimport=idImportP::bigint
	  /*SELECT    *, ts.id ts_id, ts.codice  fonteINS,tl.id_tipo_linea id_tipo_linea ,
      case when listacapSP.istat is not null then (caps)->>0   else ''   end as capSedeProd       ,
      case when c.codistat is null then null else c.codice_istat end codice_istatSedeProd,
	  case when c.codistat is not null then s.comune else null end comune  
	  FROM cu_anag.file_xls_sintesis s
	  left join cu_types.tipologie_struttura ts   on ts.codice=tipoStrCod
	  left join conf_ext.vw_comuni_vigenti_attivi  c on comune=c.denominazione_it 
	  left join conf_ext.vw_istat_lista_cap  listacapSP on listacapSP.istat=c.codice_istat::text
 	--  left join agenda.vw_tipo_linee tl ON left(m.dettaglio_attivita,3) = substring(tl.descr from '^\[.*\] (M[0-9][0-9])')
	   	join agenda.vw_tipo_linee tl ON 
		  	            case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP'
		  	                 then 'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
							 when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI'
							 then 'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
					         else upper(translate(tl.descr,' -','')) end=upper(translate(S.attivita||S.descrizione_sezione,' -',''))
 	  where s.idimport=idImportP::bigint*/




	 
	 SELECT s.id ids,*, ts.id ts_id, ts.codice fonteINS,tl.id_tipo_linea id_tipo_linea ,
	case when listacapSP.istat is not null then (caps)->>0 else '' end as capSedeProd ,
	case when c.codistat is null then null else c.codice_istat end codice_istatSedeProd,
	case when c.codistat is null then s.comune else null end comuneSedeProd
	FROM cu_anag.file_xls_sintesis s
	left join cu_types.tipologie_struttura ts on ts.codice=tipoStrCod
	left join conf_ext.vw_comuni_vigenti_attivi c on 
	  			 regexp_replace( c.denominazione_it,'[- ]+','','g') ilike regexp_replace( comune,'[- ]+','','g')||'%'
	  join config.config cc on cc.nome='cod_regione' and cc.valore=c.idregione
				 --and c.idregione='06'
	left join conf_ext.vw_istat_lista_cap listacapSP on listacapSP.istat=c.codice_istat::text
	-- left join agenda.vw_tipo_linee tl ON left(m.dettaglio_attivita,3) = substring(tl.descr from '^\[.*\] (M[0-9][0-9])')
	join agenda.vw_tipo_linee tl ON
	case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP'
	then 'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
	when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI'
	then 'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
	else upper(translate(tl.descr,' -','')) end=upper(translate(S.attivita||S.descrizione_sezione,' -',''))
	where s.idimport=idImportP::bigint
	
	
	 )     
		loop
			
				raise notice 'codice comuneSedeProd preso da rc: %',rc.comuneSedeProd;
				raise notice 'comuneSedeProd preso da rc: %',rc.comuneSedeProd;
			 	FONTE_ANAG:=rc.fonteINS||'_UPD';
			 
			 	log_string := 'comuneSedeProd' || coalesce(rc.comuneSedeProd,'') ; 
 	 			 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  

			 	log_string := 'codice_istatSedeProd' || coalesce(rc.codice_istatSedeProd,'') ; 
 	 			 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
 
			 	log_string := 'tipoStrCod' || tipoStrCod ; 
 	 			 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';
 
				log_string := 'idImportP' || idImportP ; 
 	 			 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		        log_string := 'VERIFICHIAMO SE ESISTE IMPRESA PARTITA IVA :'||rc.partita_iva;
		       

 	 		    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
 		
		  	     
     	 		/*SELECT  * INTO rec1 from cu_anag.imprese i
		  		left join cu_types.tipologie_struttura ts  on ts.id=tipoStrCod::int
		  	    where   rc.partita_iva !='' and i.piva =rc.partita_iva  ;*/
 	 		   
 	 		     if  ( ( rc.partita_iva =''  and   rc.codice_fiscale='')  or  ( rc.partita_iva ='-'  and   rc.codice_fiscale='-') )    then 				   		       
		  	    
					log_string := 'PARTITA IVA /CF NON PRESENTE NEL FILE' ;
			 	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			 	    ------------ *************** SALTARE IL LOOP ******************** ------------------
			  
		  	    else -- record valido
 	 		   
 	 		   
		 	 		   
				  	   
				  	   total_rows:=0;
				  	   select   *,ts.id ts_id  INTO rec1 from cu_anag.imprese i
						  		left join cu_types.tipologie_struttura ts  on ts.codice=tipoStrCod
						  	    where ( (rc.partita_iva!='' and i.piva =rc.partita_iva)    
						  	       or   (rc.codice_fiscale!='' and i.piva =rc.codice_fiscale )
						  	       or  (rc.codice_fiscale!='' and i.cf =rc.codice_fiscale  ) ) and i.tipo_soggetto='G'
									and validita @> current_timestamp::timestamp
                            order by i.piva limit 1 ;
				  	   
				  	   
				  		GET DIAGNOSTICS total_rows := ROW_COUNT;
			 			
				  		raise notice 'numero imprese presenti %',total_rows;	 
			 			log_string := 'numero imprese presenti:'||total_rows; 
		 	 		    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		 	 		   
		 	 		    validita_da_file :=  tsrange(			  
										  case when  rc.data_inizio_attivita >replace(rc.data_fine_attivita::text,'-','')::timestamp then rc.data_fine_attivita::timestamp  - INTERVAL '1 DAY' else rc.data_inizio_attivita::timestamp end,
										  case when replace(rc.data_fine_attivita::text,'-','')='' then null::timestamp else rc.data_fine_attivita::timestamp  + INTERVAL '1 DAY' end,'[)'
									);
								 
			 		
			 		
		--------------------------------------IMPRESA -------------------------------------------------------------------------------------------		
			 			if(total_rows=0) then
			 			 
			 			
		   			     raise info 'INSERIAMO IMPRESA'; 	 
				 	 	 log_string := 'INSERIAMO IMPRESA'; 
		 	 			 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		 	 			
		 	 			 piva=rc.partita_iva;	
					     if(piva='' and cu_anag.check_piva(rc.codice_fiscale)) then -- IF CF E' COME PIVA
			 		 	 		  piva=rc.codice_fiscale;
				 		 	 	  log_string :=   '**'||  'INSERIAMO IMPRESA PIVA COME CF' ||piva;			 			  
					 			  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			 	 
			 		 	 end if;  	-- IF CF E' COME PIVA
			 		 	 
			 		 	/* if( length(rc.codice_fiscale)=16  ) then --IF CODFISC E UN CF
				 			 	 cod_timpo_impresa:='P';	
				 			 	 tipo_soggetto:= 'F' ;
						 		     
						  else 		AF 20240924 */		 			 	 	 	   
								 cod_timpo_impresa:='S';
								 tipo_soggetto:= 'G' ;
						/*  end if; AF 20240924*/ ----IF CODFISC E UN CF
						 		 	 
				 	   INSERT INTO cu_anag.imprese
							(id, nome, cf, piva, pec, email, sdi, split_payement, cod_tipo_impresa, az_id, 
							az_cod_aziendale, az_cod_regionale, sd_id, verificato, fonte, validita, tipo_soggetto)
							VALUES(nextval('cu_anag.cu_anag_id_seq'), rc.ragione_sociale_impresa , rc.codice_fiscale,piva, NULL, NULL, NULL, 'N', cod_timpo_impresa,null,
							null,null,0,true,FONTE_ANAG,	tsrange(rc.data_inizio_attivita,null,'()'), tipo_soggetto)						 
					 		returning * into R_IMP;
				 		    n:=cu_log.upd_record('cu_anag.imprese',id_transazione,R_IMP,'I');
				 		    log_string :=   '**'|| 'INSERITA IMPRESA' || R_IMP.id ;
				 		    id_impresa_new:=R_IMP.id;		
				 	 	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
						    raise info 'INSERITA IMPRESA%',	R_IMP.id ;
			
 	 					   impresa_new:=true;
		 	   
		 
				   else 
				   
				   	     SELECT  *,ts.id ts_id INTO rec1 from cu_anag.imprese i
						  		left join cu_types.tipologie_struttura ts  on ts.codice=tipoStrCod
						  	    where ( (rc.partita_iva!='' and i.piva =rc.partita_iva)      or   (rc.codice_fiscale!='' and i.piva =rc.codice_fiscale )
						  	       or  (rc.codice_fiscale!='' and i.cf =rc.codice_fiscale  ) ) 
								and i.tipo_soggetto='G' and validita @> current_timestamp::timestamp order by i.piva limit 1;
					    id_impresa_new:=rec1.id; 
					   impresa_new:=false;
				              
			 	   end if;   -- 'IF PRESENZA  IMPRESA DB ';
			 	  
			 	  
		          log_string :='id_impresa_new'||id_impresa_new;	
		 	  	  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
						 	  
		----------------------END IMPRESA ---------------------------------------------------------------------------------------------------------		
			 		 	 
			 		 	 
			 		 	 
			 		 	 
			 		 	 
			
		---------------------------STABILIMENTO ---------------------------------------------------------------------------------------------------	
				 	
				 		raise info 'VERIFICHIAMO SE ESISTE STAB. PER APPROVAL NUMBER%',rc.approval_number;
				  	
				  		SELECT  * INTO rec2 from cu_anag.stabilimenti s  where  TRIM(s.cod_nazionale) =TRIM(rc.approval_number) 
																			and validita @> current_timestamp::timestamp;
				  --		GET DIAGNOSTICS total_rows := ROW_COUNT;
			 		--	raise notice 'numero stab presenti %',total_rows;	 	 		
				 	 --	log_string :='numero stab presenti '||total_rows;	
		 	 		--	execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		
				  		raise notice 'codice istat comune preso: %',rc.codice_istatSedeProd;
				  		raise notice 'comuneSedeProd preso: %',rc.comuneSedeProd;
				  	
				  	
			 			if(rec2.id is  null) then
			  
			 			  
			 			  raise notice 'LO STAB DEVE ESSERE INSERITO,INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';	 	 		
				 	      log_string :='LO STAB DEVE ESSERE INSERITO,INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';	
		 	 			  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			 			  	 			   
			 			  raise notice 'LO STAB DEVE ESSERE INSERITO,INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';	 	 		
				 	      log_string :='LO STAB DEVE ESSERE INSERITO,INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI istat='|| 
							coalesce(rc.codice_istatSedeProd,'') ||' com='|| coalesce(rc.comuneSedeProd,'');	
		 	 			  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  		 	 			 
		 	 			 
		  
			 	 	  	 /*   select * INTO recInd from 
			 	 	  	    cu_anag.indirizzi	i  
			 	 	  	    where  rc.indirizzo= i.indirizzo 	and i.istat_comune = rc.codice_istatSedeProd
						    and i.comune =rc.comune; */
								    
			         /*       IF( recInd.id is null) THEN -- IF   INDIRIZZO NON PRESENTE
					 		        log_string :=   'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI' ;
					 			    raise info 'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';
					 	  	  	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
						 	  	  	   */
									   
								    INSERT INTO cu_anag.indirizzi
									(id, toponimo, indirizzo, cap, stato_prov, nazione, istat_comune, comune, localita, civico, latitudine, longitudine, verificato, fonte)
									VALUES(nextval('cu_anag.cu_anag_id_seq'),null,rc.indirizzo,rc.capSedeProd, rc.provincia ,null, 
									rc.codice_istatSedeProd, rc.comuneSedeProd,null,null,null,null,true,FONTE_ANAG   )
								    returning  * into R_IND;
								    n:=cu_log.upd_record('cu_anag.indirizzi',id_transazione,R_IND,'I');
								    id_IND:=R_IND.id;
								    log_string :=   'ID INDIRIZZO NELLA TABELLA INDIRIZZI'|| id_IND ;
					 			    raise info 'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';
					 	  	  	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
					 	  	  	   
					 	  	  	   
							   
					 /*		 else
					 	  	  		   id_IND:= recInd.id;
				 	 	   END IF; -- IF   INDIRIZZO PRESENTE		   
						   */
						   
						   raise info 'INSERIAMO LO STAB NELLA TABELLA STABILIMENTI';
				 
			 	 	  	   INSERT INTO cu_anag.stabilimenti
							(id, id_impresa, nome, sd_id, id_indirizzo, cod_regionale, verificato, fonte, categoria_rischio, validita, cod_nazionale, id_tipologia_struttura, pec, telefono, sdi)
							VALUES( nextval('cu_anag.cu_anag_id_seq'), id_impresa_new, 
							  rc.denominazione_sede_operativa ,	NULL, id_IND,rc.approval_number, false,
							  FONTE_ANAG,1,tsrange(rc.data_inizio_attivita,null,'()'),
							  rc.approval_number, rc.ts_id,null, null, NULL)
						   returning  * into R_STAB;	 	 	  	  		
						   n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_STAB,'I');				    
						   log_string :=   'STAB ID' ||R_STAB.id;
						   raise info  'STAB ID%,' ,R_STAB.id;
						   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
						   id_STAB:=R_STAB.id;	   
						   
						   
			 			   raise info 'INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';	 		
				 	       log_string :='INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE'|| rc.id_tipo_linea;	
		 	 			   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				
						   INSERT INTO cu_anag.linee
								(id,id_stabilimento , id_tipo_linea, validita, attivita_fissa, linea_principale, verificato, 
								fonte, data_ultima_visita, id_esterno)
							  VALUES(nextval('cu_anag.cu_anag_id_seq'), id_STAB,rc.id_tipo_linea,	
							   validita_da_file,
							  true,false , true,FONTE_ANAG,(CURRENT_TIMESTAMP - '1 year'::interval)  , '')
							  returning  * into R_LINEA; 
								   
						  log_string :=    'id_stabilimento ID' ||R_LINEA.id_stabilimento;
						  raise info  'LINEA ID%,' ,R_LINEA.id;
						  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
						
						  log_string :=   'LINEA ID' ||R_LINEA.id;
						  raise info  'LINEA ID%,' ,R_LINEA.id;
						  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
					
						   
						   
				 	
				 		 else --- PRESENZA STAB
				 		    id_STAB:=rec2.id;
				 		    		  /** commentato per issue 11982
				 		 	raise info 'AGGIORNIAMO I VALORI DI ID_INDIRIZZO DELLO STAB , ID_INIDIRZZO%',rec2.id_indirizzo; 
				 	        log_string :='AGGIORNIAMO I VALORI DI ID_INDIRIZZO DELLO STAB , ID_INIDIRZZO'||rec2.id_indirizzo;			 	       
		 	 			    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		
			
			 	 	  
							UPDATE  cu_anag.indirizzi i
							SET indirizzo=rc.indirizzo,
									    stato_prov =rc.provincia,
									    istat_comune =rc.codice_istatSedeProd,
									    comune=rc.comune
							where i.id=rec2.id_indirizzo::BIGINT
							returning  * into R_IND;
							n:=cu_log.upd_record('cu_anag.indirizzi',id_transazione,R_IND,'U');
						 ***********/
						
						
						
						
						
							  
							raise info 'AGGIORNIAMO denominazione_sede STABILIMENTI';
							log_string :=  '**'||  'AGGIORNIAMO DENOM_SEDE DI STAB';
							execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
						 		 
				        	update   cu_anag.stabilimenti  s
				        	set nome= case when rc.denominazione_sede_operativa = '' then rc.ragione_sociale_impresa else rc.denominazione_sede_operativa end
				        	where s.id=id_STAB		            
				 	 	   	returning  * into R_STAB;
								
							n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_STAB,'U');
					
						   
						   
						   
						   
						   
						   
		 	 	   		
		 	 	   		    raise info 'VERIFCICHIAMO SE LA LINEA DELLO ESITE NELLA TABELLA LINEE';
		 	 	   			raise info ' STAB_ID%',rec2.id;
		 	 	   		    raise info ' dettaglio_attivita%',upper(translate(rc.attivita||rc.descrizione_sezione,' -',''));
		 	 	   		   
		 	 	   		    
				 	        log_string :='vERIFCICHIAMO SE LA LINEA DELLO ESITE NELLA TABELLA LINEE, STAB_ID'||rec2.id;			 	       
		 	 			    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		 	 	   		    log_string :='rc.attivita'||replace(rc.attivita,'''',' ') ||'-- '|| 'rc.attivita'||replace(rc.descrizione_sezione,'''',' ') ;			 	       
		 	 			    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		 	 	   		
		 	 			   SELECT l.*  INTO rec3 FROM cu_anag.linee l
							inner join agenda.vw_tipo_linee tl ON 
								case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP' then 
								'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
								when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI' then
								'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
								else upper(translate(tl.descr,' -','')) end=upper(translate(rc.attivita||rc.descrizione_sezione,' -',''))
								and l.id_tipo_linea =tl.id_tipo_linea 
			 				WHERE id_stabilimento =rec2.id ;   
			 			
		 	 	   		  /*  SELECT *  INTO rec3   FROM cu_anag.linee l
						    inner join agenda.vw_tipo_linee tl ON l.id_tipo_linea =tl.id_tipo_linea 
							WHERE id_stabilimento =rec2.id and
							upper(translate(rc.attivita||rc.descrizione_sezione,' -','')) = upper(translate(tl.descr,' -',''));   
					 		*/
			 			
			 			
				 	 	   		 
		 	 			    if(rec3.id is  null ) then
			 			       raise info 'INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';
			 			       log_string :='INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';	 	       		 	       
		 	 			       execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			 			      
			 		
		
					 			  INSERT INTO cu_anag.linee
									(id, id_stabilimento, id_tipo_linea, validita, attivita_fissa, linea_principale, verificato, 
									fonte, data_ultima_visita, id_esterno)
								  VALUES(nextval('cu_anag.cu_anag_id_seq') , id_STAB, rc.id_tipo_linea, 
									 validita_da_file,
									  true, false  , true, FONTE_ANAG,  (CURRENT_TIMESTAMP - '1 year'::interval) ,'')
									returning  * into R_LINEA;
									n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_LINEA,'I');
							
								 log_string :=   'R_LINEA.id' ||R_LINEA.id;						  
							    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
						
							
							
							  else
						 		 raise info 'AGGIORNIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE vffffffffffffffffffffffffffff';
						 		 log_string :='AGGIORNIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';	       		 	       
			 	 			     execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			 	 			  
			 	 			    
			 	 			    
			 	 			   
			 	 
						--		IF (rec3.validita @> validita_da_file is false ) then
				 	 		          --Calcola inizio
			 	 	
				      				   inizio:=lower(rec3.validita);
								       if ( lower_inf(validita_da_file) is false) then 
								           if( lower_inf(rec3.validita) is true ) then
								          	  inizio:=lower(validita_da_file);
								           else
								             if( lower(validita_da_file)<lower(rec3.validita) ) then
					      		      		    inizio:=lower(validita_da_file);
					      			      	 end if;						             
								           end if;		       
								        end if;
								       
				      				  
				      				  
				      				  
				 					   --Calcola fine
				      				   fine:=upper(rec3.validita);
								       if ( upper_inf(validita_da_file) is false) then 
								           if( upper_inf(rec3.validita) is true ) then
								          	  fine:=upper(validita_da_file);
								           else
								             if( upper(rec3.validita)<upper(validita_da_file)) then
					      		      		    fine:=upper(validita_da_file);
					      			      	 end if;						             
								           end if;		       
								        end if;
								       
								       
								      
									   v_validita:=tsrange(inizio,fine);
									  
									  
									  
									  
									  
									  
									  
									   update  cu_anag.linee l
							  	  	   set    validita=v_validita
								 	   where l.id=rec3.id 	returning  * into R_LINEA;
									   n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_LINEA,'U');
			 	          		-- end if;
		
						 	 end if;
					 	 	   			
		 	 	   		 
		 	 	   		
		 	 	   	 end if;
		 -----------------------------------------END STABILIMENTO----------------------------------------------------------------------------------------------	 
			
		        		 
				 /*VERIFICARE SE CI SONO STAB DA CHIUDERE SE HANNO TUTTE LE LINEE CHIUSE */
		 	 	   	
		 	 	   	
			------------------------------ AGGIORNAMENTO PER TUTTI GLI SCENARI--------------------------------------------------------------------------------------					
						select case when count(li)  filter (where li is true) >0 then null else min(lower(validita))end as minval,
						case when count(ui)  filter (where ui is true) >0 then null else max(upper(validita))end as  maxval 
						into rec1 from (
						    select  lower_inf (validita) li,upper_inf(validita) ui,validita  
						    from  cu_anag.linee
						    where id_stabilimento =id_STAB --AND FONTE='BDN_LIN_UPD';
						  )A;
						
						raise info 'MINIMO VALORE E MAX VALORE TRA LE VALIDITA DELLE LINEE %', rec1;
						 
						validita_da_linee:=tsrange(rec1.minval ,rec1.maxval,'[)');
					
					    	   	
				 	    SELECT * INTO rec4 FROM cu_anag.stabilimenti    WHERE id  =id_STAB ;  
				 	   
				 	    if ( lower_inf(validita_da_linee)) then
				     	  	  inizio := lower(rec4.validita); 
				        else 
				     	      if( lower_inf(rec4.validita) is true )then
				            	 inizio:=lower(validita_da_linee);
				              else 
					              if(lower(rec4.validita)>lower(validita_da_linee)) then
							      	 inizio:=lower(validita_da_linee);
							      else
							      	 inizio:=lower(rec4.validita);
					              end if;
				         	  end if;
				            	 
				       end if;  
				 					   --Calcola fine
				      
				      /**COMMENTATO PER ISSUE 11982
					  if  upper_inf(validita_da_linee) then 
					    	fine := upper(rec3.validita);
					  else 
				           if( upper_inf(rec3.validita) is true )then
				                 fine:=upper(validita_da_linee);
				           else 
				              if(upper(rec3.validita)<upper(validita_da_linee)) then
						      	 fine:=upper(validita_da_linee);
						      else
						      	 fine:=upper(rec3.validita);
				              end if;
				           end if;
				      end if;
				      
				      ***/ 
				     fine:=null;
		             v_validita:=tsrange(inizio,fine,'[)');  
								
								
		 	 
					
				
		              /* COMMENTATO PER RICHIESTA DEL CLIENTE   10/06/2024 */
					
					/*   select validita @> v_validita as contiene ,* into recapp  from cu_anag.stabilimento_figure sf where id_stabilimento  =id_STAB
					               and id_tipo_figura =12  AND validita && v_validita ;
			
					   if (recapp.id is null ) then  ---- IF numSogg=0 SOGGETTI FISICI 		 		     
			 			    log_string :=   'INSERT stabilimento_figure  ' ;
				            execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
							 		     
					 		  INSERT INTO cu_anag.stabilimento_figure
									(id, id_stabilimento, id_soggetto, id_tipo_figura,    fonte,validita)
								VALUES(nextval('cu_anag.cu_anag_id_seq'),id_STAB,id_impresa_new, 12,  FONTE_ANAG,v_validita)						 
						 		returning * into R_STABFIG;
					 		    n:=cu_log.upd_record('cu_anag.stabilimento_figure',id_transazione,R_STABFIG,'I');
					 		    log_string :=   '**'|| 'INSERITO STAB FIGURE' || R_STABFIG.id ;						 		     	
					 	 	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
					    
					 	else
					  
		
				 	         
		                    UPDATE  cu_anag.stabilimento_figure f
							SET validita =v_validita
					 		where f.id=recapp.id
							returning  * into R_STABFIG;
				            n:=cu_log.upd_record('cu_anag.stabilimento_figure',id_transazione,R_STABFIG,'U');                   
				 	         
				 	        
				            log_string :=   'update stabilimento_figure  ' ;
				            execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||''''; 
							 		     
				 	  end if;     
				 	 
				 	 
					select row_to_json(a.*) into chiamata_j from  (select id_impresa_new id_impresa,id_STAB id_stabilimento) a;
					select * into ver from cu_anag.check_stabilimento_valido_bool(chiamata_j,id_transazione);
			        log_string:=    'verificato:'||ver;
			        execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			       
			          log_string := 'AGGIORNIAMO rc.ts_id  '||rc.ts_id ;
				   	  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				    update cu_anag.stabilimenti 
							set  validita=v_validita , verificato =ver
							where id  =id_STAB AND id_tipologia_struttura =rc.ts_id
							returning * into R_S;
							n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_S,'U');
							   
		          */
		            
		            /************ VERIFICATO A FALSE PER RICHIESTA DEL CLIENTE 10/06/2024 *****/
				   update cu_anag.stabilimenti 
					set  validita=v_validita , verificato =FALSE
					where id  =id_STAB AND id_tipologia_struttura =rc.ts_id
					returning * into R_S;
					n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_S,'U');
							   
				
				
					if(impresa_new)  then
					    update cu_anag.imprese  
						set  validita=v_validita  
						where id  =id_impresa_new  
						returning * into R_IMP;
						n:=cu_log.upd_record('cu_anag.imprese',id_transazione,R_IMP,'U'); 
					end if;
		end if; 		
				 			  
		END LOOP ; 
		ret.esito:=true;
 	    log_string :=  '**'|| 'ESITO: '|| ret.esito;
		execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
 		return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.load_stabilimenti_sintesis(v json, id_transazione bigint) OWNER TO postgres;

--
-- Name: load_stabilimenti_sintesisOLD(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag."load_stabilimenti_sintesisOLD"() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	num integer;
    tipoStrId  varchar;
    idImport  varchar;
 	rc record ;
	rec1 record ;
	rec2 record ;
	rec3 record;
	R_IMP cu_anag.imprese;
	R_IND cu_anag.indirizzi;
	R_STAB cu_anag.stabilimenti;
    R_LINEA  cu_anag.linee;
    id_transazione integer;
    log_string varchar;
	stampa varchar;
    LOG_FILE varchar;
	begin
	    idImport:=v->'id_import'; 
		tipoStrId:=v->'tipoStrId';
		id_transazione:=-1;



 
	

	
	/********************mettere le stampe nel file di log di antonio *************/
		 
     LOG_FILE:='/tmp/loadStabSintesis'+now;
	 
	
	 FOR rc IN (SELECT * FROM cu_anag.file_xls_sintesis )    
		LOOP
		        log_string := 'VERIFICHIAMO SE ESISTE L''IMPRESA PARTITA IVA :'+rc.partita_iva;
		  		raise info 'VERIFICHIAMO SE ESISTE L''IMPRESA PARTITA IVA%',rc.partita_iva;
		  	    stampa:='echo '+log_STRING+ '>' + LOG_FILE;
		  	    raise info 'VERIFICHIAMO SE ESISTE L''IMPRESA PARTITA IVA%',stampa;
		  	   
  	   		--	COPY shell FROM PROGRAM stampa  ;
		  	     
     	 
		  		SELECT  * INTO rec1 from cu_anag.imprese i  where  i.piva =rc.partita_iva ;
		  		GET DIAGNOSTICS total_rows := ROW_COUNT;
	 			raise notice 'numero imprese presenti %',total_rows;	 
	 			if(total_rows==0) then
	 			   raise info 'INSERIAMO IMPRESA';
		 		   INSERT INTO cu_anag.imprese
					select nextval('cu_anag.cu_anag_id_seq'), a.ragione_sociale_impresa, a.codice_fiscale, a.partita_iva, NULL, NULL, NULL, NULL, 'S',null,null,null,null,true,tipoP,
					'(,)'::tsrange, 'G' from (
			   			 select distinct a.ragione_sociale_impresa,a.codice_fiscale,a.partita_iva	 
			 			  from cu_anag.file_xls_sintesis a where TRIM(rec1.partita_iva)=TRIM(a.partita_iva)
			 			)a returning * into R_IMP;
		 		   n:=cu_log.upd_record('cu_anag.imprese',id_transazione,R_IMP,'I');
			
		 		end if;
		 	
		 		raise info 'VERIFICHIAMO SE ESISTE STAB. PER APPROVAL NUMBER%',rc.approval_number;
		  	
		  		SELECT  * INTO rec2 from cu_anag.stabilimenti s  where  TRIM(s.cod_nazionale) =TRIM(rc.approval_number) ;
		  		GET DIAGNOSTICS total_rows := ROW_COUNT;
	 			raise notice 'numero stab presenti %',total_rows;	 
	 			if(total_rows==0) then
	 		
	 			   raise info 'LOSTAB DEVE ESSERE INSERITO';
	 			  
	 			   raise info 'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';
	 			   
	 			    INSERT INTO cu_anag.indirizzi
				    select   nextval('cu_anag.cu_anag_id_seq'),indirizzo,null,sigla_provincia,null,case when c.codistat is null then null else codice_istat end codistat,
				 	          case when c.codistat is null then a.comune else null end comune,null,null,null,null,true,
				 	ts.codice  fonte
				 	from cu_anag.file_xls_sintesis a
				 	left join conf_ext.vw_comuni_vigenti_attivi  c on a.comune=c.denominazione_it 
				 	left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId
				 	where TRIM(rc.approval_number) = TRIM(a.approval_number) 
				 	returning  * into R_IND;
				    n:=cu_log.upd_record('cu_anag.indirizzi',id_transazione,R_IND,'I');
 	 	   		   
				    raise info 'INSERIAMO LO STAB NELLA TABELLA STABILIMENTI';
				    
					INSERT INTO cu_anag.stabilimenti
					select nextval('cu_anag.cu_anag_id_seq'),rec1.id,denominazione_sede_operativa,null,R_IND.id,approval_number,true,
					ts.codice fonte,1,tsrange(null,null,'()'),approval_number,ts.id,null,null,null
			 		from cu_anag.file_xls_sintesis a
					left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId
					where TRIM(rc.approval_number) = TRIM(a.approval_number) 				
					returning  * into R_STAB;
				
				    n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_STAB,'I');
				    raise info 'INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';
				
		 	
		 		 else
		 		   
		 		 	raise info 'AGGIORNIAMO I VALORI DI ID_INDIRIZZO DELLO STAB , ID_INIDIRZZO%',rec2.id_indirizzo;
							 		    	
					UPDATE  cu_anag.indirizzi i
					SET indirizzo=subquery.indirizzo,
					    sigla_provincia=subquery.sigla_provincia,
					    codistat=subquery.codistat,
					    comune=subquery.comune
					FROM (select  
					     indirizzo, sigla_provincia, case when c.codistat is null then null else codice_istat end codistat,
						 case when c.codistat is null then a.comune else null end comune 
						 from cu_anag.file_xls_sintesis a
					     left join conf_ext.vw_comuni_vigenti_attivi  c on a.comune=c.denominazione_it 		
						 left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId) AS subquery
					where i.id=rec2.id_indirizzo
					returning  * into R_IND;
		            n:=cu_log.upd_record('cu_anag.indirizzi',id_transazione,R_IND,'U');
 	 	   		  
	   
		 		 
        		 	update   cu_anag.stabilimenti  set nome= rec.denominazione_sede 
 	 	   			where    cod_nazionale=rc.approval_number 	 	   		
 	 	   			returning  * into R_STAB;
				
				    n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_STAB,'U');
	
 	 	   		
 	 	   		
 	 	   		    raise info 'VERIFCICHIAMO SE LA LINEA DELLO ESITE NELLA TABELLA LINEE';
 	 	   		
 	 	   		   
 	 	   		    SELECT *  INTO rec3 FROM cu_anag.linee
					inner join agenda.vw_tipo_linee tl ON 
						case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP' then 
						'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
						when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI' then
						'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
						else upper(translate(tl.descr,' -','')) end=upper(translate(rc.attivita||rc.descrizione_sezione,' -',''))
	 				WHERE id_stabilimento =rec2.id ;   
	 			
 	 	   		
 	 	   		    GET DIAGNOSTICS num := ROW_COUNT;
	 				raise notice 'numero linee presenti %',n;	
	 			    if(num==0)then
	 			       raise info 'INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';
	 			       insert into cu_anag.linee
						select nextval('cu_anag.cu_anag_id_seq') id,
						s.id id_stabilimento,tl.id id_tipo_linea ,
						tsrange(data_inizio_attivita::timestamp,
							case when replace(data_fine_attivita,'-','')='' then null::timestamp else replace(data_fine_attivita,'-','')::timestamp end,'[)') validita,
						true,false linea_principale,true,tl.cod 
						from cu_anag.file_xls_sintesis  i 
						join cu_anag.stabilimenti s on i.approval_number=s.cod_regionale
						left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId
					 	join agenda.vw_tipo_linee tl ON 					
							case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP' then 
							'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
								when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI' then
							'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
								else upper(translate(tl.descr,' -','')) end=upper(translate(i.attivita||i.descrizione_sezione,' -',''))
				       	returning  * into R_LINEA;
						n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_LINEA,'I');
				
					  else
				 		 raise info 'AGGIORNIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';
				 		 update  cu_anag.linee l
				 	   	 set    validita= tsrange(data_inizio_attivita::timestamp,
						   		case when replace(data_fine_attivita,'-','')='' then null::timestamp else replace(data_fine_attivita,'-','')::timestamp end,'[)') 
			             where l.id=rec3.id 	returning  * into R_LINEA;
						n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_LINEA,'U');

				 	 end if;
			 	 	   			
 	 	   		 
 	 	   		
 	 	   	 end if;
        		 
		 /*VERIFICARE SE CI SONO STAB DA CHIUDERE SE HANNO TUTTE LE LINEE CHIUSE */

		 			  
		END LOOP ; 
	
	 /*   SELECT  * into  rec1  FROM cu_anag.file_xls_sintesis s
        left join  cu_anag.imprese i  on i.piva =s.partita_iva ;
       
        if(rec1.id==null)then
        
    
	        INSERT INTO cu_anag.imprese
			select nextval('cu_anag.cu_anag_id_seq'), a.ragione_sociale_impresa, a.codice_fiscale, a.partita_iva, NULL, NULL, NULL, NULL, 'S',null,null,null,null,true,tipoP,
			'(,)'::tsrange, 'G' from (
		    select distinct a.ragione_sociale_impresa,a.codice_fiscale,a.partita_iva	 
		 	from cu_anag.file_xls_sintesis a where rec1.partita_iva=a.partita_iva
		 	)a;
	 		GET DIAGNOSTICS total_rows := ROW_COUNT;
	 		raise notice '	righe caricate %',total_rows;	 
        
        end if;
   
	
	    SELECT  * into  rec2  FROM cu_anag.file_xls_sintesis 
        left join  cu_anag.stabilimenti stab  on stab.cod_nazionale =approval_number;
   
	
 	 	if(rec.cod_nazionale!=null )then
 	 		
 	 		
 	 		
 	 		update   cu_anag.stabilimenti  set nome= rec.denominazione_sede,id_tipologia_struttura=tipoP
 	 	    where cod_nazionale=rec.approval_number;
 	 	   
 	 	   --verificare se id_indirizzo esiste , se esiste non si aggiorna altrimenti si fa un aggiornamento dei valori sulla tabella degli indirizzi
 	 	 
 	 	   -- nel caso fare update indirizzi
 	 	
 	 	end if;
 	 	
 	 	
 	 	/* 852integratori853AAE */
		update cu_anag.file_xls_sintesis a
		set id=s.rn
		from 
		(select  approval_number ,attivita,descrizione_sezione,row_number() over () rn from cu_anag.file_xls_sintesis where tipo =tipoP) s
		where a.approval_number=s.approval_number and a.attivita=s.attivita and a.descrizione_sezione=s.descrizione_sezione;
		
		raise notice '12 - imprese 852integratori853AAE';
		insert into cu_anag.imprese
				select nextval('cu_anag.cu_anag_id_seq'),a.ragione_sociale_impresa,a.codice_fiscale,a.partita_iva,
	 	null,null,null,null,a.fg_an_tipo_persona,-a.az_id*10-4,null,null,-a.az_id*10-4,true,a.tipo 
	 	from(select distinct a.ragione_sociale_impresa,a.codice_fiscale,a.partita_iva,
	 	i.fg_an_tipo_persona,a.az_id,a.tipo
	 	from cu_anag.file_xls_sintesis a
	 	 	left join cu_anag.vw_fvg_gisa_imprese_all i on a.partita_iva  =i.az_an_iva and 
			upper(fg_tipo_figura_descr) in ('SEDE LEGALE')and az_cod_aziendale ilike 'CE%') a
  	    where a.tipo =tipoP;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;	 

	 

  
 	    raise notice '13 - stabilimenti 852integratori853AAE';
		insert into cu_anag.stabilimenti
		select nextval('cu_anag.cu_anag_id_seq'),id_impresa,denominazione_sede_operativa,-sd_id*10-4,-sd_id*10-4,approval_number,true,
		fonte,1,tsrange(null,null,'()'),approval_number,id_tipologia_struttura,null,null,null
		from (
			select distinct on (a.approval_number) i.id id_impresa,a.denominazione_sede_operativa,a.approval_number,tipo fonte,/*min(a.id) */a.id sd_id,
			gi.sd_cod_tipologia_struttura cod_tipologia_struttura,ts.id id_tipologia_struttura
			from cu_anag.file_xls_sintesis a
			left join cu_anag.imprese i  on i.nome=a.ragione_sociale_impresa and i.cf=a.codice_fiscale and i.piva=a.partita_iva
			left join cu_anag.vw_fvg_gisa_imprese_all gi on gi.az_cod_aziendale =a.approval_number 
			left join cu_types.tipologie_struttura ts on ts.codice=gi.sd_cod_tipologia_struttura
			where a.tipo =tipoP
			order by a.approval_number,a.id
		) t;
	 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
	
        raise notice '14 - indirizzi 852integratori853AAE';
		
		insert into cu_anag.indirizzi
	 	select ---sd_id*10-4
	 	sd_id,null,a.indirizzo,null,a.sigla_provincia,null,a.codistat,a.comune,null,null,null,null,true,fonte from
	 	(select sd_id,indirizzo,case when c.codistat is null then a.comune else null end comune,sigla_provincia,
	 	case when c.codistat is null then null else codice_istat end codistat,--gi.fonte al posto di fonte
	 	gi.fonte fonte,min(a.id) id
	 	from cu_anag.file_xls_sintesis a
		left join conf_ext.vw_comuni_vigenti_attivi  c on a.comune=c.denominazione_it 
		join cu_anag.stabilimenti gi on gi.cod_regionale =a.approval_number 
		where a.tipo =tipoP and  gi.sd_id in (
	  		select sd_id from cu_anag.stabilimenti
			inner join cu_anag.tipo_import_anagrafica ta on upper(ta.descr) =upper(fonte)
			where ta.cod = tipoP )


		group by 1,2,3,4,5,6
		) a;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe   caricate %',total_rows;
	

 	
		raise notice '15 - linee 852integratori853AAE';
		insert into cu_anag.linee
			select nextval('cu_anag.cu_anag_id_seq') id,
			s.id id_stabilimento,tl.id id_tipo_linea ,
			tsrange(data_inizio_attivita::timestamp,
				case when replace(data_fine_attivita,'-','')='' then null::timestamp else replace(data_fine_attivita,'-','')::timestamp end,'[)') validita,
			true,false linea_principale,true,i.tipo
			from cu_anag.file_xls_sintesis  i 
			join cu_anag.stabilimenti s on i.approval_number=s.cod_regionale
			--join cu_anag.imprese im on im.id=s.id_impresa
			join agenda.vw_tipo_linee tl ON 
				case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP' then 
				'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
					when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI' then
				'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
					else upper(translate(tl.descr,' -','')) end=upper(translate(i.attivita||i.descrizione_sezione,' -',''))
		   where i.tipo =tipoP ;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate %',total_rows;
 	
 	 	ret:=cu_anag.load_new_stabilimenti_upd_indirizzi();
 	 	*/
 		return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag."load_stabilimenti_sintesisOLD"() OWNER TO postgres;

--
-- Name: load_stabilimenti_sintesisOLD(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag."load_stabilimenti_sintesisOLD"(v json, id_transazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	num integer;
    tipoStrId  varchar;
    idImportP  varchar;
 	rc record ;
	rec1 record ;
	rec2 record ;
	rec3 record;
    recapp record;
    recInd record;
	R_IMP cu_anag.imprese;
	R_IND cu_anag.indirizzi;
	R_STAB cu_anag.stabilimenti;
    R_LINEA  cu_anag.linee;
    R_SOGG_FIS cu_anag.soggetti_fisici;
    R_STABFIG cu_anag.stabilimento_figure;
    R_S cu_anag.stabilimenti;
    id_IND integer;
    id_transazione integer;
    log_string varchar;
	stampa varchar;
    LOG_FILE varchar;
   	cod_timpo_impresa varchar;
    id_impresa_new bigint;
    piva varchar;
    chiamata_j json;
    id_STAB integer;
    v_validita tsrange;
    idSoggFis integer;
	begin
	    idImportP:=v->'id_import'; 
		tipoStrId:=v->'tipoStrId';
 
 

	
	/********************mettere le stampe nel file di log di antonio *************/
		 
      LOG_FILE:='/tmp/loadStabSintesis_'||CURRENT_DATE ;
     
      log_string := 'test log :' ; 
 	  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
 		
	 
	
	 FOR rc IN (--SELECT * FROM cu_anag.file_xls_sintesis s   where s.idimport=idImportP::bigint
	  SELECT    *, ts.id ts_id, ts.codice  fonteINS,tl.id id_tipo_linea ,
      case when listacapSP.istat is not null then (caps)->>0   else ''   end as capSedeProd       ,
      case when c.codistat is null then null else c.codice_istat end codice_istatSedeProd,
	  case when c.codistat is not null then s.comune else null end comune  
	  FROM cu_anag.file_xls_sintesis s
	  left join cu_types.tipologie_struttura ts   on ts.id=tipoStrId::int
	  left join conf_ext.vw_comuni_vigenti_attivi  c on comune=c.denominazione_it 
	  left join conf_ext.vw_istat_lista_cap  listacapSP on listacapSP.istat=c.codice_istat::text
 	--  left join agenda.vw_tipo_linee tl ON left(m.dettaglio_attivita,3) = substring(tl.descr from '^\[.*\] (M[0-9][0-9])')
	   	join agenda.vw_tipo_linee tl ON 
		  	            case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP'
		  	                 then 'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
							 when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI'
							 then 'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
					         else upper(translate(tl.descr,' -','')) end=upper(translate(S.attivita||S.descrizione_sezione,' -',''))
 	  where s.idimport=idImportP::bigint
	 
	 
	 )     
		LOOP
			
				log_string := 'idImportP' || idImportP ; 
 	 			 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		        log_string := 'VERIFICHIAMO SE ESISTE IMPRESA PARTITA IVA :'||rc.partita_iva;
		       

 	 		    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
 		
		  	     
     	 		/*SELECT  * INTO rec1 from cu_anag.imprese i
		  		left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId::int
		  	    where   rc.partita_iva !='' and i.piva =rc.partita_iva  ;*/
		  	   
		  	   
		  	   SELECT  *,ts.id ts_id INTO rec1 from cu_anag.imprese i
				  		left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId::int
				  	    where ( (rc.partita_iva!='' and i.piva =rc.partita_iva)      or   (rc.codice_fiscale!='' and i.piva =rc.codice_fiscale )
				  	       or  (rc.codice_fiscale!='' and i.cf =rc.codice_fiscale  ) ) ;
		  	   
		  	   
		  		GET DIAGNOSTICS total_rows := ROW_COUNT;
	 			
		  		raise notice 'numero imprese presenti %',total_rows;	 
	 			log_string := 'numero imprese presenti:'||total_rows; 
 	 		    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	 		
	 		
--------------------------------------IMPRESA -------------------------------------------------------------------------------------------		
	 			if(total_rows=0) then
   			     raise info 'INSERIAMO IMPRESA'; 	 
		 	 	 log_string := 'INSERIAMO IMPRESA'; 
 	 			 execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
 	 			
 	 			 piva=rc.partita_iva;	
			     if(piva='' and cu_anag.check_piva(rc.codice_fiscale)) then -- IF CF E' COME PIVA
	 		 	 		  piva=rc.codice_fiscale;
		 		 	 	  log_string :=   '**'||  'INSERIAMO IMPRESA PIVA COME CF' ||piva;			 			  
			 			  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	 	 
	 		 	 end if;  	-- IF CF E' COME PIVA
	 		 	 
	 		 	 if( length(rc.codice_fiscale)=16  ) then --IF CODFISC E UN CF
		 			 	 cod_timpo_impresa:='P';	 
				 		     
				  else 				 			 	 	 	   
							    cod_timpo_impresa:='S';
				  end if; ----IF CODFISC E UN CF
				 		 	 
		 	   INSERT INTO cu_anag.imprese
					(id, nome, cf, piva, pec, email, sdi, split_payement, cod_tipo_impresa, az_id, 
					az_cod_aziendale, az_cod_regionale, sd_id, verificato, fonte, validita, tipo_soggetto)
					VALUES(nextval('cu_anag.cu_anag_id_seq'), rc.ragione_sociale_impresa , rc.codice_fiscale,piva, NULL, NULL, NULL, NULL, cod_timpo_impresa,null,
					null,null,0,true,rc.fonteINS,	tsrange(rc.data_inizio_attivita,null,'()'), 'G')						 
			 		returning * into R_IMP;
		 		    n:=cu_log.upd_record('cu_anag.imprese',id_transazione,R_IMP,'I');
		 		    log_string :=   '**'|| 'INSERITA IMPRESA' || R_IMP.id ;
		 		    id_impresa_new:=R_IMP.id;		
		 	 	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				    raise info 'INSERITA IMPRESA%',	R_IMP.id ;
	
 	   
 
		   else 
			    id_impresa_new:=rec1.id ;
		              
	 	   end if;   -- 'IF PRESENZA  IMPRESA DB ';
				 	  
----------------------END IMPRESA ---------------------------------------------------------------------------------------------------------		
	 		 	 
	 		 	 
	 		 	 
	 		 	 
	 		 	 
	
---------------------------STABILIMENTO ---------------------------------------------------------------------------------------------------	
		 	
		 		raise info 'VERIFICHIAMO SE ESISTE STAB. PER APPROVAL NUMBER%',rc.approval_number;
		  	
		  		SELECT  * INTO rec2 from cu_anag.stabilimenti s  where  TRIM(s.cod_nazionale) =TRIM(rc.approval_number) ;
		  		GET DIAGNOSTICS total_rows := ROW_COUNT;
	 			raise notice 'numero stab presenti %',total_rows;	 	 		
		 	 	log_string :='numero stab presenti '||total_rows;	
 	 			execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  

	 			if(total_rows=0) then
	  
	 			  
	 			  raise notice 'LO STAB DEVE ESSERE INSERITO,INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';	 	 		
		 	      log_string :='LO STAB DEVE ESSERE INSERITO,INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';	
 	 			  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	 			  	 			   
	 			/*    INSERT INTO cu_anag.indirizzi
				    select   nextval('cu_anag.cu_anag_id_seq'),indirizzo,null,sigla_provincia,null,
				    case when c.codistat is null then null else codice_istat end codistat,
				 	          case when c.codistat is not null then a.comune else null end comune,null,null,null,null,null,true::bool,
				 	ts.codice  fonte
				 	from cu_anag.file_xls_sintesis a
				 	left join conf_ext.vw_comuni_vigenti_attivi  c on a.comune=c.denominazione_it 
				 	left join cu_types.tipologie_struttura ts  on ts.id=tipoStrId::INT
				 	where TRIM(rc.approval_number) = TRIM(a.approval_number)  and     a.idimport=idImportP::bigint
				 	returning  * into R_IND;
				    n:=cu_log.upd_record('cu_anag.indirizzi',id_transazione,R_IND,'I');
*/
				   
		     
	 	 	  	    select * INTO recInd from 
	 	 	  	    cu_anag.indirizzi	i  
	 	 	  	    where  rc.indirizzo= i.indirizzo 	and i.istat_comune = rc.codice_istatSedeProd
				    and i.comune =rc.comune;
						    
	                IF( recInd.id is null) THEN -- IF   INDIRIZZO PRESENTE
			 		        log_string :=   'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI' ;
			 			    raise info 'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';
			 	  	  	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				 	  	  	   
							   
						    INSERT INTO cu_anag.indirizzi
							(id, toponimo, indirizzo, cap, stato_prov, nazione, istat_comune, comune, localita, civico, latitudine, longitudine, verificato, fonte)
							VALUES(nextval('cu_anag.cu_anag_id_seq'),null,rc.indirizzo,rc.capSedeProd, rc.provincia ,null, 
							rc.codice_istatSedeProd, rc.comune,null,null,null,null,true, rc.fonteINS   )
						    returning  * into R_IND;
						    n:=cu_log.upd_record('cu_anag.indirizzi',id_transazione,R_IND,'I');
						    id_IND:=R_IND.id;
						    log_string :=   'ID INDIRIZZO NELLA TABELLA INDIRIZZI'|| id_IND ;
			 			    raise info 'INSERIAMO INDIRIZZO NELLA TABELLA INDIRIZZI';
			 	  	  	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
					   
			 		 else
			 	  	  		   id_IND:= recInd.id;
		 	 	   END IF; -- IF   INDIRIZZO PRESENTE		   
				   
				   
				   raise info 'INSERIAMO LO STAB NELLA TABELLA STABILIMENTI';
		 
	 	 	  	   INSERT INTO cu_anag.stabilimenti
					(id, id_impresa, nome, sd_id, id_indirizzo, cod_regionale, verificato, fonte, categoria_rischio, validita, cod_nazionale, id_tipologia_struttura, pec, telefono, sdi)
					VALUES( nextval('cu_anag.cu_anag_id_seq'), id_impresa_new, 
					  rc.denominazione_sede_operativa ,	NULL, id_IND,rc.approval_number, true,
					  rc.fonteINS,1,tsrange(rc.data_inizio_attivita,null,'()'),
					  rc.approval_number, rc.ts_id,null, null, NULL)
				   returning  * into R_STAB;	 	 	  	  		
				   n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_STAB,'I');				    
				   log_string :=   'STAB ID' ||R_STAB.id;
				   raise info  'STAB ID%,' ,R_STAB.id;
				   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				   id_STAB:=R_STAB.id;	   
				   
				   
	 			   raise info 'INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';	 		
		 	       log_string :='INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';	
 	 			   execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				
			/*	    insert into cu_anag.linee
						select nextval('cu_anag.cu_anag_id_seq') id,
						s.id id_stabilimento,tl.id id_tipo_linea ,
						tsrange(case when i.data_inizio_attivita  is null then null::timestamp else   i.data_inizio_attivita end,null::timestamp,'[)') validita,
						true,false linea_principale,true,tl.cod , (CURRENT_TIMESTAMP - '1 year'::interval),''
						from cu_anag.file_xls_sintesis  i 
						join cu_anag.stabilimenti s on 	TRIM(s.cod_nazionale) =TRIM(i.approval_number) 
						left join cu_types.tipologie_struttura ts  on ts.id=s.id_tipologia_struttura  and ts.id=tipoStrId::INT
					 --	join agenda.vw_tipo_linee tl ON left(i.dettaglio_attivita,3) = substring(tl.descr from '^\[.*\] (M[0-9][0-9])')
					 	
					 	join agenda.vw_tipo_linee tl ON 
		--		case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP' then 
			--	'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
				--	when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI' then
				--'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
					--else upper(translate(tl.descr,' -','')) end=upper(translate(i.attivita||i.descrizione_sezione,' -',''))
					upper(translate(tl.descr,' -','')) =upper(translate(i.attivita||i.descrizione_sezione,' -',''))
				     	where    TRIM(i.approval_number) = TRIM(rc.approval_number) 
				  		  and    upper(translate(i.attivita||i.descrizione_sezione,' -',''))=upper(translate(rc.attivita||rc.descrizione_sezione,' -',''))
						  and ts.codice =s.fonte   
				  		  and    i.idimport=idImportP::bigint
					 	returning  * into R_LINEA;
				    n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_LINEA,'I');*/
				   
				   
				  INSERT INTO cu_anag.linee
					(id,id_stabilimento , id_tipo_linea, validita, attivita_fissa, linea_principale, verificato, 
					fonte, data_ultima_visita, id_esterno)
				  VALUES(nextval('cu_anag.cu_anag_id_seq'), id_STAB,rc.id_tipo_linea,	
				   tsrange(data_inizio_attivita::timestamp,
				  case when replace(data_fine_attivita,'-','')='' then null::timestamp else replace(data_fine_attivita,'-','')::timestamp end,'[)') ,
				  true,false , true,rc.fonteINS,(CURRENT_TIMESTAMP - '1 year'::interval)  , '')
				  returning  * into R_LINEA;
				 
				  log_string :=    'id_stabilimento ID' ||R_LINEA.id_stabilimento;
				  raise info  'LINEA ID%,' ,R_LINEA.id;
				  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				
				  log_string :=   'LINEA ID' ||R_LINEA.id;
				  raise info  'LINEA ID%,' ,R_LINEA.id;
				  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				   
				   
				   
		 	
		 		 else --- PRESENZA STAB
		 		    id_STAB:=rec2.id;
		 		   
		 		 	raise info 'AGGIORNIAMO I VALORI DI ID_INDIRIZZO DELLO STAB , ID_INIDIRZZO%',rec2.id_indirizzo; 
		 	        log_string :='AGGIORNIAMO I VALORI DI ID_INDIRIZZO DELLO STAB , ID_INIDIRZZO'||rec2.id_indirizzo;			 	       
 	 			    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  

	
	 	 	   		
					UPDATE  cu_anag.indirizzi i
					SET indirizzo=rc.indirizzo,
							    stato_prov =rc.provincia,
							    istat_comune =rc.codice_istatSedeProd,
							    comune=rc.comune
					where i.id=rec2.id_indirizzo::BIGINT
					returning  * into R_IND;
					n:=cu_log.upd_record('cu_anag.indirizzi',id_transazione,R_IND,'U');
					  
					raise info 'AGGIORNIAMO denominazione_sede STABILIMENTI';
					log_string :=  '**'||  'AGGIORNIAMO DENOM_SEDE DI STAB';
					execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				 		 
		        	update   cu_anag.stabilimenti  s
		        	set nome= case when rc.denominazione_sede_operativa = '' then rc.ragione_sociale_impresa else rc.denominazione_sede_operativa end
		        	where s.id=id_STAB		            
		 	 	   	returning  * into R_STAB;
						
					n:=cu_log.upd_record('cu_anag.stabilimenti',id_transazione,R_STAB,'U');
			
				   
				   
				   
				   
				   
				   
 	 	   		
 	 	   		    raise info 'VERIFCICHIAMO SE LA LINEA DELLO ESITE NELLA TABELLA LINEE';
 	 	   			raise info ' STAB_ID%',rec2.id;
 	 	   		    raise info ' dettaglio_attivita%',upper(translate(rc.attivita||rc.descrizione_sezione,' -',''));
 	 	   		   
 	 	   		    
		 	        log_string :='vERIFCICHIAMO SE LA LINEA DELLO ESITE NELLA TABELLA LINEE, STAB_ID'||rec2.id;			 	       
 	 			    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
 	 	   		   
 	 	   		    SELECT *  INTO rec3 FROM cu_anag.linee
					inner join agenda.vw_tipo_linee tl ON 
						case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP' then 
						'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
						when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI' then
						'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
						else upper(translate(tl.descr,' -','')) end=upper(translate(rc.attivita||rc.descrizione_sezione,' -',''))
	 				WHERE id_stabilimento =rec2.id ;   
	 			
 	 	   		    SELECT *  INTO rec3   FROM cu_anag.linee l
				    inner join agenda.vw_tipo_linee tl ON l.id_tipo_linea =tl.id_tipo_linea 
					WHERE id_stabilimento =rec2.id and
					upper(translate(rc.attivita||rc.descrizione_sezione,' -','')) = upper(translate(tl.descr,' -',''));   
			 			
		 	 	   		
	 			
	 			
	 			
	 			
	 			
 	 	   		    GET DIAGNOSTICS num := ROW_COUNT;
	 				raise notice 'numero linee presenti %',n;	
	 			    log_string :='Numero linee presenti'||n;			 	       		 	       
 	 			    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	 			
 	 			    if(num=0)then
	 			       raise info 'INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';
	 			       log_string :='INSERIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';	 	       		 	       
 	 			       execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
	 			      
	 			      /* insert into cu_anag.linee
						select nextval('cu_anag.cu_anag_id_seq') id,
						s.id id_stabilimento,tl.id id_tipo_linea ,
						tsrange(data_inizio_attivita::timestamp,
							case when data_fine_attivita is null then null::timestamp else data_fine_attivita::timestamp end,'[)')  validita,
						true,false linea_principale,true,tl.cod 
						from cu_anag.file_xls_sintesis  i 
						join cu_anag.stabilimenti s on i.approval_number=s.cod_regionale
						left join cu_types.tipologie_struttura ts  on ts.id=s.id_tipologia_struttura and ts.id=tipoStrId::INT
					 	join agenda.vw_tipo_linee tl ON 					
							case when tl.descr='[XVII.PP] XVII.PP PP - MIELE - STABILIMENTO DI TRASFORMAZIONE - XVII ??? MIELE - STABILIMENTO DI TRASFORMAZIONE ??? PP' then 
							'PPSTABILIMENTODITRASFORMAZIONE17MIELE'
								when tl.descr='STABILIMENTO DI PRODUZIONE PRODOTTI ALTAMENTE RAFFINATI - 16 - PRODOTTI ALTAMENTE RAFFINATI' then
							'PPSTABILIMENTODITRASFORMAZIONE16PRODOTTIALTAMENTERAFFINATI'
								else upper(translate(tl.descr,' -','')) end=upper(translate(i.attivita||i.descrizione_sezione,' -',''))
					    where    TRIM(i.approval_number) =TRIM(rc.approval_number)  
						         and    i.idimport=idImportP::bigint
				       	returning  * into R_LINEA;
						n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_LINEA,'I');*/
				
			     
		 			  INSERT INTO cu_anag.linee
						(id, id_stabilimento, id_tipo_linea, validita, attivita_fissa, linea_principale, verificato, 
						fonte, data_ultima_visita, id_esterno)
					  VALUES(nextval('cu_anag.cu_anag_id_seq') , id_STAB, rc.id_tipo_linea, 
					    tsrange(data_inizio_attivita::timestamp,
				        case when replace(data_fine_attivita,'-','')='' then null::timestamp else replace(data_fine_attivita,'-','')::timestamp end,'[)') ,  true, false  , true, rc.fonteINS,  (CURRENT_TIMESTAMP - '1 year'::interval) ,'')
						returning  * into R_LINEA;
						n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_LINEA,'I');
		
					
					
					
					  else
				 		 raise info 'AGGIORNIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';
				 		 log_string :='AGGIORNIAMO LA LINEA DELLO  STAB NELLA TABELLA LINEE';	       		 	       
	 	 			     execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
				 		 update  cu_anag.linee l
				 	   	 set    validita= tsrange(data_inizio_attivita::timestamp,
								case when replace(data_fine_attivita,'-','')='' then null::timestamp else replace(data_fine_attivita,'-','')::timestamp end,'[)') 
			             where l.id=rec3.id 	returning  * into R_LINEA;
						n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_LINEA,'U');
		

				 	 end if;
			 	 	   			
 	 	   		 
 	 	   		
 	 	   	 end if;
 -----------------------------------------END STABILIMENTO----------------------------------------------------------------------------------------------	 
	
        		 
		 /*VERIFICARE SE CI SONO STAB DA CHIUDERE SE HANNO TUTTE LE LINEE CHIUSE */
 	 	   	
 	 	   	
	------------------------------ AGGIORNAMENTO PER TUTTI GLI SCENARI--------------------------------------------------------------------------------------					
				select case when count(li)  filter (where li is true) >0 then null else min(lower(validita))end as minval,
				case when count(ui)  filter (where ui is true) >0 then null else max(upper(validita))end as  maxval 
				into rec1 from (
				    select  lower_inf (validita) li,upper_inf(validita) ui,validita  
				    from  cu_anag.linee
				    where id_stabilimento =id_STAB --AND FONTE='BDN_LIN_UPD';
				  )A;
				
				raise info 'MINIMO VALORE E MAX VALORE TRA LE VALIDITA DEGLI ALLEVAMENTI %', rec1;
				 
				v_validita:=tsrange(rec1.minval ,rec1.maxval,'[)');
				update cu_anag.stabilimenti 
				set  validita=v_validita
				where id  =id_STAB AND id_tipologia_struttura =18 
				returning * into R_S;
				n:=cu_log.upd_record('cu_anag.linee',id_transazione,R_S,'U');
				   
				log_string := 'AGGIORNIAMO VALIDITA SU STAB CON MINIMO VALORE E MAX VALORE TRA LE VALIDITA DEGLI ALLEVAMENTI ';
				execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			
			 /*   if( length(rc.codice_fiscale)=16  ) then --IF CODFISC E UN CF
			    
			      log_string :=   '**'||  'PRESENZA SOGGFISICO'  ;			 			  
 				  execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			 			  ---- CHECK ESISTENZA CF NELLA TAB DEI SOGGETTI FISICI
		 		  select * into recapp  from cu_anag.soggetti_fisici sf where codice_fiscale =trim(rc.codice_fiscale);
		 			     
			 			
			 	   if (recapp.id is null ) then  ---- IF numSogg=0 SOGGETTI FISICI 
		 			            
		 			  		    log_string :=   '**'||  'PRESENZA SOGGFISICO recapp.id is null  '  ;			 			  
 				 			    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		 			    	    log_string :=   '**'||  'INSERIAMO IMPRESA PIVA COME CF' ||piva;			 			  
 				 			    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
		 			 	        select row_to_json(a.*) into chiamata_j from  (select  rc.fonteINS,trim(rc.codice_fiscale) cf) a;		
				 			 	 
								INSERT INTO cu_anag.soggetti_fisici
								(id, codice_fiscale, fonte)
								VALUES(nextval('cu_anag.cu_anag_id_seq'),   trim(rc.codice_fiscale)  ,  rc.fonteINS)
							    returning  * into R_SOGG_FIS;
								idSoggFis:=R_SOGG_FIS.id;
							    n:=cu_log.upd_record('cu_anag.soggetti_fisici',id_transazione,R_SOGG_FIS,'I');
								log_string :=   '**'|| 'INSERITO SOGG FISICO' || R_SOGG_FIS.id ;
								execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';   
				   else 							 
							   idSoggFis:=recapp.id;							 
				   end if;  ---- IF numSogg=0 SOGGETTI FISICI 
			    
			       select * into recapp  from cu_anag.stabilimento_figure sf where id_stabilimento  =id_STAB
			                and id_tipo_figura =12 AND validita =v_validita ;
				   if (recapp.id is null ) then  ---- IF numSogg=0 SOGGETTI FISICI 		 		     
					  -------------INSERIAMO IN STAB FIGURE
					 		     
			 		  INSERT INTO cu_anag.stabilimento_figure
						(id, id_stabilimento, id_soggetto, id_tipo_figura,    fonte,validita)
						VALUES(nextval('cu_anag.cu_anag_id_seq'),id_STAB,idSoggFis, 12,  rc.fonteINS,v_validita)					 
				 		returning * into R_STABFIG;
			 		    n:=cu_log.upd_record('cu_anag.stabilimento_figure',id_transazione,R_STABFIG,'I');
			 		    log_string :=   '**'|| 'INSERITO STAB FIGURE' || R_STABFIG.id ;						 		     	
			 	 	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			 	   end if;	   
                end if;*/
			  select * into recapp  from cu_anag.stabilimento_figure sf where id_stabilimento  =id_STAB
			               and id_tipo_figura =12  AND validita =v_validita ;
	
			  select * into recapp  from cu_anag.stabilimento_figure sf where id_stabilimento  =id_STAB
			               and id_tipo_figura =12  AND validita && v_validita ;
	
			   if (recapp.id is null ) then  ---- IF numSogg=0 SOGGETTI FISICI 		 		     
					  -------------INSERIAMO IN STAB FIGURE
			         --  log_string :=   '**'|| 'INSERITO STAB FIGURE' || R_STABFIG.id ;						 		     	
			 	-- 	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
					 		     
			 		  INSERT INTO cu_anag.stabilimento_figure
							(id, id_stabilimento, id_soggetto, id_tipo_figura,    fonte,validita)
						VALUES(nextval('cu_anag.cu_anag_id_seq'),id_STAB,id_impresa_new, 12,  rc.fonteINS,v_validita)						 
				 		returning * into R_STABFIG;
			 		    n:=cu_log.upd_record('cu_anag.stabilimento_figure',id_transazione,R_STABFIG,'I');
			 		    log_string :=   '**'|| 'INSERITO STAB FIGURE' || R_STABFIG.id ;						 		     	
			 	 	    execute ' COPY shell FROM PROGRAM ''  ' || 'echo '|| log_string|| '>>' || LOG_FILE ||'''';  
			    end if;	   
			 
		 			  
		END LOOP ; 
		ret.esito:=true;
 
 		return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag."load_stabilimenti_sintesisOLD"(v json, id_transazione bigint) OWNER TO postgres;

--
-- Name: load_upd_accorpa_imprese(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_upd_accorpa_imprese() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	begin

		update cu_anag.imprese set validita =tsrange(lower(validita),'2024-03-21','[)')
		where (piva,cf) in
		(select piva,cf from cu_anag.imprese
		where upper(validita) is null and (piva is not null or cf is not null)
		group by 1,2 having count(*) > 1)
		and id not in (
		select min(id) id from cu_anag.imprese
		where upper(validita) is null and (piva is not null or cf is not null)
		group by piva,cf having count(*) > 1);
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.imprese set validita =tsrange(lower(validita),'2024-03-24','[)')
		--select * from cu_anag.imprese
		where (coalesce(piva,''),coalesce(cf,'')) in
		(select coalesce(piva,''),coalesce(cf,'') from cu_anag.imprese
		where upper(validita) is null and (piva is not null or cf is not null)
		group by 1,2 having count(*) > 1)
		and id not in (
		select min(id) id from cu_anag.imprese
		where upper(validita) is null and (piva is not null or cf is not null)
		group by piva,cf having count(*) > 1);
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
		
		update cu_anag.stabilimenti s set id_impresa =q.id_impresa
		from
		(select s.id,inew.id id_impresa
		from  cu_anag.stabilimenti s join cu_anag.imprese i  on s.id_impresa=i.id
		join cu_anag.imprese inew on (inew.piva=i.piva or (inew.piva is null and i.piva is null))
		    and (inew.cf=i.cf or (inew.cf is null and i.cf is null )) and upper_inf(inew.validita) 
		    where upper(i.validita)='2024-03-21') q
		where s.id=q.id;
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.stabilimento_figure s set id_soggetto =q.id_impresa
		from
		(select s.id,inew.id id_impresa
		--select *
		from  cu_anag.stabilimento_figure s join cu_anag.imprese i  on s.id_soggetto=i.id
		join cu_anag.imprese inew on (inew.piva=i.piva or (inew.piva is null and i.piva is null))
		    and (inew.cf=i.cf or (inew.cf is null and i.cf is null )) and upper_inf(inew.validita) 
		    where upper(i.validita)='2024-03-21') q
		where s.id=q.id;
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		insert into cu_anag.impresa_sedi
		select id,
		id_impresa,
		1,
		id_indirizzo,
		pec,
		email,
		old_id,
		fonte,
		validita from cu_anag.vw_stabilimento_sedi ss where  cod_tipo_sede ilike 'SL' and 
		ss.id_impresa in 
		(select id_impresa from  cu_anag.vw_stabilimento_sedi
		where cod_tipo_sede ilike 'SL'  and
		id_impresa not in (select id_impresa from cu_anag.vw_impresa_sedi where cod_tipo_sede ilike 'SL')
		group by 1
		having count(*) = 1) ;
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe inserite %',total_rows;
 	
		delete from cu_anag.stabilimento_sedi where id in (select id from cu_anag.impresa_sedi);
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe eliminate %',total_rows;		
 	
		/*insert into cu_anag.impresa_figure
		select
		id,
		id_impresa,
		id_tipo_figura,
		id_indirizzo,
		old_id,
		fonte,
		descr,
		validita ,
		id_soggetto
		from cu_anag.vw_stabilimento_figure ss where  cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE' and 
		ss.id_impresa in 
		(select id_impresa from  cu_anag.vw_stabilimento_figure
		where cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE'  and
		id_impresa not in (select id_impresa from cu_anag.vw_impresa_figure where cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE')
		group by 1
		having count(*) = 1) ;*/
 	
 		insert into cu_anag.impresa_figure
		select
		ss.id,
		ss.id_impresa,
		ss.id_tipo_figura,
		ss.id_indirizzo,
		ss.old_id,
		ss.fonte,
		ss.descr,
		ss.validita ,
		ss.id_soggetto
		from cu_anag.vw_stabilimento_figure ss left join  
		(select id_impresa,count(*) from cu_anag.vw_impresa_figure where cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE'
		group by 1
		having count(*) >= 1) impf on impf.id_impresa=ss.id_impresa
		where impf.id_impresa is  null and ss.cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE';
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe inserite %',total_rows;
		
		delete  from cu_anag.stabilimento_figure where id in (select id from cu_anag.impresa_figure);
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe eliminate %',total_rows;
 		ret.esito=true;
 		return ret;

	END;
	END;
$$;


ALTER FUNCTION cu_anag.load_upd_accorpa_imprese() OWNER TO postgres;

--
-- Name: load_upd_normalize_indirizzi(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_upd_normalize_indirizzi() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
R_SOGG cu_anag.soggetti_fisici;
j_info_cf json;
dt varchar;

	begin
	 	--select * from cu_anag.indirizzi where istat_comune is not null and length(istat_comune) = 6 and comune is not null 
		update cu_anag.indirizzi i
			set istat_comune=s.codice_istat,comune=null,stato_prov=null, nazione=null
			from (
			select i.id,c.codice_istat, comune,istat_comune from cu_anag.indirizzi i
			join conf_ext.vw_comuni_vigenti_attivi c on left(upper(translate(c.denominazione_it,' -''','')),13) =
													    left(upper(translate(i.comune,' -''','')),13) ) s
			where  i.id=s.id ;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
 		update cu_anag.indirizzi set istat_comune =lpad(istat_comune,6,'0') where istat_comune is not null and length(istat_comune)=5;
 	
 	
		update cu_anag.indirizzi set comune = null,stato_prov=null, nazione=null
		where istat_comune  in (select codice_istat from conf_ext.vw_comuni_vigenti_attivi vcva)
		and comune is not null or stato_prov is not null or nazione is not null;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set comune = null,stato_prov=null, nazione=null,istat_comune =codice_istat
		from (select codice_istat,denominazione_it from conf_ext.vw_comuni_vigenti_attivi) s
		where comune is not null and comune=s.denominazione_it;
	

	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set comune = null,stato_prov=null, nazione=null,istat_comune =codice_istat
		from (select codice_istat,denomtraslitterata from conf_ext.vw_comuni_vigenti) s
		where comune is not null and comune=s.denomtraslitterata;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set nazione=comune,istat_comune=null where nazione is null and istat_comune='000000';
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set cap=null where cap='00000';
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set stato_prov=null where stato_prov='00'; 
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
		update cu_anag.indirizzi set stato_prov=null
			where stato_prov is not null and istat_comune is not null and length(istat_comune)=6 and istat_comune !='000000'; 
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
 	
 		/*update cu_anag.stabilimento_figure f
		set cf=q.cf from 
		(select f.id,s.codice_fiscale cf
		from cu_anag.stabilimento_figure f join cu_anag.soggetti_fisici s on f.id_soggetto_fisico =s.id) q
		where f.id=q.id and f.cf is null and f.id_soggetto_fisico is not null;
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;
	
	 	update cu_anag.stabilimento_figure f
		set id_soggetto_fisico =null where cf is not null and length(cf)=16 and id_soggetto_fisico is not null;
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;*/
	
		/*update cu_anag.indirizzi  set istat_comune = lpad(istat_comune,6,'0')
		where istat_comune is not null and istat_comune != '' and length(istat_comune) <6;
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe modificate %',total_rows;*/
 	
 		update cu_anag.soggetti_fisici set nome=cu_anag.string_normalize(nome),cognome=cu_anag.string_normalize(cognome),codice_fiscale =cu_anag.string_normalize(codice_fiscale);
 	
 				update cu_anag.soggetti_fisici set sesso =
	 CASE
           WHEN
           ( CASE "substring"(codice_fiscale::text, 10, 1)
                WHEN 'L'::text THEN '0'::text
                WHEN 'M'::text THEN '1'::text
                WHEN 'N'::text THEN '2'::text
                WHEN 'P'::text THEN '3'::text
                WHEN 'Q'::text THEN '4'::text
                WHEN 'R'::text THEN '5'::text
                WHEN 'S'::text THEN '6'::text
                WHEN 'T'::text THEN '7'::text
                WHEN 'U'::text THEN '8'::text
                WHEN 'V'::text THEN '9'::text
                ELSE "substring"(codice_fiscale::text, 10, 1)
            end)::integer > 3 THEN 'F'::varchar
            ELSE 'M'::varchar end where sesso is null; 
           
     update cu_anag.soggetti_fisici t1 set comune_nascita =
(("substring"(t1.codice_fiscale::text, 12, 1) ||
        CASE "substring"(t1.codice_fiscale::text, 13, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            ELSE "substring"(t1.codice_fiscale::text, 13, 1)
        END) ||
        CASE "substring"(t1.codice_fiscale::text, 14, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            ELSE "substring"(t1.codice_fiscale::text, 14, 1)
        END) ||
        CASE "substring"(t1.codice_fiscale::text, 15, 1)
            WHEN 'L'::text THEN '0'::text
            WHEN 'M'::text THEN '1'::text
            WHEN 'N'::text THEN '2'::text
            WHEN 'P'::text THEN '3'::text
            WHEN 'Q'::text THEN '4'::text
            WHEN 'R'::text THEN '5'::text
            WHEN 'S'::text THEN '6'::text
            WHEN 'T'::text THEN '7'::text
            WHEN 'U'::text THEN '8'::text
            WHEN 'V'::text THEN '9'::text
            ELSE "substring"(t1.codice_fiscale::text, 15, 1) end
            where comune_nascita ='ZZZZ';
           
       delete from cu_anag.soggetti_fisici where  length(codice_fiscale)!=16;
      
      update cu_anag.stabilimento_figure x set id_indirizzo=qry.indirizzo_id
		from 
		(select sf.id,p.indirizzo_id  from cu_anag.stabilimento_figure sf left join cu_anag.indirizzi i on sf.id_indirizzo=i.id
		join cu_anag.imprese imp on imp.id=sf.id_soggetto join cu_anag.soggetti_fisici p on p.codice_fiscale =imp.cf 
		where i.id is null and tipo_soggetto ='F') qry
		where x.id=qry.id;

	update cu_anag.impresa_figure x set id_indirizzo=qry.indirizzo_id
		from 
		(select if.id,p.indirizzo_id  from cu_anag.impresa_figure if left join cu_anag.indirizzi i on if.id_indirizzo=i.id
		join cu_anag.imprese imp on imp.id=if.id_soggetto join cu_anag.soggetti_fisici p on p.codice_fiscale =imp.cf 
		where i.id is null and tipo_soggetto ='F') qry
		where x.id=qry.id;
	
	insert into cu_anag.linee
		select nextval('cu_anag.cu_anag_id_seq') id,
			s.id id_stabilimento,tl.id id_tipo_linea ,tsrange(linea_data_inizio,linea_data_fine,'[)') validita,
			true,false linea_principale,true verificato, 'GISA_'||tipo_ab as fonte
		from cu_anag.vw_gisa_imprese_completa_ab i 
			join cu_anag.stabilimenti s on s.sd_id=i.stabilimento_id
			join agenda.vw_tipo_linee tl ON tl.cod_mod  = i.linea_ateco 
		where (s.id,tl.id )  not in 
			(select id_stabilimento, id_tipo_linea from cu_anag.linee);
		
	insert into cu_anag.linee 
		select nextval('cu_anag.cu_anag_id_seq'),s.id , -10000000,tsrange(null,null,'()'),true,true,true,'SICER_FIX' from cu_anag.stabilimenti s left join cu_anag.linee l on s.id=l.id_stabilimento
		where l.id is null and s.fonte ilike 'SICER%';
	for R_SOGG in select * from cu_anag.soggetti_fisici sf where data_nascita is null and codice_fiscale is not null loop
		j_info_cf:=cu_anag.split_cf(R_SOGG.codice_fiscale) ;
		if j_info_cf is not null then
			raise notice 'j_info_cf %',j_info_cf;
			raise notice 'data %',j_info_cf->>'nascita';
			dt:= '19'||(j_info_cf->>'nascita')::varchar;
			 dt:= substring(dt,1,4)||'-'||substring(dt,5,2)||'-'||substring(dt,7,2);
			raise notice 'cf % dt %',R_SOGG.codice_fiscale,dt;
			update cu_anag.soggetti_fisici set data_nascita=(dt)::date where id=R_SOGG.id;
		end if;	
	end loop;
	
 	
 		--alter table cu_anag.mangimifici_reg add column id bigint;
 
 		 return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.load_upd_normalize_indirizzi() OWNER TO postgres;

--
-- Name: load_upd_stabilimenti_sicer(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.load_upd_stabilimenti_sicer() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	begin

/* IMPRESE START */
	/* IMPRESE DEL */
	
		--select *
	delete	from cu_anag.imprese
		where fonte ilike 'SICER%'
		and sd_id 	 not in (
			select 
			a.stabilimento_id
			from cu_anag.vw_gisa_imprese_completa_ab a );
	
	GET DIAGNOSTICS total_rows := ROW_COUNT;
 	raise notice 'righe delete %',total_rows;
 	
	/* IMPRESE UPD */
	update cu_anag.imprese i set
		nome =qry.impresa_ragione_sociale,
		cf =qry.impresa_cf,
		piva =qry.impresa_piva,
		pec =qry.impresa_pec,
		email =qry.impresa_email,
		sdi =qry.impresa_sdi,
		split_payement =qry.impresa_split_payment,
		cod_tipo_impresa =qry.impresa_tipo_persona,
		az_id =qry.impresa_id,
		az_cod_aziendale =qry.impresa_cod_aziendale,
		az_cod_regionale =qry.az_cod_regionale,
		sd_id =qry.sd_id,
		verificato =qry.verificato,
		fonte =qry.fonte,
		validita =qry.validita,
		tipo_soggetto =qry.t
	from (
		select i.id ,
			 impresa_ragione_sociale,impresa_cf,impresa_piva,impresa_pec,
			impresa_email ,impresa_sdi ,impresa_split_payment ,
			impresa_tipo_persona ,impresa_id,impresa_cod_aziendale ,null az_cod_regionale,
			a.stabilimento_id as sd_id,tipo_ab='A' verificato,'SICER_'||tipo_ab fonte,tsrange(impresa_data_inizio,null,'[)') validita,
			case when length(impresa_cf)=16 then 'F' else 'G' end	t
			from cu_anag.vw_gisa_imprese_completa_ab a -- 15286
			join cu_anag.vw_imprese_all i on a.stabilimento_id =i.sd_id) qry
		where i.id=qry.id;
	
	GET DIAGNOSTICS total_rows := ROW_COUNT;
 	raise notice 'update cu_anag.imprese: %',total_rows;
 	
	
	/* IMPRESE ADD */
	insert into  cu_anag.imprese
	select nextval('cu_anag.cu_anag_id_seq') id ,
		 impresa_ragione_sociale,impresa_cf,impresa_piva,impresa_pec,
		impresa_email ,impresa_sdi ,impresa_split_payment ,
		impresa_tipo_persona ,impresa_id,impresa_cod_aziendale ,null az_cod_regionale,
		a.stabilimento_id as sd_id,tipo_ab='A','SICER_'||tipo_ab,tsrange(impresa_data_inizio,null,'[)'),
		case when length(impresa_cf)=16 then 'F' else 'G' end	
		from cu_anag.vw_gisa_imprese_completa_ab a
		where 
		 a.stabilimento_id not in (select sd_id from cu_anag.imprese where sd_id is not null);

		
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'insert into  cu_anag.imprese: %',total_rows;
 		
/* FINE IMPRESE */		
		
/* STABILIMENTI */
		
	/* DELETE STABILIMENTI */
	
	delete	from cu_anag.stabilimenti  where fonte ilike 'SICER%' and id_impresa is null;
	/* UPDATE STABILIMENTI */

		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'delete from cu_anag.stabilimenti: %',total_rows;
 		

	update cu_anag.stabilimenti s set 
		id_impresa=qry.id_impresa,
		nome=qry.nome,
		sd_id=qry.sd_id,
		id_indirizzo=qry.id_indirizzo,
		cod_regionale=qry.cod_regionale,
		verificato=qry.verificato,
		fonte=qry.fonte,
		categoria_rischio=qry.categoria_rischio,
		validita=qry.validita,
		cod_nazionale=qry.cod_nazionale,
		id_tipologia_struttura=qry.id_tipologia_struttura,
		pec=qry.pec,
		telefono=qry.telefono,
		sdi=qry.sdi
	from 
	(select 
			s.id,ni.id id_impresa,
			stabilimento_denominazione nome,
			stabilimento_id sd_id,0 id_indirizzo ,stabilimento_codice_regionale cod_regionale,
			tipo_ab='A' verificato,'SICER_'||tipo_ab fonte
			,null::integer categoria_rischio	,tsrange(stabilimento_data_inizio,null,'[)') validita,null cod_nazionale,
			ts.id id_tipologia_struttura,stabilimento_pec pec,null telefono,null sdi		
	 from cu_anag.vw_gisa_imprese_completa_ab a
	 join cu_anag.imprese ni on ni.sd_id=a.stabilimento_id
	 join cu_anag.stabilimenti s on s.sd_id=a.stabilimento_id
	 join cu_types.vw_tipologie_struttura ts on ts.codice =stabilimento_cod_tipologia_struttura) qry
	 where s.id=qry.id;
	
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'update cu_anag.stabilimenti: %',total_rows;
 		
	
	
	/* IMPRESE ADD */
	insert into cu_anag.stabilimenti 
	select 
			nextval('cu_anag.cu_anag_id_seq') id,
			ni.id id_impresa,
			stabilimento_denominazione nome,
			stabilimento_id sd_id,0 id_indirizzo ,stabilimento_codice_regionale cod_regionale,
			tipo_ab='A' verificato,'SICER_'||tipo_ab fonte
			,null categoria_rischio	,tsrange(stabilimento_data_inizio,null,'[)') validita,null cod_nazionale,
			ts.id id_tipologia_struttura,stabilimento_pec pec,null telefono,null sdi		
	 from cu_anag.vw_gisa_imprese_completa_ab a
	 join cu_anag.imprese ni on ni.sd_id=a.stabilimento_id
	 join cu_types.vw_tipologie_struttura ts on ts.codice =stabilimento_cod_tipologia_struttura
	 where a.stabilimento_id not in (select sd_id from cu_anag.stabilimenti where sd_id is not null);


		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'insert into cu_anag.stabilimenti: %',total_rows;
 			 
	 /* INDIRIZZI */
	delete 
	 from cu_anag.indirizzi where fonte ilike 'SICER_%' and id not in (
		select id_indirizzo from cu_anag.stabilimenti where id_indirizzo is not null
		union
		select id_indirizzo from cu_anag.stabilimento_sedi where id_indirizzo is not null
		union
		select id_indirizzo from cu_anag.stabilimento_figure where id_indirizzo is not null
		union
		select id_indirizzo from cu_anag.impresa_sedi where id_indirizzo is not null
		union
		select id_indirizzo from cu_anag.impresa_figure where id_indirizzo is not null);
	
	
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'idelete from cu_anag.indirizzi: %',total_rows;
 		
	insert into cu_anag.indirizzi 
	select  s.id id,stabilimento_indirizzo_toponimo toponimo,
		stabilimento_indirizzo indirizzo,
		stabilimento_indirizzo_cap cap,
		stabilimento_indirizzo_provincia prov_stato,
		null nazione,
		stabilimento_indirizzo_istat_comune istat_comune,
		null comune,
		'' localita,
		stabilimento_indirizzo_civico civico,
		stabilimento_latitudine latitudine,
		stabilimento_longitudine longitudine,
		c.id is not null verificato,'SICER_'||a.tipo_ab fonte
	from cu_anag.vw_gisa_imprese_completa_ab a 
	join cu_anag.stabilimenti s on a.stabilimento_id =s.sd_id 
	left join conf_ext.vw_comuni_vigenti_attivi c on c.codistat =a.stabilimento_indirizzo_istat_comune::integer ;


		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'insert into cu_anag.indirizzi: %',total_rows;
 		
	update   cu_anag.stabilimenti set id_indirizzo=id 
	where fonte ilike 'SICER_%';
/* FINE STABILIMENTI */

/* SOGGETTI FISICI */
	delete from cu_anag.soggetti_fisici;
	

		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'delete from cu_anag.soggetti_fisici: %',total_rows;
 		
	insert into cu_anag.soggetti_fisici 
		select nextval('cu_anag.cu_anag_id_seq') id,
		null,cognome,nome, codice_catastale_nascita,codice_fiscale,sesso,telefono,email,pec,null,
		--data_nascita_fiscale::date,documento,null,cu_anag.check_cf(codice_fiscale),'SICER' from conf_ext.vw_soggetti_fisici_fvg ;
	replace(data_nascita_fiscale,'1900-02-29','2000-02-29')::date,documento,null,cu_anag.check_cf(codice_fiscale),'SICER' from conf_ext.vw_soggetti_fisici_fvg ;
	
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'insert into cu_anag.soggetti_fisici: %',total_rows;
 		
	
	delete from cu_anag.indirizzi where fonte = 'SICER' ;
	insert into cu_anag.indirizzi
		select s.id,null,res_indirizzo,res_cap,res_provincia,nazione,res_istat,res_comune,null,res_civico,null,null,true,'SICER'
		from cu_anag.soggetti_fisici s
		join conf_ext.vw_soggetti_fisici_fvg sfvg on s.codice_fiscale =sfvg.codice_fiscale;

		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'delete from cu_anag.indirizzi: %',total_rows;
 		
	
	update cu_anag.soggetti_fisici set indirizzo_id=id where indirizzo_id is null and fonte='SICER';
		--and id in (select id from cu_anag.indirizzi);
	
	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'update cu_anag.soggetti_fisici: %',total_rows;
 		
	
/* FINE SOGGETTI FISICI */
	
/* LINEE PRINCIPALI */
	/* LINEE PRINCIPALI DEL */	
	delete 
		from cu_anag.linee l
		where fonte ilike 'SICER%' and l.linea_principale and
			(id_stabilimento,id_tipo_linea)
			not in 		(select 
				s.id id_stabilimento,tl.id id_tipo_linea 
				from cu_anag.vw_gisa_imprese_completa_ab i 
				join cu_anag.stabilimenti s on s.sd_id=i.stabilimento_id
				join agenda.vw_tipo_linee tl ON tl.cod_mod  = i.linea_ateco);
		

		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'delete from cu_anag.linee: %',total_rows;
 		
			
	/* LINEE PRINCIPALI UPD */	
	update cu_anag.linee l
		set 
		validita=qry.validita,
		attivita_fissa=qry.attivita_fissa,
		linea_principale=qry.linea_principale,
		verificato=qry.verificato,
		fonte=qry.fonte,
		data_ultima_visita=null,
		id_esterno=null
	from (select --nextval('cu_anag.cu_anag_id_seq') id,
		l.id,
		s.id id_stabilimento,tl.id id_tipo_linea ,
		tsrange(linea_data_inizio,linea_data_fine,'[)') validita,
		i.attivita_fissa,i.linea_principale=1 linea_principale,i.tipo_ab='A' verificato, 'SICER_'||i.tipo_ab as fonte --from cu_anag.linee
		from cu_anag.vw_gisa_imprese_completa_ab i 
		join cu_anag.stabilimenti s on s.sd_id=i.stabilimento_id
		join agenda.vw_tipo_linee tl ON tl.cod_mod  = i.linea_ateco 
		join cu_anag.linee l on l.id_stabilimento =s.id and l.id_tipo_linea =tl.id) qry
	where l.id=qry.id;
	
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'update cu_anag.linee: %',total_rows;
 		


	/* LINEE PRINCIPALI ADD */
	insert into cu_anag.linee
		select nextval('cu_anag.cu_anag_id_seq') id,
			s.id id_stabilimento,tl.id id_tipo_linea ,tsrange(linea_data_inizio,linea_data_fine,'[)') validita,
			true,true linea_principale,true verificato, 'SICER_A' as fonte
		from cu_anag.vw_gisa_imprese_completa_ab i 
			join cu_anag.stabilimenti s on s.sd_id=i.stabilimento_id
			join agenda.vw_tipo_linee tl ON tl.cod_mod  = i.linea_ateco 
		where (s.id,tl.id )  not in 
			(select id_stabilimento, id_tipo_linea from cu_anag.linee);
		
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'insert into cu_anag.linee: %',total_rows;
 		
		
		
/* LINEE PRINCIPALI END */
		
/* LINEE SECONDARIE */
		
	/* LINEE SECONDARIE DEL*/
	delete 
	--select count(*)
	from cu_anag.linee l
	where fonte ilike 'SICER%' and not l.linea_principale and
		(id_stabilimento,id_tipo_linea)
		not in 		(select 
			s.id id_stabilimento,tl.id id_tipo_linea 
			from cu_anag.vw_gisa_imprese_linee_secondarie_a i 
			join cu_anag.stabilimenti s on s.sd_id=i.stabilimento_id
			join agenda.vw_tipo_linee tl ON tl.cod_mod  = i.linea_ateco);


	/* LINEE SECONDARIE UPD*/	
	update cu_anag.linee l
		set 
		validita=qry.validita,
		attivita_fissa=qry.attivita_fissa,
		linea_principale=qry.linea_principale,
		verificato=qry.verificato,
		fonte=qry.fonte,
		data_ultima_visita=null,
		id_esterno=null
	from (select --nextval('cu_anag.cu_anag_id_seq') id,
		l.id,
		s.id id_stabilimento,tl.id id_tipo_linea ,
		tsrange(linea_data_inizio,linea_data_fine,'[)') validita,
		true attivita_fissa,i.linea_principale=1 linea_principale,true verificato,
		'SICER_A' as fonte --from cu_anag.linee
		from cu_anag.vw_gisa_imprese_linee_secondarie_a i 
		join cu_anag.stabilimenti s on s.sd_id=i.stabilimento_id
		join agenda.vw_tipo_linee tl ON tl.cod_mod  = i.linea_ateco 
		join cu_anag.linee l on l.id_stabilimento =s.id and l.id_tipo_linea =tl.id) qry
	where l.id=qry.id;
	
		
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'update linee: %',total_rows;
 		

	/* LINEE SECONDARIE ADD*/	
	insert into cu_anag.linee
		select nextval('cu_anag.cu_anag_id_seq') id,
		s.id id_stabilimento,tl.id id_tipo_linea ,tsrange(linea_data_inizio,linea_data_fine,'[)') validita,
		true,false linea_principale,true verificato, 'SICER_A' as fonte
		from conf_ext.vw_gisa_imprese_linee_secondarie_a i 
		join cu_anag.stabilimenti s on s.sd_id=i.stabilimento_id
		join agenda.vw_tipo_linee tl ON tl.cod_mod  = i.linea_ateco 
		and (s.id,tl.id) not in 
		(select 
			id_stabilimento,id_tipo_linea 
			from cu_anag.linee) ;
/* LINEE SECONDARIE END*/	
		
		
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'FINE LINEE: %',total_rows;
 		
		
		
/* STABILIMENTO SEDE */  /*SEDE LEGALE -> DOMICILIO LEGALE*/
	delete from cu_anag.indirizzi where id < 0 and mod((id*-1),10 )=1;
	
	insert into cu_anag.indirizzi
		select distinct -i.id*10-1,fg_an_res_toponimo toponimo,	fg_an_res_indirizzo indirizzo,fg_an_res_cap,
			fg_an_res_provincia prov_stato, null nazione,	
			fg_an_res_istat istat_comune,
			fg_an_res_comune comune, null localita,
			fg_an_res_civico civico ,null,null, s.verificato,s.fonte
		from cu_anag.vw_fvg_gisa_imprese_all i 
		join cu_types.tipi_sede ts on (upper(ts.descr) =upper(i.fg_tipo_figura_descr)) or 
			(upper(ts.descr)='DOMICILIO LEGALE' and upper(i.fg_tipo_figura_descr)='SEDE LEGALE')
		join cu_anag.stabilimenti s on s.sd_id =i.sd_id ;

	delete from cu_anag.stabilimento_sedi where fonte ilike 'SICER%' or id_stabilimento
		in (select id from cu_anag.stabilimenti where fonte ilike 'SICER%');
	insert into cu_anag.stabilimento_sedi 
		select distinct on (ns.id,ts.id)
		nextval('cu_anag.cu_anag_id_seq') id,
			 ns.id,ts.id,-i.id*10-1, 
			i.fg_an_pec pec,i.fg_an_email email,
			i.id old_id,ns.fonte
		from cu_anag.vw_fvg_gisa_imprese_all i
		join cu_anag.stabilimenti ns on ns.sd_id =i.sd_id 
		join cu_types.tipi_sede ts on upper(ts.descr) =upper(i.fg_tipo_figura_descr) or 
				(upper(ts.descr)='DOMICILIO LEGALE' and upper(i.fg_tipo_figura_descr)='SEDE LEGALE');
/* STABILIMENTO SEDE END */
		
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'FINE STABILIMENTO SEDE: %',total_rows;	
 	
/* STABILIMENTO FIGURA */	/*	LEGALE RAPPRESENTANTE-> LEGALE RAPPRESENTANTE PER PROCURA */
		delete from cu_anag.indirizzi where id < 0 and mod((id*-1),10 )=2 and fonte ilike 'SICER%';

	
	
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'delete from cu_anag.indirizzi STABILIMENTO FIGURA: %',total_rows;	
 		
		insert into cu_anag.indirizzi
			select distinct -i.id*10-2,fg_an_res_toponimo toponimo,		fg_an_res_indirizzo indirizzo,fg_an_res_cap,
			fg_an_res_provincia prov_stato, null nazione,	
			fg_an_res_istat comune,
			fg_an_res_comune comune, null localita,
			fg_an_res_civico civico ,null,null, s.verificato,s.fonte
		from cu_anag.vw_fvg_gisa_imprese_all i 
		join cu_anag.stabilimenti s on s.sd_id =i.sd_id 
		join cu_types.tipi_figura tf on (upper(tf.cod) =upper(i.fg_tipo_figura_descr)) -- or 
		 		--(upper(tf.descr) ='LEGALE RAPPRESENTANTE PER PROCURA' and upper(i.fg_tipo_figura_descr)='LEGALE RAPPRESENTANTE')
		join cu_anag.soggetti_fisici sf on sf.codice_fiscale =fg_an_cf
		where length(fg_an_cf)=16;
	
	
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'insert into cu_anag.indirizzi STABILIMENTO FIGURA: %',total_rows;	
 	
	
		insert into cu_anag.imprese
			select nextval('cu_anag.cu_anag_id_seq'),
			null,f.fg_an_cf,null,f.fg_an_pec,f.fg_an_email,false,'N','P',null,null,null,f.sd_id,sf.id is not null,
			s.fonte,tsrange(null::timestamp,null::timestamp,'[)'),'F'
		from cu_anag.vw_fvg_gisa_imprese_all f 
		join cu_anag.stabilimenti s on s.sd_id =f.sd_id 
		join cu_types.tipi_figura tf on (upper(tf.descr) =upper(f.fg_tipo_figura_descr)) or 
		 		(upper(tf.descr) ='LEGALE RAPPRESENTANTE PER PROCURA' and upper(f.fg_tipo_figura_descr)='LEGALE RAPPRESENTANTE')
		join cu_anag.soggetti_fisici sf on sf.codice_fiscale =fg_an_cf
		where length(fg_an_cf)=16 and not exists (select * from cu_anag.imprese where cf=fg_an_cf);

		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'insert into cu_anag.imprese STABILIMENTO FIGURA: %',total_rows;	
 	
	
	
		delete from cu_anag.stabilimento_figure where fonte ilike 'SICER%';
	
	
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'delete from cu_anag.stabilimento_figure STABILIMENTO FIGURA: %',total_rows;	
 	
	
		insert into cu_anag.stabilimento_figure  
			select distinct on (ns.id ,tf.id  ) nextval('cu_anag.cu_anag_id_seq'),
			 ns.id id_stabilimento,imp.id id_soggetto,tf.id id_tipo_figura,-i.id*10-2 id_indirizzo,i.id old_id,ns.fonte
			from cu_anag.vw_fvg_gisa_imprese_all i 
			join cu_anag.stabilimenti ns on ns.sd_id =i.sd_id 
			join cu_types.tipi_figura tf on upper(tf.descr) =upper(i.fg_tipo_figura_descr)  or 
		 		(upper(tf.descr) ='LEGALE RAPPRESENTANTE PER PROCURA' and upper(i.fg_tipo_figura_descr)='LEGALE RAPPRESENTANTE')
			join (select cf,max(id) id from cu_anag.imprese where cod_tipo_impresa='P' and tipo_soggetto='F' group by 1) imp on imp.cf =fg_an_cf
			--join cu_anag.stabilimenti s on s.sd_id = i.sd_id
			where ns.fonte ilike 'SICER%' and length(fg_an_cf)=16;
		
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'insert into cu_anag.stabilimento_figure STABILIMENTO FIGURA: %',total_rows;	
 
		
	

	 	 		--ret:=cu_anag.load_new_stabilimenti_upd_indirizzi();
 	
 		update cu_anag.stabilimenti s set categoria_rischio =sub.id_categoria_rischio
 		from (
 			select sd_id,id_categoria_rischio from conf_ext.vw_gisa_imprese_categoria_rischio icr
 			join cu_types.vw_categorie_rischio cr on upper(cr.descrizione)=upper(icr.categoria_rischio_valore)
 			where id_categoria_rischio is not null
 		) sub
 		where s.sd_id=sub.sd_id;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe caricate per categoria rischio %',total_rows;
 	
 		insert into cu_anag.stabilimento_categorizzazioni
 		select nextval('cu_anag.cu_anag_id_seq'),id,tsrange(dt,null,'[)'),id_categoria_rischio from (
 	 	select distinct on (s.id) s.id,id_categoria_rischio,categoria_rischio_data_controllo dt from conf_ext.vw_gisa_imprese_categoria_rischio icr
 			join cu_types.vw_categorie_rischio cr on upper(cr.descrizione)=upper(icr.categoria_rischio_valore)
 			join cu_anag.stabilimenti s on s.sd_id=icr.sd_id
 			where id_categoria_rischio is not null order by s.id,categoria_rischio_data_controllo desc) a;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe inserite per categoria rischio %',total_rows;
 	
 	 	update cu_anag.linee l set data_ultima_visita =sub.dt
 		from (
 			select distinct on (l.id) l.id,u.data_sopralluogo dt from 
				conf_ext.fvg_gisa_imprese_cuf_motivo_ultimo u
				join cu_anag.vw_linee l on u.sd_id= l.sd_id
				order by l.id,u.data_sopralluogo desc
 		) sub
 		where l.id=sub.id;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	data ultima visita %',total_rows;
 	
	 return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.load_upd_stabilimenti_sicer() OWNER TO postgres;

--
-- Name: split_cf(character varying); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.split_cf(cf character varying) RETURNS json
    LANGUAGE plpgsql
    AS $_$
begin
	declare 
        DecodeN hstore;
		DecodeM hstore;
		j_str varchar;
        n int;
       decade int;
    begin
	    
	    DecodeN   :='L=>0, M=>1, N=>2, P=>3, Q=>4, R=>5, S=>6, T=>7, U=>8, V=>9, 0=>0, 1=>1, 2=>2, 3=>3, 4=>4, 5=>5, 6=>6, 7=>7, 8=>8, 9=>9';
	    DecodeM   :='A=>01, E=>05, P=>09, B=>02, H=>06, R=>10, C=>03, L=>07, S=>11, D=>04, M=>08, T=>12';
		
		cf:=upper(replace(cf,' ',''));
		if cf ~ '^[0-9]{11}$' then 
			return null;
		end if;
		if not cu_anag.check_cf(cf) then
			return null;
		end if;
		j_str:='{"sesso":"';
		--raise notice 'J_str %',j_str;
		decade:=(DecodeN->substring(cf,10,1))::integer;
		if decade between 0 and 3 then
			j_str:=j_str||'M';
		else
			j_str:=j_str||'F';
		decade:=decade -4;
		end if;
		--raise notice 'J_str %',j_str;
		j_str:=j_str||'","comune":"'||substring(cf,12,1) ||(DecodeN->substring(cf,13,1))||(DecodeN->substring(cf,14,1))||
				(DecodeN->substring(cf,15,1))||'","nascita":"';
				--raise notice 'J_str %',j_str;
		j_str:=j_str||(DecodeN->substring(cf,7,1))||(DecodeN->substring(cf,8,1))|| (DecodeM->substring(cf,9,1))||
				decade||(DecodeN->substring(cf,11,1));
				--raise notice 'J_str %',j_str;
		j_str:=j_str||'"}';
		--raise notice 'J_str %',j_str;
		--j:=j_str;
		--raise notice 'j %',j;
	    return j_str::json;
	end;
END
$_$;


ALTER FUNCTION cu_anag.split_cf(cf character varying) OWNER TO postgres;

--
-- Name: split_cf(character varying, json); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.split_cf(cf character varying, j json) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
begin
	declare 
        DecodeN hstore;
		DecodeM hstore;
		j_str varchar;
        n int;
    begin
	    
	    DecodeN   :='L=>0, M=>1, N=>2, P=>3, Q=>4, R=>5, S=>6, T=>7, U=>8, V=>9, 0=>0, 1=>1, 2=>2, 3=>3, 4=>4, 5=>5, 6=>6, 7=>7, 8=>8, 9=>9';
	    DecodeM   :='A=>01, E=>05, P=>09, B=>02, H=>06, R=>10, C=>03, L=>07, S=>11, D=>04, M=>08, T=>12';
		
		cf:=upper(replace(cf,' ',''));
		if cf ~ '^[0-9]{11}$' then 
			j:='{}';
			return true;
		end if;
		if not cu_anag.check_cf(cf) then
			j:=null;
			return false;
		end if;
		j_str:='{"sesso":"';
		raise notice 'J_str %',j_str;
		if (DecodeN->substring(cf,10,1))::integer between 0 and 3 then
			j_str:=j_str||'M';
		else
			j_str:=j_str||'F';
		end if;
		raise notice 'J_str %',j_str;
		j_str:=j_str||'","comune":"'||substring(cf,12,1) ||(DecodeN->substring(cf,13,1))||(DecodeN->substring(cf,14,1))||
				(DecodeN->substring(cf,15,1))||'","nascita":"';
				raise notice 'J_str %',j_str;
		j_str:=j_str||(DecodeN->substring(cf,7,1))||(DecodeN->substring(cf,8,1))|| (DecodeM->substring(cf,9,1))||
				(DecodeN->substring(cf,10,1))||(DecodeN->substring(cf,11,1));
				raise notice 'J_str %',j_str;
		j_str:=j_str||'"}';
		raise notice 'J_str %',j_str;
		j:=j_str;
	    return true;
	end;
END
$_$;


ALTER FUNCTION cu_anag.split_cf(cf character varying, j json) OWNER TO postgres;

--
-- Name: split_cf_da_eliminare(character varying, json); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.split_cf_da_eliminare(cf character varying, j json) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
begin
	declare 
        DecodeN hstore;
		DecodeM hstore;
		j_str varchar;
        n int;
    begin
	    
	    DecodeN   :='L=>0, M=>1, N=>2, P=>3, Q=>4, R=>5, S=>6, T=>7, U=>8, V=>9, 0=>0, 1=>1, 2=>2, 3=>3, 4=>4, 5=>5, 6=>6, 7=>7, 8=>8, 9=>9';
	    DecodeM   :='A=>01, E=>05, P=>09, B=>02, H=>06, R=>10, C=>03, L=>07, S=>11, D=>04, M=>08, T=>12';
		
		cf:=upper(replace(cf,' ',''));
		if cf ~ '^[0-9]{11}$' then 
			j:='{}';
			return true;
		end if;
		if not cu_anag.check_cf(cf) then
			j:=null;
			return false;
		end if;
		j_str:='{"sesso":"';
		raise notice 'J_str %',j_str;
		if (DecodeN->substring(cf,10,1))::integer between 0 and 3 then
			j_str:=j_str||'M';
		else
			j_str:=j_str||'F';
		end if;
		raise notice 'J_str %',j_str;
		j_str:=j_str||'","comune":"'||substring(cf,12,1) ||(DecodeN->substring(cf,13,1))||(DecodeN->substring(cf,14,1))||
				(DecodeN->substring(cf,15,1))||'","nascita":"';
				raise notice 'J_str %',j_str;
		j_str:=j_str||(DecodeN->substring(cf,7,1))||(DecodeN->substring(cf,8,1))|| (DecodeM->substring(cf,9,1))||
				(DecodeN->substring(cf,10,1))||(DecodeN->substring(cf,11,1));
				raise notice 'J_str %',j_str;
		j_str:=j_str||'"}';
		raise notice 'J_str %',j_str;
		j:=j_str;
		raise notice 'J %',j;
	    return true;
	end;
END
$_$;


ALTER FUNCTION cu_anag.split_cf_da_eliminare(cf character varying, j json) OWNER TO postgres;

--
-- Name: split_check_cf(character varying, character varying, character varying, date, character varying, character varying); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.split_check_cf(cf character varying, nome character varying, cognome character varying, dt date, sesso character varying, luogo character varying) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
        nome_cf varchar;
		cognome_cf varchar;
		proc_name varchar;
		j_str varchar;
      	j_cf json; 
      	ret cu_types.result_type;
      	vocali varchar;
     	consonanti varchar;
    begin
	    
	cf:=trim(upper(cf));
nome:=trim(upper(nome));
cognome:=trim(upper(cognome));
sesso:=trim(upper(sesso));
luogo:=trim(upper(luogo));
	
	vocali:='[^AEIOU]';
	consonanti:='[^BCDFGHJKLMNPQRSTVXYWZ]';
	proc_name:='cu_anag.split_check_cf';
	if  not cu_anag.check_cf(cf) or cf is null then
		ret.esito:=false;
		ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_non_corretto');
		ret.info = null;
		return ret;
	end if;
	j_cf:=cu_anag.split_cf(cf);
	if j_cf is null then
		ret.esito:=false;
		ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_non_separabile_in_campi');
		ret.info = null;
		return ret;
	end if;
	if  luogo !=(j_cf->>'comune')::varchar then
		ret.esito:=false;
		ret:=cu_ui.build_ret(ret,proc_name, 'codice_catastale_luogo_di_nascita_non_congruente_con_codice_fiscale');
		ret.info = null;
		return ret;
	end if;
   	if  (j_cf->>'sesso')::varchar!= upper(sesso) then
		ret.esito:=false;
		ret:=cu_ui.build_ret(ret,proc_name, 'sesso_non_congruente_con_codice_fiscale');
		ret.info = null;
		return ret;
	end if;
    if  (j_cf->>'nascita')::varchar!= to_char(dt,'YYMMDD') then
		ret.esito:=false;
		ret:=cu_ui.build_ret(ret,proc_name, 'data_nascita_non_congruente_con_codice_fiscale');
		ret.info = null;
		return ret;
	end if;

	nome_cf:=regexp_replace(nome, consonanti, '', 'g');
	if (length(nome_cf ) > 3) then
		nome_cf:=substr(nome_cf,1,1)||substr(nome_cf,3,2);
	end if;
	if (length(nome_cf ) < 3) then
		nome_cf:=nome_cf||regexp_replace(nome, vocali, '', 'g');
	end if;
	if (length(nome_cf ) < 3) then
		nome_cf:=rpad(nome_cf,3,'X');
	end if;
	nome_cf:=substr(nome_cf,1,3);
	--raise notice 'CF % NOME_CF %',cf,nome_cf;
	if nome_cf != substr(cf,4,3) then
		ret.esito:=false;
		ret:=cu_ui.build_ret(ret,proc_name, 'nome_non_congruente_con_codice_fiscale cf:'|| cf||' nome_cf:'||nome_cf||' nome :'|| substr(cf,4,3));
		ret.info = null;
		return ret;
	end if;
	
	cognome_cf:=regexp_replace(cognome, consonanti, '', 'g');

	if (length(cognome_cf ) < 3) then
		cognome_cf:=cognome_cf||regexp_replace(cognome, vocali, '', 'g');
	end if;
	if (length(cognome_cf ) < 3) then
		cognome_cf:=rpad(cognome_cf,3,'X');
	end if;
	cognome_cf:=substr(cognome_cf,1,3);
	--raise notice 'CF % COGNOME_CF %',cf,cognome_cf;
	if cognome_cf != substr(cf,1,3) then
		ret.esito:=false;
		ret:=cu_ui.build_ret(ret,proc_name, 'cognome_non_congruente_con_codice_fiscale');
		ret.info = null;
		return ret;
	end if;

	ret.esito := true;
	ret.info  :=null;
	return ret;
	    
	end;
END
$$;


ALTER FUNCTION cu_anag.split_check_cf(cf character varying, nome character varying, cognome character varying, dt date, sesso character varying, luogo character varying) OWNER TO postgres;

--
-- Name: split_check_cf_bool(character varying, character varying, character varying, date, character varying, character varying); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.split_check_cf_bool(cf character varying, nome character varying, cognome character varying, dt date, sesso character varying, luogo character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
begin
	declare 
      	ret cu_types.result_type;
    begin
	    
	ret:=cu_anag.split_check_cf(cf, nome , cognome, dt, sesso , luogo);

	return ret.esito;
	end;
end;
$$;


ALTER FUNCTION cu_anag.split_check_cf_bool(cf character varying, nome character varying, cognome character varying, dt date, sesso character varying, luogo character varying) OWNER TO postgres;

--
-- Name: string_normalize(character varying); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.string_normalize(str character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare 
		n integer;   
    begin
	    return  regexp_replace(TRIM(coalesce(str,'')),'[ 	]+', ' ', 'g');
	end;
END
$$;


ALTER FUNCTION cu_anag.string_normalize(str character varying) OWNER TO postgres;

--
-- Name: string_normalize_upper(character varying); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.string_normalize_upper(str character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare 
		n integer;   
    begin
	    return  upper(cu_anag.string_normalize(str));
	end;
END
$$;


ALTER FUNCTION cu_anag.string_normalize_upper(str character varying) OWNER TO postgres;

--
-- Name: upd_accorpa_imprese(); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_accorpa_imprese() RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	begin
		
		drop table if exists tmp.accorpa_imprese_per_piva,tmp.accorpa_imprese_per_cf, tmp.accorpa_imprese_cambio_id;
	
		create table tmp.accorpa_imprese_per_piva as 
			select piva,id id_impresa from (
			select distinct on (i.piva) i.piva,i.id,coalesce(cnt,0) cnt
				from cu_anag.imprese i
				left join(
					select id_impresa,count(*) cnt from (
					select id_impresa from cu_anag.impresa_figure where upper_inf(validita) 
					union all
					select id_impresa from cu_anag.impresa_sedi where upper_inf(validita) ) ic
					group by 1) ic on ic.id_impresa=i.id
				join (
					select piva,count(*)  from cu_anag.imprese
					where upper(validita) is null and piva is not null and trim(piva) != ''
					group by piva having count(*) > 1) k on k.piva=i.piva
				where upper_inf(i.validita)
			order by piva,coalesce(cnt,0) desc) z ;

		create table tmp.accorpa_imprese_per_cf as
			select cf,id_impresa from (
					select distinct on (i.cf) i.cf,i.id id_impresa,coalesce(cnt,0) cnt
						from cu_anag.imprese i
						left join(
							select id_impresa,count(*) cnt from (
							select id_impresa from cu_anag.impresa_figure where upper_inf(validita) 
							union all
							select id_impresa from cu_anag.impresa_sedi where upper_inf(validita) ) ic
							group by 1) ic on ic.id_impresa=i.id
						join (
							select cf,count(*)  from cu_anag.imprese
							where upper(validita) is null and cf is not null and trim(cf) != '' and (piva is null or trim(piva)='')
							group by cf having count(*) > 1) k on k.cf=i.cf
						where upper_inf(i.validita)
					order by cf,coalesce(cnt,0) desc) z ;	

		update cu_anag.imprese set validita =tsrange(lower(validita),'2999-01-01','[)')
		where (piva) in (select piva from tmp.accorpa_imprese_per_piva where piva is not null) and 
			  (id) not in (select id_impresa from tmp.accorpa_imprese_per_piva) and
			   upper(validita) is null and (piva is not null);
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'Imprese per piva righe modificate %',total_rows;

 	create table tmp.accorpa_imprese_cambio_id
 	as select i.id id_impresa_old, n.id_impresa id_impresa_new
				from cu_anag.imprese i
				join tmp.accorpa_imprese_per_piva n on n.piva=i.piva and i.id != n.id_impresa
				where i.piva is not null;
 	
		update cu_anag.stabilimenti s set id_impresa =q.id_impresa_new
		from
			(select id_impresa_old, id_impresa_new
				from tmp.accorpa_imprese_cambio_id) q
		where s.id_impresa=q.id_impresa_old;
		--where s.id_impresa=q.id_impresa;
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'stabilimenti per piva	righe modificate %',total_rows;
 
 
 
		update cu_anag.stabilimento_figure s set id_soggetto =q.id_impresa_new
				from
			(select i.id id_impresa_old, n.id_impresa id_impresa_new
				from cu_anag.imprese i
				join tmp.accorpa_imprese_per_piva n on n.piva=i.piva and i.id != n.id_impresa
				where i.piva is not null) q
		where s.id_soggetto=q.id_impresa_old;
		--where s.id_impresa=q.id_impresa;
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'stabilimenti_figure per piva	righe modificate %',total_rows;
 	
		update cu_anag.impresa_figure s set id_soggetto =q.id_impresa_new
				from
			(select i.id id_impresa_old, n.id_impresa id_impresa_new
				from cu_anag.imprese i
				join tmp.accorpa_imprese_per_piva n on n.piva=i.piva and i.id != n.id_impresa
				where i.piva is not null) q
		where s.id_soggetto=q.id_impresa_old;
		--where s.id_impresa=q.id_impresa;
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'stabilimenti_figure per piva	righe modificate %',total_rows; 	
 	
 	
 	
		update cu_anag.imprese set validita =tsrange(lower(validita),'2999-01-01','[)')
		where (cf) in (select cf from tmp.accorpa_imprese_per_cf) and 
			  (id) not in (select id_impresa from tmp.accorpa_imprese_per_cf) and
			  (piva is null or trim(piva) ='') and
			   upper(validita) is null and (piva is not null);
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'Imprese per piva righe modificate %',total_rows;
		
		update cu_anag.stabilimenti s set id_impresa =q.id_impresa_new
		from
			(select i.id id_impresa_old, n.id_impresa id_impresa_new
				from cu_anag.imprese i
				join tmp.accorpa_imprese_per_cf n on n.cf=i.cf and i.id != n.id_impresa
				where i.cf is not null and
					upper(validita) is null and (piva is not null)
				) q
		where s.id_impresa=q.id_impresa_old;
		--where s.id_impresa=q.id_impresa;
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'stabilimenti per piva	righe modificate %',total_rows;
 	
		update cu_anag.stabilimento_figure s set id_soggetto =q.id_impresa_new
				from
			(select i.id id_impresa_old, n.id_impresa id_impresa_new
				from cu_anag.imprese i
				join tmp.accorpa_imprese_per_cf n on n.cf=i.cf and i.id != n.id_impresa
				where i.cf is not null and
					upper(validita) is null and (piva is not null)
				) q
		where s.id_soggetto=q.id_impresa_old;
		--where s.id_impresa=q.id_impresa;
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'stabilimenti_figure per piva	righe modificate %',total_rows;
 	
 		update cu_anag.impresa_figure s set id_soggetto =q.id_impresa_new
				from
			(select i.id id_impresa_old, n.id_impresa id_impresa_new
				from cu_anag.imprese i
				join tmp.accorpa_imprese_per_cf n on n.cf=i.cf and i.id != n.id_impresa
				where i.cf is not null) q
		where s.id_soggetto=q.id_impresa_old;
		--where s.id_impresa=q.id_impresa;
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'stabilimenti_figure per piva	righe modificate %',total_rows; 	
 	
 	
		insert into cu_anag.impresa_sedi
		select id,	id_impresa,	1,	id_indirizzo,	pec,	email,	old_id,	fonte, validita 
		from cu_anag.vw_stabilimento_sedi ss where  cod_tipo_sede ilike 'SL' and 
		ss.id_impresa in 
		(select id_impresa from  cu_anag.vw_stabilimento_sedi
		where cod_tipo_sede ilike 'SL'  and
		id_impresa not in (select id_impresa from cu_anag.vw_impresa_sedi where cod_tipo_sede ilike 'SL')
		group by 1
		having count(*) = 1) ;
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	righe inserite %',total_rows;
 	
		delete from cu_anag.stabilimento_sedi where id in (select id from cu_anag.impresa_sedi);
	 	GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice 'cu_anag.impresa_sedi	righe eliminate %',total_rows;		
 	
		insert into cu_anag.impresa_figure
		select		id,	id_impresa,	id_tipo_figura,	id_indirizzo, old_id,	fonte, descr, validita , id_soggetto
		from cu_anag.vw_stabilimento_figure ss where  cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE' and 
		ss.id_impresa in 
		(select id_impresa from  cu_anag.vw_stabilimento_figure
		where cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE%'  and
		id_impresa not in (select id_impresa from cu_anag.vw_impresa_figure where cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE')
		group by 1
		having count(*) = 1) ;
 		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	cu_anag.impresa_figure righe inserite %',total_rows;
		delete  from cu_anag.stabilimento_figure where id in (select id from cu_anag.impresa_figure);
		GET DIAGNOSTICS total_rows := ROW_COUNT;
 		raise notice '	cu_anag.impresa_figure	 righe eliminate %',total_rows;
 		ret.esito=true;
 		return ret;
	END;
	END;
$$;


ALTER FUNCTION cu_anag.upd_accorpa_imprese() OWNER TO postgres;

--
-- Name: upd_allinea_stabilimenti_bdn(character varying, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_allinea_stabilimenti_bdn(cod_az_zootecnica character varying, id_transazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer;
	n integer;
	begin
		
		/*SELECT sd_id ,id_fiscale_prop,i.cf,i.piva ,a.cf,a.piva
		FROM cu_anag.imprese i
		INNER JOIN (
		SELECT * FROM   dblink('bdn_fvg','select id_azienda,
		case when length(id_fiscale_prop) =16 then id_fiscale_prop else null end cf,
		case when length(id_fiscale_prop)!=16 then id_fiscale_prop else null end piva,min(id_azienda::bigint) id_azienda
		from bdn.vw_aziende  
        --WHERE cod_azienda =''041PN133''
		WHERE cod_azienda ='+ cod_az_zootecnica + '
         group by 1,2,3')
		T(id_fiscale_prop varchar,cf varchar,piva varchar,id_azienda bigint)
		) a on  sd_id= (-a.id_azienda)*10-1
		WHERE FONTE='BDN_PROP_AZ'
		AND sd_id= (-a.id_azienda)*10-1
		and id_fiscale_prop =a.id_fiscale_prop
		and ( i.cf=a.cf or  i.piva =a.piva);*/
		 
 		return ret;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.upd_allinea_stabilimenti_bdn(cod_az_zootecnica character varying, id_transazione bigint) OWNER TO postgres;

--
-- Name: upd_allinea_stabilimenti_bdn2(character varying); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_allinea_stabilimenti_bdn2(cod_az_zootecnica character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer; 
    num_BDN_PROP_AZ integer;
    num_BDN_PROP_ALL integer;
    num_BDN_DET_ALL integer;
    num_BDN_IND_AZ integer;
	n integer;
	begin
		
		--raise notice 'BDN 1 - BDN_PROP_AZ Proprietario Azienda zootecnica';

		select   COUNT(*) into num_BDN_PROP_AZ
		FROM cu_anag.imprese i
		INNER JOIN (
		SELECT * FROM   dblink('bdn_fvg','select id_azienda,
		case when length(id_fiscale_prop) =16 then id_fiscale_prop else null end cf,
		case when length(id_fiscale_prop)!=16 then id_fiscale_prop else null end piva,min(id_azienda::bigint) id_azienda
		from bdn.vw_aziende  
        WHERE cod_azienda::text ='+cod_az_zootecnica+'
         group by 1,2,3')
		T(id_fiscale_prop varchar,cf varchar,piva varchar,id_azienda bigint)
		) a on  sd_id= (-a.id_azienda)*10-1
		WHERE FONTE='BDN_PROP_AZ'
		AND sd_id= (-a.id_azienda)*10-1
		and id_fiscale_prop =a.id_fiscale_prop
		and ( i.cf=a.cf or  i.piva =a.piva);
		  
	
	  --	raise notice '%cod_az_zootecnica ',  	 cod_az_zootecnica;
	  --  raise notice '%total_rows num_BDN_PROP_AZ ',  	 num_BDN_PROP_AZ;
	    if (num_BDN_PROP_AZ = 0) then
		   	raise notice '%', 'eseguire insert';	
		
		   /*	insert into cu_anag.imprese
			select nextval('cu_anag.cu_anag_id_seq') ,
			id_fiscale_prop,cf,piva,
			null,null,null,
			null,null,null,
			null,null,(-id_azienda)*10-1,true,
			'BDN_PROP_AZ'
			from dblink('bdn_fvg','select id_fiscale_prop,
			case when length(id_fiscale_prop) =16 then id_fiscale_prop else null end cf,
			case when length(id_fiscale_prop)!=16 then id_fiscale_prop else null end piva,min(id_azienda::bigint) id_azienda
			from bdn.vw_aziende
			WHERE cod_azienda::text =''041PN133''
			 group by 1,2,3')
			T(id_fiscale_prop varchar,cf varchar,piva varchar,id_azienda bigint);	*/
		else  
		--  	raise notice '%','amdare avanti con i check';	
	   end if;
	  
	 --  raise notice 'BDN 2 - BDN_PROP_ALL Proprietario Allevamento';
	  
 
	  	select count(*) into num_BDN_PROP_ALL
		FROM cu_anag.imprese i
		right JOIN (		
		SELECT *    
		from dblink('bdn_fvg','select 
		case when length(trim(cf_proprietario))<16 then null								 else cf_proprietario end cf,
		case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else null end piva,
		min(id_allevamento::bigint) id_allevamento
		from bdn.vw_allevamenti
       -- where account_number::text=''041PN133''
        group by 1,2')
		T(cf varchar,piva varchar,id_allevamento bigint)
		)a
		on sd_id= ((-a.id_allevamento)*10)-2 
		WHERE 
		FONTE='BDN_PROP_ALL'
		and sd_id is null;
	 		 
	 
	 --   raise notice 'BDN_PROP_ALL ',  	 num_BDN_PROP_ALL;
	   
   	    if (num_BDN_PROP_ALL > 1) then
	  -- 	raise notice '%', 'eseguire insert';	
		/*insert into cu_anag.imprese
			select nextval('cu_anag.cu_anag_id_seq') ,
			case when a.cf is null then a.piva else a.cf end name,a.cf,a.piva,
			null,null,null,
			null,case when length(a.cf)=16 then 'P' else 'S' end
			,null,
			null,null,(-id_allevamento*10)-2,true,
			'BDN_PROP_ALL'
			FROM cu_anag.imprese i
			right JOIN (		
				SELECT *    
				from dblink('bdn_fvg','select 
				case when length(trim(cf_proprietario))<16 then null								 else cf_proprietario end cf,
			    case when length(trim(cf_proprietario))<16 then lpad(trim(cf_proprietario),11,''0'') else null end piva,
				min(id_allevamento::bigint) id_allevamento
				from bdn.vw_allevamenti
      		  -- where account_number::text=''041PN133''
       			 group by 1,2')
			   T(cf varchar,piva varchar,id_allevamento bigint)
		  	)a
		  on sd_id= ((-a.id_allevamento)*10)-2 
		  WHERE 
		  FONTE='BDN_PROP_ALL'
		  and sd_id is null*/
	
	   else  
		--  	raise notice '%','amdare avanti con i check';	
	   end if;
	   
	  
	 --  raise notice 'BDN 3 - BDN_DET_ALL Detentore Allevamento';  
 	 	select count(*) into num_BDN_DET_ALL
		FROM cu_anag.imprese i
		right JOIN (		
		SELECT *    
		from dblink('bdn_fvg','select 
		case when length(cf_detentore) =16 then cf_detentore else null end cf,
		case when length(cf_detentore) !=16 then cf_detentore else null end piva,min(id_allevamento::bigint) id_azienda
		from bdn.vw_allevamenti
 	 -- where account_number::text=''041PN133''
	    group by 1,2')
		T(cf varchar,piva varchar,id_allevamento bigint)
		)a
		on sd_id= ((-a.id_allevamento)*10)-3 
		WHERE 
		FONTE='BDN_DET_ALL'
		and sd_id is null;

	    if (num_BDN_DET_ALL > 1) then 
	   
	   /* insert into cu_anag.imprese
			select nextval('cu_anag.cu_anag_id_seq') ,
			case when cf is null then piva else cf end name,cf,piva,
			null,null,null,
			null,null,null,
			null,null,(-id_allevamento)*10-3,true,
			'BDN_DET_ALL'
			FROM cu_anag.imprese i
			right JOIN (		
				SELECT *    
				from dblink('bdn_fvg','select 
				case when length(cf_detentore) =16 then cf_detentore else null end cf,
				case when length(cf_detentore) !=16 then cf_detentore else null end piva,min(id_allevamento::bigint) id_azienda
				from bdn.vw_allevamenti 
                 -- where account_number::text=''041PN133''
                group by 1,2')
				T(cf varchar,piva varchar,id_allevamento bigint)
		  	)a
		  on sd_id= ((-a.id_allevamento)*10)-3 
		  WHERE 
		  FONTE='BDN_DET_ALL'
		  and sd_id is null;
		
	*/

	  else  
		 -- 	raise notice '%','amdare avanti con i check';	
	  end if;
	 
	 
	 raise notice 'BDN 4 - BDN_IND_AZ Indirizzo Azienda Zootecnica';
	 
	 SELECT COUNT(*) FROM cu_anag.indirizzi  into num_BDN_IND_AZ
	 WHERE id IN (
	 select T.id
			from dblink('bdn_fvg','select -id*10-6 id
			from bdn.vw_aziende
            WHERE COD_AZIENDA =''041PN133'' '
        )
	 )
	 AND FONTE ='BDN_IND_AZ' ;

	 
	 if ( num_BDN_IND_AZ = 0 ) then
     -- eseguire inser	
   		insert into cu_anag.indirizzi
			select T.id,null,indirizzo_azienda,cap_azienda,null,null,c.codistat,null,null,null,
				latitudine,longitudine,true,'BDN_IND_AZ'
				from dblink('bdn_fvg','select -id*10-6 id,indirizzo_azienda,cap_azienda,cod_comune_azienda,
				case when prov_sede_azienda is null then substring(cod_azienda,4,2) else prov_sede_azienda end prov_sede_azienda, 
			latitudine,longitudine
			from bdn.vw_aziende
    		 WHERE COD_AZIENDA =''041PN133'' ')
		  T(id int8,indirizzo_azienda varchar,cap_azienda varchar,cod_comune_azienda varchar,prov_sede_azienda varchar ,latitudine float8,longitudine float8) 
		 left join conf_ext.vw_comuni_vigenti_attivi c on right(lpad(c.codistat::varchar,6,'0'),3)=T.cod_comune_azienda and c.siglaprovincia=prov_sede_azienda;
  	else 
      -- eseguire update
		UPDATE cu_anag.indirizzi cuind_table
		SET  indirizzo=bdntable.indirizzo_azienda,
		     cap=bdntable.cap_azienda,      
		     istat_comune=bdntable.codistat, 
		     latitudine=bdntable.latitudine, 
		     longitudine=bdntable.longitudine
		FROM (
				select T.id,indirizzo_azienda,cap_azienda, c.codistat, latitudine,longitudine 
				from dblink('bdn_fvg','select -id*10-6 id,indirizzo_azienda,cap_azienda,cod_comune_azienda,	latitudine,longitudine
					from bdn.vw_aziende
		    		WHERE COD_AZIENDA =''041PN133'' ')
				  T(id int8,indirizzo_azienda varchar,cap_azienda varchar,cod_comune_azienda varchar, latitudine float8,longitudine float8) 
		    
		) AS bdntable
		WHERE 
		    bdntable.ID = cuind_table.ID;
	  end if;	   
		
 	return presenza;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.upd_allinea_stabilimenti_bdn2(cod_az_zootecnica character varying) OWNER TO postgres;

--
-- Name: upd_allinea_stabilimenti_bdn3(character varying); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_allinea_stabilimenti_bdn3(cod_az_zootecnica character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
	begin
	declare 
	ret cu_types.result_type; 
	total_rows integer; 
    num_BDN_PROP_AZ integer;
    num_BDN_PROP_ALL integer;
    num_BDN_DET_ALL integer;
    num_BDN_IND_AZ integer;
	n integer;
	begin
		
		
		
 	return presenza;
	end;
	END;
$$;


ALTER FUNCTION cu_anag.upd_allinea_stabilimenti_bdn3(cod_az_zootecnica character varying) OWNER TO postgres;

--
-- Name: upd_automezzo(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_automezzo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_marca varchar;
		v_modello varchar;
		v_targa varchar;
		v_id_automezzo bigint;
		n integer;
		R_A cu_anag.automezzi;
	
		v_j json;
		begin 
			proc_name:='cu_anag.upd_automezzo';
			v_j:=v::json;
			v_marca:=cu_anag.string_normalize_upper(v_j->>'marca');
			v_modello:=cu_anag.string_normalize_upper(v_j->>'modello');
			v_targa:=cu_anag.string_normalize_upper(v_j->>'targa');
			v_id_automezzo:=v_j->'id_automezzo';
			
		
			update cu_anag.automezzi 
			set marca = v_marca,
				modello = v_modello,
				targa = v_targa
			where id = v_id_automezzo
			returning * into R_A;
			n:=cu_log.upd_record('cu_anag.upd_automezzo',idtransazione,R_A,'I');
			
			
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		end;
		

	END;
$$;


ALTER FUNCTION cu_anag.upd_automezzo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_impresa(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_add_impresa(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_nome varchar;
		v_az_cod_regionale varchar;
		v_piva varchar;
		v_pec varchar;
		v_email varchar;
		v_sdi varchar;
		v_split_payement varchar;
		v_cf varchar;
	    v_fonte varchar;
		v_az_cod_aziendale varchar;
		v_cod_tipo_impresa varchar;
		v_data_inizio_validita timestamp;
		v_id_asl integer;
		idimpresa bigint;
		v_tiposoggetto varchar;
		R_IMP cu_anag.imprese;
		n integer;
	
		v_j json;
		begin 
			proc_name:='cu_anag.upd_cu_add_impresa';
			v_j:=v::json;
			--v_az_cod_regionale:=v_j->>'az_cod_regionale';
			v_piva:=cu_anag.string_normalize(v_j->>'piva');
			v_pec:=cu_anag.string_normalize(v_j->>'pec');
			v_email:=cu_anag.string_normalize(v_j->>'email');
			v_nome:=cu_anag.string_normalize(v_j->>'nome');
			v_sdi:=cu_anag.string_normalize(v_j->>'sdi');
			v_split_payement:=cu_anag.string_normalize(v_j->>'split_payement');
			v_cf:=cu_anag.string_normalize(v_j->>'cf');
			--v_az_cod_aziendale:=v_j->>'az_cod_aziendale';
			v_cod_tipo_impresa:=cu_anag.string_normalize(v_j->>'cod_tipo_impresa');
			v_data_inizio_validita:=cu_anag.string_normalize(v_j->>'data_inizio_validita');
			--v_id_asl:=cu_anag.string_normalize(v_j->>'id_asl');
			v_fonte:=cu_anag.string_normalize(v_j->>'fonte');
		
			ret:=cu_anag.check_impresa(v,idtransazione);
			if not ret.esito then
				return ret;
			end if;
			if v_split_payement is null or upper(v_split_payement) != 'S' then
				v_split_payement := 'N';
			else
				v_split_payement := 'S';
			end if;
			
			if(v_fonte is null or v_fonte ='') then 
				v_fonte:='GISA-FVG';
			end if;
		
			if v_cod_tipo_impresa is null or v_cod_tipo_impresa = '' then
				if length(v_cf)=16 and (v_piva is null or v_piva ='') then
					v_tiposoggetto:='F';
				else
					v_tiposoggetto:='G';
				end if;
			else
				if v_cod_tipo_impresa = 'P' then
					v_tiposoggetto:='F';
				else
					v_tiposoggetto:='G';
				end if;
			end if;
		
			insert into cu_anag.imprese (
				id,nome,piva,pec,email,sdi,split_payement,
					cf,cod_tipo_impresa,validita,verificato,fonte,tipo_soggetto) 
				values (nextval('cu_anag.cu_anag_id_seq'),v_nome,v_piva,v_pec,v_email,v_sdi,v_split_payement,
				v_cf,v_cod_tipo_impresa,(tsrange(v_data_inizio_validita,null,'[)')),false,v_fonte,v_tiposoggetto)
			returning * into R_IMP;
			idimpresa:=R_IMP.id;
			n:=cu_log.upd_record('cu_anag.imprese',idtransazione,R_IMP,'I');
			
			
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info=idimpresa;
			return ret;
		end;
		

	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_add_impresa(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_imprese_figure(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_add_imprese_figure(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		R_IF cu_anag.impresa_figure;
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_id_impresa bigint;
		v_tipo_figura bigint;
		v_cf varchar;
		n integer;
		idindirizzo bigint;
		idsoggettofisico bigint;
		v_data_inizio_validita timestamp;
		R_IMP cu_anag.imprese;
		R_SF cu_anag.soggetti_fisici;
		R_SOGG cu_anag.imprese;
		R_IND cu_anag.indirizzi;
		--R_IF cu_anag.impresa_figure;
		v_j json;
		v_validita tsrange;
		R_TF cu_types.vw_tipi_figura_impresa;
		ns integer;
		v_id bigint;
		jarg json;
		v_stab_verificato cu_types.result_type;
		R_STAB cu_anag.stabilimenti;
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		v_fonte varchar;
		v_parix bool := false;
		istatcomune varchar;
		begin 
			proc_name:='cu_anag.upd_cu_add_imprese_figure';
			v_j:=v::json;
			v_id_impresa:=v_j->'id_impresa';
			v_tipo_figura:=v_j->'figura';
			v_cf:=v_j->>'cf';
			v_cf:=trim(upper(v_cf));
			v_data_inizio_validita:=v_j->>'data_inizio_validita';

			--flag per "modifica" figura via parix
			v_parix:= v_j->>'parix';
		
		
		
			if v_fonte is null or v_fonte = '' then
				v_fonte:= 'GISA-FVG';
			end if;
		
			raise notice 'v=%', v_j;

			select * into R_IMP from cu_anag.imprese where id=v_id_impresa;
			if v_data_inizio_validita is null then
				v_data_inizio_validita:= lower(R_IMP.validita);
			end if;
			if (not upper_inf(R_IMP.validita)) and v_data_inizio_validita > upper(R_IMP.validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_supera_validita_impresa');
				ret.info='0';
				return ret;
			end if;

			v_validita:=tsrange(v_data_inizio_validita,upper(R_IMP.validita),'[)');
			raise notice 'v_validita=%', v_validita;
			if not (R_IMP.validita @> v_validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_impresa');
				ret.info='0';
				return ret;
			end if;

			if not v_parix then
				select * into R_IF from cu_anag.impresa_figure
				where id_impresa=v_id_impresa and id_tipo_figura =v_tipo_figura  and validita && v_validita
					limit 1;
				raise notice 'R_IF %',R_IF;
				if R_IF.id is not null then
					ret.esito:=false;	
		    		ret:=cu_ui.build_ret(ret,proc_name,'figura_gia_presente_per_validita');
					ret.info='0';
					return ret;
				end if;
			end if;
	
			select * into R_SF from cu_anag.soggetti_fisici where codice_fiscale=v_cf;
			if R_SF.id is null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'codice_fiscale_non_presente');
				ret.info='0';
				return ret;
			end if;
			select * into R_SOGG from cu_anag.imprese where cf=v_cf;
			if R_SOGG.id is null then
					R_SOGG.id:=nextval('cu_anag.cu_anag_id_seq');
					R_SOGG.cf:=v_cf;
					R_SOGG.verificato:= true;
					R_SOGG.fonte:= 'IMP_FIG';
					R_SOGG.tipo_soggetto:='F';
					R_SOGG.validita=tsrange(null,null,'()');
					insert into cu_anag.imprese values(R_SOGG.*);
			end if;

			--idindirizzo = nextval('cu_anag.cu_anag_id_seq');
			--insert into cu_anag.indirizzi (id) VALUES(idindirizzo) returning * into R_IND;
			--n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'I');
			
			--insert into cu_anag.indirizzi (id,toponimo,indirizzo,comune,civico,cap,nazione,stato_prov,istat_comune,fonte)
			--values (nextval('cu_anag.cu_anag_id_seq'),v_toponimo,v_indirizzo,v_comune,v_civico,v_cap,v_nazione,v_provincia,lpad(trim(istatcomune),6,'0'),v_fonte)
			--returning id into idindirizzo;
			
			
			idindirizzo:=v_j->'id_indirizzo';
		
			if idindirizzo is null then
				ret := cu_anag.upsert_indirizzi(v,idtransazione);
				idindirizzo = ret.info;
			end if;
			raise notice 'v_validita=%', v_validita;

			--cancellare solo da allineamento parix
			if v_parix then
				update cu_anag.impresa_figure
				set validita= tsrange(lower(validita),v_data_inizio_validita + interval '1 day','[)')
				where id in ( select id from cu_anag.impresa_figure where id_impresa=v_id_impresa and id_tipo_figura =v_tipo_figura  and validita && v_validita limit 1);
			end if;

			insert into cu_anag.impresa_figure (id,id_impresa,id_tipo_figura,id_indirizzo,validita,id_soggetto,fonte)
				values (nextval('cu_anag.cu_anag_id_seq'),v_id_impresa,v_tipo_figura,idindirizzo,
						v_validita,R_SOGG.id,'GISA-FVG') returning * into R_IF;
			n:=cu_log.upd_record('cu_anag.impresa_figure',idtransazione,R_IF,'I');
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='{"id_indirizzo":'||idindirizzo||',"id_impresa_figura":'||(R_IF.id)||'}';
			select * into R_TF from cu_types.vw_tipi_figura_impresa where id=R_IF.id_tipo_figura;
			raise notice 'R_TF.sigla %',R_TF.sigla;
			if upper(R_TF.sigla)='LEGALE RAPPRESENTANTE' then 
				raise notice 'R_IMP.verificato %',R_IMP.verificato;
				if (not R_IMP.verificato)  then
					select count(*) into ns from cu_anag.vw_impresa_sedi
						where id_impresa=v_id_impresa and cod_tipo_sede ilike 'SL';
					raise notice 'NS %',ns;
					if ns > 0 then
						update cu_anag.imprese set verificato=true where id=v_id_impresa returning * into R_IMP;
						n:=cu_log.upd_record('cu_anag.imprese',idtransazione,R_IMP,'I');
					end if;
				end if;
				for v_id in select id from cu_anag.stabilimenti where id_impresa=v_id_impresa and not verificato loop
					jarg:='{"id_stabilimento":'||v_id||',"id_impresa":'||v_id_impresa||'}';
					v_stab_verificato:= cu_anag.check_stabilimento_valido(jarg,idtransazione);
					if v_stab_verificato.esito then
						update cu_anag.stabilimenti set verificato=true where id=v_id returning * into R_STAB;
						n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_STAB,'I');
					end if;
				end loop;
			end if;
			return ret;
		end;
		

	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_add_imprese_figure(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_imprese_sedi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_add_imprese_sedi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_id_impresa bigint;
		v_tipo_sede bigint;
		v_piva varchar;
		v_pec varchar;
		v_email varchar;
		v_sdi varchar;
		v_split_payement varchar;
		v_cf varchar;
		v_cod_tipo_impresa varchar;
		v_j json;
		idindirizzo bigint;
		idimpresa bigint;
		v_data_inizio_validita timestamp;
		R_IMP cu_anag.imprese;
		R_STAB cu_anag.stabilimenti;
		R_TSI cu_types.vw_tipi_sede_impresa;
		R_IND cu_anag.indirizzi;
		R_IS cu_anag.impresa_sedi;
		v_validita tsrange;
		n integer;
		v_id bigint;
		nf integer;
		jarg json;
		v_stab_verificato cu_types.result_type;
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		v_fonte varchar;
		istatcomune varchar;
		begin 
			proc_name:='cu_anag.upd_cu_add_imprese_sedi';
			v_j:=v::json;
			v_id_impresa:=v_j->'id_impresa';
			v_tipo_sede:=v_j->'sede';
			v_piva:=trim(upper(v_j->>'piva'));
			v_pec:=trim(upper(v_j->>'pec'));
			v_email:=trim(upper(v_j->>'email'));
			v_sdi:=trim(upper(v_j->>'sdi'));
			v_split_payement:=trim(upper(v_j->>'split_payement'));
			v_cf:=trim(upper(v_j->>'cf'));
			v_cod_tipo_impresa:=trim(upper(v_j->>'cod_tipo_impresa'));
			v_data_inizio_validita:=v_j->>'data_inizio_validita';
			/*v_indirizzo:=cu_anag.string_normalize(v_j->>'indirizzo');
			v_indirizzo:=cu_anag.string_normalize(v_indirizzo);
			v_civico:=cu_anag.string_normalize(v_j->>'civico');
			v_indirizzo:= cu_anag.string_normalize(v_indirizzo);
			v_comune:=cu_anag.string_normalize_upper(v_j->>'comune');

			v_toponimo:=cu_anag.string_normalize_upper(v_j->>'toponimo');

			v_cap:=cu_anag.string_normalize_upper(v_j->>'cap');

			v_nazione:=cu_anag.string_normalize_upper(v_j->>'nazione');

			v_provincia:=cu_anag.string_normalize_upper(v_j->>'stato_provincia');

			istatcomune:=cu_anag.string_normalize_upper(v_j->>'istat_comune'); */
			
			raise notice 'v=%', v_j;

			if v_fonte is null or v_fonte = '' then
				v_fonte:= 'GISA-FVG';
			end if;
			--raise notice 'idindirizzo=%',idindirizzo;
			select * into R_IMP from cu_anag.imprese where id=v_id_impresa;
			if v_data_inizio_validita is null then
				v_data_inizio_validita:= lower(R_IMP.validita);
			end if;
			if (not upper_inf(R_IMP.validita)) and v_data_inizio_validita > upper(R_IMP.validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_supera_validita_impresa');
				ret.info='0';
				return ret;
			end if;
			
			v_validita:=tsrange(v_data_inizio_validita,upper(R_IMP.validita),'[)');
			if not (R_IMP.validita @> v_validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_impresa');
				ret.info='0';
				return ret;
			end if;
			v_validita:=tsrange(v_data_inizio_validita,upper(R_IMP.validita),'[)');
			select * into R_IS from cu_anag.impresa_sedi
			where id_impresa=v_id_impresa and id_tipo_sede =v_tipo_sede  and validita && v_validita
				limit 1;
			if R_IS.id is not null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'sede_gia_presente_per_validita');
				ret.info='0';
				return ret;
			end if;
			select * into R_TSI from cu_types.vw_tipi_sede_impresa where id=v_tipo_sede;
			if R_TSI.id is null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'tipo_sede_impresa_non_valida');
				ret.info='0';
				return ret;
			end if;
				
			--idindirizzo = nextval('cu_anag.cu_anag_id_seq');
			--insert into cu_anag.indirizzi (id) VALUES(idindirizzo) returning * into R_IND;	
			--n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'I');
		
			--insert into cu_anag.indirizzi (id,toponimo,indirizzo,comune,civico,cap,nazione,stato_prov,istat_comune,fonte)
			--values (nextval('cu_anag.cu_anag_id_seq'),v_toponimo,v_indirizzo,v_comune,v_civico,v_cap,v_nazione,v_provincia,lpad(trim(istatcomune),6,'0'),v_fonte)
			--returning id into idindirizzo;
			
			ret := cu_anag.upsert_indirizzi(v,idtransazione);
			idindirizzo = ret.info;
		
			insert into cu_anag.impresa_sedi          (id,id_impresa, id_tipo_sede,pec,  email,  id_indirizzo,validita,fonte) 
				values (nextval('cu_anag.cu_anag_id_seq'),v_id_impresa,v_tipo_sede,v_pec,v_email,idindirizzo, v_validita,'GISA-FVG')
				returning * into R_IS;
			n:=cu_log.upd_record('cu_anag.impresa_sedi',idtransazione,R_IS,'I');
		
		
					
			if  upper(R_TSI.sigla)='SL' then 
				if (not R_IMP.verificato) then 
					select count(*) into nf from cu_anag.vw_impresa_figure
						where id_impresa=v_id_impresa and cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE';
					if nf > 0 then
						update cu_anag.imprese set verificato=true where id=v_id_impresa returning * into R_IMP;
						n:=cu_log.upd_record('cu_anag.imprese',idtransazione,R_IS,'I');
					end if;
				end if;
	
				for v_id in select id from cu_anag.stabilimenti where id_impresa=v_id_impresa and not verificato loop
					jarg:='{"id_stabilimento":'||v_id||',"id_impresa":'||v_id_impresa||'}';
					v_stab_verificato:= cu_anag.check_stabilimento_valido(jarg,idtransazione);
					if v_stab_verificato.esito then
						update cu_anag.stabilimenti set verificato=true where id=v_id returning * into R_STAB;
						n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_STAB,'I');
					end if;
				end loop;
				
			end if;
			/*idimpresa = (select vs.id_impresa 
			from cu_anag.vw_imprese vs 
			where vs.id_impresa = v_id_impresa);
		
			raise notice 'idimpresa %',idimpresa;
			
			update cu_anag.imprese 
			set cod_tipo_impresa = v_cod_tipo_impresa
			where id = idimpresa;*/
			
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='{"id_indirizzo":'||idindirizzo||',"id_impresa_sede":'||(R_IS.id)||'}';
			return ret;
		end;
		

	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_add_imprese_sedi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_indirizzi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_add_indirizzi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type; -- start
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		v_fonte varchar;
		istatcomune varchar;
		proc_name varchar; -- end
		v_j json;
	    _id_ind bigint; 
	
		v_latitudine varchar;
		v_longitudine varchar;
		R_IND cu_anag.indirizzi;
		n integer;
		begin
			proc_name:='cu_anag.upd_cu_add_indirizzi';
			v_j:=v::json;
			v_id_indirizzo:=v_j->'id_indirizzo';
			v_indirizzo:=cu_anag.string_normalize(v_j->>'indirizzo');
			v_civico:=cu_anag.string_normalize(v_j->>'civico');
			v_comune:=cu_anag.string_normalize(v_j->>'comune');
			v_toponimo:=cu_anag.string_normalize(v_j->>'toponimo');
			v_cap:=cu_anag.string_normalize(v_j->>'cap');
			v_nazione:=cu_anag.string_normalize(v_j->>'nazione');
			v_provincia:=cu_anag.string_normalize(v_j->>'stato_provincia');
			istatcomune:=cu_anag.string_normalize(v_j->>'istat_comune');
		
			v_fonte:=cu_anag.string_normalize(v_j->>'fonte');
			v_latitudine:=cu_anag.string_normalize(v_j->>'longitudine');
			v_longitudine:=cu_anag.string_normalize(v_j->>'latitudine');
		
			 raise  info 'v_latitudine'; 
			 raise notice 'v_latitudine% ',v_latitudine; 
			
			 raise notice 'v_longitudine% ',v_longitudine; 
			if v_fonte is null or v_fonte ='' then
				v_fonte:= 'GISA-FVG';
			end if;
		
			if (istatcomune is null or istatcomune='') and (v_nazione is null or v_nazione='') then
					insert into cu_anag.indirizzi 
						  (id,  fonte )
					values(nextval('cu_anag.cu_anag_id_seq'),v_fonte) returning * into R_IND;
					ret.esito=true;
					return ret;	
			end if;
			--	  select* from cu_anag.upd_cu_add_indirizzi
			if v_cap is null or v_cap = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'cap_obbligatorio');
					return ret;
			end if;
			if v_indirizzo is null or v_indirizzo = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_obbligatorio');
					return ret;
			end if;
		
			if istatcomune is null or istatcomune='' then
				if v_nazione is null or v_nazione = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_nazione');
					return ret;
				end if;
				if v_comune is null or v_comune = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_comune');
					return ret;
				end if;
			  
				insert into cu_anag.indirizzi 
						  (id,                                 indirizzo,  comune,  toponimo,  civico,  cap,  nazione,  stato_prov,istat_comune,latitudine,  longitudine,  fonte )
					values(nextval('cu_anag.cu_anag_id_seq'),v_indirizzo,v_comune,v_toponimo,v_civico,v_cap,v_nazione,v_provincia,null       ,v_latitudine,v_longitudine,v_fonte) returning * into R_IND;
			else
				select count(*) into n from conf_ext.vw_comuni_vigenti_attivi c
					where c.codice_istat = istatcomune;
				if n > 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_non_valido');
					return ret;
				end if;	
				if n < 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_inesistente');
					return ret;
				end if;	
			 	
				insert into cu_anag.indirizzi
						  (id,                               indirizzo,  comune,toponimo  ,civico  ,cap,  nazione,stato_prov,istat_comune,latitudine,   longitudine,  fonte)
					values(nextval('cu_anag.cu_anag_id_seq'),v_indirizzo,null  ,v_toponimo,v_civico,v_cap,null   ,null      ,istatcomune ,v_latitudine ,v_longitudine,v_fonte) returning * into R_IND;

			end if;
			n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'I');
			_id_ind:= R_IND.id;
		    raise notice 'indirizzo id% ',_id_ind;
		   
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    	ret.info = '{"indirizzo_id" :'||_id_ind || '}';
 			return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_add_indirizzi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_linea_stabilimenti(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_add_linea_stabilimenti(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_id_stabilimento bigint;
	v_data_inizio_validita timestamp;
	v_data_ultima_visita timestamp;
	v_id_tipo_linea bigint;
	v_linea_principale boolean;
	v_j json;
	R_STAB cu_anag.stabilimenti;
	R_SL cu_anag.linee;
	v_validita tsrange;
	n integer;
	begin
		proc_name:='cu_anag.get_cu_linee_stabilimenti';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		v_j:=v::json;
		v_id_stabilimento = v->'id_stabilimento';
		v_data_inizio_validita:=v_j->>'data_inizio_validita';
		--v_data_ultima_visita:=v_j->>'data_ultima_visita';
		v_id_tipo_linea:=v_j->>'id_tipo_linea';
		v_linea_principale:=v_j->>'linea_principale';
		if v_linea_principale is null then
			v_linea_principale:=false;
		end if;
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		--raise notice 'data_ultima_visita%',v_data_ultima_visita;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
	
		select * into R_STAB from cu_anag.stabilimenti where id=v_id_stabilimento;
		v_validita:=tsrange(v_data_inizio_validita,upper(R_STAB.validita),'[)');
		if not (R_STAB.validita @> v_validita) then
			ret.esito:=false;	
    		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_stabilimento');
			ret.info='0';
			return ret;
		end if;
		select * into R_SL from cu_anag.linee
		where id_stabilimento=v_id_stabilimento and id_tipo_linea =v_id_tipo_linea  and validita && v_validita
		order by linea_principale desc
			limit 1;
		
		if not R_SL.linea_principale then
			v_linea_principale:= true;
		end if;
		if R_SL.id is not null then
			ret.esito:=false;	
    		ret:=cu_ui.build_ret(ret,proc_name,'linea_gia_presente_per_validita');
			ret.info='0';
			return ret;
		end if;
	
	
	
	
		insert into cu_anag.linee (id, id_stabilimento, data_ultima_visita,validita, linea_principale,id_tipo_linea) 
			values (nextval('cu_anag.cu_anag_id_seq'),v_id_stabilimento, null, v_validita,v_linea_principale,v_id_tipo_linea)
				returning * into R_SL;
		n:=cu_log.upd_record('cu_anag.linee',idtransazione,R_SL,'I');
		
		ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
	 	return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_add_linea_stabilimenti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_pratica(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_add_pratica(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- start
        proc_name varchar; -- end
        R_S cu_anag.vw_stabilimenti_all%ROWTYPE;
		R_P cu_anag.pratiche;
		idstab int;
		r record;
		n bigint;

	begin
		proc_name:='cu_anag.upd_cu_add_pratica';
		raise notice 'V_J=%', v_j;
		ret.esito:=false;
	
	
		if v_j->>'id_stabilimento' is not null then
			select * into R_S from cu_anag.vw_stabilimenti_all where id_stabilimento= (v_j->>'id_stabilimento')::int;
			if R_S.id is null then
				ret:=cu_ui.build_ret(ret,proc_name,'stabilimento_non_trovato');
				return ret;
			end if;
		end if;

		R_P.n_pratica:= v_j->>'n_pratica';
		
		select count(*) into n from cu_anag.pratiche p where p.n_pratica = R_P.n_pratica;
		if n > 0 then
			ret:=cu_ui.build_ret(ret,proc_name,'n_pratica_gia_presente');
			return ret;
		end if;
	
		R_P.id:= nextval('cu_anag.pratiche_id_seq');
		R_P.id_tipo_pratica:= v_j->>'id_tipo_pratica';
		R_P.dt:= v_j->>'data_pratica';
		R_P.id_stabilimento:= (v_j->>'id_stabilimento')::int;
		R_P.stato= (select id from cu_types.vw_stati_pratiche where descr = 'Creato');
		R_P.dt_autorizzazione:= v_j->>'data_autorizzazione';
	
		insert into cu_anag.pratiche values(R_P.*) returning id into R_P.id;
		n:=cu_log.upd_record('cu_anag.pratiche',idtransazione,R_P,'I');
	
		insert into cu_anag.storico_pratiche (id_pratica, id_stato_pratica,dt, user_id) 
		values(R_P.id, R_P.stato, (select current_timestamp),(v_j->>'id_utente')::int) returning * into r; 
		n:=cu_log.upd_record('cu_anag.storico_pratiche',idtransazione,r,'I');
	
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '{"id_pratica":'||R_P.id||'}';
	   
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu_anag.upd_cu_add_pratica(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_soggetti_fisici(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_add_soggetti_fisici(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		ret_cf cu_types.result_type; -- start
		n integer;
		v_id_soggetto_fisico bigint;
		v_titolo varchar;
		v_nome varchar;
		v_cognome varchar;
		v_comune_nascita varchar;
		v_pec varchar;
		v_email varchar;
		v_cf varchar;
		v_sesso varchar;
		v_telefono varchar;
		v_telefono2 varchar;
		v_data_nascita timestamp;
		v_documento_identita varchar;
		cn varchar;
		v_j json;
		j_cf json;
		s varchar;
	    idindirizzo bigint;
		proc_name varchar; -- end
		R_SF cu_anag.soggetti_fisici;
		R_IND cu_anag.indirizzi;
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		v_fonte varchar;
		istatcomune varchar;
		begin 
			proc_name:='cu_anag.upd_cu_soggetti_fisici';
			v_j:=v::json;
			--v_id_soggetto_fisico:=v_j->'id_soggetto_fisico';
			--v_titolo:=cu_anag.string_normalize_upper(v_j->>'titolo');
			v_cognome:=cu_anag.string_normalize_upper(v_j->>'cognome');
			v_pec:=cu_anag.string_normalize(v_j->>'pec');
			v_email:=cu_anag.string_normalize(v_j->>'email');
			v_nome:=cu_anag.string_normalize_upper(v_j->>'nome');
			v_comune_nascita:=cu_anag.string_normalize_upper(v_j->>'comune_nascita');
			v_sesso:=cu_anag.string_normalize_upper(v_j->>'sesso');
			v_cf:=cu_anag.string_normalize_upper(v_j->>'cf');
			v_telefono:=cu_anag.string_normalize(v_j->>'telefono');
			v_telefono2:=cu_anag.string_normalize(v_j->>'telefono2');
			v_data_nascita:=v_j->>'data_nascita';
			v_documento_identita:=cu_anag.string_normalize_upper(v_j->>'documento_identita');
			/*v_indirizzo:=cu_anag.string_normalize(v_j->>'indirizzo');
			v_indirizzo:=cu_anag.string_normalize(v_indirizzo);
			v_civico:=cu_anag.string_normalize(v_j->>'civico');
			v_indirizzo:= cu_anag.string_normalize(v_indirizzo);
			v_comune:=cu_anag.string_normalize_upper(v_j->>'comune');

			v_toponimo:=cu_anag.string_normalize_upper(v_j->>'toponimo');

			v_cap:=cu_anag.string_normalize_upper(v_j->>'cap');

			v_nazione:=cu_anag.string_normalize_upper(v_j->>'nazione');

			v_provincia:=cu_anag.string_normalize_upper(v_j->>'stato_provincia');

			istatcomune:=cu_anag.string_normalize_upper(v_j->>'istat_comune'); */
		
			if v_fonte is null or v_fonte = '' then
				v_fonte:= 'GISA-FVG';
			end if;
			ret_cf:=cu_anag.split_check_cf(v_cf,v_nome,v_cognome,v_data_nascita::date,v_sesso,v_comune_nascita);
			if not ret_cf.esito then
				return ret_cf;
			end if;
		
			/*
			if  not cu_anag.check_cf(v_cf) or v_cf is null then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_non_corretto');
	    		ret.info = null;
	    		return ret;
			end if;

			
			j_cf:=cu_anag.split_cf(v_cf);
			if j_cf is null then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_non_separabile_in_campi');
	    		ret.info = null;
	    		return ret;
			end if;
			if  v_comune_nascita !=(j_cf->>'comune')::varchar then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'codice_catastale_comune_di_nascita_non_congruente_con_codice_fiscale');
	    		ret.info = null;
	    		return ret;
			end if;
           	if  (j_cf->>'sesso')::varchar!= v_sesso then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'sesso_non_congruente_con_codice_fiscale');
	    		ret.info = null;
	    		return ret;
			end if;
		    if  (j_cf->>'nascita')::varchar!= to_char(v_data_nascita,'YYMMDD') then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'data_nascita_non_congruente_con_codice_fiscale');
	    		ret.info = null;
	    		return ret;
			end if;*/
			select count(*) into n from cu_anag.soggetti_fisici where codice_fiscale=v_cf;
			if  n>0 then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_gia_presente');
	    		ret.info = null;
	    		return ret;
			end if;
			select count(*) into n from conf_ext.vw_codici_vigenti_catastali where codcatastale=v_comune_nascita;
			if  n < 1 then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'codice_catastale_non_presente');
	    		ret.info = null;
	    		return ret;
			end if;
		
			raise notice 'v=%',v_j;
		
			--idindirizzo:=nextval('cu_anag.cu_anag_id_seq');
			--insert into cu_anag.indirizzi (id) values (idindirizzo) returning * into R_IND;
			--n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'I');
		
			--insert into cu_anag.indirizzi (id,toponimo,indirizzo,comune,civico,cap,nazione,stato_prov,istat_comune,fonte)
			--values (nextval('cu_anag.cu_anag_id_seq'),v_toponimo,v_indirizzo,v_comune,v_civico,v_cap,v_nazione,v_provincia,lpad(trim(istatcomune),6,'0'),v_fonte)
			--returning id into idindirizzo;
		
			ret := cu_anag.upsert_indirizzi(v,idtransazione);
			idindirizzo = ret.info;
			
			insert into cu_anag.soggetti_fisici
			 (id,indirizzo_id,nome,cognome,pec,email,	comune_nascita,
				sesso,codice_fiscale,telefono,telefono2,data_nascita,documento_identita) values
				
				
				(nextval('cu_anag.cu_anag_id_seq'),idindirizzo,v_nome,v_cognome,v_pec,v_email,
				v_comune_nascita,
				v_sesso,v_cf,v_telefono,v_telefono2,v_data_nascita,	v_documento_identita)
				returning * into R_SF;
			n:=cu_log.upd_record('cu_anag.soggetti_fisici',idtransazione,R_SF,'I');
			
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    	ret.info = '{"id_indirizzo":'||idindirizzo||',"id_soggetto_fisico":'||(R_SF.id)||'}';
 			return ret;
		end;
	end;
$$;


ALTER FUNCTION cu_anag.upd_cu_add_soggetti_fisici(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_soggetti_fisici_from_service(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_add_soggetti_fisici_from_service(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		ret_cf cu_types.result_type; -- start
		n integer;
		v_id_soggetto_fisico bigint;
		v_titolo varchar;
		v_nome varchar;
		v_cognome varchar;
		v_comune_nascita varchar;
		v_pec varchar;
		v_email varchar;
		v_cf varchar;
		v_sesso varchar;
		v_telefono varchar;
		v_telefono2 varchar;
		v_data_nascita timestamp;
		v_documento_identita varchar;
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_codice_catastale varchar;
		v_cap varchar;
		v_fonte varchar;
		cn varchar;
		v_j json;
		v_i json;
		j_cf json;
		s varchar;
	    idindirizzo bigint;
		proc_name varchar; -- end
		R_SF cu_anag.soggetti_fisici;
		R_IND cu_anag.indirizzi;
		begin 
			proc_name:='cu_anag.upd_cu_soggetti_fisici';
			v_j:=v::json;
			v_i:=v_j->'indirizzo';
			--v_id_soggetto_fisico:=v_j->'id_soggetto_fisico';
			v_titolo:=cu_anag.string_normalize_upper(v_j->>'titolo');
			v_cognome:=cu_anag.string_normalize_upper(v_j->>'cognome');
			v_pec:=cu_anag.string_normalize(v_j->>'pec');
			v_email:=cu_anag.string_normalize(v_j->>'email');
			v_nome:=cu_anag.string_normalize_upper(v_j->>'nome');
			v_comune_nascita:=cu_anag.string_normalize_upper(v_j->>'comune_nascita');
			v_sesso:=cu_anag.string_normalize_upper(v_j->>'sesso');
			v_cf:=cu_anag.string_normalize_upper(v_j->>'cf');
			v_telefono:=cu_anag.string_normalize(v_j->>'telefono');
			v_telefono2:=cu_anag.string_normalize(v_j->>'telefono2');
			v_data_nascita:=v_j->>'data_nascita';
			v_documento_identita:=cu_anag.string_normalize_upper(v_j->>'documento_identita');
		
			v_toponimo:=cu_anag.string_normalize_upper(v_i->>'toponimo');
			v_indirizzo:=cu_anag.string_normalize_upper(v_i->>'descrizione');
			v_civico:=v_i->>'civico';
			v_codice_catastale:=cu_anag.string_normalize_upper(v_i->>'codice_catastale');
			v_cap:=v_i->>'cap';
			v_fonte:=v_i->>'fonte';
		
			if v_fonte is null or v_fonte = '' then
				v_fonte:= 'GISA-FVG-ANAG-REG';
			end if;
			if v_titolo = '' then
				v_titolo:= null;
			end if;
		
		
			ret_cf:=cu_anag.split_check_cf(v_cf,v_nome,v_cognome,v_data_nascita::date,v_sesso,v_comune_nascita);
			if not ret_cf.esito then
				return ret_cf;
			end if;
		
			if  not cu_anag.check_cf(v_cf) or v_cf is null then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_non_corretto');
	    		ret.info = null;
	    		return ret;
			end if;
			j_cf:=cu_anag.split_cf(v_cf);
			if j_cf is null then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_non_separabile_in_campi');
	    		ret.info = null;
	    		return ret;
			end if;
			if  v_comune_nascita !=(j_cf->>'comune')::varchar then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'codice_catastale_comune_di_nascita_non_congruente_con_codice_fiscale');
	    		ret.info = null;
	    		return ret;
			end if;
           	if  (j_cf->>'sesso')::varchar!= v_sesso then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'sesso_non_congruente_con_codice_fiscale');
	    		ret.info = null;
	    		return ret;
			end if;
		    if  j_cf->>'data_nascita' != null and (j_cf->'data_nascita')::varchar!= to_char(v_data_nascita,'YYMMDD') then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'data_nascita_non_congruente_con_codice_fiscale');
	    		ret.info = null;
	    		return ret;
			end if;
		
			select count(*) into n from cu_anag.soggetti_fisici where codice_fiscale=v_cf;
			if  n>0 then
				/*
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_gia_presente');
	    		ret.info = null;
	    		return ret;
	    		*/
			
				update cu_anag.soggetti_fisici set
				titolo = v_titolo,
				nome = v_nome,
				cognome = v_cognome,
				pec = v_pec,
				email = v_email,
				comune_nascita = v_comune_nascita,
				sesso = v_sesso,
				telefono = v_telefono,
				telefono2 = v_telefono2,
				data_nascita = v_data_nascita,
				documento_identita = v_documento_identita
				where codice_fiscale = v_cf
				returning * into R_SF;
				n:=cu_log.upd_record('cu_anag.soggetti_fisici',idtransazione,R_SF,'U');
			
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					--comune= v_comune,
					toponimo = v_toponimo,
					civico = v_civico,
					istat_comune = (select codice_istat from conf_ext.vw_comuni_vigenti_attivi where codcatastale = v_codice_catastale),
					cap = v_cap
				where id = (select indirizzo_id from cu_anag.vw_soggetti_fisici where codice_fiscale = v_cf)
				returning * into R_IND;
				n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'U');
			
	    	else
	    		idindirizzo:=nextval('cu_anag.cu_anag_id_seq');
				insert into cu_anag.indirizzi (id, indirizzo, toponimo, civico, istat_comune, cap) 
				values (idindirizzo, v_indirizzo, v_toponimo, v_civico, (select codice_istat from conf_ext.vw_comuni_vigenti_attivi where codcatastale = v_codice_catastale), v_cap);
			
				--(select codice_istat from conf_ext.vw_comuni_vigenti_attivi where codcatastale = codice_catastale) 
			
				insert into cu_anag.soggetti_fisici
			 	(id,indirizzo_id,nome,titolo,cognome,pec,email,	comune_nascita,
				sesso,codice_fiscale,telefono,telefono2,data_nascita,documento_identita,verificato,fonte) values
				(nextval('cu_anag.cu_anag_id_seq'),idindirizzo,v_nome,v_titolo,v_cognome,v_pec,v_email,v_comune_nascita,
				v_sesso,v_cf,v_telefono,v_telefono2,v_data_nascita,	v_documento_identita,true,v_fonte)
				returning * into R_SF;
				n:=cu_log.upd_record('cu_anag.soggetti_fisici',idtransazione,R_SF,'I');
			end if;
		
			raise notice 'v=%',v_j;
		
			
			
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    	ret.info = '{"id_soggetto_fisico" :'|| R_SF.id::varchar || '}';

 			return ret;
		end;
	end;
$$;


ALTER FUNCTION cu_anag.upd_cu_add_soggetti_fisici_from_service(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_stabilimenti_figure(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_add_stabilimenti_figure(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		R_SF cu_anag.stabilimento_figure;
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_id_stabilimento bigint;
		v_tipo_figura bigint;
		--v_nome varchar;
		--v_cognome varchar;
		v_cf varchar;
		n integer;
		--v_toponimo varchar;
		--v_indirizzo varchar;
		--v_civico varchar;
		--v_comune varchar;
		idindirizzo bigint;
		idsoggettofisico bigint;
		v_data_inizio_validita timestamp;
		R_IMP cu_anag.imprese;
		R_SOGG cu_anag.imprese;
		R_SOGG_F cu_anag.soggetti_fisici;
		R_STAB cu_anag.stabilimenti;

		R_IND cu_anag.indirizzi;
		v_j json;
		v_validita tsrange;
		jarg json;
		ret_verificato cu_types.result_type;
		
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		v_fonte varchar;
		istatcomune varchar;
		begin 
			proc_name:='cu_anag.upd_cu_add_stabilimenti_figure';
			v_j:=v::json;
			v_id_stabilimento:=v_j->'id_stabilimento';
			v_tipo_figura:=v_j->'figura';
			--v_nome:=v_j->>'nome';
			--v_cognome:=v_j->>'cognome';
			v_cf:=v_j->>'cf';
			--v_nome:=trim(upper(v_nome));
			--v_cognome:=trim(upper(v_cognome));
			v_cf:=trim(upper(v_cf));
			--v_toponimo:=v_j->>'toponimo';
			--v_indirizzo:=v_j->>'indirizzo';
			--v_civico:=v_j->>'civico';
			--v_comune:=v_j->>'comune';
			v_data_inizio_validita:=v_j->>'data_inizio_validita';
			v_validita:=tsrange(v_data_inizio_validita,null,'[)');
			/*v_indirizzo:=cu_anag.string_normalize(v_j->>'indirizzo');
			v_indirizzo:=cu_anag.string_normalize(v_indirizzo);
			v_civico:=cu_anag.string_normalize(v_j->>'civico');
			v_indirizzo:= cu_anag.string_normalize(v_indirizzo);
			v_comune:=cu_anag.string_normalize_upper(v_j->>'comune');

			v_toponimo:=cu_anag.string_normalize_upper(v_j->>'toponimo');

			v_cap:=cu_anag.string_normalize_upper(v_j->>'cap');

			v_nazione:=cu_anag.string_normalize_upper(v_j->>'nazione');

			v_provincia:=cu_anag.string_normalize_upper(v_j->>'stato_provincia');

			istatcomune:=cu_anag.string_normalize_upper(v_j->>'istat_comune'); */
			raise notice 'v=%', v_j;

			if v_fonte is null or v_fonte = '' then
				v_fonte:= 'GISA-FVG';
			end if;
		
			select * into R_STAB from cu_anag.stabilimenti where id=v_id_stabilimento;
			/*if ( not upper_inf(R_STAB.validita)) and v_data_inizio_validita > upper(R_STAB.validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_supera_validita_impresa');
				ret.info='0';
				return ret;
			end if;*/
			if v_data_inizio_validita is null then
				v_data_inizio_validita:= lower(R_STAB.validita);
			end if;
			v_validita:=tsrange(v_data_inizio_validita,upper(R_STAB.validita),'[)');
			if not (R_STAB.validita @> v_validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_stabilimento');
				ret.info='0';
				return ret;
			end if;
			--insert into cu_anag.soggetti_fisici (id,nome,cognome,codice_fiscale,indirizzo_id) values(nextval('cu_anag.cu_anag_id_seq'),v_nome,v_cognome,v_cf,idindirizzo) returning id into idsoggettofisico;
		
			--raise notice 'idsoggettofisico=%',idsoggettofisico;
			select * into R_SF from cu_anag.stabilimento_figure
			where id_stabilimento=v_id_stabilimento and id_tipo_figura =v_tipo_figura  and validita && v_validita
				limit 1;
			raise notice 'R_SF %',R_SF;
			if R_SF.id is not null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'figura_gia_presente_per_validita');
				ret.info='0';
				return ret;
			end if;
			select * into R_SOGG from cu_anag.imprese where cf=v_cf;
			if R_SOGG.id is null then
				select * into R_SOGG_F from cu_anag.soggetti_fisici where codice_fiscale=v_cf;
				if R_SOGG_F.id is not null then
					R_SOGG.id:=nextval('cu_anag.cu_anag_id_seq');
					R_SOGG.cf:=v_cf;
					R_SOGG.verificato:= true;
					R_SOGG.fonte:= 'STAB_FIG';
					R_SOGG.tipo_soggetto:='F';
					R_SOGG.validita=tsrange(null,null,'()');
					R_SOGG.nome=null;
					insert into cu_anag.imprese values(R_SOGG.*);
				end if;
			end if;
			if R_SOGG.id is null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'codice_fiscale_non_presente');
				ret.info='0';
				return ret;
			end if;
			--idindirizzo = nextval('cu_anag.cu_anag_id_seq');
			--insert into cu_anag.indirizzi (id) VALUES(idindirizzo)
			--	returning * into R_IND;
			--insert into cu_anag.indirizzi (id,toponimo,indirizzo,comune,civico,cap,nazione,stato_prov,istat_comune,fonte)
			--values (nextval('cu_anag.cu_anag_id_seq'),v_toponimo,v_indirizzo,v_comune,v_civico,v_cap,v_nazione,v_provincia,lpad(trim(istatcomune),6,'0'),v_fonte)
			--returning id into idindirizzo;
		
			idindirizzo:=v_j->'id_indirizzo';
		
			if idindirizzo is null then
				ret := cu_anag.upsert_indirizzi(v,idtransazione);
				idindirizzo = ret.info;
			end if;
			n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'I');
			insert into cu_anag.stabilimento_figure (id,id_stabilimento,id_tipo_figura,id_indirizzo,validita,id_soggetto)
				values (nextval('cu_anag.cu_anag_id_seq'),v_id_stabilimento,v_tipo_figura,idindirizzo,
						v_validita,R_SOGG.id)
				returning * into R_SF;
			n:=cu_log.upd_record('cu_anag.stabilimento_figure',idtransazione,R_SF,'I');
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='{"id_indirizzo":'||idindirizzo||',"id_stabilimento_figura":'||(R_SF.id)||'}';
			if (not R_STAB.verificato) or R_STAB.verificato is null then
				jarg:='{"id_stabilimento":'||R_STAB.id||',"id_impresa":'||R_STAB.id_impresa||'}';
				ret_verificato:= cu_anag.check_stabilimento_valido(jarg,idtransazione);
				if ret_verificato.esito then
					update cu_anag.stabilimenti set verificato=true where id=R_STAB.id returning * into R_STAB;
					n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_STAB,'U');
				end if;
			end if;
			return ret;
		end;
		

	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_add_stabilimenti_figure(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_stabilimenti_sedi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_add_stabilimenti_sedi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_id_stabilimento bigint;
		v_tipo_sede bigint;
		v_piva varchar;
		v_pec varchar;
		v_email varchar;
		v_sdi varchar;
		v_split_payement varchar;
		v_cf varchar;
		v_cod_tipo_impresa varchar;
		v_j json;
		idindirizzo bigint;
		idimpresa bigint;
		v_data_inizio_validita timestamp;
		R_STAB cu_anag.stabilimenti;
		R_SS cu_anag.stabilimento_sedi;
		R_IND cu_anag.indirizzi;
		R_IMP cu_anag.imprese;
		R_TS cu_types.tipi_sede;
		v_validita tsrange;
		n integer;
		jarg json;
		ret_verificato cu_types.result_type;
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		v_fonte varchar;
		istatcomune varchar;
		begin 
			proc_name:='cu_anag.upd_cu_add_stabilimenti_sedi';
			v_j:=v::json;
			v_id_stabilimento:=v_j->'id_stabilimento';
			v_tipo_sede:=v_j->'sede';
			v_piva:=cu_anag.string_normalize_upper(v_j->>'piva');
			v_pec:=cu_anag.string_normalize(v_j->>'pec');
			v_email:=cu_anag.string_normalize(v_j->>'email');
			v_sdi:=cu_anag.string_normalize_upper(v_j->>'sdi');
			v_split_payement:=cu_anag.string_normalize_upper(v_j->>'split_payement');
			v_cf:=cu_anag.string_normalize_upper(v_j->>'cf');
			v_cod_tipo_impresa:=cu_anag.string_normalize(v_j->>'cod_tipo_impresa');
			v_data_inizio_validita:=v_j->>'data_inizio_validita';
			/*v_indirizzo:=cu_anag.string_normalize(v_j->>'indirizzo');
			v_indirizzo:=cu_anag.string_normalize(v_indirizzo);
			v_civico:=cu_anag.string_normalize(v_j->>'civico');
			v_indirizzo:= cu_anag.string_normalize(v_indirizzo);
			v_comune:=cu_anag.string_normalize_upper(v_j->>'comune');

			v_toponimo:=cu_anag.string_normalize_upper(v_j->>'toponimo');

			v_cap:=cu_anag.string_normalize_upper(v_j->>'cap');

			v_nazione:=cu_anag.string_normalize_upper(v_j->>'nazione');

			v_provincia:=cu_anag.string_normalize_upper(v_j->>'stato_provincia');

			istatcomune:=cu_anag.string_normalize_upper(v_j->>'istat_comune'); */
			
			raise notice 'v=%', v_j;
		
			if v_email is not null and v_email != '' and v_email !~ '.+@.+\..+' then
				ret:=cu_ui.build_ret(ret,proc_name,'e-mail_non_valida');
				return ret;
			end if;
			if v_pec is not null and v_pec != '' and v_pec !~ '.+@.+\..+' then
				ret:=cu_ui.build_ret(ret,proc_name,'pec_non_valida');
				return ret;
			end if;
			/*select * into R_TS from cu_types.tipi_sede where id=v_tipo_sede;
			if upper(R_TS.cod) !='SF' and v_sdi is not null and v_sdi != '' then
				ret:=cu_ui.build_ret(ret,proc_name,'sdi_non_ammissibile_per_il_tipo_sede');
				return ret;
			end if;
			if upper(R_TS.cod) !='SF' and v_split_payement is not null and v_split_payement != '' then
				ret:=cu_ui.build_ret(ret,proc_name,'split_payement_non_ammissibile_per_il_tipo_sede');
				return ret;
			end if;
		

			
			--raise notice 'idindirizzo=%',idindirizzo;
			select * into R_STAB from cu_anag.stabilimenti where id=v_id_stabilimento;
			if (v_sdi is not null and v_sdi != '') or (v_split_payement is not null and v_split_payement != '') then
				select * into R_IMP from cu_anag.imprese where id =R_STAB.id_impresa;
				if R_IMP.sdi is not null and R_IMP.sdi != '' then
					ret:=cu_ui.build_ret(ret,proc_name,'sdi_presente_in_impresa');
					return ret;
				end if;
		
				if R_IMP.tipo_soggetto = 'Z' then
					if length(v_sdi) != 6 then
					    ret:=cu_ui.build_ret(ret,proc_name,'codice_sdi_non_valido_per_pubblica_amministrazione');
						return ret;
					end if;
				else
					if length(v_sdi) != 7 then
					    ret:=cu_ui.build_ret(ret,proc_name,'codice_sdi_non_valido_per_imprese_private');
						return ret;
					end if;
				end if;
			end if;*/
			select * into R_STAB from cu_anag.stabilimenti where id=v_id_stabilimento;
			/*if upper(R_STAB.validita) is not null and v_data_inizio_validita > upper(R_STAB.validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_supera_validita_impresa');
				ret.info='0';
				return ret;
			end if;*/
			if v_data_inizio_validita is null then
				v_data_inizio_validita:= lower(R_STAB.validita);
			end if;
		
			v_validita:=tsrange(v_data_inizio_validita,upper(R_STAB.validita),'[)');
			if not (R_STAB.validita @> v_validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_stabilimento');
				ret.info='0';
				return ret;
			end if;
			select * into R_SS from cu_anag.stabilimento_sedi
			where id_stabilimento=v_id_stabilimento and id_tipo_sede =v_tipo_sede  and validita && v_validita
				limit 1;
			if R_SS.id is not null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'sede_gia_presente_per_validita');
				ret.info='0';
				return ret;
			end if;
				
			--idindirizzo = nextval('cu_anag.cu_anag_id_seq');
			--insert into cu_anag.indirizzi (id) VALUES(idindirizzo) returning * into R_IND;
			--n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'I');
		
			--insert into cu_anag.indirizzi (id,toponimo,indirizzo,comune,civico,cap,nazione,stato_prov,istat_comune,fonte)
			--values (nextval('cu_anag.cu_anag_id_seq'),v_toponimo,v_indirizzo,v_comune,v_civico,v_cap,v_nazione,v_provincia,lpad(trim(istatcomune),6,'0'),v_fonte)
			--returning id into idindirizzo;
		
			ret := cu_anag.upsert_indirizzi(v,idtransazione);
			idindirizzo = ret.info;
		
			insert into cu_anag.stabilimento_sedi (id,id_stabilimento,id_tipo_sede,pec,email,id_indirizzo,validita,fonte) 
				values (nextval('cu_anag.cu_anag_id_seq'),v_id_stabilimento,v_tipo_sede,v_pec,v_email,idindirizzo,v_validita,'GISA-FVG')
							returning * into R_SS;
			n:=cu_log.upd_record('cu_anag.stabilimento_sedi',idtransazione,R_SS,'I');
			/*idimpresa = (select vs.id_impresa 
			from cu_anag.vw_stabilimenti vs 
			where vs.id_stabilimento = v_id_stabilimento);
		
			raise notice 'idimpresa %',idimpresa;
			
			update cu_anag.imprese 
			set cod_tipo_impresa = v_cod_tipo_impresa
			where id = idimpresa;*/
			
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='{"id_indirizzo":'||idindirizzo||',"id_stabilimento_sede":'||(R_SS.id)||'}';
		
			if (not R_STAB.verificato) or R_STAB.verificato is null then
				jarg:='{"id_stabilimento":'||R_STAB.id||',"id_impresa":'||R_STAB.id_impresa||'}';
				ret_verificato:= cu_anag.check_stabilimento_valido(jarg,idtransazione);
				if ret_verificato.esito then
					update cu_anag.stabilimenti set verificato=true where id=R_STAB.id returning * into R_STAB;
					n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_STAB,'U');
				end if;
			end if;
			return ret;
		end;
		

	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_add_stabilimenti_sedi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_add_stabilimento(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_add_stabilimento(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		ret_imp cu_types.result_type;  	
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_id_impresa bigint;
		v_nome varchar;
		v_sd_cod_regionale varchar;
		v_cod_nazionale varchar;
		v_cod_tipologia_struttura varchar;
		v_pec varchar;
		v_telefono varchar;
		v_sdi varchar;
		v_categoria_rischio bigint;
		idindirizzo bigint;
		v_data_inizio_validita timestamp;
		v_j json;
		v_id_tipologia_struttura bigint;
		v_id_asl integer;
		v_validita tsrange;
		R_IMP cu_anag.imprese;
		R_IND cu_anag.indirizzi;
		R_TS cu_types.vw_tipologie_struttura ;
		R_S cu_anag.stabilimenti;
		v_fonte varchar;
		n integer;
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		istatcomune varchar;
		v_verificato bool;
		v_n_pratica varchar;
		r record;
		begin 
			proc_name:='cu_anag.upd_cu_add_stabilimento';
			v_j:=v::json;
			v_id_impresa:=v_j->'id_impresa';
			v_fonte:=v_j->>'fonte';
			v_sd_cod_regionale:=v_j->>'sd_cod_regionale';
			v_nome:=v_j->>'nome';
			v_cod_tipologia_struttura:=v_j->>'cod_tipologia_struttura';
			v_cod_nazionale:=v_j->>'cod_nazionale';
			--v_categoria_rischio:=v_j->>'categoria_rischio';
			v_data_inizio_validita:=v_j->>'data_inizio_validita';
			v_id_tipologia_struttura:=v_j->>'id_tipologia_struttura';
			--v_id_asl:=v_j->'id_asl';
			v_pec:=v_j->>'pec';
			v_telefono:=v_j->>'telefono';
			v_validita:=tsrange(v_data_inizio_validita,null::timestamp,'[)');
			v_sdi:=v_j->>'sdi';
			v_indirizzo:=cu_anag.string_normalize(v_j->>'indirizzo');
			v_indirizzo:=cu_anag.string_normalize(v_indirizzo);
			v_civico:=cu_anag.string_normalize(v_j->>'civico');
			v_indirizzo:= cu_anag.string_normalize(v_indirizzo);
			v_comune:=cu_anag.string_normalize_upper(v_j->>'comune');

			v_toponimo:=cu_anag.string_normalize_upper(v_j->>'toponimo');

			v_cap:=cu_anag.string_normalize_upper(v_j->>'cap');

			v_nazione:=cu_anag.string_normalize_upper(v_j->>'nazione');

			v_provincia:=cu_anag.string_normalize_upper(v_j->>'stato_provincia');

			istatcomune:=cu_anag.string_normalize_upper(v_j->>'istat_comune');
			
			v_n_pratica:=v_j->>'n_pratica';

			raise notice 'v=%',v_j;
			ret:=cu_anag.check_stabilimento(v,idtransazione);
			if not ret.esito then
				return ret;
			end if;
		
			select * into R_IMP from cu_anag.imprese i where i.id = v_id_impresa;
			if R_IMP.id is null then
				ret.esito:=false;
				ret:=cu_ui.build_ret(ret,proc_name,'impresa_inesistente');
				return ret;
			end if;
			
			--idindirizzo = nextval('cu_anag.cu_anag_id_seq');
			--insert into cu_anag.indirizzi (id) VALUES(idindirizzo) returning * into R_IND;
			--n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'I');
		
			if v_fonte is null or v_fonte = '' then
				v_fonte:= 'GISA-FVG';
			end if;
		
			--insert into cu_anag.indirizzi (id,toponimo,indirizzo,comune,civico,cap,nazione,stato_prov,istat_comune,fonte)
			--values (nextval('cu_anag.cu_anag_id_seq'),v_toponimo,v_indirizzo,v_comune,v_civico,v_cap,v_nazione,v_provincia,lpad(trim(istatcomune),6,'0'),v_fonte)
			--returning id into idindirizzo;
		
			if lower(v_validita) < lower(R_IMP.validita) then
				ret.esito:=false;
				ret:=cu_ui.build_ret(ret,proc_name,'data_inizio_validita_stabilimento_minore_inizio_validita_impresa');
				return ret;
			end if;
		
		
			ret := cu_anag.upsert_indirizzi(v,idtransazione);
			idindirizzo = ret.info;
		
			if v_id_tipologia_struttura in (16,17)  then -- DATI DI BDN
				ret_imp.esito:=true;
			else
				ret_imp:=cu_anag.check_impresa_valida(('{"id_impresa":'||R_IMP.id||'}')::json,idtransazione);
			end if;
		
			insert into cu_anag.stabilimenti (id,id_impresa,cod_nazionale ,nome,
				categoria_rischio,id_indirizzo,validita,id_tipologia_struttura, /*id_asl,*/ pec, 
				telefono,fonte,cod_regionale,sdi,verificato) 
			values (nextval('cu_anag.cu_anag_id_seq'),v_id_impresa,v_cod_nazionale,
						v_nome,v_categoria_rischio,idindirizzo,
						v_validita,v_id_tipologia_struttura, /*v_id_asl,*/ v_pec, v_telefono,
						coalesce(v_fonte,'GISA-FVG'),v_sd_cod_regionale,v_sdi,ret_imp.esito)
					returning * into R_S;
			n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_S,'I');
		
			update cu_anag.pratiche p
			set id_stabilimento = R_S.id
			where p.n_pratica = v_n_pratica
			returning * into r;
			n:=cu_log.upd_record('cu_anag.pratiche',idtransazione,r,'U');
		
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='{"id_indirizzo":'||idindirizzo||',"id_stabilimento":'||(R_S.id)||'}';
			return ret;
		end;
		

	END;

$$;


ALTER FUNCTION cu_anag.upd_cu_add_stabilimento(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_impresa(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_del_impresa(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_id_impresa bigint;
		v_data_fine_validita timestamp;
		v_j json;
		idindirizzo bigint;
		n integer;

		v_char varchar;
		v_id bigint;
		R_IMP cu_anag.imprese;
		R_IF cu_anag.impresa_figure;
		R_IS cu_anag.impresa_sedi;
	
		R_S cu_anag.stabilimenti;
		R_SF cu_anag.stabilimento_figure;
		R_SS cu_anag.stabilimento_sedi;
	
		R_L cu_anag.linee;
		begin 
			proc_name:='cu_anag.upd_cu_del_impresa';
			v_j:=v;
			v_id_impresa:=v_j->'id_impresa';
			v_char:= v::varchar;
			v_char:=left(v_char,length(v_char)-1)||',"action":"delete"}';
			ret:=cu_anag.check_impresa(v_char::json,idtransazione);
			if not ret.esito then
				return ret;
			end if;


			v_data_fine_validita:=v_j->>'data_fine_validita';
			v_data_fine_validita:=v_data_fine_validita + interval '1 day';
		
			select * into R_IMP from cu_anag.imprese where id=v_id_impresa;


			--GET DIAGNOSTICS n = ROW_COUNT;
			
			if (upper(R_IMP.validita) is not null and  upper(R_IMP.validita)<v_data_fine_validita) then
				ret.esito:=false;	
	        	ret:=cu_ui.build_ret(ret,proc_name,'errore_data_fine_validita');
				ret.info='0';
				return ret;
			end if;
			raise notice ' data fine % id %',v_data_fine_validita,v_id_impresa;
			update cu_anag.imprese set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
				where id=v_id_impresa returning * into R_IMP;
			n:=cu_log.upd_record('cu_anag.imprese',idtransazione,R_IMP,'U');
		
			raise notice 'update cu_anag.impresa_figure';
			
			for v_id in select id from cu_anag.impresa_figure
						where id_impresa=v_id_impresa and (upper_inf(validita) or (upper(validita) >= v_data_fine_validita)) loop
				update cu_anag.impresa_figure set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
					where id= v_id returning * into R_IF;
				n:=cu_log.upd_record('cu_anag.impresa_figure',idtransazione,R_IF,'U');
			end loop;
			
			raise notice 'update cu_anag.impresa_sedi';
			for v_id in select id from cu_anag.impresa_sedi
						where id_impresa=v_id_impresa and (upper_inf(validita) or (upper(validita) >= v_data_fine_validita)) loop
				update cu_anag.impresa_sedi set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
					where id= v_id returning * into R_IS;
				n:=cu_log.upd_record('cu_anag.impresa_sedi',idtransazione,R_IS,'U');
			end loop;
		
		 	raise notice 'update cu_anag.stabilimenti';
			for v_id in select id from cu_anag.stabilimenti
						where id_impresa=v_id_impresa and (upper_inf(validita) or (upper(validita) >= v_data_fine_validita)) loop
				update cu_anag.stabilimenti set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
					where id= v_id returning * into R_S;
				n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_S,'U');
			end loop;
			
			raise notice 'update cu_anag.stabilimento_figure';
			for v_id in select id from cu_anag.stabilimento_figure
						where id_stabilimento in (select id from cu_anag.stabilimenti where id_impresa=v_id_impresa) and
							(upper_inf(validita) or (upper(validita) >= v_data_fine_validita)) loop
				update cu_anag.stabilimento_figure set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
					where id= v_id returning * into R_SF;
				n:=cu_log.upd_record('cu_anag.stabilimento_figure',idtransazione,R_SF,'U');
			end loop;
		
			raise notice 'update cu_anag.stabilimento_sedi';
			for v_id in select id from cu_anag.stabilimento_sedi
						where id_stabilimento in (select id from cu_anag.stabilimenti where id_impresa=v_id_impresa) and
							(upper_inf(validita) or (upper(validita) > v_data_fine_validita)) loop
				update cu_anag.stabilimento_sedi set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
					where id= v_id returning * into R_SS;
				n:=cu_log.upd_record('cu_anag.stabilimento_sedi',idtransazione,R_SS,'U');
			end loop;
		
			raise notice 'update cu_anag.linee';
			for v_id in select id from cu_anag.linee
						where id_stabilimento in (select id from cu_anag.stabilimenti where id_impresa=v_id_impresa) and
							(upper_inf(validita) or (upper(validita) > v_data_fine_validita)) loop
				update cu_anag.linee set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
					where id= v_id returning * into R_L;
				n:=cu_log.upd_record('cu_anag.linee',idtransazione,R_L,'U');
			end loop;
		
		
		
		/*
			update cu_anag.stabilimento_figure set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
			where id_stabilimento in (select id from cu_anag.stabilimenti where id_impresa=v_id_impresa)
				and upper(validita) > v_data_fine_validita;
			
			raise notice 'update cu_anag.stabilimento_sedi';
			update cu_anag.stabilimento_sedi set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
			where id_stabilimento in (select id from cu_anag.stabilimenti where id_impresa=v_id_impresa)
				and upper(validita) > v_data_fine_validita;
			
			raise notice 'update cu_anag.linee';
			update cu_anag.linee set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
			where id_stabilimento in (select id from cu_anag.stabilimenti where id_impresa=v_id_impresa)
				and upper(validita) > v_data_fine_validita;*/
					
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		end;

	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_del_impresa(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_impresa_figure(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_del_impresa_figure(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		--v_id_soggetto_fisico bigint;
		v_id_impresa_figura bigint;
		v_data_fine_validita timestamp;
		R_IMP cu_anag.imprese;
		R_IF cu_anag.impresa_figure;
		v_j json;
		n integer;
		--idindirizzo bigint;
		begin 
			proc_name:='cu_anag.upd_cu_del_impresa_figure';
			v_j:=v::json;
			v_id_impresa_figura:=v_j->>'id_impresa_figura';
			v_data_fine_validita:=v_j->>'data_fine_validita';
			v_data_fine_validita:= v_data_fine_validita + interval '1 day';
			--v_id_soggetto_fisico:=v_j->>'id_soggetto_fisico';
			--idindirizzo:=v_j->>'id_indirizzo';
		
			select * into R_IMP from cu_anag.imprese where id=R_SF.id_impresa;
			
			if upper(R_IMP.validita) < v_data_fine_validita then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_impresa');
				ret.info='0';
				return ret;
			end if;
		
			select * into R_IF from cu_anag.impresa_figure where id=v_id_impresa_figura;
			if (upper(R_IF.validita) is not null and  upper(R_IF.validita)<v_data_fine_validita) then
				ret.esito:=false;	
	        	ret:=cu_ui.build_ret(ret,proc_name,'errore_data_fine_validita');
				ret.info='0';
				return ret;
			end if;
		
			update cu_anag.impresa_figure set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
			where id=v_id_impresa_figura returning * into R_IF;
			n:=cu_log.upd_record('cu_anag.impresa_figure',idtransazione,R_IF,'U');

			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		end;
		

	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_del_impresa_figure(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_impresa_figure_indirizzo_errato(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_del_impresa_figure_indirizzo_errato(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		n integer;
		v_id_impresa_figura bigint;
	    v_id_indirizzo bigint;
	  	v_j json;
		proc_name varchar; -- end
		R_S cu_anag.stabilimenti;
		R_IND cu_anag.indirizzi;
		begin 
			proc_name:='cu_anag.upd_cu_del_impresa_figure_indirizzo_errato';
			v_j:=v::json;
			v_id_impresa_figura:=v_j->>'id_impresa_figura';
			v_id_indirizzo:=v_j->>'id_indirizzo';
		
			--select * into R_S from cu_anag.impresa_figure 
			--where id = v_id_impresa_figura;
			

			delete from cu_anag.impresa_figure 
			where id = v_id_impresa_figura;
			
			n:=cu_log.upd_record('cu_anag.upd_cu_del_impresa_figure_indirizzo_errato',idtransazione,R_S,'I');
			
			ret.esito:=true;
	    	--ret:=cu_ui.build_ret(ret,proc_name, 'eliminazione_stabilimento_per_indirizzo_errato_avvenuta_con_successo');
	    	ret.info = '0';
 			return ret;
		end;
	end;
$$;


ALTER FUNCTION cu_anag.upd_cu_del_impresa_figure_indirizzo_errato(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_impresa_sedi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_del_impresa_sedi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_id_impresa_sede bigint;
		v_id_impresa bigint;
		v_data_fine_validita timestamp;
		v_j json;
		idindirizzo bigint;
		n integer;
	
		R_IS cu_anag.impresA_SEDI;
		begin 
			proc_name:='cu_anag.upd_cu_del_impresa_sedi';
			v_j:=v::json;
			v_id_impresa_sede:=v_j->>'id_impresa_sedi';
			v_data_fine_validita:=v_j->>'data_fine_validita';
			v_data_fine_validita:= v_data_fine_validita + interval '1 day';
			raise notice 'data=%', v_data_fine_validita;

			select * into R_IS from cu_anag.impresa_sedi where id=v_id_impresa_sede;
		
			update cu_anag.impresa_sedi set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
			where id=v_id_impresa_sede;  --and (upper(validita) is null or upper(validita)>v_data_fine_validita);
			--GET DIAGNOSTICS n = ROW_COUNT;
			
			if upper(R_IS.validita) is not null and upper(R_IS.validita)<v_data_fine_validita then
				ret.esito:=false;	
	        	ret:=cu_ui.build_ret(ret,proc_name,'errore_data_fine_validita');
				ret.info='0';
				return ret;
			end if;
		
			update cu_anag.impresa_sedi set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
				where id=v_id_impresa_sede returning * into R_IS;
			n:=cu_log.upd_record('cu_anag.impresa_sedi',idtransazione,R_IS,'U');
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		end;

	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_del_impresa_sedi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_impresa_sedi_indirizzo_errato(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_del_impresa_sedi_indirizzo_errato(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		n integer;
		v_id_impresa_sede bigint;
	    v_id_indirizzo bigint;
	  	v_j json;
		proc_name varchar; -- end
		R_S cu_anag.stabilimenti;
		R_IND cu_anag.indirizzi;
		begin 
			proc_name:='cu_anag.upd_cu_del_impresa_sedi_indirizzo_errato';
			v_j:=v::json;
			v_id_impresa_sede:=v_j->>'id_impresa_sede';
			v_id_indirizzo:=v_j->>'id_indirizzo';
		
			--select * into R_S from cu_anag.impresa_sedi 
			---where id_impresa = v_id_impresa;
			

			delete from cu_anag.impresa_sedi 
			where id = v_id_impresa_sede;
			
			n:=cu_log.upd_record('cu_anag.upd_cu_del_impresa_sedi_indirizzo_errato',idtransazione,R_S,'I');
			
			ret.esito:=true;
	    	--ret:=cu_ui.build_ret(ret,proc_name, 'eliminazione_stabilimento_per_indirizzo_errato_avvenuta_con_successo');
	    	ret.info = '0';
 			return ret;
		end;
	end;
$$;


ALTER FUNCTION cu_anag.upd_cu_del_impresa_sedi_indirizzo_errato(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_linea_stabilimenti(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_del_linea_stabilimenti(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		--v_id_soggetto_fisico bigint;
		v_id_linea bigint;
		v_data_fine_validita timestamp;
		R_STAB cu_anag.stabilimenti;
		R_L cu_anag.linee;
		v_j json;
		n integer;
		--idindirizzo bigint;
		begin 
			proc_name:='cu_anag.upd_cu_del_linee';
			v_j:=v::json;
			v_id_linea:=v_j->>'id_stabilimento_linea';
			v_data_fine_validita:=v_j->>'data_fine_validita';
			v_data_fine_validita:= v_data_fine_validita + interval '1 day';
		
			select * into R_L from cu_anag.linee where id=v_id_linea;
			if R_L.id is null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'figura_per_lo_stabilimento_inesistente');
				ret.info='0';
				return ret;
			end if;
			select * into R_STAB from cu_anag.stabilimenti where id=R_L.id_stabilimento;
			if R_STAB.id is null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'errore_grave_stabilimento_inesistente');
				ret.info='0';
				return ret;
			end if;
		
			if upper(R_STAB.validita) < v_data_fine_validita then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_stabilimento');
				ret.info='0';
				return ret;
			end if;
		
			if (upper(R_L.validita) is null or upper(R_L.validita)>v_data_fine_validita) then
				ret.esito:=false;	
	        	ret:=cu_ui.build_ret(ret,proc_name,'errore_data_fine_validita');
				ret.info='0';
				return ret;
			end if;
		
		
			update cu_anag.linee set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
			where id=v_id_linea returning * into R_L;
			n:=cu_log.upd_record('cu_anag.linee',idtransazione,R_L,'I');
			
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_del_linea_stabilimenti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_soggetti_fisici_indirizzo_errato(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_del_soggetti_fisici_indirizzo_errato(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		n integer;
		v_id_soggetto_fisico bigint;
	    v_id_indirizzo bigint;
	  	v_j json;
		proc_name varchar; -- end
		R_S cu_anag.stabilimenti;
		R_IND cu_anag.indirizzi;
		begin 
			proc_name:='cu_anag.upd_cu_del_soggetti_fisici_indirizzo_errato';
			v_j:=v::json;
			v_id_soggetto_fisico:=v_j->>'id_soggetto_fisico';
			v_id_indirizzo:=v_j->>'id_indirizzo';
		
			--select * into R_S from cu_anag.soggetti_fisici 
			--where id = v_id_soggetto_fisico;
			

			delete from cu_anag.soggetti_fisici 
			where id = v_id_soggetto_fisico;
			
			n:=cu_log.upd_record('cu_anag.upd_cu_del_soggetti_fisici_indirizzo_errato',idtransazione,R_S,'I');
			
			ret.esito:=true;
	    	--ret:=cu_ui.build_ret(ret,proc_name, 'eliminazione_stabilimento_per_indirizzo_errato_avvenuta_con_successo');
	    	ret.info = '0';
 			return ret;
		end;
	end;
$$;


ALTER FUNCTION cu_anag.upd_cu_del_soggetti_fisici_indirizzo_errato(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_stab_indirizzo_errato(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_del_stab_indirizzo_errato(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		n integer;
		v_id_stabilimento bigint;
	    v_id_indirizzo bigint;
	  	v_j json;
		proc_name varchar; -- end
		R_S cu_anag.stabilimenti;
		R_IND cu_anag.indirizzi;
		begin 
			proc_name:='cu_anag.upd_cu_del_stab_indirizzo_errato';
			v_j:=v::json;
			v_id_stabilimento:=v_j->>'id_stabilimento';
			v_id_indirizzo:=v_j->>'id_indirizzo';
		
			select * into R_S from cu_anag.stabilimenti s 
			where id = v_id_stabilimento;
			/*if R_S.id is null then
				ret:=cu_ui.build_ret(ret,proc_name,'stabilimento_non_trovato');
				ret.info='0';
				return ret;
			end if;
			*/
			delete from cu_anag.stabilimenti 
			where id = v_id_stabilimento;
			
			--update cu_anag.stabilimenti 
			--set validita = tsrange(lower(validita)::timestamp without time zone,CURRENT_TIMESTAMP::timestamp without time zone),
			--	id_indirizzo = null
			--where id = v_id_stabilimento;
			
			n:=cu_log.upd_record('cu_anag.upd_cu_del_stab_indirizzo_errato',idtransazione,R_S,'I');
			
			ret.esito:=true;
	    	--ret:=cu_ui.build_ret(ret,proc_name, 'eliminazione_stabilimento_per_indirizzo_errato_avvenuta_con_successo');
	    	ret.info = '0';
 			return ret;
		end;
	end;
$$;


ALTER FUNCTION cu_anag.upd_cu_del_stab_indirizzo_errato(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_stabilimento(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_del_stabilimento(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_id_stabilimento bigint;
		v_data_fine_validita timestamp;
		v_j json;
		idindirizzo bigint;
		n integer;

		v_char varchar;
		v_id bigint;
		R_STAB cu_anag.stabilimenti;

	
		R_S cu_anag.stabilimenti;
		R_SF cu_anag.stabilimento_figure;
		R_SS cu_anag.stabilimento_sedi;
	
		R_L cu_anag.linee;
		begin 
			proc_name:='cu_anag.upd_cu_del_stabilimento';
		
			v_j:=v;
			v_id_stabilimento:=v_j->>'id_stabilimento';
			raise notice '=========v_id_stabilimento %',v_id_stabilimento;
			v_char:= v::varchar;
			v_char:=left(v_char,length(v_char)-1)||',"action":"delete"}';
			ret:=cu_anag.check_stabilimento(v_char::json,idtransazione);
		
			raise notice ' ret.esito %',ret.esito;
			if not ret.esito then
				return ret;
			end if;


			v_data_fine_validita:=v_j->>'data_fine_validita';
			v_data_fine_validita:=v_data_fine_validita + interval '1 day';
		
			select * into R_STAB from cu_anag.stabilimenti where id=v_id_stabilimento;

			raise notice 'select R_STAB from cu_anag.stabilimenti %',R_STAB;
			--GET DIAGNOSTICS n = ROW_COUNT;
			
			/*if (upper(R_STAB.validita) is not null and  upper(R_STAB.validita)<v_data_fine_validita) then
				ret.esito:=false;	
	        	ret:=cu_ui.build_ret(ret,proc_name,'errore_data_fine_validita');
				ret.info='0';
				return ret;
			end if;*/
		

			select count(*) into n from cu_anag.stabilimento_figure where id_stabilimento=v_id_stabilimento and lower(validita) > v_data_fine_validita;
			if n>0 then ret.esito:=false; ret:=cu_ui.build_ret(ret,proc_name,'figure_con_data_inizio_maggiore_di_data_fine_stabilimento'); return ret; end if;
			select count(*) into n from cu_anag.stabilimento_sedi   where id_stabilimento=v_id_stabilimento and  lower(validita) > v_data_fine_validita;
			if n>0 then ret.esito:=false; ret:=cu_ui.build_ret(ret,proc_name,'sedi_con_data_inizio_maggiore_di_data_fine_stabilimento'); return ret; end if;
			select count(*) into n from cu_anag.linee               where id_stabilimento=v_id_stabilimento and  lower(validita) > v_data_fine_validita;
			if n>0 then ret.esito:=false; ret:=cu_ui.build_ret(ret,proc_name,'linee_con_data_inizio_maggiore_di_data_fine_stabilimento'); return ret; end if;

			update cu_anag.stabilimenti set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
				where id=v_id_stabilimento returning * into R_STAB;
			n:=cu_log.upd_record('cu_anag.imprese',idtransazione,R_STAB,'U');
	
			
			raise notice 'update cu_anag.stabilimento_figure % id %',v_data_fine_validita,v_id_stabilimento;
			for v_id in select id from cu_anag.stabilimento_figure
						where id_stabilimento =v_id_stabilimento
							and (upper_inf(validita) or upper(validita) > v_data_fine_validita) loop
				update cu_anag.stabilimento_figure set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
					where id= v_id returning * into R_SF;
				raise notice 'cu_anag.stabilimento_figure';
				n:=cu_log.upd_record('cu_anag.stabilimento_figure',idtransazione,R_SF,'U');
			end loop;
		
			raise notice 'update cu_anag.stabilimento_sedi % id %',v_data_fine_validita,v_id_stabilimento;
			for v_id in select id from cu_anag.stabilimento_sedi
						where id_stabilimento =v_id_stabilimento
							and (upper_inf(validita) or upper(validita) > v_data_fine_validita) loop
				update cu_anag.stabilimento_sedi set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
					where id= v_id returning * into R_SS;
				raise notice 'cu_anag.stabilimento_sedi';
				n:=cu_log.upd_record('cu_anag.stabilimento_sedi',idtransazione,R_SS,'U');
			end loop;
		
			raise notice 'update cu_anag.linee % id %',v_data_fine_validita,v_id_stabilimento;
			for v_id in select id from cu_anag.linee
						where id_stabilimento =v_id_stabilimento
							and (upper_inf(validita) or upper(validita) > v_data_fine_validita) loop
				update cu_anag.linee set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
					where id= v_id returning * into R_L;
				raise notice 'cu_anag.linee';
				n:=cu_log.upd_record('cu_anag.linee',idtransazione,R_L,'U');
			end loop;
		
		
		
		/*
			update cu_anag.stabilimento_figure set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
			where id_stabilimento in (select id from cu_anag.stabilimenti where id_impresa=v_id_stabilimento)
				and upper(validita) > v_data_fine_validita;
			
			raise notice 'update cu_anag.stabilimento_sedi';
			update cu_anag.stabilimento_sedi set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
			where id_stabilimento in (select id from cu_anag.stabilimenti where id_impresa=v_id_stabilimento)
				and upper(validita) > v_data_fine_validita;
			
			raise notice 'update cu_anag.linee';
			update cu_anag.linee set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
			where id_stabilimento in (select id from cu_anag.stabilimenti where id_impresa=v_id_stabilimento)
				and upper(validita) > v_data_fine_validita;*/
					
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		end;

	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_del_stabilimento(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_stabilimento_figure(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_del_stabilimento_figure(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		--v_id_soggetto_fisico bigint;
		v_id_stabilimento_figura bigint;
		v_data_fine_validita timestamp;
		R_STAB cu_anag.stabilimenti;
		R_SF cu_anag.stabilimento_figure;
		v_j json;
		n integer;
		--idindirizzo bigint;
		begin 
			proc_name:='cu_anag.upd_cu_del_stabilimento_figure';
			v_j:=v::json;
			v_id_stabilimento_figura:=v_j->>'id_stabilimento_figura';
			v_data_fine_validita:=v_j->>'data_fine_validita';
			v_data_fine_validita:= v_data_fine_validita + interval '1 day';
		
			select * into R_SF from cu_anag.stabilimento_figure where id=v_id_stabilimento_figura;
			if R_SF.id is null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'figura_per_lo_stabilimento_inesistente');
				ret.info='0';
				return ret;
			end if;
			select * into R_STAB from cu_anag.stabilimenti where id=R_SF.id_stabilimento;
			if R_STAB.id is null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'errore_grave_stabilimento_inesistente');
				ret.info='0';
				return ret;
			end if;
		
			if upper(R_STAB.validita) < v_data_fine_validita then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_stabilimento');
				ret.info='0';
				return ret;
			end if;
		
			if (upper(R_SF.validita) is null or upper(R_SF.validita)>v_data_fine_validita) then
				ret.esito:=false;	
	        	ret:=cu_ui.build_ret(ret,proc_name,'errore_data_fine_validita');
				ret.info='0';
				return ret;
			end if;
		
			update cu_anag.stabilimento_figure set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
			where id=v_id_stabilimento_figura returning * into R_SF;
			n:=cu_log.upd_record('cu_anag.stabilimento_figure',idtransazione,R_SF,'I');
			
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_del_stabilimento_figure(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_stabilimento_figure_indirizzo_errato(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_del_stabilimento_figure_indirizzo_errato(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		n integer;
		v_id_stabilimento_figura bigint;
	    v_id_indirizzo bigint;
	  	v_j json;
		proc_name varchar; -- end
		R_S cu_anag.stabilimenti;
		R_IND cu_anag.indirizzi;
		begin 
			proc_name:='cu_anag.upd_cu_del_stabilimento_figure_indirizzo_errato';
			v_j:=v::json;
			v_id_stabilimento_figura:=v_j->>'id_stabilimento_figura';
			v_id_indirizzo:=v_j->>'id_indirizzo';
		
			--select * into R_S from cu_anag.stabilimento_figure 
			--where id_stabilimento_figura = v_id_stabilimento_figura;
			

			delete from cu_anag.stabilimento_figure 
			where id = v_id_stabilimento_figura;
			
			n:=cu_log.upd_record('cu_anag.upd_cu_del_stabilimento_figure_indirizzo_errato',idtransazione,R_S,'I');
			
			ret.esito:=true;
	    	--ret:=cu_ui.build_ret(ret,proc_name, 'eliminazione_stabilimento_per_indirizzo_errato_avvenuta_con_successo');
	    	ret.info = '0';
 			return ret;
		end;
	end;
$$;


ALTER FUNCTION cu_anag.upd_cu_del_stabilimento_figure_indirizzo_errato(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_stabilimento_indirizzo_errato(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_del_stabilimento_indirizzo_errato(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		n integer;
		v_id_stabilimento bigint;
	    v_id_indirizzo bigint;
	  	v_j json;
		proc_name varchar; -- end
		R_S cu_anag.stabilimenti;
		R_IND cu_anag.indirizzi;
		begin 
			proc_name:='cu_anag.upd_cu_del_stabilimento_indirizzo_errato';
			v_j:=v::json;
			v_id_stabilimento:=v_j->>'id_stabilimento';
			v_id_indirizzo:=v_j->>'id_indirizzo';
		
			select * into R_S from cu_anag.stabilimenti s 
			where id = v_id_stabilimento;
			/*if R_S.id is null then
				ret:=cu_ui.build_ret(ret,proc_name,'stabilimento_non_trovato');
				ret.info='0';
				return ret;
			end if;
			*/
			delete from cu_anag.stabilimenti 
			where id = v_id_stabilimento;
			
			--update cu_anag.stabilimenti 
			--set validita = tsrange(lower(validita)::timestamp without time zone,CURRENT_TIMESTAMP::timestamp without time zone),
			--	id_indirizzo = null
			--where id = v_id_stabilimento;
			
			n:=cu_log.upd_record('cu_anag.upd_cu_del_stabilimento_indirizzo_errato',idtransazione,R_S,'I');
			
			ret.esito:=true;
	    	--ret:=cu_ui.build_ret(ret,proc_name, 'eliminazione_stabilimento_per_indirizzo_errato_avvenuta_con_successo');
	    	ret.info = '0';
 			return ret;
		end;
	end;
$$;


ALTER FUNCTION cu_anag.upd_cu_del_stabilimento_indirizzo_errato(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_stabilimento_sedi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_del_stabilimento_sedi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		--v_id_soggetto_fisico bigint;
		v_id_stabilimento_figura bigint;
		v_data_fine_validita timestamp;
		R_STAB cu_anag.stabilimenti;
		R_SF cu_anag.stabilimento_sedi;
		v_j json;
		n integer;
		--idindirizzo bigint;
		begin 
			proc_name:='cu_anag.upd_cu_del_stabilimento_sedi';
			v_j:=v::json;
			v_id_stabilimento_figura:=v_j->>'id_stabilimento_figura';
			v_data_fine_validita:=v_j->>'data_fine_validita';
			v_data_fine_validita:= v_data_fine_validita + interval '1 day';
		
			select * into R_SF from cu_anag.stabilimento_sedi where id=v_id_stabilimento_figura;
			if R_SF.id is null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'figura_per_lo_stabilimento_inesistente');
				ret.info='0';
				return ret;
			end if;
			select * into R_STAB from cu_anag.stabilimenti where id=R_SF.id_stabilimento;
			if R_STAB.id is null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'errore_grave_stabilimento_inesistente');
				ret.info='0';
				return ret;
			end if;
		
			if upper(R_STAB.validita) < v_data_fine_validita then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_stabilimento');
				ret.info='0';
				return ret;
			end if;
		
			if (upper(R_SF.validita) is null or upper(R_SF.validita)>v_data_fine_validita) then
				ret.esito:=false;	
	        	ret:=cu_ui.build_ret(ret,proc_name,'errore_data_fine_validita');
				ret.info='0';
				return ret;
			end if;
		
			update cu_anag.stabilimento_sedi set validita=tsrange(lower(validita),v_data_fine_validita,'[)')
			where id=v_id_stabilimento_figura returning * into R_SF;
			n:=cu_log.upd_record('cu_anag.stabilimento_sedi',idtransazione,R_SF,'I');
			
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_del_stabilimento_sedi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_del_stabilimento_sedi_indirizzo_errato(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_del_stabilimento_sedi_indirizzo_errato(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		n integer;
		v_id_stabilimento_sede bigint;
	    v_id_indirizzo bigint;
	  	v_j json;
		proc_name varchar; -- end
		R_S cu_anag.stabilimenti;
		R_IND cu_anag.indirizzi;
		begin 
			proc_name:='cu_anag.upd_cu_del_stabilimento_sedi_indirizzo_errato';
			v_j:=v::json;
			raise notice 'v=%',v;
			v_id_stabilimento_sede:=v_j->'id_stabilimento_sede';
			v_id_indirizzo:=v_j->'id_indirizzo';
		
			--select * into R_S from cu_anag.stabilimento_sedi 
			--where id_stabilimento = v_id_stabilimento;
			

			delete from cu_anag.stabilimento_sedi 
			where id = v_id_stabilimento_sede;
			
			n:=cu_log.upd_record('cu_anag.upd_cu_del_stabilimento_sedi_indirizzo_errato',idtransazione,R_S,'I');
			
			ret.esito:=true;
	    	--ret:=cu_ui.build_ret(ret,proc_name, 'eliminazione_stabilimento_per_indirizzo_errato_avvenuta_con_successo');
	    	ret.info = '0';
 			return ret;
		end;
	end;
$$;


ALTER FUNCTION cu_anag.upd_cu_del_stabilimento_sedi_indirizzo_errato(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_imprese(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_imprese(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		v_id_impresa bigint;
		v_verificato bool;
		v_nome varchar;
		v_az_cod_regionale varchar;
		v_piva varchar;
		v_pec varchar;
		v_email varchar;
		v_sdi varchar;
		v_split_payement varchar;
		v_cf varchar;
		v_az_cod_aziendale varchar;
		v_cod_tipo_impresa varchar;
	v_tiposoggetto varchar;
		v_tipo_soggetto varchar;
		v_data_inizio_validita timestamp;
		v_data_fine_validita timestamp;
		v_validita tsrange;
		--v_id_asl integer;
		v_j json;
		proc_name varchar; -- end
		ini timestamp;
		fin timestamp;
		v_id bigint;
		R_STAB cu_anag.stabilimenti;
		r_imp cu_anag.imprese;
		ns integer;
	nf integer;
n integer;
		begin 
			proc_name:='cu_anag.upd_cu_imprese';
			v_j:=v::json;
			v_id_impresa:=v_j->'id_impresa';
			--v_az_cod_regionale:=v_j->>'az_cod_regionale';
			v_piva:=v_j->>'piva';
			v_pec:=v_j->>'pec';
			v_email:=v_j->>'email';
			v_nome:=v_j->>'nome';
			v_sdi:=v_j->>'sdi';
			v_split_payement:=v_j->>'split_payement';
			v_cf:=v_j->>'cf';
			--v_az_cod_aziendale:=v_j->>'az_cod_aziendale';
			v_cod_tipo_impresa:=v_j->>'cod_tipo_impresa';
			--v_data_inizio_validita:=v_j->>'data_inizio_validita';
		
			if v_cod_tipo_impresa != 'P' then
				if (v_piva='' or v_piva is null) then
					ret.esito:=false;	
	        		ret:=cu_ui.build_ret(ret,proc_name,'partita_iva_obbligatoria');
					ret.info='0';
					return ret;
				end if;
			else
				if (v_cf='' or v_cf is null) then 
					ret.esito:=false;	
	        		ret:=cu_ui.build_ret(ret,proc_name,'codice_fiscale_obbligatoria_per_persone');
					ret.info='0';
					return ret;
				end if;
			end if;
		
			if v_cod_tipo_impresa is null or v_cod_tipo_impresa = '' then
				if length(v_cf)=16 and (v_piva is null or v_piva ='') then
					v_tiposoggetto:='F';
				else
					v_tiposoggetto:='G';
				end if;
			else
				if v_cod_tipo_impresa = 'P' then
					v_tiposoggetto:='F';
				else
					v_tiposoggetto:='G';
				end if;
			end if;
		
			if v_j->>'data_fine_validita' != '' and v_j->>'data_fine_validita' is not null then
				v_data_fine_validita:=v_j->>'data_fine_validita';
				v_data_fine_validita:= v_data_fine_validita + interval '1 day';
			end if;
			if v_j->>'data_inizio_validita' != '' and v_j->>'data_inizio_validita' is not null then
				v_data_inizio_validita:=v_j->>'data_inizio_validita'; 
			end if;
			if v_data_inizio_validita is not null and  v_data_fine_validita is not null
					and v_data_inizio_validita >= v_data_fine_validita then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'inizio_e_fine_validita_non_compatibli');
				ret.info='0';
				return ret;
			end if;
			raise notice 'v_data_fine_validita %',v_data_fine_validita;
			if v_data_fine_validita is not null  and 
				v_data_fine_validita <= 
				coalesce(upper(R_IMP.validita),v_data_fine_validita) then
				raise notice 'call cu_anag.upd_cu_del_impresa';
				ret:= cu_anag.upd_cu_del_impresa(v_j,idtransazione);
				if not ret.esito then
					return ret;
				end if;
			end if;
			select * into R_IMP from cu_anag.imprese where id=v_id_impresa;
			v_validita:=tsrange(coalesce(v_data_inizio_validita,lower(R_IMP.validita)),
								coalesce(v_data_fine_validita,upper(R_IMP.validita)),'[)');
			ret:=cu_anag.check_impresa(v_j,idtransazione);
			if not ret.esito then
				return ret;
			end if;

			raise notice 'v=%',v_j;
			select min(i),max(f) into ini, fin from (
				select lower(validita) i,upper(validita) f from cu_anag.stabilimenti where id_impresa=v_id_impresa
			) v;
			if ini < v_data_inizio_validita then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'inizio_validita_incompatibile_con_stabilimenti');
				ret.info='0';
				return ret;
			end if;
			if fin > v_data_fine_validita then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'fine_validita_incompatibile_con_stabilimenti');
				ret.info='0';
				return ret;
			end if;
		
			select count(*) into ns from cu_anag.vw_impresa_sedi where id_impresa=v_id_impresa and upper(sigla_tipo_sede)='SL';
			select count(*) into nf from cu_anag.vw_impresa_figure where id_impresa=v_id_impresa and  upper(cod_tipo_figura) = 'LEGALE RAPPRESENTANTE';
			if ns >0 and nf >0 then v_verificato=true; else v_verificato=false; end if;
			if (not R_IMP.verificato) and v_verificato then
				for v_id in select id from cu_anag.stabilimenti where id_impresa=v_id_impresa and not verificato loop
					update cu_anag.stabilimenti set verificato=true where id=v_id returning * into R_STAB;
					n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_STAB,'I');					
				end loop;
			end if;
			if v_cod_tipo_impresa = 'P' or  v_cod_tipo_impresa='Z' then
				v_sdi:=null;
			end if;
			update cu_anag.imprese 
			set nome = v_nome,
				piva = v_piva,
				pec = v_pec,
				email = v_email,
				sdi = v_sdi,
				split_payement = v_split_payement,
				cf = v_cf,
				cod_tipo_impresa = v_cod_tipo_impresa,
				validita = v_validita,
				verificato=v_verificato,
				tipo_soggetto=v_tiposoggetto
				
			where id = v_id_impresa returning * into R_IMP;

			n:=cu_log.upd_record('cu_anag.imprese',idtransazione,R_IMP,'U');
			
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    	ret.info = '0';
 			return ret;
		end;
	end;
$$;


ALTER FUNCTION cu_anag.upd_cu_imprese(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_indirizzi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_indirizzi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type; -- start
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		v_fonte varchar;
		istatcomune varchar;
		proc_name varchar; -- end
		v_j json;
		R_IND cu_anag.indirizzi;
		n integer;
	

	
		begin
			proc_name:='cu_anag.upd_cu_indirizzi';
			v_j:=v::json;
			v_id_indirizzo:=v_j->'id_indirizzo';
			v_fonte:=v_j->>'fonte';
			v_indirizzo:=cu_anag.string_normalize(v_j->>'indirizzo');
			v_indirizzo:=cu_anag.string_normalize(v_indirizzo);
			v_civico:=cu_anag.string_normalize(v_j->>'civico');
			v_indirizzo:= cu_anag.string_normalize(v_indirizzo);
			v_comune:=cu_anag.string_normalize_upper(v_j->>'comune');

			v_toponimo:=cu_anag.string_normalize_upper(v_j->>'toponimo');

			v_cap:=cu_anag.string_normalize_upper(v_j->>'cap');

			v_nazione:=cu_anag.string_normalize_upper(v_j->>'nazione');

			v_provincia:=cu_anag.string_normalize_upper(v_j->>'stato_provincia');

			istatcomune:=cu_anag.string_normalize_upper(v_j->>'istat_comune');

			if v_fonte is null or v_fonte = '' then
				v_fonte:= 'GISA-FVG';
			end if;
			if v_cap is null or v_cap = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'cap_obbligatorio');
					return ret;
			end if;
			if v_indirizzo is null or v_indirizzo = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_obbligatorio');
					return ret;
			end if;
		
			if istatcomune is null or istatcomune='' then
				if v_nazione is null or v_nazione = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_nazione');
					return ret;
				end if;
				if v_comune is null or v_comune = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_comune');
					return ret;
				end if;
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune = v_comune,
					toponimo = v_toponimo,
					civico = v_civico,
					cap = v_cap,
					nazione = v_nazione,
					stato_prov = v_provincia,
					istat_comune = null,
					fonte = v_fonte
				where id = v_id_indirizzo returning * into R_IND;
			else
				select count(*) into n from conf_ext.vw_comuni_vigenti_attivi c
					where c.codice_istat = istatcomune;
				if n > 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_non_valido');
					return ret;
				end if;	
				if n < 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_inesistente');
					return ret;
				end if;	
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune= null,
					toponimo = v_toponimo,
					civico = v_civico,
					istat_comune = lpad(trim(istatcomune),6,'0'),
					cap = v_cap,
					nazione = null,
					stato_prov = null,
					fonte = v_fonte
				where id = v_id_indirizzo  returning * into R_IND;
			end if;
			n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'U');
			ret.esito:=true;
	    	--ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    	ret.info = '0';
 			return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_indirizzi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_linea_stabilimenti(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_linea_stabilimenti(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	v_id_stabilimento bigint;
	v_id_linea bigint;
	v_data_inizio_validita timestamp;
	v_data_fine_validita timestamp;
	v_linea_principale boolean;
	v_id_tipo_linea bigint;
	v_j json;
	R_STAB cu_anag.stabilimenti;
	R_SL cu_anag.linee;
	v_validita tsrange;
	n integer;
	begin
		proc_name:='cu_anag.upd_cu_linea_stabilimenti';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
	raise notice 'idstrutturaroot=%',idstrutturaroot;
	raise notice 'v=%',v;
		v_j:=v::json;
		v_id_stabilimento = v->'id_stabilimento';
		v_id_linea:=v_j->>'id_linea';
		v_data_inizio_validita:=v_j->>'data_inizio_validita';
		--v_linea_principale:=v_j->>'linea_principale';
		if v_j->>'data_fine_validita' != '' then
			v_data_fine_validita:=v_j->>'data_fine_validita';
			v_data_fine_validita:=v_data_fine_validita+interval '1 day';
			v_linea_principale:=false;
		end if;
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
		--raise notice 'data_ultima_visita%',v_data_ultima_visita;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
	
		if v_data_inizio_validita >= v_data_fine_validita then
			ret.esito:=false;	
    		ret:=cu_ui.build_ret(ret,proc_name,'inizio_e_fine_validita_non_compatibili');
			ret.info='0';
			return ret;
		end if;
			
		select * into R_SL from cu_anag.linee where id=v_id_linea;
		--R_SF.validita:=tsrange(v_data_fine_validita,v_data_fine_validita,'[]');
	
		select * into R_STAB from cu_anag.stabilimenti where id=R_SL.id_stabilimento;
		v_validita:=tsrange(v_data_inizio_validita,upper(R_STAB.validita),'[)');

		--if not (R_STAB.validita @> R_SL.validita) then
		if not (R_STAB.validita @> v_validita) then
			ret.esito:=false;	
    		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_stabilimento');
			ret.info='0';
			return ret;
		end if;
	
		--select * into R_STAB from cu_anag.stabilimenti where id=R_SL.id_stabilimento;
		v_validita:=tsrange(v_data_inizio_validita,v_data_fine_validita,'[)');
		raise notice 'validita %',v_validita;
		if not (R_STAB.validita @> v_validita) then
			ret.esito:=false;	
    		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_stabilimento_fine_validita');
			ret.info='0';
			return ret;
		end if;

		select * into R_SL from cu_anag.linee
		where id=v_id_stabilimento
			and id_tipo_linea =R_SL.id_tipo_linea
			and validita && v_validita
			and id!=R_SL.id
			limit 1;
		if R_SL.id is not null then
			ret.esito:=false;	
    		ret:=cu_ui.build_ret(ret,proc_name,'linea_gia_presente_per_validita');
			ret.info='0';
			return ret;
		end if;
	
	
		update cu_anag.linee
		set validita = v_validita
		    ,linea_principale = v_linea_principale
		where id = v_id_linea returning * into R_SL;
		n:=cu_log.upd_record('cu_anag.linee',idtransazione,R_SL,'U');

		
		ret.esito:=true;
    	ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
    	ret.info = '0';
		return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_linea_stabilimenti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_soggetti_fisici(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_soggetti_fisici(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		ret_cf cu_types.result_type; -- start
		v_id_soggetto_fisico bigint;
		v_titolo varchar;
		v_nome varchar;
		v_cognome varchar;
		v_comune_nascita varchar;
		v_pec varchar;
		v_email varchar;
		v_cf varchar;
		v_sesso varchar;
		v_telefono varchar;
		v_telefono2 varchar;
		v_data_nascita timestamp;
		v_documento_identita varchar;
		cn varchar;
		v_j json;
		j_cf json;
		s varchar;
		n integer;
		R_SF cu_anag.soggetti_fisici;
		R_IND cu_anag.indirizzi;
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		v_fonte varchar;
		istatcomune varchar;
		proc_name varchar; -- end
		begin 
			proc_name:='cu_anag.upd_cu_soggetti_fisici';
			v_j:=v::json;
			v_id_soggetto_fisico:=v_j->'id_soggetto_fisico';
			--v_titolo:=cu_anag.string_normalize_upper(v_j->>'titolo');
			v_cognome:=cu_anag.string_normalize_upper(v_j->>'cognome');
			v_pec:=cu_anag.string_normalize(v_j->>'pec');
			v_email:=cu_anag.string_normalize(v_j->>'email');
			v_nome:=cu_anag.string_normalize_upper(v_j->>'nome');
			v_comune_nascita:=cu_anag.string_normalize_upper(v_j->>'comune_nascita');
			v_sesso:=cu_anag.string_normalize_upper(v_j->>'sesso');
			v_cf:=cu_anag.string_normalize_upper(v_j->>'cf');
			v_telefono:=cu_anag.string_normalize_upper(v_j->>'telefono');
			v_telefono2:=cu_anag.string_normalize_upper(v_j->>'telefono2');
			v_data_nascita:=v_j->>'data_nascita';
			v_documento_identita:=cu_anag.string_normalize_upper(v_j->>'documento_identita');
		
			select * into R_SF from cu_anag.soggetti_fisici sf where id=v_id_soggetto_fisico;
		
			if R_SF.id is null then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'id_soggetto_fisico_non_presente');
	    		ret.info = null;
	    		return ret;
			end if;
			if R_SF.codice_fiscale !=  v_cf then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'soggetto_fisico_e_codice_fiscale_incongruente');
	    		ret.info = null;
	    		return ret;
			end if;
			/*v_id_indirizzo:=v_j->'id_indirizzo';
			v_indirizzo:=cu_anag.string_normalize(v_j->>'indirizzo');
			v_indirizzo:=cu_anag.string_normalize(v_indirizzo);
			v_civico:=cu_anag.string_normalize(v_j->>'civico');
			v_indirizzo:= cu_anag.string_normalize(v_indirizzo);
			v_comune:=cu_anag.string_normalize_upper(v_j->>'comune');

			v_toponimo:=cu_anag.string_normalize_upper(v_j->>'toponimo');

			v_cap:=cu_anag.string_normalize_upper(v_j->>'cap');

			v_nazione:=cu_anag.string_normalize_upper(v_j->>'nazione');

			v_provincia:=cu_anag.string_normalize_upper(v_j->>'stato_provincia');

			istatcomune:=cu_anag.string_normalize_upper(v_j->>'istat_comune');*/	
		
			if v_fonte is null or v_fonte = '' then
				v_fonte:= 'GISA-FVG';
			end if;
		
			ret_cf:=cu_anag.split_check_cf(v_cf,v_nome,v_cognome,v_data_nascita::date,v_sesso,v_comune_nascita);
			if not ret_cf.esito then
				return ret_cf;
			end if;
			/*if  not cu_anag.check_cf(v_cf) then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_non_corretto');
	    		ret.info = null;
	    		return ret;
			end if;
		 	j_cf:=cu_anag.split_cf(v_cf);
			if j_cf is null then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'codice_fiscale_non_separabile_in_campi');
	    		ret.info = null;
	    		return ret;
			end if;
			raise notice 'SPLITCF % CF%',v_cf,j_cf;
			if  (j_cf->>'comune')::varchar != v_comune_nascita then
				raise notice 'COMUNE % %',j_cf->>'comune',v_comune_nascita;
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'codice_catastale_comune_di_nascita_non_congruente_con_codice_fiscale');
	    		ret.info = null;
	    		return ret;
			end if;
           	if  (j_cf->>'sesso')::varchar != v_sesso then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'sesso_non_congruente_con_codice_fiscale');
	    		ret.info = null;
	    		return ret;
			end if;
		    if  (j_cf->>'nascita')::varchar != to_char(v_data_nascita,'YYMMDD') then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'data_nascita_non_congruente_con_codice_fiscale');
	    		ret.info = null;
	    		return ret;
			end if;*/
			select count(*) into n from conf_ext.vw_codici_vigenti_catastali where codcatastale=v_comune_nascita;
			if  n < 1 then
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'codice_catastale_non_presente');
	    		ret.info = null;
	    		return ret;
			end if;
			raise notice 'v=%',v_j;
		
				/*		if istatcomune is null or istatcomune='' then
				if v_nazione is null or v_nazione = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_nazione');
					return ret;
				end if;
				if v_comune is null or v_comune = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_comune');
					return ret;
				end if;
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune = v_comune,
					toponimo = v_toponimo,
					civico = v_civico,
					cap = v_cap,
					nazione = v_nazione,
					stato_prov = v_provincia,
					istat_comune = null,
					fonte = v_fonte
				where id = v_id_indirizzo returning * into R_IND;
			else
				select count(*) into n from conf_ext.vw_comuni_vigenti_attivi c
					where c.codice_istat = istatcomune;
				if n > 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_non_valido');
					return ret;
				end if;	
				if n < 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_inesistente');
					return ret;
				end if;	
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune= null,
					toponimo = v_toponimo,
					civico = v_civico,
					istat_comune = lpad(trim(istatcomune),6,'0'),
					cap = v_cap,
					nazione = null,
					stato_prov = null,
					fonte = v_fonte
				where id = v_id_indirizzo  returning * into R_IND;
			end if;
			n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'U'); */
		
			ret := cu_anag.upsert_indirizzi(v,idtransazione);
			
			update cu_anag.soggetti_fisici
			set nome = v_nome,
				--titolo = v_titolo,
				cognome = v_cognome,
				pec = v_pec,
				email = v_email,
				comune_nascita = v_comune_nascita,
				sesso = v_sesso,
				--codice_fiscale = v_cf,
				telefono = v_telefono,
				telefono2 = v_telefono2,
				data_nascita = v_data_nascita,
				documento_identita = v_documento_identita
			where id = v_id_soggetto_fisico returning * into R_SF;
			n:=cu_log.upd_record('cu_anag.soggetti_fisici',idtransazione,R_SF,'U');
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    	ret.info = '0';
 			return ret;
		end;
	end;
$$;


ALTER FUNCTION cu_anag.upd_cu_soggetti_fisici(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_stabilimenti(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_stabilimenti(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		v_id_stabilimento bigint;
		v_nome varchar;
		v_cod_regionale varchar;
		--v_id_tipologia_struttura varchar;
		v_id_tipologia_struttura bigint;
		v_categoria_rischio bigint;
		v_cod_nazionale varchar;
		v_pec varchar;
		v_telefono varchar;
		v_data_inizio_validita timestamp;
		v_data_fine_validita timestamp;
		v_sdi varchar;
		v_j json;
		R_S cu_anag.stabilimenti;
		R_IMP cu_anag.imprese;
		R_IND cu_anag.indirizzi;
		proc_name varchar; -- end
		msg varchar;
		--v_id_asl integer;
		ini timestamp;
		fin timestamp;
		R_TS cu_types.vw_tipologie_struttura;
		R_TS_NEW cu_types.vw_tipologie_struttura;
		R_I cu_anag.vw_imprese;
		v_validita tsrange;
	    v_validita_a tsrange;
		flag_aggiorna_sedi_figure bool;
		n integer;
		np integer;
		jarg json;
		ret_verificato cu_types.result_type;
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		v_fonte varchar;
		istatcomune varchar;
		begin 
			proc_name:='cu_anag.upd_cu_stabilimenti';
			v_j:=v::json;
			v_id_stabilimento:=v_j->'id_stabilimento';
			--v_cod_regionale:=cu_anag.string_normalize_upper(v_j->>'sd_cod_regionale');
			v_nome:=cu_anag.string_normalize(v_j->>'nome');
			--v_cod_nazionale:=cu_anag.string_normalize(v_j->>'cod_nazionale');
			--v_id_tipologia_struttura:=v_j->>'id_tipologia_struttura';
			--v_categoria_rischio:=v_j->>'categoria_rischio';
			v_data_inizio_validita:=v_j->>'data_inizio_validita';
			v_sdi:=v_j->>'sdi';
			--v_id_indirizzo:=v_j->'id_indirizzo';
			v_fonte:=v_j->>'fonte';
			v_indirizzo:=cu_anag.string_normalize(v_j->>'indirizzo');
			v_indirizzo:=cu_anag.string_normalize(v_indirizzo);
			v_civico:=cu_anag.string_normalize(v_j->>'civico');
			v_indirizzo:= cu_anag.string_normalize(v_indirizzo);
			v_comune:=cu_anag.string_normalize_upper(v_j->>'comune');

			v_toponimo:=cu_anag.string_normalize_upper(v_j->>'toponimo');

			v_cap:=cu_anag.string_normalize_upper(v_j->>'cap');

			v_nazione:=cu_anag.string_normalize_upper(v_j->>'nazione');

			v_provincia:=cu_anag.string_normalize_upper(v_j->>'stato_provincia');

			istatcomune:=cu_anag.string_normalize_upper(v_j->>'istat_comune');
		raise notice 'istat %',istatcomune;
		
			select * into R_S from cu_anag.stabilimenti where id=v_id_stabilimento;
			if v_j->>'data_fine_validita' != '' and v_j->>'data_fine_validita' is not null then
				v_data_fine_validita:=(v_j->>'data_fine_validita')::date + interval '1 day';
			end if;
			if not upper_inf(R_S.validita) and v_data_fine_validita is null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'data_fine_validita_non_cancellabile');
				ret.info='0';
				return ret;
			end if;
			select * into R_TS from cu_types.vw_tipologie_struttura vts where id=R_S.id_tipologia_struttura;
			select * into R_I from cu_anag.vw_imprese where id=R_S.id_impresa;
			v_id_indirizzo := R_S.id_indirizzo;
			if v_id_indirizzo is not null then
				select id into v_id_indirizzo from cu_anag.indirizzi where id =v_id_indirizzo;
			end if;
			if v_id_indirizzo is null then
				insert into cu_anag.indirizzi values(nextval('cu_anag.cu_anag_id_seq'));
				v_id_indirizzo:=currval('cu_anag.cu_anag_id_seq');
			end if;
			if R_I.cod_tipo_impresa!='Z' then
				v_sdi=null;
			end if;

			if not R_TS.modifica then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'identificativo_tipologia_struttura_non_modificabile');
				ret.info='0';
				return ret;
			end if;

			raise notice 'data inizio val %',v_data_inizio_validita;
			if v_j->>'data_fine_validita' != '' and v_j->>'data_fine_validita' is not null then
				v_data_fine_validita:=(v_j->>'data_fine_validita')::date + interval '1 day';
			end if;
		
			if v_j->>'data_inizio_validita' != '' and v_j->>'data_inizio_validita' is not null then
				v_data_inizio_validita:=v_j->>'data_inizio_validita';
			end if;
		
			if v_data_inizio_validita is not null and  v_data_fine_validita is not null
					and v_data_inizio_validita >= v_data_fine_validita then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'inizio_e_fine_validita_non_compatibli');
				ret.info='0';
				return ret;
			end if;
			select * into R_IMP from cu_anag.imprese where id=R_S.id_impresa;
			raise notice 'data fine % R_S.validita %',v_data_fine_validita,R_S.validita;
			raise notice 'upper   %', upper(R_S.validita);
			raise notice 'coalesce %',coalesce(upper(R_S.validita),v_data_fine_validita);

			--v_id_asl:=v_j->'id_asl';
			v_pec:=cu_anag.string_normalize(v_j->>'pec');
			v_telefono:=cu_anag.string_normalize(v_j->>'telefono');
			raise notice 'v=%',v_j;
			ret:=cu_anag.check_stabilimento(v,idtransazione);
			if not ret.esito then
				return ret;
			end if;
			
			raise notice 'data inizio val %',v_data_inizio_validita;
			
			if v_data_inizio_validita is null then v_data_inizio_validita=lower(R_S.validita); end if;
			raise notice 'data inizio val %',v_data_inizio_validita;			
			/*if v_data_fine_validita is null then
				v_data_fine_validita=upper(R_S.validita);
			end if;*/
			raise notice 'data inizio val %',v_data_inizio_validita;			
			v_validita:=tsrange(v_data_inizio_validita,v_data_fine_validita,'[)');
			raise notice 'VALIDITA %',v_validita;
		

			--v_validita:=tsrange(v_data_inizio_validita,v_data_fine_validita,'[)');
			raise notice 'R_IMP % v_validita_a %',R_IMP.validita,v_validita_a;
			if not upper_inf(R_IMP.validita) and (upper(R_IMP.validita) < v_data_fine_validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_impresa');
				ret.info='0';
				return ret;
			end if;
		
			select * into R_TS from cu_types.vw_tipologie_struttura vts where id=R_S.id_tipologia_struttura;

		
			/*if not R_TS.modificabile or R_TS.modificabile is null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'identificativo_tipologia_struttura_non_modificabile');
				ret.info='0';
				return ret;
			end if ;*/

			msg:=null;

			if not R_S.verificato or R_S.verificato is null then
				jarg:='{"id_stabilimento":'||R_S.id||',"id_impresa":'||R_S.id_impresa||'}';
				ret_verificato:= cu_anag.check_stabilimento_valido(jarg,idtransazione);
				/*select count(*) into np from (
					select id from cu_anag.vw_impresa_figure vif where id_impresa =R_S.id_impresa and 
								validita @> current_timestamp::timestamp
								and cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE'
					union
					select id from cu_anag.vw_stabilimento_figure vif where id_stabilimento =v_id_stabilimento and 
								validita @> current_timestamp::timestamp
								and cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE'
				) a;
				if np > 0 then
					R_S.verificato:=true;
				else
					R_S.verificato:=false;
				end if;*/
				R_S.verificato:=ret_verificato.esito;
			end if;
		
			if v_data_fine_validita is not null and 
				(v_data_fine_validita <= coalesce(upper(R_S.validita),v_data_fine_validita))  then
				flag_aggiorna_sedi_figure=true;
			else
				flag_aggiorna_sedi_figure=false;
			end if;
				
			if flag_aggiorna_sedi_figure  then
				raise notice 'AGGIORNA FIGURE E SEDI v=% %',v,v_j;
				ret:= cu_anag.upd_cu_del_stabilimento(v,idtransazione);
				if not ret.esito then
					return ret;
				end if;
			end if;

			if v_fonte is null or v_fonte = '' then
				v_fonte:= 'GISA-FVG';
			end if;
			if v_cap is null or v_cap = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'cap_obbligatorio');
					return ret;
			end if;
			if v_indirizzo is null or v_indirizzo = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_obbligatorio');
					return ret;
			end if;
		
			/*if istatcomune is null or istatcomune='' then
				if v_nazione is null or v_nazione = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_nazione');
					return ret;
				end if;
				if v_comune is null or v_comune = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_comune');
					return ret;
				end if;
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune = v_comune,
					toponimo = v_toponimo,
					civico = v_civico,
					cap = v_cap,
					nazione = v_nazione,
					stato_prov = v_provincia,
					istat_comune = null,
					fonte = v_fonte
				where id = v_id_indirizzo returning * into R_IND;
			else
				select count(*) into n from conf_ext.vw_comuni_vigenti_attivi c
					where c.codice_istat = istatcomune;
				if n > 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_non_valido');
					return ret;
				end if;	
				if n < 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_inesistente');
					return ret;
				end if;	
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune= null,
					toponimo = v_toponimo,
					civico = v_civico,
					istat_comune = lpad(trim(istatcomune),6,'0'),
					cap = v_cap,
					nazione = null,
					stato_prov = null,
					fonte = v_fonte
				where id = v_id_indirizzo  returning * into R_IND;
			end if; 
			n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'U'); */
			update cu_anag.stabilimenti 
			set nome = v_nome,
				--cod_regionale = v_cod_regionale,
				--id_tipologia_struttura = v_id_tipologia_struttura,
				--cod_nazionale = v_cod_nazionale,
				categoria_rischio = v_categoria_rischio,
				verificato = R_S.verificato,
				validita = v_validita,
				--id_asl = v_id_asl,
				id_indirizzo=v_id_indirizzo,
				sdi=v_sdi,
				pec = v_pec,
				telefono = v_telefono,
				fonte='GISA-FVG'
			where id = v_id_stabilimento returning * into R_S; 
		
			ret := cu_anag.upsert_indirizzi(v,idtransazione);

		
			n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_S,'U');
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, coalesce(msg,'salvataggio_effettuato_con_successo'));
	    	ret.info = '0';
 			return ret;
		end;
	end;

$$;


ALTER FUNCTION cu_anag.upd_cu_stabilimenti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_stabilimenti_deb(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_stabilimenti_deb(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		v_id_stabilimento bigint;
		v_nome varchar;
		v_cod_regionale varchar;
		--v_id_tipologia_struttura varchar;
		v_id_tipologia_struttura bigint;
		v_categoria_rischio bigint;
		v_cod_nazionale varchar;
		v_pec varchar;
		v_telefono varchar;
		v_data_inizio_validita timestamp;
		v_data_fine_validita timestamp;
		v_sdi varchar;
		v_j json;
		R_S cu_anag.stabilimenti;
		R_IMP cu_anag.imprese;
		R_IND cu_anag.indirizzi;
		proc_name varchar; -- end
		msg varchar;
		--v_id_asl integer;
		ini timestamp;
		fin timestamp;
		R_TS cu_types.vw_tipologie_struttura;
		R_TS_NEW cu_types.vw_tipologie_struttura;
		R_I cu_anag.vw_imprese;
		v_validita tsrange;
		flag_aggiorna_sedi_figure bool;
		n integer;
		np integer;
		jarg json;
		ret_verificato cu_types.result_type;
		begin 
			proc_name:='cu_anag.upd_cu_stabilimenti';
			v_j:=v::json;
			v_id_stabilimento:=v_j->'id_stabilimento';
			--v_cod_regionale:=cu_anag.string_normalize_upper(v_j->>'sd_cod_regionale');
			v_nome:=cu_anag.string_normalize(v_j->>'nome');
			--v_cod_nazionale:=cu_anag.string_normalize(v_j->>'cod_nazionale');
			--v_id_tipologia_struttura:=v_j->>'id_tipologia_struttura';
			v_categoria_rischio:=v_j->>'categoria_rischio';
			v_data_inizio_validita:=v_j->>'data_inizio_validita';
			v_sdi:=v_j->>'sdi';
		
			select * into R_S from cu_anag.stabilimenti where id=v_id_stabilimento;
			select * into R_TS from cu_types.vw_tipologie_struttura vts where id=R_S.id_tipologia_struttura;
			select * into R_I from cu_anag.vw_imprese where id=R_S.id_impresa;
			if R_I.cod_tipo_impresa!='Z' then
				v_sdi=null;
			end if;

			if not R_TS.modificabile  then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'identificativo_tipologia_struttura_non_modificabile');
				ret.info='0';
				return ret;
			end if;

			raise notice 'data inizio val %',v_data_inizio_validita;
			if v_j->>'data_fine_validita' != '' and v_j->>'data_fine_validita' is not null then
				v_data_fine_validita:=(v_j->>'data_fine_validita')::date + interval '1 day';
			end if;
		
			if v_j->>'data_inizio_validita' != '' and v_j->>'data_inizio_validita' is not null then
				v_data_inizio_validita:=v_j->>'data_inizio_validita';
			end if;
		
			if v_data_inizio_validita is not null and  v_data_fine_validita is not null
					and v_data_inizio_validita >= v_data_fine_validita then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'inizio_e_fine_validita_non_compatibli');
				ret.info='0';
				return ret;
			end if;
			select * into R_IMP from cu_anag.imprese where id=R_S.id_impresa;
			raise notice 'data fine % R_S.validita %',v_data_fine_validita,R_S.validita;
			raise notice 'upper   %', upper(R_S.validita);
			raise notice 'coalesce %',coalesce(upper(R_S.validita),v_data_fine_validita);

			--v_id_asl:=v_j->'id_asl';
			v_pec:=cu_anag.string_normalize(v_j->>'pec');
			v_telefono:=cu_anag.string_normalize(v_j->>'telefono');
			raise notice 'v=%',v_j;
			ret:=cu_anag.check_stabilimento_deb(v,idtransazione);
			if not ret.esito then
				return ret;
			end if;
			
			raise notice 'data inizio val %',v_data_inizio_validita;
			
			if v_data_inizio_validita is null then v_data_inizio_validita=lower(R_S.validita); end if;
			raise notice 'data inizio val %',v_data_inizio_validita;			
			/*if v_data_fine_validita is null then
				v_data_fine_validita=upper(R_S.validita);
			end if;*/
			raise notice 'data inizio val %',v_data_inizio_validita;			
			v_validita:=tsrange(v_data_inizio_validita,v_data_fine_validita,'[)');
			raise notice 'VALIDITA %',v_validita;
		

			--v_validita:=tsrange(v_data_inizio_validita,v_data_fine_validita,'[)');
			raise notice 'R_IMP % v_validita %',R_IMP.validita,v_validita;
			if ((not upper_inf(R_IMP.validita)) and upper(R_IMP.validita) < v_validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_impresa');
				ret.info='0';
				return ret;
			end if;
return ret;
		
			select * into R_TS from cu_types.vw_tipologie_struttura vts where id=R_S.id_tipologia_struttura;

		
			if not R_TS.modificabile or R_TS.modificabile is null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'identificativo_tipologia_struttura_non_modificabile');
				ret.info='0';
				return ret;
			end if;

			msg:=null;

			if not R_S.verificato or R_S.verificato is null then
				jarg:='{"id_stabilimento":'||R_S.id||',"id_impresa":'||R_S.id_impresa||'}';
				ret_verificato:= cu_anag.check_stabilimento_valido(jarg,idtransazione);
				/*select count(*) into np from (
					select id from cu_anag.vw_impresa_figure vif where id_impresa =R_S.id_impresa and 
								validita @> current_timestamp::timestamp
								and cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE'
					union
					select id from cu_anag.vw_stabilimento_figure vif where id_stabilimento =v_id_stabilimento and 
								validita @> current_timestamp::timestamp
								and cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE'
				) a;
				if np > 0 then
					R_S.verificato:=true;
				else
					R_S.verificato:=false;
				end if;*/
				R_S.verificato:=ret_verificato.esito;
			end if;
		
			if v_data_fine_validita is not null and 
				(v_data_fine_validita <= coalesce(upper(R_S.validita),v_data_fine_validita))  then
				flag_aggiorna_sedi_figure=true;
			else
				flag_aggiorna_sedi_figure=false;
			end if;
				
			if flag_aggiorna_sedi_figure  then
				raise notice 'AGGIORNA FIGURE E SEDI v=% %',v,v_j;
				ret:= cu_anag.upd_cu_del_stabilimento(v,idtransazione);
				if not ret.esito then
					return ret;
				end if;
			end if;
			update cu_anag.stabilimenti 
			set nome = v_nome,
				--cod_regionale = v_cod_regionale,
				--id_tipologia_struttura = v_id_tipologia_struttura,
				--cod_nazionale = v_cod_nazionale,
				categoria_rischio = v_categoria_rischio,
				verificato = R_S.verificato,
				validita = v_validita,
				--id_asl = v_id_asl,
				sdi=v_sdi,
				pec = v_pec,
				telefono = v_telefono,
				fonte='GISA-FVG'
			where id = v_id_stabilimento returning * into R_S;

		
			n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_S,'U');
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, coalesce(msg,'salvataggio_effettuato_con_successo'));
	    	ret.info = '0';
 			return ret;
		end;
	end;

$$;


ALTER FUNCTION cu_anag.upd_cu_stabilimenti_deb(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_stabilimenti_linea_principale(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_stabilimenti_linea_principale(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idstabilimento bigint;
	idlinea bigint;
	v_id bigint;
	R_L cu_anag.linee;
	n integer;
	begin
		proc_name:='cu_anag.upd_cu_stabilimenti_linea_principale';
		idstabilimento = v->'id_stabilimento';
		idlinea = v->'id_linea';
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		
		ret.esito:=false;
		
		for v_id in
			select id from cu_anag.linee
			where id_stabilimento = idstabilimento and linea_principale loop
				update cu_anag.linee 
				set linea_principale = false
				where id =v_id
				returning * into R_L;
			n:=cu_log.upd_record('cu_anag.linee',idtransazione,R_L,'U');
		end loop;
	
		update cu_anag.linee
		set linea_principale = true
		where id = idlinea
		returning * into R_L;
		n:=cu_log.upd_record('cu_anag.linee',idtransazione,R_L,'U');
	
		ret.esito:=true;
	    --ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
 		return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_stabilimenti_linea_principale(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_stabilimento_subingresso(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_stabilimento_subingresso(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idimpresa bigint;
		idstabilimento bigint;
		datadomanda timestamp;
		v_j json;
		R_I cu_anag.vw_imprese_all;
		R_SS cu_anag.stabilimento_sedi;
		R_SF cu_anag.stabilimento_figure;
		R_STAB cu_anag.stabilimenti;
		R_STAB_S cu_anag.stabilimenti_storico;
		n integer;
		v_id bigint;
		jarg json;
		ret_verificato cu_types.result_type;
		vl timestamp;
		begin 
			proc_name:='cu_anag.upd_cu_stabilimento_subingresso';
			v_j:=v::json;
			ret.esito:=false;
			idstabilimento:=v_j->'id_stabilimento';
			idimpresa:=v_j->'id_impresa';
			datadomanda:=v_j->>'data_domanda';
			
			raise notice 'v=%',v_j;
		
			select * from cu_anag.vw_imprese_all into R_I where id_impresa = idimpresa;
			if R_I.id_impresa = null then
				ret:=cu_ui.build_ret(ret,proc_name,'impresa_non_trovata');
				ret.info='0';
				return ret;
			end if;
			if not (R_I.validita @> datadomanda) then
				ret:=cu_ui.build_ret(ret,proc_name,'impresa_non_attiva_alla_data_domanda');
				ret.info='0';
				return ret;
			end if;
		
			select * from cu_anag.stabilimenti into R_STAB where id = idstabilimento;
			if R_STAB.id = null then
				ret:=cu_ui.build_ret(ret,proc_name,'stabilimento_non_trovato');
				ret.info='0';
				return ret;
			end if;
			if not (R_STAB.validita @> datadomanda) then
				ret:=cu_ui.build_ret(ret,proc_name,'stabilimento_non_attivo_alla_data_domanda');
				ret.info='0';
				return ret;
			end if;
			select max(upper(validita)) into vl from cu_anag.stabilimenti_storico where id_stabilimento =R_STAB.id;
			if (vl is null) then vl:=lower(R_STAB.validita); end if;
			if (vl >= datadomanda) then
				ret:=cu_ui.build_ret(ret,proc_name,'data_domanda_non_valida');
				ret.info='0';
				return ret;
			end if;

			if idimpresa = R_STAB.id_impresa then
				ret:=cu_ui.build_ret(ret,proc_name,'subingresso_non_consentito_per_la_stessa_impresa');
				ret.info='0';
				return ret;
			end if;

			insert into cu_anag.stabilimenti_storico (id_stabilimento, id_impresa, validita, note)
			values(
				R_STAB.id,
				R_STAB.id_impresa,
				tsrange(vl,datadomanda,'[)'),
				'SUBINGRESSO'
			) returning * into R_STAB_S;
			n:=cu_log.upd_record('cu_anag.stabilimenti_storico',idtransazione,R_STAB,'U');
		
			--update stabilimento validita[datadomanda,)
			update cu_anag.stabilimenti
			set id_impresa = idimpresa
			where id = idstabilimento returning * into R_STAB;
			n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_STAB,'U');
			/* VERIFICA STABILIMENTO VALIDO */
			jarg:='{"id_stabilimento":'||idstabilimento||',"id_impresa":'||idimpresa||'}';
			ret_verificato:= cu_anag.check_stabilimento_valido(jarg,idtransazione);
			if ret_verificato.esito != R_STAB.verificato then
				update cu_anag.stabilimenti
				set id_impresa = idimpresa,verificato=ret_verificato.esito
				where id = idstabilimento returning * into R_STAB;
				n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_STAB,'U');
			end if;

			/*    */
		
			--insert into storico validita [inizio, datadomanda)

		
			--cessa sedi e figure ancora attive
			for v_id in select id from cu_anag.stabilimento_sedi
				where id_stabilimento = idstabilimento and validita @> datadomanda  loop
					update cu_anag.stabilimento_sedi 
					set validita = tsrange(lower(validita),datadomanda+interval '1 day','[)')
					where id=v_id returning * into R_SS;
					n:=cu_log.upd_record('cu_anag.stabilimento_sedi',idtransazione,R_SS,'U');
			end loop;
		
			for v_id in select id from cu_anag.stabilimento_figure
				where id_stabilimento = idstabilimento and validita @> datadomanda  loop
					update cu_anag.stabilimento_figure 
					set validita = tsrange(lower(validita),datadomanda+interval '1 day','[)')
					where id=v_id returning * into R_SF;
					n:=cu_log.upd_record('cu_anag.stabilimento_figure',idtransazione,R_SF,'U');
			end loop;
						
		
		
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
	        ret.info = '0';
			return ret;
		end;
		

	END;

$$;


ALTER FUNCTION cu_anag.upd_cu_stabilimento_subingresso(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_stato_pratica(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_stato_pratica(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- start
        proc_name varchar; -- end
		R_P cu_anag.pratiche;
		idstato int;
		r record;
		n bigint;
	begin
		proc_name:='cu_anag.upd_cu_stato_pratica';
		raise notice 'V_J=%', v_j;
		ret.esito:=false;
	
	
		if v_j->>'id_pratica' is not null then
			select * into R_P from cu_anag.pratiche where id= (v_j->>'id_pratica')::int;
			if R_P.id is null then
				ret:=cu_ui.build_ret(ret,proc_name,'pratica_non_trovato');
				return ret;
			end if;
		end if;
		
		if (select descr from cu_types.vw_stati_pratiche where id = R_P.stato) in ('Creato', 'Chiuso') then 
			select id into idstato from cu_types.vw_stati_pratiche where descr = 'Aperto';
		else
			select id into idstato from cu_types.vw_stati_pratiche where descr = 'Chiuso';
		end if;
	
		update cu_anag.pratiche 
		set stato = idstato
		where id = R_P.id returning * into r;
		n:=cu_log.upd_record('cu_anag.pratiche',idtransazione,r,'U');
	
		insert into cu_anag.storico_pratiche (id_pratica, id_stato_pratica,dt, user_id) 
		values(R_P.id, idstato, (select current_timestamp),(v_j->'user_info'->>'id_utente_struttura_ruolo')::int) returning * into r;
		n:=cu_log.upd_record('cu_anag.storico_pratiche',idtransazione,r,'I');
		
		
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '0';
	   
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu_anag.upd_cu_stato_pratica(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_upd_imprese_figure(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_upd_imprese_figure(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		v_stab_verificato cu_types.result_type; -- start
		v_j json;
		v_id_impresa_figura bigint;
		v_data_inizio_validita timestamp;
		v_data_fine_validita timestamp;
		proc_name varchar; -- end
		R_IF cu_anag.impresa_figure;
		R_IMP cu_anag.imprese;
		R_IND cu_anag.indirizzi;
		R_STAB cu_anag.stabilimenti;	
		R_TFI cu_types.tipi_figura_impresa;
		v_id_impresa bigint;
		v_validita tsrange;
		n integer;
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		v_fonte varchar;
		istatcomune varchar;
		ns integer;
		jarg json;
		begin 
			proc_name:='cu_anag.upd_cu_upd_imprese_figure';
			v_j:=v::json;
			if v_j->>'data_fine_validita' != '' then
				v_data_fine_validita:=(v_j->>'data_fine_validita')::date + interval '1 day';
			end if;
			v_id_impresa_figura:=v_j->'id_impresa_figura';
			v_id_impresa:=v_j->'id_impresa';
			v_data_inizio_validita:=v_j->>'data_inizio_validita';
			--v_data_fine_validita:=v_j->>'data_fine_validita';
			
			raise notice 'v=%',v_j;
			
			if v_data_inizio_validita >= v_data_fine_validita then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'inizio_e_fine_validita_non_compatibli');
				ret.info='0';
				return ret;
			end if;

		/*	v_id_indirizzo:=v_j->'id_indirizzo';
			v_indirizzo:=cu_anag.string_normalize(v_j->>'indirizzo');
			v_indirizzo:=cu_anag.string_normalize(v_indirizzo);
			v_civico:=cu_anag.string_normalize(v_j->>'civico');
			v_indirizzo:= cu_anag.string_normalize(v_indirizzo);
			v_comune:=cu_anag.string_normalize_upper(v_j->>'comune');

			v_toponimo:=cu_anag.string_normalize_upper(v_j->>'toponimo');

			v_cap:=cu_anag.string_normalize_upper(v_j->>'cap');

			v_nazione:=cu_anag.string_normalize_upper(v_j->>'nazione');

			v_provincia:=cu_anag.string_normalize_upper(v_j->>'stato_provincia');

			istatcomune:=cu_anag.string_normalize_upper(v_j->>'istat_comune'); */
			
			if v_fonte is null or v_fonte = '' then
				v_fonte:= 'GISA-FVG';
			end if;
		
			select * into R_IF from cu_anag.impresa_figure where id=v_id_impresa_figura;
			--R_IF.validita:=tsrange(v_data_fine_validita,v_data_fine_validita,'[]');
		
			select * into R_IMP from cu_anag.imprese where id=R_IF.id_impresa;
			if upper(R_IMP.validita) is not null and v_data_inizio_validita > upper(R_IMP.validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_supera_validita_impresa');
				ret.info='0';
				return ret;
			end if;
			v_validita:=tsrange(v_data_inizio_validita,v_data_fine_validita,'[)');--upper(R_IMP.validita),'[)');
			if not (R_IMP.validita @> v_validita ) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_impresa');
				ret.info='0';
				return ret;
			end if;
		/*
			select * into R_IMP from cu_anag.imprese where id=R_IF.id_impresa;
			v_validita:=tsrange(v_data_inizio_validita,v_data_fine_validita,'[)');
			raise notice 'validita %',v_validita;
			if not (R_IMP.validita @> v_validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_impresa_fine_validita');
				ret.info='0';
				return ret;
			end if;*/
			--insert into cu_anag.soggetti_fisici (id,nome,cognome,codice_fiscale,indirizzo_id) values(nextval('cu_anag.cu_anag_id_seq'),v_nome,v_cognome,v_cf,idindirizzo) returning id into idsoggettofisico;
		
			--raise notice 'idsoggettofisico=%',idsoggettofisico;
			select * into R_IF from cu_anag.impresa_figure
			where id_impresa=v_id_impresa
				and id_tipo_figura =R_IF.id_tipo_figura
				and validita && v_validita
				and id!=R_IF.id
				limit 1;
			if R_IF.id is not null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'figura_gia_presente_per_validita');
				ret.info='0';
				return ret;
			end if;
		
		/*	if istatcomune is null or istatcomune='' then
				if v_nazione is null or v_nazione = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_nazione');
					return ret;
				end if;
				if v_comune is null or v_comune = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_comune');
					return ret;
				end if;
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune = v_comune,
					toponimo = v_toponimo,
					civico = v_civico,
					cap = v_cap,
					nazione = v_nazione,
					stato_prov = v_provincia,
					istat_comune = null,
					fonte = v_fonte
				where id = v_id_indirizzo returning * into R_IND;
			else
				select count(*) into n from conf_ext.vw_comuni_vigenti_attivi c
					where c.codice_istat = istatcomune;
				if n > 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_non_valido');
					return ret;
				end if;	
				if n < 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_inesistente');
					return ret;
				end if;	
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune= null,
					toponimo = v_toponimo,
					civico = v_civico,
					istat_comune = lpad(trim(istatcomune),6,'0'),
					cap = v_cap,
					nazione = null,
					stato_prov = null,
					fonte = v_fonte
				where id = v_id_indirizzo  returning * into R_IND;
			end if;
			n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'U'); */
		
			ret := cu_anag.upsert_indirizzi(v,idtransazione);
			raise notice 'ret.info:%',ret.info;
			if ret.info is not null and ret.info <> '0' then
				v_id_indirizzo := ret.info;
			end if;
			
			raise notice 'id indirizzo%',v_id_indirizzo;
			if v_id_indirizzo is not null then
				update cu_anag.impresa_figure 
				set id_indirizzo = v_id_indirizzo
				where id = v_id_impresa_figura;
			end if; 
			
			update cu_anag.impresa_figure 
			set validita = v_validita
			where id = v_id_impresa_figura
							returning * into R_IF;
			n:=cu_log.upd_record('cu_anag.impresa_figure',idtransazione,R_IF,'U');

			select * into R_TFI from cu_types.vw_tipi_figura_impresa vtfi where id=R_IF.id;

			if  upper(R_TFI.sigla)='LEGALE RAPPRESENTANTE' then 
				if (not R_IMP.verificato) then 
					select count(*) into ns from cu_anag.vw_impresa_sedi
						where id_impresa=v_id_impresa and cod_tipo_figura ilike 'SL';
					if ns > 0 then
						update cu_anag.imprese set verificato=true where id=v_id_impresa returning * into R_IMP;
						n:=cu_log.upd_record('cu_anag.imprese',idtransazione,R_IS,'I');
					end if;
				end if;
	
				for R_STAB in select * from cu_anag.stabilimenti where id_impresa=v_id_impresa loop
					jarg:='{"id_stabilimento":'||R_STA.id||',"id_impresa":'||v_id_impresa||'}';
					v_stab_verificato:= cu_anag.check_stabilimento_valido(jarg,idtransazione);
					if v_stab_verificato.esito != R_STAB.verificato then
						update cu_anag.stabilimenti set verificato=v_stab_verificato.esito
						where id=v_id returning * into R_STAB;
						n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_STAB,'I');
					end if;
				end loop;
				
			end if;
			
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    	ret.info = '0';
 			return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_upd_imprese_figure(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_upd_imprese_sedi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_upd_imprese_sedi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		v_stab_verificato cu_types.result_type; -- start
		v_id_impresa bigint;
--		v_piva varchar;
		v_pec varchar;
		v_email varchar;
--		v_sdi varchar;
--		v_split_payement varchar;
--		v_cf varchar;
--		v_cod_tipo_impresa varchar;
		v_j json;
		v_id_impresa_sedi bigint;
		v_data_inizio_validita timestamp;
		v_data_fine_validita timestamp;
		proc_name varchar; -- end
		idimpresa bigint;
		R_IMP cu_anag.imprese;
		R_IS cu_anag.impresa_sedi;
		R_IND cu_anag.indirizzi;
		v_validita tsrange;
		n integer;
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		v_fonte varchar;
		istatcomune varchar;
		R_TSI cu_types.vw_tipi_sede_impresa;
		R_STAB cu_anag.stabilimenti;
		nf integer;
		jarg json;
		begin 
			proc_name:='cu_anag.upd_cu_upd_imprese_sedi';
			v_j:=v::json;
			v_id_impresa:=v_j->'id_impresa';
--			v_piva:=v_j->>'piva';
			v_pec:=v_j->>'pec';
			v_email:=v_j->>'email';
--			v_sdi:=v_j->>'sdi';
--			v_split_payement:=v_j->>'split_payement';
--			v_cf:=v_j->>'cf';
--			v_cod_tipo_impresa:=v_j->>'cod_tipo_impresa';
			v_id_impresa_sedi:=v_j->'id_impresa_sedi';
			v_data_inizio_validita:=v_j->>'data_inizio_validita';
			if v_j->>'data_fine_validita' != '' then
				v_data_fine_validita:=(v_j->>'data_fine_validita')::date + interval '1 day';
			end if;
		/*	v_id_indirizzo:=v_j->'id_indirizzo';
			v_indirizzo:=cu_anag.string_normalize(v_j->>'indirizzo');
			v_indirizzo:=cu_anag.string_normalize(v_indirizzo);
			v_civico:=cu_anag.string_normalize(v_j->>'civico');
			v_indirizzo:= cu_anag.string_normalize(v_indirizzo);
			v_comune:=cu_anag.string_normalize_upper(v_j->>'comune');

			v_toponimo:=cu_anag.string_normalize_upper(v_j->>'toponimo');

			v_cap:=cu_anag.string_normalize_upper(v_j->>'cap');

			v_nazione:=cu_anag.string_normalize_upper(v_j->>'nazione');

			v_provincia:=cu_anag.string_normalize_upper(v_j->>'stato_provincia');

			istatcomune:=cu_anag.string_normalize_upper(v_j->>'istat_comune'); */

		
			raise notice 'v=%',v_j;
		
			if v_data_inizio_validita >= v_data_fine_validita then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'inizio_e_fine_validita_non_compatibili');
				ret.info='0';
				return ret;
			end if;
			
			if v_fonte is null or v_fonte = '' then
				v_fonte:= 'GISA-FVG';
			end if;
			
		/*	update cu_anag.indirizzi 
			set indirizzo = v_nome,
				comune = v_comune,
				toponimo = v_toponimo,
				stato_prov = v_stato,
				nazione = v_nazione,
				civico = v_civico,
				cap = v_cap
			where id = v_id_indirizzo; */
			select * into R_IS from cu_anag.impresa_sedi where id=v_id_impresa_sedi;
			--R_SS.validita:=tsrange(v_data_fine_validita,v_data_fine_validita,'[]');
		
			select * into R_IMP from cu_anag.imprese where id=R_IS.id_impresa;
			if upper(R_IMP.validita) is not null and v_data_inizio_validita > upper(R_IMP.validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_supera_validita_impresa');
				ret.info='0';
				return ret;
			end if;
			
			v_validita:=tsrange(v_data_inizio_validita,v_data_fine_validita,'[)');
			if not (R_IMP.validita @> v_validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_impresa');
				ret.info='0';
				return ret;
			end if;
		
			--select * into R_STAB from cu_anag.imprese where id=R_SS.id_impresa;
			--v_validita:=tsrange(v_data_inizio_validita,v_data_fine_validita,'[)');
			raise notice 'validita %',v_validita;
			if not (R_IMP.validita @> v_validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_impresa_fine_validita');
				ret.info='0';
				return ret;
			end if;
			--insert into cu_anag.soggetti_fisici (id,nome,cognome,codice_fiscale,indirizzo_id) values(nextval('cu_anag.cu_anag_id_seq'),v_nome,v_cognome,v_cf,idindirizzo) returning id into idsoggettofisico;
		
			--raise notice 'idsoggettofisico=%',idsoggettofisico;
			select * into R_IS from cu_anag.impresa_sedi
			where id_impresa=v_id_impresa
				and id_tipo_sede  =R_IS.id_tipo_sede
				and validita && v_validita
				and id!=R_IS.id
				limit 1;
			if R_IS.id is not null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'sede_gia_presente_per_validita');
				ret.info='0';
				return ret;
			end if;			
			
		/*	if istatcomune is null or istatcomune='' then
				if v_nazione is null or v_nazione = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_nazione');
					return ret;
				end if;
				if v_comune is null or v_comune = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_comune');
					return ret;
				end if;
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune = v_comune,
					toponimo = v_toponimo,
					civico = v_civico,
					cap = v_cap,
					nazione = v_nazione,
					stato_prov = v_provincia,
					istat_comune = null,
					fonte = v_fonte
				where id = v_id_indirizzo returning * into R_IND;
			else
				select count(*) into n from conf_ext.vw_comuni_vigenti_attivi c
					where c.codice_istat = istatcomune;
				if n > 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_non_valido');
					return ret;
				end if;	
				if n < 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_inesistente');
					return ret;
				end if;	
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune= null,
					toponimo = v_toponimo,
					civico = v_civico,
					istat_comune = lpad(trim(istatcomune),6,'0'),
					cap = v_cap,
					nazione = null,
					stato_prov = null,
					fonte = v_fonte
				where id = v_id_indirizzo  returning * into R_IND;
			end if;
			n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'U'); */
		
			ret := cu_anag.upsert_indirizzi(v,idtransazione);
		
			update cu_anag.impresa_sedi
			set 
				email = v_email,
--				sdi = v_sdi,
				validita = v_validita,
				pec = v_pec
			where id = v_id_impresa_sedi and id_impresa = v_id_impresa
				returning * into R_IS;
			n:=cu_log.upd_record('cu_anag.impresa_sedi',idtransazione,R_IS,'U');

			select * into R_TSI from cu_types.vw_tipi_sede_impresa where id=R_IS.id;

			if  upper(R_TSI.sigla)='SL' then 
				if (not R_IMP.verificato) then 
					select count(*) into nf from cu_anag.vw_impresa_figure
						where id_impresa=v_id_impresa and cod_tipo_figura ilike 'LEGALE RAPPRESENTANTE';
					if nf > 0 then
						update cu_anag.imprese set verificato=true where id=v_id_impresa returning * into R_IMP;
						n:=cu_log.upd_record('cu_anag.imprese',idtransazione,R_IS,'I');
					end if;
				end if;
	
				for R_STAB in select * from cu_anag.stabilimenti where id_impresa=v_id_impresa loop
					jarg:='{"id_stabilimento":'||R_STA.id||',"id_impresa":'||v_id_impresa||'}';
					v_stab_verificato:= cu_anag.check_stabilimento_valido(jarg,idtransazione);
					if v_stab_verificato.esito != R_STAB.verificato then
						update cu_anag.stabilimenti set verificato=v_stab_verificato.esito
						where id=v_id returning * into R_STAB;
						n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_STAB,'I');
					end if;
				end loop;
				
			end if;
			
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    	ret.info = '0';
 			return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_upd_imprese_sedi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_upd_pratica(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_upd_pratica(v_j json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret cu_types.result_type; -- start
        proc_name varchar; -- end
        R_S cu_anag.vw_stabilimenti_all%ROWTYPE;
		R_P cu_anag.pratiche;
		npratica text;
		idstab int;
		idpratica int;
		r record;
		n bigint;

	begin
		proc_name:='cu_anag.upd_cu_upd_pratica';
		raise notice 'V_J=%', v_j;
		ret.esito:=false;
	
	
		if v_j->>'id_pratica' is not null then
			select * into R_P from cu_anag.pratiche where id= (v_j->>'id_pratica')::int;
			if R_P.id is null then
				ret:=cu_ui.build_ret(ret,proc_name,'pratica_non_trovato');
				return ret;
			end if;
		end if;
	
		if v_j->>'id_stabilimento' is not null then
			select * into R_S from cu_anag.vw_stabilimenti_all where id_stabilimento= (v_j->>'id_stabilimento')::int;
			if R_S.id is null then
				ret:=cu_ui.build_ret(ret,proc_name,'stabilimento_non_trovato');
				return ret;
			end if;
		end if;

		idpratica:= v_j->>'id_pratica';
		npratica:= v_j->>'n_pratica';
		idstab:= v_j->>'id_stabilimento';

		select count(*) into n from cu_anag.pratiche
		where n_pratica = npratica and id != R_P.id;

		if n > 0 then
			ret:=cu_ui.build_ret(ret,proc_name,'n_pratica_gia_presente');
			return ret;
		end if;
		
		
		update cu_anag.pratiche 
		set n_pratica = npratica,
		id_stabilimento = idstab
		where id = idpratica returning * into r;
		n:=cu_log.upd_record('cu_anag.pratiche',idtransazione,r,'U');
		
		ret.esito:=true;
	    ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    ret.info = '{"id_pratica":'||R_P.id||'}';
	   
 		return ret;
	end;
END
$$;


ALTER FUNCTION cu_anag.upd_cu_upd_pratica(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_upd_stabilimenti_figure(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_upd_stabilimenti_figure(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		v_j json;
		v_id_stabilimento_figura bigint;
		v_data_inizio_validita timestamp;
		v_data_fine_validita timestamp;
		proc_name varchar; -- end
		R_SF cu_anag.stabilimento_figure;
		R_STAB cu_anag.stabilimenti;
		v_id_stabilimento bigint;
		v_validita tsrange;
		R_IND cu_anag.indirizzi;
		n integer;
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		v_fonte varchar;
		istatcomune varchar;
		jarg json;
		v_stab_verificato cu_types.result_type;
		begin 
			proc_name:='cu_anag.upd_cu_upd_stabilimenti_figure';
			v_j:=v::json;
			if v_j->>'data_fine_validita' != '' then
				v_data_fine_validita:=(v_j->>'data_fine_validita')::date + interval '1 day';
			end if;
			v_id_stabilimento_figura:=v_j->'id_stabilimento_figura';
			v_id_stabilimento:=v_j->'id_stabilimento';
			v_data_inizio_validita:=v_j->>'data_inizio_validita';
			--v_data_fine_validita:=v_j->>'data_fine_validita';
			/* v_id_indirizzo:=v_j->'id_indirizzo';
			v_indirizzo:=cu_anag.string_normalize(v_j->>'indirizzo');
			v_indirizzo:=cu_anag.string_normalize(v_indirizzo);
			v_civico:=cu_anag.string_normalize(v_j->>'civico');
			v_indirizzo:= cu_anag.string_normalize(v_indirizzo);
			v_comune:=cu_anag.string_normalize_upper(v_j->>'comune');

			v_toponimo:=cu_anag.string_normalize_upper(v_j->>'toponimo');

			v_cap:=cu_anag.string_normalize_upper(v_j->>'cap');

			v_nazione:=cu_anag.string_normalize_upper(v_j->>'nazione');

			v_provincia:=cu_anag.string_normalize_upper(v_j->>'stato_provincia');

			istatcomune:=cu_anag.string_normalize_upper(v_j->>'istat_comune'); */
			
			raise notice 'v=%',v_j;
			
			if v_data_inizio_validita >= v_data_fine_validita then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'inizio_e_fine_validita_non_compatibli');
				ret.info='0';
				return ret;
			end if;
			
			if v_fonte is null or v_fonte = '' then
				v_fonte:= 'GISA-FVG';
			end if;
		
			select * into R_SF from cu_anag.stabilimento_figure where id=v_id_stabilimento_figura;
			--R_SF.validita:=tsrange(v_data_fine_validita,v_data_fine_validita,'[]');
		
			select * into R_STAB from cu_anag.stabilimenti where id=R_SF.id_stabilimento;
					--select * into R_STAB from cu_anag.stabilimenti where id=v_id_stabilimento;
			if upper(R_STAB.validita) is not null and v_data_inizio_validita > upper(R_STAB.validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_supera_validita_impresa');
				ret.info='0';
				return ret;
			end if;
			v_validita:=tsrange(v_data_inizio_validita,v_data_fine_validita,'[)'); --upper(R_STAB.validita),'[)');
			if not (R_STAB.validita @> v_validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_stabilimento');
				ret.info='0';
				return ret;
			end if;
		
			--select * into R_STAB from cu_anag.stabilimenti where id=R_SF.id_stabilimento;
			--v_validita:=tsrange(v_data_inizio_validita,v_data_fine_validita,'[)');
			raise notice 'validita %',v_validita;
			if not (R_STAB.validita @> v_validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_stabilimento_fine_validita');
				ret.info='0';
				return ret;
			end if;
			--insert into cu_anag.soggetti_fisici (id,nome,cognome,codice_fiscale,indirizzo_id) values(nextval('cu_anag.cu_anag_id_seq'),v_nome,v_cognome,v_cf,idindirizzo) returning id into idsoggettofisico;
		
			--raise notice 'idsoggettofisico=%',idsoggettofisico;
			select * into R_SF from cu_anag.stabilimento_figure
			where id_stabilimento=v_id_stabilimento
				and id_tipo_figura =R_SF.id_tipo_figura
				and validita && v_validita
				and id!=R_SF.id
				limit 1;
			if R_SF.id is not null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'figura_gia_presente_per_validita');
				ret.info='0';
				return ret;
			end if;
	
			/*if istatcomune is null or istatcomune='' then
				if v_nazione is null or v_nazione = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_nazione');
					return ret;
				end if;
				if v_comune is null or v_comune = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_comune');
					return ret;
				end if;
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune = v_comune,
					toponimo = v_toponimo,
					civico = v_civico,
					cap = v_cap,
					nazione = v_nazione,
					stato_prov = v_provincia,
					istat_comune = null,
					fonte = v_fonte
				where id = v_id_indirizzo returning * into R_IND;
			else
				select count(*) into n from conf_ext.vw_comuni_vigenti_attivi c
					where c.codice_istat = istatcomune;
				if n > 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_non_valido');
					return ret;
				end if;	
				if n < 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_inesistente');
					return ret;
				end if;	
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune= null,
					toponimo = v_toponimo,
					civico = v_civico,
					istat_comune = lpad(trim(istatcomune),6,'0'),
					cap = v_cap,
					nazione = null,
					stato_prov = null,
					fonte = v_fonte
				where id = v_id_indirizzo  returning * into R_IND;
			end if;
			n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'U'); */
			
			ret := cu_anag.upsert_indirizzi(v,idtransazione);
			raise notice 'ret.info:%',ret.info;
			if ret.info is not null and ret.info <> '0' then
				v_id_indirizzo := ret.info;
			end if;
			
			raise notice 'id indirizzo%',v_id_indirizzo;
			if v_id_indirizzo is not null then
				update cu_anag.stabilimento_figure 
				set id_indirizzo = v_id_indirizzo
				where id = v_id_stabilimento_figura;
			end if; 
		
			update cu_anag.stabilimento_figure 
				set validita = v_validita
					where id = v_id_stabilimento_figura
					returning * into R_SF;
			n:=cu_log.upd_record('cu_anag.stabilimento_figure',idtransazione,R_SF,'U');

			jarg:='{"id_stabilimento":'||R_STAB.id||',"id_impresa":'||R_STAB.id_impresa||'}';
			v_stab_verificato:= cu_anag.check_stabilimento_valido(jarg,idtransazione);
			if v_stab_verificato.esito != R_STAB.verificato then
				update cu_anag.stabilimenti set verificato=v_stab_verificato.esito
				where id=R_STAB.id returning * into R_STAB;
				n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_STAB,'I');
			end if;
			
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    	ret.info = '0';
 			return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_upd_stabilimenti_figure(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_upd_stabilimenti_sedi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_cu_upd_stabilimenti_sedi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		ret cu_types.result_type; -- start
		v_id_stabilimento bigint;
		v_piva varchar;
		v_pec varchar;
		v_email varchar;
		v_sdi varchar;
		v_split_payement varchar;
		v_cf varchar;
		v_cod_tipo_impresa varchar;
		v_j json;
		v_id_stabilimento_sedi bigint;
		v_data_inizio_validita timestamp;
		v_data_fine_validita timestamp;
		proc_name varchar; -- end
		idimpresa bigint;
		R_STAB cu_anag.stabilimenti;
		R_SS cu_anag.stabilimento_sedi;
		v_validita tsrange;
		R_TS cu_types.tipi_sede;
		R_IMP cu_anag.imprese;
		R_IND cu_anag.indirizzi;
		n integer;
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		v_fonte varchar;
		istatcomune varchar;
		jarg json;
		v_stab_verificato cu_types.result_type;
		begin 
			proc_name:='cu_anag.upd_cu_upd_stabilimenti_sedi';
			v_j:=v::json;
			v_id_stabilimento:=v_j->'id_stabilimento';
			v_piva:=cu_anag.string_normalize_upper(v_j->>'piva');
			v_pec:=cu_anag.string_normalize(v_j->>'pec');
			v_email:=cu_anag.string_normalize(v_j->>'email');
			v_sdi:=cu_anag.string_normalize_upper(v_j->>'sdi');
			v_cf:=cu_anag.string_normalize_upper(v_j->>'cf');
			v_cod_tipo_impresa:=cu_anag.string_normalize(v_j->>'cod_tipo_impresa');
			v_id_stabilimento_sedi:=v_j->'id_stabilimento_sedi';
			v_data_inizio_validita:=v_j->>'data_inizio_validita';
			if v_j->>'data_fine_validita' != '' then
				v_data_fine_validita:=(v_j->>'data_fine_validita')::date + interval '1 day';
			end if;
			/*v_id_indirizzo:=v_j->'id_indirizzo';
			v_indirizzo:=cu_anag.string_normalize(v_j->>'indirizzo');
			v_indirizzo:=cu_anag.string_normalize(v_indirizzo);
			v_civico:=cu_anag.string_normalize(v_j->>'civico');
			v_indirizzo:= cu_anag.string_normalize(v_indirizzo);
			v_comune:=cu_anag.string_normalize_upper(v_j->>'comune');

			v_toponimo:=cu_anag.string_normalize_upper(v_j->>'toponimo');

			v_cap:=cu_anag.string_normalize_upper(v_j->>'cap');

			v_nazione:=cu_anag.string_normalize_upper(v_j->>'nazione');

			v_provincia:=cu_anag.string_normalize_upper(v_j->>'stato_provincia');

			istatcomune:=cu_anag.string_normalize_upper(v_j->>'istat_comune');*/

		
			raise notice 'v=%',v_j;
			raise notice 'v_data_fine_validita %',v_data_fine_validita;
		
			if v_email is not null and v_email != '' and v_email !~ '.+@.+\..+' then
				ret:=cu_ui.build_ret(ret,proc_name,'e-mail_non_valida');
				return ret;
			end if;
			if v_pec is not null and v_pec != '' and v_pec !~ '.+@.+\..+' then
				ret:=cu_ui.build_ret(ret,proc_name,'pec_non_valida');
				return ret;
			end if;
			/*select * into R_TS from cu_types.tipi_sede where id=v_tipo_sede;
			if upper(v_tipo_sede) !='SF' and v_sdi is not null and v_sdi != '' then
				ret:=cu_ui.build_ret(ret,proc_name,'sdi_non_ammissibile_per_il_tipo_sede');
				return ret;
			end if;
			if upper(v_tipo_sede) !='SF' and v_split_payement is not null and v_split_payement != '' then
				ret:=cu_ui.build_ret(ret,proc_name,'split_payement_non_ammissibile_per_il_tipo_sede');
				return ret;
			end if;*/
		
			if v_data_inizio_validita >= v_data_fine_validita then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'inizio_e_fine_validita_non_compatibili');
				ret.info='0';
				return ret;
			end if;
			
			
		/*	update cu_anag.indirizzi 
			set indirizzo = v_nome,
				comune = v_comune,
				toponimo = v_toponimo,
				stato_prov = v_stato,
				nazione = v_nazione,
				civico = v_civico,
				cap = v_cap
			where id = v_id_indirizzo; */
			select * into R_SS from cu_anag.stabilimento_sedi where id=v_id_stabilimento_sedi;
			--R_SS.validita:=tsrange(v_data_fine_validita,v_data_fine_validita,'[]');
		
			select * into R_STAB from cu_anag.stabilimenti where id=R_SS.id_stabilimento;

			if upper(R_STAB.validita) is not null and v_data_inizio_validita > upper(R_STAB.validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_supera_validita_impresa');
				ret.info='0';
				return ret;
			end if;
			--v_validita:=tsrange(v_data_inizio_validita,upper(R_STAB.validita),'[)');
			v_validita:=tsrange(v_data_inizio_validita,v_data_fine_validita,'[)');
			if not (R_STAB.validita @> v_validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_stabilimento');
				ret.info='0';
				return ret;
			end if;
		
			--select * into R_STAB from cu_anag.stabilimenti where id=R_SS.id_stabilimento;
			
		
			if (v_sdi is not null and v_sdi != '') then
				select * into R_IMP from cu_anag.imprese where id =R_STAB.id_impresa;
				if R_IMP.sdi is not null and R_IMP.sdi != '' then
					ret:=cu_ui.build_ret(ret,proc_name,'sdi_presente_in_impresa');
					return ret;
				end if;
		
				if R_IMP.tipo_soggetto = 'Z' then
					if length(v_sdi) != 6 then
					    ret:=cu_ui.build_ret(ret,proc_name,'codice_sdi_non_valido_per_pubblica_amministrazione');
						return ret;
					end if;
				else
					if length(v_sdi) != 7 then
					    ret:=cu_ui.build_ret(ret,proc_name,'codice_sdi_non_valido_per_imprese_private');
						return ret;
					end if;
				end if;
			end if;
			raise notice 'validita %',v_validita;
			if not (R_STAB.validita @> v_validita) then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile_con_stabilimento_fine_validita');
				ret.info='0';
				return ret;
			end if;
			--insert into cu_anag.soggetti_fisici (id,nome,cognome,codice_fiscale,indirizzo_id) values(nextval('cu_anag.cu_anag_id_seq'),v_nome,v_cognome,v_cf,idindirizzo) returning id into idsoggettofisico;
		
			--raise notice 'idsoggettofisico=%',idsoggettofisico;
			raise notice 'tipo sede % v_validita % id=%',R_SS.id_tipo_sede,v_validita,R_SS.id;
			select * into R_SS from cu_anag.stabilimento_sedi
			where id_stabilimento=v_id_stabilimento
				and id_tipo_sede  =R_SS.id_tipo_sede
				and validita && v_validita
				and id!=R_SS.id
				limit 1;
			if R_SS.id is not null then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'sede_gia_presente_per_validita');
				ret.info='0';
				return ret;
			end if;			
		
			if v_fonte is null or v_fonte = '' then
				v_fonte:= 'GISA-FVG';
			end if;
		/*	if v_cap is null or v_cap = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'cap_obbligatorio');
					return ret;
			end if;
			if v_indirizzo is null or v_indirizzo = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_obbligatorio');
					return ret;
			end if;
		
			if istatcomune is null or istatcomune='' then
				if v_nazione is null or v_nazione = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_nazione');
					return ret;
				end if;
				if v_comune is null or v_comune = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_comune');
					return ret;
				end if;
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune = v_comune,
					toponimo = v_toponimo,
					civico = v_civico,
					cap = v_cap,
					nazione = v_nazione,
					stato_prov = v_provincia,
					istat_comune = null,
					fonte = v_fonte
				where id = v_id_indirizzo returning * into R_IND;
			else
				select count(*) into n from conf_ext.vw_comuni_vigenti_attivi c
					where c.codice_istat = istatcomune;
				if n > 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_non_valido');
					return ret;
				end if;	
				if n < 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_inesistente');
					return ret;
				end if;	
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune= null,
					toponimo = v_toponimo,
					civico = v_civico,
					istat_comune = lpad(trim(istatcomune),6,'0'),
					cap = v_cap,
					nazione = null,
					stato_prov = null,
					fonte = v_fonte
				where id = v_id_indirizzo  returning * into R_IND;
			end if;
			n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'U'); */
			ret := cu_anag.upsert_indirizzi(v,idtransazione);
			
			update cu_anag.stabilimento_sedi
			set 
				pec = v_pec,
				email = v_email,
				--cod_tipo_impresa = v_cod_tipo_impresa,
				validita = v_validita
			where id = v_id_stabilimento_sedi --and id_stabilimento = v_id_stabilimento
			returning * into R_SS;
			n:=cu_log.upd_record('cu_anag.stabilimento_sedi',idtransazione,R_SS,'U');
		
			jarg:='{"id_stabilimento":'||R_STAB.id||',"id_impresa":'||R_STAB.id_impresa||'}';
			v_stab_verificato:= cu_anag.check_stabilimento_valido(jarg,idtransazione);
			if v_stab_verificato.esito != R_STAB.verificato then
				update cu_anag.stabilimenti set verificato=v_stab_verificato.esito
				where id=R_STAB.id returning * into R_STAB;
				n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,R_STAB,'I');
			end if;
			/*idimpresa = (select vs.id_impresa 
			from cu_anag.vw_stabilimenti vs 
			where vs.id_stabilimento = v_id_stabilimento);
		
			raise notice 'idimpresa %',idimpresa;
			
			update cu_anag.imprese 
			set cod_tipo_impresa = v_cod_tipo_impresa
			where id = idimpresa;*/
			
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    	ret.info = '0';
 			return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.upd_cu_upd_stabilimenti_sedi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_istat_cessati(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_istat_cessati(v_j json, idtransazione bigint) RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
	declare
	n integer;

	begin
  update cu_anag.indirizzi set istat_comune ='030188'  where istat_comune ='030096' ;
  		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='030188'  where istat_comune ='030119';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='093053'  where istat_comune ='093003';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='030191'  where istat_comune ='030125';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='030191'  where istat_comune ='030050';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='093053'  where istat_comune ='093048';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='030138'  where istat_comune ='030017';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='108034'  where istat_comune ='015152';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='025074'  where istat_comune ='025061';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='024124'  where istat_comune ='024011';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='030138'  where istat_comune ='030115';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='090062'  where istat_comune ='104002';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='090062'  where istat_comune ='096052';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='025074'  where istat_comune ='025034';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='091095'  where istat_comune ='105018';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='025071'  where istat_comune ='025009';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='030189'  where istat_comune ='025052';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='075098'  where istat_comune ='075001';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='024123'  where istat_comune ='024045';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
  update cu_anag.indirizzi set istat_comune ='020071'  where istat_comune ='020069';
   		GET DIAGNOSTICS n := ROW_COUNT;
 		raise notice '	righe modificate %',n;
	 	return n;
	end;
end;
$$;


ALTER FUNCTION cu_anag.upd_istat_cessati(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_set_codice_stabilimento(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_set_codice_stabilimento(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type; -- start
		proc_name varchar; -- end
		r record;
		R_COD  cu_anag.codici;
		R_STAB cu_anag.vw_stabilimenti;
		n integer;
		id_op integer;
		v_id_stabilimento bigint;
		v_j json;
		begin
			proc_name:='cu_anag.upd_set_codice_stabilimento';
			id_op:=cu_log.start_op(proc_name,idtransazione ,'');
			v_j:=v::json;
			v_id_stabilimento:=v_j->'id_stabilimento';
			raise notice 'id_stab %',v_id_stabilimento;
			select * into R_STAB from cu_anag.vw_stabilimenti where id=v_id_stabilimento;
			if R_STAB.id is null then
				ret.esito:=false;
				ret:=cu_ui.build_ret(ret,proc_name, 'stabilimento_inesistente');
				return ret;
			end if;
			if not R_STAB.richiede_codice_regionale then
				ret.esito:=false;
				ret:=cu_ui.build_ret(ret,proc_name, 'stabilimento_non_richiede_codice_regionale');
				return ret;
			end if;
			if R_STAB.id_asl is null then
				ret.esito:=false;
				ret:=cu_ui.build_ret(ret,proc_name, 'stabilimento_asl_inesistente');
				return ret;
			end if;
		
			update cu_anag.codici set value=value+1 where appl='codice_regionale' and id_asl=R_STAB.id_asl
			returning * into R_COD;
			
			GET DIAGNOSTICS n = ROW_COUNT;
			if n < 1 then
				ret.esito:=false;
				ret:=cu_ui.build_ret(ret,proc_name, 'codice_stabilimento_per_asl_inesistente');
				return ret;
			end if;
			n:=cu_log.upd_record('cu_anag.codici',idtransazione,R_COD,'U');

			update cu_anag.stabilimenti set cod_regionale=R_COD.prefix||R_COD.value
			where id=v_id_stabilimento and (cod_regionale is null or cod_regionale='')
			returning * into r;
			GET DIAGNOSTICS n = ROW_COUNT;
			if n < 1 then
				ret.esito:=false;
				ret:=cu_ui.build_ret(ret,proc_name, 'errore_aggiornamento_stabilimento');
				return ret;
			end if;
			n:=cu_log.upd_record('cu_anag.stabilimenti',idtransazione,r,'U');
			ret.esito:=true;
	    	ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    	ret.info = '{"codice_regionale":'||R_COD.value||'}';
 			return ret;
		end;
	END;
$$;


ALTER FUNCTION cu_anag.upd_set_codice_stabilimento(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_stabilimenti_automezzi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upd_stabilimenti_automezzi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	begin
		declare 
		ret cu_types.result_type;    
		proc_name varchar;
		rt json;
		idstrutturaroot bigint;
		v_id_stabilimento_automezzo bigint;
		v_id_automezzo bigint;
		v_id_stabilimento bigint;
		v_data_inizio_validita timestamp;
		v_data_fine_validita timestamp;
		n integer;
		R_SA cu_anag.stabilimento_automezzi;
	
		v_j json;
		begin 
			proc_name:='cu_anag.upd_stabilimenti_automezzi';
			v_j:=v::json;
			v_id_stabilimento_automezzo:=v_j->'id_stabilimento_automezzi';
			v_data_inizio_validita:=cu_anag.string_normalize(v_j->>'data_inizio_validita');
			if v_j->>'data_fine_validita' is not null and v_j->>'data_fine_validita' != '' then
				v_data_fine_validita:=cu_anag.string_normalize(v_j->>'data_fine_validita');
				if v_data_inizio_validita = v_data_fine_validita then 
					v_data_fine_validita:=(v_j->>'data_fine_validita')::date + interval '1 day';
				end if;
				if v_data_inizio_validita > v_data_fine_validita then
					ret.esito:=false;	
	        		ret:=cu_ui.build_ret(ret,proc_name,'inizio_validità_maggiore_di_fine_validità');
					ret.info='0';
					return ret;
				end if;
			end if;

			select id_automezzo into v_id_automezzo from cu_anag.stabilimento_automezzi sa 
			where sa.id = v_id_stabilimento_automezzo;

			select count(*) into n from cu_anag.stabilimento_automezzi sa 
			where sa.id_automezzo = v_id_automezzo and validita && tsrange(v_data_inizio_validita,v_data_fine_validita,'[)')
			and id != v_id_stabilimento_automezzo;
		
			if n > 0 then
				ret.esito:=false;	
        		ret:=cu_ui.build_ret(ret,proc_name,'validita_non_compatibile');
				ret.info='0';
				return ret;
			end if;
			
			raise notice 'v%',v_j;
			update cu_anag.stabilimento_automezzi 
			set validita = tsrange(v_data_inizio_validita::timestamp without time zone, v_data_fine_validita::timestamp without time zone, '[)')
			where id = v_id_stabilimento_automezzo
			returning * into R_SA;
			n:=cu_log.upd_record('cu_anag.upd_stabilimenti_automezzi',idtransazione,R_SA,'I');
			
			
			ret.esito:=true;	
        	ret:=cu_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
			ret.info='0';
			return ret;
		end;
		

	END;
$$;


ALTER FUNCTION cu_anag.upd_stabilimenti_automezzi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upsert_indirizzi(json, bigint); Type: FUNCTION; Schema: cu_anag; Owner: postgres
--

CREATE FUNCTION cu_anag.upsert_indirizzi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
		declare 
		proc_name varchar;		
		idindirizzo bigint;
		R_IND cu_anag.indirizzi;
		v_j json;
		v_indirizzo varchar;
		v_toponimo varchar;
		v_civico varchar;
		v_cap varchar;
		v_comune varchar;
		v_nazione varchar;
		v_provincia varchar;
		v_id_indirizzo bigint;
		v_fonte varchar;
		v_latitudine varchar;
		v_longitudine varchar;
		istatcomune varchar;
		ret cu_types.result_type;
		n integer;
		msg varchar;
		domicilio varchar;
		idindirizzosoggetto bigint;
		begin
			proc_name:='cu_anag.upsert_indirizzi';
			v_j:=v::json;
			v_indirizzo:=cu_anag.string_normalize_upper(v_j->>'indirizzo');
			--v_indirizzo:=cu_anag.string_normalize(v_indirizzo);
			v_civico:=cu_anag.string_normalize(v_j->>'civico');
			v_comune:=cu_anag.string_normalize_upper(v_j->>'comune');
			v_id_indirizzo:=v_j->'id_indirizzo';

			v_toponimo:=cu_anag.string_normalize_upper(v_j->>'toponimo');

			v_cap:=cu_anag.string_normalize_upper(v_j->>'cap');

			v_nazione:=cu_anag.string_normalize_upper(v_j->>'nazione');

			v_latitudine:=cu_anag.string_normalize_upper(v_j->>'latitudine');
		
			v_longitudine:=cu_anag.string_normalize_upper(v_j->>'longitudine');
	
			v_provincia:=cu_anag.string_normalize_upper(v_j->>'stato_provincia');

			istatcomune:=cu_anag.string_normalize_upper(v_j->>'istat_comune');
			raise notice 'v upsert=%', v_j;
		
			if v_fonte is null or v_fonte = '' then
				v_fonte:= 'GISA-FVG';
			end if;
			msg:=null;
			raise notice 'v_id_indirizzo%', v_id_indirizzo;
			if v_id_indirizzo is null or v_id_indirizzo = 0 then 
				if istatcomune is null or istatcomune='' then 
					insert into cu_anag.indirizzi (id,toponimo,indirizzo,comune,civico,cap,nazione,stato_prov,istat_comune,fonte)
					values (nextval('cu_anag.cu_anag_id_seq'),v_toponimo,v_indirizzo,v_comune,v_civico,v_cap,v_nazione,v_provincia,null,v_fonte)
					returning * into R_IND;
					n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'I');
					ret.esito = true;
					ret:=cu_ui.build_ret(ret,proc_name, coalesce(msg,'salvataggio_effettuato_con_successo'));
					ret.info = R_IND.id;
					return ret;
				else
					insert into cu_anag.indirizzi (id,toponimo,indirizzo,comune,civico,cap,nazione,stato_prov,istat_comune,fonte,latitudine,longitudine)
					values (nextval('cu_anag.cu_anag_id_seq'),v_toponimo,v_indirizzo,null,v_civico,v_cap,null,null,lpad(trim(istatcomune),6,'0'),v_fonte,v_latitudine,v_longitudine)
					returning * into R_IND;
					n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'I');
					ret.esito = true;
					ret:=cu_ui.build_ret(ret,proc_name, coalesce(msg,'salvataggio_effettuato_con_successo'));
					ret.info = R_IND.id;
					return ret;
				end if;
			end if;
			
			domicilio:=v_j->>'domicilio';
			idindirizzosoggetto:=v_j->>'id_indirizzo_soggetto';
			
			raise notice 'domicilio %',domicilio;
		
		
			--Gestione domicilio
			if domicilio is not null and domicilio = 'no' then
		  		raise notice 'entrato nell else if';
				--Metto i dati dell'indirizzo in un nuovo id
				if istatcomune is null or istatcomune='' then 
					insert into cu_anag.indirizzi (id,toponimo,indirizzo,comune,civico,cap,nazione,stato_prov,istat_comune,fonte)
					values (nextval('cu_anag.cu_anag_id_seq'),v_toponimo,v_indirizzo,v_comune,v_civico,v_cap,v_nazione,v_provincia,null,v_fonte)
					returning * into R_IND;
					n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'I');
					ret.esito = true;
					ret:=cu_ui.build_ret(ret,proc_name, coalesce(msg,'salvataggio_effettuato_con_successo'));
					ret.info = R_IND.id;
					return ret;
				else
					insert into cu_anag.indirizzi (id,toponimo,indirizzo,comune,civico,cap,nazione,stato_prov,istat_comune,fonte)
					values (nextval('cu_anag.cu_anag_id_seq'),v_toponimo,v_indirizzo,null,v_civico,v_cap,null,null,lpad(trim(istatcomune),6,'0'),v_fonte)
					returning * into R_IND;
					n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'I');
					ret.esito = true;
					ret:=cu_ui.build_ret(ret,proc_name, coalesce(msg,'salvataggio_effettuato_con_successo'));
					ret.info = R_IND.id;
					return ret;
				end if;
			end if;
			if domicilio is not null then
				n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'U');
				ret.esito:=true;
	    		--ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	    		ret.info = idindirizzosoggetto;
	    		raise notice 'ret info upsert %',ret.info;
				return ret;
			end if;
			
			--End gestione domicilio	 
		
			if istatcomune is null or istatcomune='' then
				/*if v_cap is null or v_cap = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'cap_obbligatorio');
					return ret;
				end if;
				if v_indirizzo is null or v_indirizzo = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_obbligatorio');
					return ret;
				end if; */
				if v_nazione is null or v_nazione = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_nazione');
					return ret;
				end if;
				/* if v_comune is null or v_comune = '' then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'indirizzo_estero_inserire_comune');
					return ret;
				end if; */
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune = v_comune,
					toponimo = v_toponimo,
					civico = v_civico,
					cap = v_cap,
					nazione = v_nazione,
					stato_prov = v_provincia,
					istat_comune = null,
					fonte = v_fonte
				where id = v_id_indirizzo returning * into R_IND;
			else
				select count(*) into n from conf_ext.vw_comuni_vigenti_attivi c
					where c.codice_istat = istatcomune;
				if n > 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_non_valido');
					return ret;
				end if;	
				if n < 1 then
					ret.esito:=false;
					ret:=cu_ui.build_ret(ret,proc_name, 'comune_istat_inesistente');
					return ret;
				end if;	
				update cu_anag.indirizzi 
				set indirizzo = v_indirizzo,
					comune = null,
					toponimo = v_toponimo,
					civico = v_civico,
					istat_comune = lpad(trim(istatcomune),6,'0'),
					cap = v_cap,
					nazione = null,
					stato_prov = null,
					fonte = v_fonte,
					latitudine = v_latitudine,
					longitudine = v_longitudine
				where id = v_id_indirizzo  returning * into R_IND;
			end if;
			n:=cu_log.upd_record('cu_anag.indirizzi',idtransazione,R_IND,'U');
			ret.esito:=true;
    		--ret:=cu_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
    		ret.info = '0';
			return ret;
			--end if;
			
		end;
	END;
$$;


ALTER FUNCTION cu_anag.upsert_indirizzi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: exp_piano_oggetti(json, bigint); Type: FUNCTION; Schema: cu_conf; Owner: postgres
--

CREATE FUNCTION cu_conf.exp_piano_oggetti(v json, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstruttura bigint;
	rt varchar;

	begin
		proc_name:='cu_conf.exp_piano_oggetti';
		idstruttura=v->'user_info'->'id_struttura_root';

	
		select string_agg(
    		regexp_replace(regexp_replace(
    		regexp_replace(row_to_json(c.*)::varchar,'"[^"]+":','','g'),'^{','['),'}$',']')
    		,',') into rt from (	
		    		select sigla_oggetto,alias_piano,descr_piano from  cu_conf.vw_cu_tipo_oggetto_piani p   				
					order by 2,3
    			) c;

	 	return '['||rt||']';
	end;
end;
$_$;


ALTER FUNCTION cu_conf.exp_piano_oggetti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_categ_rischio(json, bigint); Type: FUNCTION; Schema: cu_conf; Owner: postgres
--

CREATE FUNCTION cu_conf.get_categ_rischio(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_CU cu.vw_cu%ROWTYPE;
	rt json;

	begin
		proc_name:='cu_conf.get_categ_rischio';
		ret.esito:=false;
		
		select json_agg(row_to_json(a.*)) into rt   from (
				select c.id_node,c.id_node_parent,
					c.id_node_parent id_node_ref,c.node_descr,c.descr descrizione_breve
				from cu_conf.vw_cu_categ_nodes_up_descr c 
				join cu_conf.vw_cu_categ_nodes_down down on c.id_node = down.id_node 
				where id_node_ref = 246
				order by c.ordinamento
			) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_conf.get_categ_rischio(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_classe_evidenze(json, bigint); Type: FUNCTION; Schema: cu_conf; Owner: postgres
--

CREATE FUNCTION cu_conf.get_cu_classe_evidenze(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	begin
		proc_name:='cu.get_cu_classe_evidenze';
		ret.esito:=false;

		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu_conf.vw_cu_classe_evidenze) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_conf.get_cu_classe_evidenze(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipi_isp(json, bigint); Type: FUNCTION; Schema: cu_conf; Owner: postgres
--

CREATE FUNCTION cu_conf.get_cu_tipi_isp(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idcu bigint;
	rt json;
	isp record;
	ret2 cu_types.result_type;

	begin
		proc_name:='cu_conf.get_cu_tipi_isp';
		idcu=v->'id_cu';
		raise notice 'v=%',v;
	
		select json_agg(row_to_json(a.*)) into rt from (
			select distinct(vcti.*)
			from cu_conf.vw_cu_tipo_isp vcti 
			left join cu.vw_cu_nucleo_ni vcnn on vcnn.id_tipo_isp = vcti.id_tipo_isp 
			where ((select count(*) 
					from cu.vw_cu_nucleo_ni vcnn 
					where id_cu = idcu 
					and vcnn.id_tipo_isp = vcti.id_tipo_isp) < vcti.massimo)
		)a;
	
		raise notice '%',json_array_length(rt);

    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:='{"dati":'||rt||'}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_conf.get_cu_tipi_isp(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipi_oggetti_piano(json, bigint); Type: FUNCTION; Schema: cu_conf; Owner: postgres
--

CREATE FUNCTION cu_conf.get_cu_tipi_oggetti_piano(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idpiano bigint;
	rt json;
	isp record;
	ret2 cu_types.result_type;
	begin
		proc_name:='cu_conf.get_cu_tipi_oggetti_piano';
		idpiano=v->'id_piano';
		raise notice 'v=%',v;
	
		select json_agg(row_to_json(a.*)) into rt from (
		SELECT t.id,t.descr,tp.id is not null selezionato, t.sigla, t.cod
   			FROM cu_conf.vw_cu_tipo_oggetti t
   			JOIN matrix.struttura_piani p on 1=1
     		left JOIN cu_conf.cu_tipo_oggetto_piani tp ON tp.id_tipo_oggetto = t.id_tipo_oggetto and p.id=tp.id_piano 
			where p.id=idpiano 
			and upper(t.validita) is null	--2024-04-23 (issue #11319)
			order by t.id asc
     		)a;
		raise notice '%',json_array_length(rt);
    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:='{"dati":'||rt||'}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_conf.get_cu_tipi_oggetti_piano(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipi_per(json, bigint); Type: FUNCTION; Schema: cu_conf; Owner: postgres
--

CREATE FUNCTION cu_conf.get_cu_tipi_per(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idcu bigint;
	rt json;

	begin
		proc_name:='cu_conf.get_cu_tipi_per';
		--idcu=v->'id_cu';
		raise notice 'v=%',v;
	
		select json_agg(row_to_json(a.*)) into rt from (
			select * from cu_conf.vw_cu_tipo_per
		)a;
	
		raise notice '%',json_array_length(rt);

    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:='{"dati":'||rt||'}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_conf.get_cu_tipi_per(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipo_oggetti(json, bigint); Type: FUNCTION; Schema: cu_conf; Owner: postgres
--

CREATE FUNCTION cu_conf.get_cu_tipo_oggetti(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;

	begin
		proc_name:='cu_conf.get_cu_tipo_oggetti';
		raise notice 'v=%',v;
	
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (
		select * from 
			cu_conf.vw_cu_tipo_oggetti
			--where id_tipo_oggetto = (v->"id_tipo_oggetto") or  (v->"id_tipo_oggetto") is null
		)a;
	
		--ret.valore:= id_record;
	
	
	
		/*	select json_agg(row_to_json(a.*))  from (
		select * from (
					select distinct on (mi.cod)  mi.cod ,mm.lev,ord,mi.descr, mm.modality from ag_ui.menu m join ag_ui.menu_items mi on m.id=mi.id_menu 
				join ag_ui.menu_item_modes mm on mm.id_menu_item =mi.id
			where m.cod = 'config' and mm.lev>=2 order by mi.cod , mm.lev,ord
		) b order by b.ord) a*/
	
		raise notice '%',json_array_length(rt);

    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:='{"dati":'||rt||'}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_conf.get_cu_tipo_oggetti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipo_oggetti_requisiti(json, bigint); Type: FUNCTION; Schema: cu_conf; Owner: postgres
--

CREATE FUNCTION cu_conf.get_cu_tipo_oggetti_requisiti(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idtipooggetto bigint;
	rt json;

	begin
		proc_name:='cu_conf.get_cu_tipo_oggetti_requisiti';
		idtipooggetto:=v->'id_tipo_oggetto';
		raise notice 'v=%',v;
	
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (
		select * from 
			cu_conf.vw_cu_tipo_oggetti_requisiti where id_tipo_oggetto=idtipooggetto
			--where id_tipo_oggetto = (v->"id_tipo_oggetto") or  (v->"id_tipo_oggetto") is null
		)a;
	
		raise notice '%',json_array_length(rt);

    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:='{"dati":'||rt||'}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_conf.get_cu_tipo_oggetti_requisiti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipo_oggetti_requisiti_validi(json, bigint); Type: FUNCTION; Schema: cu_conf; Owner: postgres
--

CREATE FUNCTION cu_conf.get_cu_tipo_oggetti_requisiti_validi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idtipooggetto bigint;
	rt json;

	begin
		proc_name:='cu_conf.get_cu_tipo_oggetti_requisiti_validi';
		idtipooggetto:=v->'id_tipo_oggetto';
		raise notice 'v=%',v;
	
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (
		select * from 
			cu_conf.vw_cu_tipo_oggetti_requisiti_validi where id_tipo_oggetto=idtipooggetto
			--where id_tipo_oggetto = (v->"id_tipo_oggetto") or  (v->"id_tipo_oggetto") is null
		)a;
	
		raise notice '%',json_array_length(rt);

    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:='{"dati":'||rt||'}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_conf.get_cu_tipo_oggetti_requisiti_validi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipo_oggetti_validi(json, bigint); Type: FUNCTION; Schema: cu_conf; Owner: postgres
--

CREATE FUNCTION cu_conf.get_cu_tipo_oggetti_validi(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;

	begin
		proc_name:='cu_conf.get_cu_tipo_oggetti_validi';
		raise notice 'v=%',v;
	
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (
		select * from 
			cu_conf.vw_cu_tipo_oggetti_validi 
			--where id_tipo_oggetto = (v->"id_tipo_oggetto") or  (v->"id_tipo_oggetto") is null
		)a;
	
		--ret.valore:= id_record;
	
	
	
		/*	select json_agg(row_to_json(a.*))  from (
		select * from (
					select distinct on (mi.cod)  mi.cod ,mm.lev,ord,mi.descr, mm.modality from ag_ui.menu m join ag_ui.menu_items mi on m.id=mi.id_menu 
				join ag_ui.menu_item_modes mm on mm.id_menu_item =mi.id
			where m.cod = 'config' and mm.lev>=2 order by mi.cod , mm.lev,ord
		) b order by b.ord) a*/
	
		raise notice '%',json_array_length(rt);

    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:='{"dati":'||rt||'}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_conf.get_cu_tipo_oggetti_validi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_tipi_oggetti_piano(json, bigint); Type: FUNCTION; Schema: cu_conf; Owner: postgres
--

CREATE FUNCTION cu_conf.upd_cu_tipi_oggetti_piano(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idpiano bigint;
        proc_name varchar; -- END
        v_j json;
        begin
		proc_name:='cu_conf.upd_cu_tipi_oggetti_piano';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		idpiano:=v_j->'id_piano';
		
		raise notice 'v%', v_j;
		raise notice 'id_tipo_oggetto %', v_j->'id_tipo_oggetto';
		delete  from cu_conf.cu_tipo_oggetto_piani  where id_tipo_oggetto not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_tipo_oggetto'))
			and id_piano =idpiano;
		
		insert into cu_conf.cu_tipo_oggetto_piani
			select nextval('cu.cu_id_seq'),(value::varchar)::bigint, idpiano from 
			json_array_elements(v_j->'id_tipo_oggetto') 
			where (value::varchar)::bigint not in (select id_tipo_oggetto from  cu_conf.cu_tipo_oggetto_piani op
			where  id_piano =idpiano);

    	ret.esito:=true;	
        ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
		return ret;
	end;
END
$$;


ALTER FUNCTION cu_conf.upd_cu_tipi_oggetti_piano(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_cu_tipi_oggetti_piano(character varying, bigint); Type: FUNCTION; Schema: cu_conf; Owner: postgres
--

CREATE FUNCTION cu_conf.upd_cu_tipi_oggetti_piano(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idpiano bigint;
        proc_name varchar; -- END
        v_j json;
        begin
		proc_name:='cu_conf.upd_cu_tipi_oggetti_piano';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		idpiano:=v_j->'id_piano';
	
		delete  from cu_conf.cu_tipo_ogetti_piani  where id_tipo_oggetto not in 
			(select (value::varchar)::bigint from json_array_elements(v_j->'id_tipo_oggetto'))
			and id_piano =idpiano;
		
		insert into cu_conf.cu_tipo_oggetto_piani
			select nextval('cu.cu_id_seq'), idpiano,(value::varchar)::bigint from 
			json_array_elements(v_j->'id_tipo_oggetto') 
			where (value::varchar)::bigint not in (select id_tipo_oggetto from  cu_conf.cu_tipo_ogetti_piani op
			where  id_piano =idpiano);

    	ret.esito:=true;	
        ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
		return ret;
	end;
END
$$;


ALTER FUNCTION cu_conf.upd_cu_tipi_oggetti_piano(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: result_type; Type: TABLE; Schema: rbac_types; Owner: postgres
--

CREATE TABLE rbac_types.result_type (
    esito boolean,
    valore text,
    msg character varying,
    info character varying,
    err_msg character varying
);


ALTER TABLE rbac_types.result_type OWNER TO postgres;

--
-- Name: get_operazioni_by_sel(json, bigint); Type: FUNCTION; Schema: cu_his; Owner: postgres
--

CREATE FUNCTION cu_his.get_operazioni_by_sel(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;
	proc_name varchar;
	rt json;
	v_limite int;
	v_id_funzione int;
	v_tipo_operazione varchar;
	v_data_inizio timestamp;
	v_data_fine timestamp;
	codice varchar;

	begin
		proc_name:='cu_his.get_operazioni_by_sel';
		ret.esito:=false;

		if v->>'limite' is not null then
			v_limite:=v->>'limite';
		end if;

		codice:='%'||cu_anag.string_normalize(v->>'codice')||'%';
/*	
		select json_agg(row_to_json(a.*)) into rt   
			from (select * from cu_his.vw_ref_all r
			where (descr_oggetto ilike codice or( descr_oggetto is null and codice = '%%')) 
			order by r.his_id_transazione desc limit v_limite) a;
*/
		select json_agg(row_to_json(a.*)) into rt   
			from (select * from log.vw_operazioni vo
			where (id_funzione = v_id_funzione or (v_id_funzione is null))
			and (tipo ilike v_tipo_operazione or (v_tipo_operazione is null))
			and (v_data_inizio is null or ts >= v_data_inizio)
			and (ts <= v_data_fine or v_data_fine is null )
			and (cod_area ilike 'AN' or cod_area ilike 'CU')  
			order by descr limit v_limite) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_his.get_operazioni_by_sel(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_riepilogo_cu(json, bigint); Type: FUNCTION; Schema: cu_his; Owner: postgres
--

CREATE FUNCTION cu_his.get_riepilogo_cu(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idtransazione bigint;
	idcu bigint;
	_dt timestamp;
	rt json;
	R_T cu_his.vw_ref_all;

	begin
		proc_name:='cu_his.get_riepilogo_cu';
		ret.esito:=false;
		
		/*
		if v->>'id_cu' is null then
			select id_cu into idcu from cu.vw_cu
			where codice = v->>'codice';
		else
			idcu:=v->>'id_cu';
		end if;
		
		_dt:=localtimestamp;
		*/
		idtransazione:=v->>'id_transazione';

		select * into R_T from cu_his.vw_ref_all_cu where his_id_transazione = idtransazione;

		idcu:=R_T.id;
		_dt:=lower(R_T.his_validita);
		
		select json_agg(row_to_json(a.*)) into rt   from (
		select c.id_node, c.id_node_parent, c.id_node_parent id_node_ref, c.node_descr, c.descr descrizione_breve 
			from (
			select id_node,id_node_parent,node_descr,descr from cu_his.vw_riepilogo_cu_nodes_up_descr
			union
			select id id_node,
				case 
					when cn.id_tipo_nucleo = 1 then 3
					when cn.id_tipo_nucleo = 3 then 4
					when cn.id_tipo_nucleo = 2 then 5
				end as id_node_parent, 
			'' descr_breve,cn.nominativo_nucleo as descr
			from cu_his.vw_cu_nucleo cn
			where id_cu=idcu and cn.his_validita @> _dt 
			union
			select id id_node, id_cu_nucleo id_node_parent, '',
			coalesce(np.descr_isp, np.descr_per, np.ruolo)||' ['|| np.inizio || ' - '||np.fine||']'
			from cu_his.vw_cu_nucleo_periodi np
			where id_cu=idcu and np.his_validita @> _dt
			union
			select id id_node, 6 id_node_parent, '',
			l.desc_tipo_linea
			from cu_his.vw_cu_linee l
			where id_cu=idcu and l.his_validita @> _dt 
			union
			select id id_node, 7 id_node_parent, '',
			p.descrizione_completa_piano
			from cu_his.vw_cu_piani p
			where id_cu=idcu and p.his_validita @> _dt 
			union
			select id id_node, 8 id_node_parent, '',
			o.cod_oggetto ||' - '||o.sigla_oggetto|| coalesce(' ['|| o.descr_stato ||']', '')
			from cu_his.vw_cu_oggetti o
			where id_cu=idcu and o.his_validita @> _dt 
			union
			select id id_node,cl.id_cu_oggetto id_node_parent, '',
			cl.descr_requisito|| coalesce(' ['|| cl.descr_stato ||']', '')
			from cu_his.vw_cu_oggetti_cl cl
			where id_cu=idcu and cl.his_validita @> _dt 
			union
			select id id_node,e.id_cu_oggetto_cl id_node_parent, '',
			e.descr_classe_evidenza || coalesce(' - '|| e.descr_grado_evidenza, '') || coalesce(' - '|| e.evidenza, '') || ' ' ||(select string_agg(descr, ', ') from cu.vw_evidenza_lista_linee l where l.id_cu_evidenza = e.id)
			from cu_his.vw_cu_evidenze e
			where id_cu=idcu and e.his_validita @> _dt 
			union
			select id id_node,9 id_node_parent, '',
			nv.norma
			from cu_his.vw_cu_norme_violate nv
			where id_cu=idcu and nv.his_validita @> _dt 
			union
			select id id_node,p.id_norma_violata id_node_parent, '',
			p.descr_tipo_provv || coalesce(' ['||p.dt::text||']','')
			from cu_his.vw_cu_provv p
			where id_cu=idcu and p.his_validita @> _dt 
			union
			select id id_node,10 id_node_parent, '',
			pf.norma || ' - '|| pf.descr_provv || coalesce(' ['||pf.risolta_descr::text||']','')
			from cu_his.vw_cu_provv_fu pf
			where id_cu=idcu and pf.his_validita @> _dt 
			union
			select id id_node,11 id_node_parent, '',
			ps.descr_classe_evidenza || coalesce(' - '|| ps.descr_grado_evidenza, '') || coalesce(' - '|| ps.evidenza, '') || ' ' || ps.descr_linee || ' - ' || ps.descrizione_completa_piano || ' - ' || ps.descr_provv || ' - ' || ps.nominativo_vet
			from cu_his.vw_cu_provv_sopralluogo ps
			where id_cu=idcu and ps.his_validita @> _dt 
			union
			select id id_node,12 id_node_parent, '',
			psf.descr_classe_evidenza || coalesce(' - '|| psf.descr_grado_evidenza, '') || coalesce(' - '|| psf.evidenza, '') || ' ' || psf.descr_linee || ' - ' || psf.descrizione_completa_piano || ' - ' || psf.descr_provv || coalesce(' ['||psf.risolta_descr::text||']','')
			from cu_his.vw_cu_provv_sopralluogo_fu psf
			where id_cu=idcu and psf.his_validita @> _dt 
			union
			select id id_node,13 id_node_parent, '',
			ca.marca || ' - ' || ca.modello || ' - ' || ca.targa
			from cu_his.vw_cu_automezzi ca
			where id_cu=idcu and ca.his_validita @> _dt 
			
			--union ...
			) c order by id_node
		) a;
	
	
	
		/*select json_agg(row_to_json(a.*)) into rt   from (
				select c.id_node, c.id_node_parent, c.id_node_parent id_node_ref, c.node_descr, c.descr descrizione_breve 
				from (
				select * from cu_his.vw_riepilogo_cu_nodes_up_descr
				union
				select vcnp.his_id, '' cod, '' sigla,
				vcnp.nominativo_nucleo || ' - ' || coalesce(vcnp.descr_isp, vcnp.descr_per, vcnp.ruolo) || ' [' || vcnp.inizio ||' - '|| vcnp.fine || ']' as descr,
				vcnp.his_id as id_node, 
				case 
					when vcnp.sigla_tipo_nucleo = 'NI' then 3
					when vcnp.sigla_tipo_nucleo = 'P' then 4
					when vcnp.sigla_tipo_nucleo = 'E' then 5
				end as id_node_parent, -- case
				'' path, '' path_ord, '' path_descr, null::int lv, '' node_descr, row_number() over()::text as ordinamento
				from cu_his.vw_cu_nucleo cn
				join cu_his.vw_cu_nucleo_periodi vcnp on vcnp.id_cu_nucleo = cn.id
				where cn.id_cu = idcu
				and cn.his_validita @> localtimestamp 
				and vcnp.his_validita @> localtimestamp 
				--union ...
				) c
			) a;*/
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||rt::varchar||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_his.get_riepilogo_cu(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: end_op(character varying, bigint, character varying); Type: FUNCTION; Schema: cu_log; Owner: postgres
--

CREATE FUNCTION cu_log.end_op(pname character varying, idtransazione bigint, v character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	begin
		insert into cu_log.call_logs   values (nextval('cu_log.call_logs_id_seq'),idtransazione,pname,'END',CLOCK_TIMESTAMP(),v);
		/*if length(v)>0 then
			update cu_log.operazioni set ret=v,ts_end=CLOCK_TIMESTAMP()
			where id_transazione=idtransazione and ret is null and procedura=pname;
		else
			update cu_log.operazioni set ret=v,ts_end=CLOCK_TIMESTAMP()
			where id_transazione=idtransazione and ret is null and procedura=pname;
		end if;*/
		return(currval('cu_log.operazioni_id_seq'));
	end;
END
$$;


ALTER FUNCTION cu_log.end_op(pname character varying, idtransazione bigint, v character varying) OWNER TO postgres;

--
-- Name: get_id_transazione(bigint, character varying); Type: FUNCTION; Schema: cu_log; Owner: postgres
--

CREATE FUNCTION cu_log.get_id_transazione(iduser bigint, titolo character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare R_T cu_log.transazioni%ROWTYPE;
	begin
		R_T.id=nextval('cu_log.transazioni_id_seq');
		R_T.id_user=iduser;
		R_T.ts:=current_timestamp;
		R_T.descr:=titolo;
		insert into cu_log.transazioni values (R_T.*);
		return R_T.id;
	end;
END
$$;


ALTER FUNCTION cu_log.get_id_transazione(iduser bigint, titolo character varying) OWNER TO postgres;

--
-- Name: op(character varying, bigint, character varying, json, timestamp without time zone, bigint, character varying); Type: FUNCTION; Schema: cu_log; Owner: postgres
--

CREATE FUNCTION cu_log.op(pname character varying, idtransazione bigint, param character varying, v json, tsstart timestamp without time zone, idtrattato bigint DEFAULT '-1'::integer, tipooperazione character varying DEFAULT ''::character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	stmt varchar;
	begin
		
		/*stmt:= format('insert into ag_log.operazioni (id,id_transazione,procedura,fase,ts_start,ts_end,ts_transazione,val,id_trattato,ret) 
		values (nextval(''ag_log.operazioni_id_seq''),%L,''%s'',''%s'',''%s'',CLOCK_TIMESTAMP(),current_timestamp,''%s'',
			%L,    		''%s'')',idtransazione,pname,tipooperazione,tsstart::varchar,param,idtrattato,v::varchar);
		perform dblink_exec('dbname=mdgm_fvg',stmt);*/
		insert into cu_log.operazioni  
			(id,id_transazione,procedura,fase,ts_start,ts_end,ts_transazione,val,id_trattato,ret) 
		values 
			(nextval('cu_log.operazioni_id_seq'),idtransazione,pname,tipooperazione,tsstart,CLOCK_TIMESTAMP(),current_timestamp,param,
			idtrattato,    						 '"esito":' ||coalesce(v->>'esito','')  ||
				',"valore":'||coalesce(v->>'valore','') ||
				',"msg":'   ||coalesce(v->>'msg'  ,''));

    	return(currval('cu_log.operazioni_id_seq'));
	end;
END
$$;


ALTER FUNCTION cu_log.op(pname character varying, idtransazione bigint, param character varying, v json, tsstart timestamp without time zone, idtrattato bigint, tipooperazione character varying) OWNER TO postgres;

--
-- Name: start_op(character varying, bigint, character varying, bigint); Type: FUNCTION; Schema: cu_log; Owner: postgres
--

CREATE FUNCTION cu_log.start_op(pname character varying, idtransazione bigint, param character varying, idtrattato bigint DEFAULT '-1'::integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	begin
		insert into cu_log.call_logs   values (nextval('cu_log.call_logs_id_seq'),idtransazione,pname,'START',CLOCK_TIMESTAMP(),param);
		--insert into cu_log.operazioni  (id,id_transazione,procedura,fase,ts_start,ts_transazione,val,id_trattato) values 
	--(nextval('cu_log.operazioni_id_seq'),idtransazione,pname,'START',CLOCK_TIMESTAMP(),current_timestamp,param,idtrattato);
		return(currval('cu_log.call_logs_id_seq'));
	end;
END
$$;


ALTER FUNCTION cu_log.start_op(pname character varying, idtransazione bigint, param character varying, idtrattato bigint) OWNER TO postgres;

--
-- Name: upd_record(character varying, bigint, record, character varying); Type: FUNCTION; Schema: cu_log; Owner: postgres
--

CREATE FUNCTION cu_log.upd_record(tbl character varying, idtransazione bigint, r record, act character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	r_new record;
	begin
		act = upper(act);
		raise notice 'TBL=% ACT=%',tbl,act;
		if act = 'D' or act = 'U' then
			raise notice 'D U TBL %',tbl;
			case   tbl 
				when 'cu_anag.imprese'      then
					update cu_his.imprese             					set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id=R.id and upper_inf(his_validita);
				when 'cu_anag.impresa_sedi'      then
					update cu_his.impresa_sedi             					set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id=R.id and upper_inf(his_validita);
				when 'cu_anag.impresa_figure'      then
					update cu_his.impresa_figure             					set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id=R.id and upper_inf(his_validita);
				when 'cu_anag.stabilimenti' then 
					update cu_his.stabilimenti      			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id=R.id and upper_inf(his_validita);
				when 'cu_anag.stabilimento_sedi'      then
					update cu_his.stabilimento_sedi             					set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id=R.id and upper_inf(his_validita);
				when 'cu_anag.stabilimento_figure'      then
					update cu_his.stabilimento_figure             					set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id=R.id and upper_inf(his_validita);
				when 'cu_anag.linee'        then 
				    update cu_his.linee      			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu_anag.indirizzi'        then 
				    update cu_his.indirizzi      			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu_anag.soggetti_fisici'        then 
				    update cu_his.soggetti_fisici      			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu_anag.pratiche'        then 
				    update cu_his.pratiche      			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu_anag.storico_pratiche'        then 
				    update cu_his.storico_pratiche      			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu_anag.codici'        then 
				    update cu_his.codici	set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
					
				when 'cu.cu_nucleo'        then 
				    update cu_his.cu_nucleo   			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_nucleo_periodi'        then 
				    update cu_his.cu_nucleo_periodi 			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_altri'        then 
				    update cu_his.cu_altri  			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_dichiarazioni'        then 
				    update cu_his.cu_dichiarazioni			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_linee'        then 
				    update cu_his.cu_linee			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_piani'        then 
				    update cu_his.cu_piani			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_oggetti'        then 
				    update cu_his.cu_oggetti			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_oggetti_cl'        then 
				    update cu_his.cu_oggetti_cl			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_evidenze'        then 
				    update cu_his.cu_evidenze			 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_evidenza_linee'        then 
				    update cu_his.cu_evidenza_linee		 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_norme_violate'        then 
				    update cu_his.cu_norme_violate		 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_provv'        then 
				    update cu_his.cu_provv		 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu'        then 
				    update cu_his.cu		 			set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_provv_sopralluogo_fu'        then 
				    update cu_his.cu_provv_sopralluogo_fu	set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_provv_sopralluogo'        then 
				    update cu_his.cu_provv_sopralluogo	set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_provv_fu'        then 
				    update cu_his.cu_provv_fu	set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_automezzi'        then 
				    update cu_his.cu_automezzi	set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
				when 'cu.cu_indirizzi'        then 
				    update cu_his.cu_indirizzi	set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id  =R.id and upper_inf(his_validita);
			else
				return -1;
			end case;
		end if;
		if act = 'U' or act = 'I' then
			raise notice 'I U TBL %',tbl;
					raise notice 'D U TBL %',tbl;
			case   tbl 
				when 'cu_anag.imprese'      then 
					insert into cu_his.imprese
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu_anag.imprese e where id=r.id;				
				when 'cu_anag.impresa_sedi'      then 
					insert into cu_his.impresa_sedi
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu_anag.impresa_sedi e where id=r.id;	
				when 'cu_anag.impresa_figure'      then 
					insert into cu_his.impresa_figure
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from  cu_anag.impresa_figure e where id=r.id;	
				when 'cu_anag.stabilimenti'      then 
					insert into cu_his.stabilimenti
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu_anag.stabilimenti e where id=r.id;	
				when 'cu_anag.stabilimento_sedi'      then 
					insert into cu_his.stabilimento_sedi
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu_anag.stabilimento_sedi e where id=r.id;	
				when 'cu_anag.stabilimento_figure'      then 
					insert into cu_his.stabilimento_figure
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu_anag.stabilimento_figure e where id=r.id;	
				when 'cu_anag.linee'      then 
					insert into cu_his.linee
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu_anag.linee e where id=r.id;	
				when 'cu_anag.indirizzi'      then 
					insert into cu_his.indirizzi
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu_anag.indirizzi e where id=r.id;
				when 'cu_anag.soggetti_fisici'      then 
					insert into cu_his.soggetti_fisici
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu_anag.soggetti_fisici e where id=r.id;	
				when 'cu_anag.pratiche'      then 
					insert into cu_his.pratiche
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu_anag.pratiche e where id=r.id;	
				when 'cu_anag.storico_pratiche'      then 
					insert into cu_his.storico_pratiche
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu_anag.storico_pratiche e where id=r.id;	
				when 'cu_anag.codici'      then 
					insert into cu_his.codici
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu_anag.codici e where id=r.id;	
						
				when 'cu.cu_nucleo'      then 
					insert into cu_his.cu_nucleo
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_nucleo e where id=r.id;	
				when 'cu.cu_nucleo_periodi'      then 
					insert into cu_his.cu_nucleo_periodi
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_nucleo_periodi  e where id=r.id;	
				when 'cu.cu_altri'      then 
					insert into cu_his.cu_altri
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_altri  e where id=r.id;	
				when 'cu.cu_dichiarazioni'      then 
					insert into cu_his.cu_dichiarazioni
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_dichiarazioni  e where id=r.id;	
				when 'cu.cu_linee'      then 
					insert into cu_his.cu_linee
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_linee  e where id=r.id;	
				when 'cu.cu_piani'      then 
					insert into cu_his.cu_piani
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_piani  e where id=r.id;	
				when 'cu.cu_oggetti'      then 
					insert into cu_his.cu_oggetti
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_oggetti  e where id=r.id;	
				when 'cu.cu_oggetti_cl'      then 
					insert into cu_his.cu_oggetti_cl
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_oggetti_cl  e where id=r.id;	
				when 'cu.cu_evidenze'      then 
					insert into cu_his.cu_evidenze
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_evidenze  e where id=r.id;	
				when 'cu.cu_evidenza_linee'      then 
					insert into cu_his.cu_evidenza_linee
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_evidenza_linee  e where id=r.id;	
				when 'cu.cu_norme_violate'      then 
					insert into cu_his.cu_norme_violate
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_norme_violate  e where id=r.id;	
				when 'cu.cu_provv'      then 
					insert into cu_his.cu_provv
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_provv  e where id=r.id;	
				when 'cu.cu'      then 
					insert into cu_his.cu
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu  e where id=r.id;	
				when 'cu.cu_provv_sopralluogo_fu'      then 
					insert into cu_his.cu_provv_sopralluogo_fu
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_provv_sopralluogo_fu  e where id=r.id;	
				when 'cu.cu_provv_sopralluogo'      then 
					insert into cu_his.cu_provv_sopralluogo
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_provv_sopralluogo  e where id=r.id;	
				when 'cu.cu_provv_fu'      then 
					insert into cu_his.cu_provv_fu
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_provv_fu  e where id=r.id;	
				when 'cu.cu_automezzi'      then 
					insert into cu_his.cu_automezzi
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_automezzi  e where id=r.id;	
				when 'cu.cu_indirizzi'      then 
					insert into cu_his.cu_indirizzi
						select nextval('cu_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from cu.cu_indirizzi  e where id=r.id;	
			else
				return -1;
			end case;
		end if;
		return 0;
	end;
END
$$;


ALTER FUNCTION cu_log.upd_record(tbl character varying, idtransazione bigint, r record, act character varying) OWNER TO postgres;

--
-- Name: get_dati(character varying, character varying, bigint, json); Type: PROCEDURE; Schema: cu_srv; Owner: postgres
--

CREATE PROCEDURE cu_srv.get_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json)
    LANGUAGE plpgsql
    AS $$
begin
	declare
		proc_name varchar;
	begin
		proc_name:='cu_srv.get_dati';
		call cu.get_dati(operazione,v,idutente,joutput);
	end;
END
$$;


ALTER PROCEDURE cu_srv.get_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json) OWNER TO postgres;

--
-- Name: get_id_transazione(bigint); Type: FUNCTION; Schema: cu_srv; Owner: postgres
--

CREATE FUNCTION cu_srv.get_id_transazione(iduser bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare R_T cu_log.transazioni%ROWTYPE;
	proc_name varchar;
	id_op bigint;

	begin
		proc_name:='cu_srv.get_id_transazione';
	    R_T.id:=cu_log.get_id_transazione(iduser);
		id_op:=cu_log.start_op(proc_name, R_T.id ,'');
		id_op:=cu_log.end_op(proc_name, R_T.id , '');
		return R_T.id;

	end;
END
$$;


ALTER FUNCTION cu_srv.get_id_transazione(iduser bigint) OWNER TO postgres;

--
-- Name: upd_dati(character varying, character varying, bigint, json); Type: PROCEDURE; Schema: cu_srv; Owner: postgres
--

CREATE PROCEDURE cu_srv.upd_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json)
    LANGUAGE plpgsql
    AS $$

	declare
		proc_name varchar;
		text_msg1 varchar;	
	text_msg2 varchar;	
	text_msg3 varchar;	
	text_msg4 varchar;
	ret cu_types.result_type;
	begin
		proc_name:='cu_srv.upd_dati';
		call cu.upd_dati(operazione,v,idutente,joutput);

	end;

$$;


ALTER PROCEDURE cu_srv.upd_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json) OWNER TO postgres;

--
-- Name: get_categorie_rischio(json, bigint); Type: FUNCTION; Schema: cu_types; Owner: postgres
--

CREATE FUNCTION cu_types.get_categorie_rischio(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	begin
		proc_name:='cu.get_categorie_rischio';
		ret.esito:=false;

		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu_types.vw_categorie_rischio order by id asc) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_types.get_categorie_rischio(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_classe_evidenze(json, bigint); Type: FUNCTION; Schema: cu_types; Owner: postgres
--

CREATE FUNCTION cu_types.get_cu_classe_evidenze(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	v_id_tipo_oggetto bigint;
	begin
		proc_name:='cu.get_cu_classe_evidenze';
		ret.esito:=false;

		if v->'id_tipo_oggetto' is not null then
			v_id_tipo_oggetto:=v->'id_tipo_oggetto';
		else
			v_id_tipo_oggetto:=1;
		end if;

		select json_agg(row_to_json(a.*)) into rt   from (
			--select * from cu_types.vw_cu_classe_evidenze 30/08/2024
			select * from cu_types.vw_cu_classe_evidenze c
			where c.id_cu_classe_evidenza in (
					select id_classe_evidenza 
					from cu_types.cu_tipo_oggetti_evidenze
					where id_oggetto = v_id_tipo_oggetto)
		) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_types.get_cu_classe_evidenze(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_grado_evidenze(json, bigint); Type: FUNCTION; Schema: cu_types; Owner: postgres
--

CREATE FUNCTION cu_types.get_cu_grado_evidenze(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	begin
		proc_name:='cu.get_cu_grado_evidenze';
		ret.esito:=false;

		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu_types.vw_cu_grado_evidenze) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_types.get_cu_grado_evidenze(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipi_figure(json, bigint); Type: FUNCTION; Schema: cu_types; Owner: postgres
--

CREATE FUNCTION cu_types.get_cu_tipi_figure(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	begin 
		proc_name:='cu_types.get_cu_tipi_figure';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
	select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_types.vw_tipi_figura )  g;
		
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'sedi_non_trovati');
    	else
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_types.get_cu_tipi_figure(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipi_figure_impresa(json, bigint); Type: FUNCTION; Schema: cu_types; Owner: postgres
--

CREATE FUNCTION cu_types.get_cu_tipi_figure_impresa(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	begin 
		proc_name:='cu_types.get_cu_tipi_figure_impresa';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
	select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_types.vw_tipi_figura_impresa )  g;
		
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'sedi_non_trovati');
    	else
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_types.get_cu_tipi_figure_impresa(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipi_provv(json, bigint); Type: FUNCTION; Schema: cu_types; Owner: postgres
--

CREATE FUNCTION cu_types.get_cu_tipi_provv(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	--idcu bigint;
	idnorma bigint;
	v_id_tipo_oggetto bigint;
	begin
		proc_name:='cu.get_cu_tipi_provv';
		ret.esito:=false;
		--idcu:= v->'id_cu';
		idnorma:= v->'id_norma';

		if v->'id_tipo_oggetto' is not null then
			v_id_tipo_oggetto:=v->'id_tipo_oggetto';
		else
			v_id_tipo_oggetto:=1;
		end if;

		select json_agg(row_to_json(a.*)) into rt   from (
			/* 30/08/2024
			select * from cu_types.vw_cu_tipi_provv vctp 
			where id not in (select id_tipo_provv from cu.vw_cu_provv where id_evidenza = idnorma)
			order by id asc
			*/
			
			select * from cu_types.vw_cu_tipi_provv vctp 
			where id not in (select id_tipo_provv from cu.vw_cu_provv where id_evidenza = idnorma)
			and id in (select id_tipo_provvedimento from cu_types.cu_tipo_oggetti_provvedimenti where id_oggetto = v_id_tipo_oggetto)
			order by id asc
	
		) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_types.get_cu_tipi_provv(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipi_provv_sopralluogo(json, bigint); Type: FUNCTION; Schema: cu_types; Owner: postgres
--

CREATE FUNCTION cu_types.get_cu_tipi_provv_sopralluogo(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idcu bigint;
	--idnorma bigint;
	begin
		proc_name:='cu.get_cu_tipi_provv_sopralluogo';
		ret.esito:=false;
		idcu:= v->'id_cu';
		--idnorma:= v->'id_norma';

		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu_types.vw_cu_tipi_provv vctp 
			--where id not in (select id_tipo_provv from cu.vw_cu_provv_sopralluogo where id_cu = idcu)
			order by id asc) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_types.get_cu_tipi_provv_sopralluogo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipi_sede(json, bigint); Type: FUNCTION; Schema: cu_types; Owner: postgres
--

CREATE FUNCTION cu_types.get_cu_tipi_sede(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	begin 
		proc_name:='cu_types.get_cu_tipi_sede';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
	select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_types.vw_tipi_sede )  g;
		
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'sedi_non_trovati');
    	else
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_types.get_cu_tipi_sede(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipi_sede_impresa(json, bigint); Type: FUNCTION; Schema: cu_types; Owner: postgres
--

CREATE FUNCTION cu_types.get_cu_tipi_sede_impresa(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	begin 
		proc_name:='cu_types.get_cu_tipi_sede_impresa';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
	select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_types.vw_tipi_sede_impresa)  g;
		
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'sedi_non_trovati');
    	else
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_types.get_cu_tipi_sede_impresa(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_cu_tipo_imprese(json, bigint); Type: FUNCTION; Schema: cu_types; Owner: postgres
--

CREATE FUNCTION cu_types.get_cu_tipo_imprese(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
declare
	ret cu_types.result_type; 
	proc_name varchar;
	rt json;
	idstrutturaroot bigint;
	begin 
		proc_name:='cu_types.get_cu_tipo_imprese';
		idstrutturaroot=v->'user_info'->'id_struttura_root';
		raise notice 'v=%',v;
		raise notice 'idstrutturaroot=%',idstrutturaroot;
	select json_agg(row_to_json(g.*)) into rt from (
			select * from cu_types.vw_cu_tipo_imprese)  g;
		
		raise notice '%',json_array_length(rt);
		ret.info:=null;
		ret.esito:=true;	
	
		if json_array_length(rt) is null then
    	    ret:=cu_ui.build_ret(ret,proc_name, 'tipo_imprese_non_trovate');
    	else
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
	
	END;
$$;


ALTER FUNCTION cu_types.get_cu_tipo_imprese(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tipi_pratiche(json, bigint); Type: FUNCTION; Schema: cu_types; Owner: postgres
--

CREATE FUNCTION cu_types.get_tipi_pratiche(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	begin
		proc_name:='cu_types.get_tipi_pratiche';
		ret.esito:=false;

		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu_types.vw_tipi_pratiche) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_types.get_tipi_pratiche(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tipologie_struttura(json, bigint); Type: FUNCTION; Schema: cu_types; Owner: postgres
--

CREATE FUNCTION cu_types.get_tipologie_struttura(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	begin
		proc_name:='cu.get_tipologie_struttura';
		ret.esito:=false;

		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu_types.vw_tipologie_struttura where modificabile) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_types.get_tipologie_struttura(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tipologie_struttura_all(json, bigint); Type: FUNCTION; Schema: cu_types; Owner: postgres
--

CREATE FUNCTION cu_types.get_tipologie_struttura_all(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	begin
		proc_name:='cu.get_tipologie_struttura_all';
		ret.esito:=false;

		select json_agg(row_to_json(a.*)) into rt   from (
			select * from cu_types.vw_tipologie_struttura order by descrizione asc) a;
		raise notice 'RT %',rt;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_types.get_tipologie_struttura_all(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: build_ret(cu_types.result_type, character varying, character varying); Type: FUNCTION; Schema: cu_ui; Owner: postgres
--

CREATE FUNCTION cu_ui.build_ret(r cu_types.result_type, pname character varying, val character varying) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	begin
		--r.valore:= val;
		--if not r.esito then
			--r.msg:=coalesce(r.msg,'') || ' ('|| coalesce(r.valore,-1)||')' ;
			raise notice 'get_proc_msg';
			r.msg:=/*coalesce(r.msg,'')||' '||CHR(13)||*/cu_ui.get_proc_msg(pname,val);
			if r.msg is null then 
				r.msg:='Messaggio non presente in tabella '||val;
				r.err_msg :=' ['||coalesce(pname,'PROC UNDEFINED')||' ('||val||') ] ';
			end if;
		--end if;
		return r;
	end;
END
$$;


ALTER FUNCTION cu_ui.build_ret(r cu_types.result_type, pname character varying, val character varying) OWNER TO postgres;

--
-- Name: get_menu(json, bigint); Type: FUNCTION; Schema: cu_ui; Owner: postgres
--

CREATE FUNCTION cu_ui.get_menu(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	v_mn varchar;
	rt json;
	lv numeric;
	idasl numeric;
	idruolo bigint;

	begin
		proc_name:='cu_ui.get_menu';
		raise notice 'v=%',v;
		v_mn:=replace((v->'menu')::varchar,'"','');
	
		if v_mn is null then
			ret.esito:=false;
			--ret.msg:='parametro menu non specificato';
		    ret:=cu_ui.build_ret(ret,proc_name, 'parametro_menu_non_specificato');
			ret.info:=rt;
			return ret;
		end if;
		
		lv:=v->'user_info'->'livello';
		idasl:=v->'user_info'->'id_asl';
		idruolo:=v->'user_info'->'id_ruolo';
		raise notice 'lv -> %', lv;
	
		raise notice 'v_mn=%',v_mn;	
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (
		select * from (
					select distinct on (mi.cod)  mi.cod,icon ,mm.lev,ord,mi.descr, mm.modality
					from cu_ui.menu m join cu_ui.menu_items mi on m.id=mi.id_menu 
				join cu_ui.menu_item_modes mm on mm.id_menu_item =mi.id
				where m.cod = v_mn
					and mm.lev_range @>lv
					and (mm.id_asl is null or mm.id_asl =idasl)
					and (mm.id_ruolo is null or mm.id_ruolo =idruolo)
					order by mi.cod ,ord
			--where m.cod = v_mn and mm.lev>=lv order by mi.cod , mm.lev,ord
		) b order by b.ord) a;
	
		--ret.valore:= id_record;
	
	
	
		/*	select json_agg(row_to_json(a.*))  from (
		select * from (
					select distinct on (mi.cod)  mi.cod ,mm.lev,ord,mi.descr, mm.modality from ag_ui.menu m join ag_ui.menu_items mi on m.id=mi.id_menu 
				join ag_ui.menu_item_modes mm on mm.id_menu_item =mi.id
			where m.cod = 'config' and mm.lev>=2 order by mi.cod , mm.lev,ord
		) b order by b.ord) a*/
	
		raise notice '%',json_array_length(rt);

    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=rt;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_ui.get_menu(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_proc_msg(character varying, character varying); Type: FUNCTION; Schema: cu_ui; Owner: postgres
--

CREATE FUNCTION cu_ui.get_proc_msg(proc character varying, cod character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare n integer;
	R_msg cu_ui.messaggi_ui%ROWTYPE;
begin
	select * into R_msg from cu_ui.messaggi_ui where procedura=proc and valore=cod;
	raise notice 'cu_ui.get_proc_msg % % %',proc,cod,R_msg.id;
	if R_msg.id is null then
		insert into cu_ui.messaggi_ui values(nextval('cu_ui.messaggi_ui_id_seq'),proc,cod,cod);
	end if;
	if R_msg.id is not null then
		return coalesce(R_msg.msg,'');
	end if;
	if cod is null and cod != '0' then
		return 'ERRORE GENERICO ('|| cod ||')';
	end if;

	if cod = '0' then
		return 'DATI SALVATI';
	end if;
	return /* 'ERRORE ['||proc||'] */ '( '||cod||' )' ;
end;
end
$$;


ALTER FUNCTION cu_ui.get_proc_msg(proc character varying, cod character varying) OWNER TO postgres;

--
-- Name: get_ui_definition(character varying, character varying, bigint, bigint); Type: FUNCTION; Schema: cu_ui; Owner: postgres
--

CREATE FUNCTION cu_ui.get_ui_definition(type_info character varying, fnct character varying, id_ns bigint, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare
	R_NS matrix.vw_nominativi_struttura;
	R_GD cu_ui.grid_definition;
	proc_name varchar;
	begin
		proc_name:='cu_ui.get_ui_definition';
		raise notice 'type_info % fcnt % id_ns %',type_info,fnct,id_ns;
	
		select * into R_GD from cu_ui.grid_definition gd where funct=fnct limit 1;

		/*case type_info
			when  'grid' then
			
				select * into R_GD from ag_ui.grid_definition gd join matrix.vw_tree_nodes_down t on t.id_node_ref=gd.id_user
					where t.id_node=id_ns and funct=fnct order by dist_node limit 1;
				/*select * into R_GD from ag_ui.grid_definition gd where gd.id_user =id_ns  and funct=fnct;
				if R_GD.id_user is null then
					select * into R_NS from matrix.vw_nominativi_struttura ns where id=id_ns;
	
					select * into R_GD from ag_ui.grid_definition gd join matrix.vw_tree_nodes_down t on t.id_node_ref=gd.id_user
					where t.id_node=R_NS.id_node_struttura and funct=fnct order by dist_node limit 1;
				end if;*/
			else
				select * into R_GD from ag_ui.grid_definition gd join matrix.vw_tree_nodes_down t on t.id_node_ref=gd.id_user
					where t.id_node=id_ns and funct=fnct order by dist_node limit 1;
		end case;*/
		return R_GD.str_conf;
	end;
end;
$$;


ALTER FUNCTION cu_ui.get_ui_definition(type_info character varying, fnct character varying, id_ns bigint, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ui_form_definition(json, bigint); Type: FUNCTION; Schema: cu_ui; Owner: postgres
--

CREATE FUNCTION cu_ui.get_ui_form_definition(v json, idtransazione bigint) RETURNS cu_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	proc_name varchar;
	ret cu_types.result_type; 
	f varchar;
	typeuser varchar;
	v_sigla varchar;
	rt json;

	begin
		proc_name:='cu_ui.get_ui_form_definition';
		raise notice 'v % ',v;
		f:=v->>'funct';
		--iduser:=
		--typeuser:=
		v_sigla:=v->>'sigla';
	
		select json_agg(row_to_json(a.*)) into rt from (
			select str_conf configurazione  from cu_ui.form_definition fd where funct=f and (v_sigla is null or sigla=v_sigla)) a;

		raise notice '%',json_array_length(rt);

    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=rt;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION cu_ui.get_ui_form_definition(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ui_form_definition(character varying, character varying, bigint, bigint); Type: FUNCTION; Schema: cu_ui; Owner: postgres
--

CREATE FUNCTION cu_ui.get_ui_form_definition(type_info character varying, fnct character varying, id_ns bigint, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare
	R_NS matrix.vw_nominativi_struttura;
	R_FD cu_ui.form_definition;
	proc_name varchar;
	begin
		proc_name:='cu_ui.get_ui_form_definition';
		raise notice 'type_info % fcnt % id_ns %',type_info,fnct,id_ns;
	
		select * into R_FD from cu_ui.form_definition fd where funct=fnct limit 1;

		return R_FD.str_conf;
	end;
end;
$$;


ALTER FUNCTION cu_ui.get_ui_form_definition(type_info character varying, fnct character varying, id_ns bigint, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_dettaglio_operazione(json, bigint); Type: FUNCTION; Schema: log; Owner: postgres
--

CREATE FUNCTION log.get_dettaglio_operazione(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;
	v_id_transazione bigint;
	v_id bigint;
	v_vista varchar;
	v_identificativo varchar;
	str varchar;
	str_ui varchar;
	proc_name varchar;
	rt json;
	rt_ui varchar;
	
	begin
		proc_name:='log.get_dettaglio_operazione';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');

		v_id_transazione:=v->>'id_transazione';	

		v_vista:=v->>'vista';
	
		v_id:= v->>'id';
	
		v_identificativo:= v->>'identificativo';
	
		if v_vista ilike '%ag_his%' or v_vista ilike '%trf_his%' then 
			if v_identificativo is not null then
				select val::json->>v_identificativo into v_id from ag_log.operazioni o 
				where id_transazione = v_id_transazione
				order by id limit 1;
			end if;
		elsif v_vista ilike '%cu_his%' then
			if v_identificativo is not null then
				select val::json->>v_identificativo into v_id from cu_log.operazioni o 
				where id_transazione = v_id_transazione
				order by id limit 1;
			end if;
		end if;
		
		
		
		if v_vista ilike '%_impresa_%' and v_identificativo is not null and v_identificativo = 'id_impresa' then
			raise notice 'v_vista imprese %',v_vista;
			raise notice 'v_id:%',v_id;
			str='select json_agg(row_to_json(a.*))
				from (
					select * from ' ||v_vista||' 
					where id_impresa ';
					if v_id is not null then
						str=str || '= ' || v_id;
					else
						str= str || 'in (select id_impresa 
									from '|| v_vista ||' 
									where his_id_transazione ='|| v_id_transazione||')';
					end if;			
					str = str || ') a';
		elsif (v_vista ilike '%_stabilimento_%' or v_vista ilike '%_linee')  and v_identificativo is not null and v_identificativo = 'id_stabilimento' then
			raise notice 'v_vista stabilimenti %',v_vista;
			raise notice 'v_id:%',v_id;
			str='select json_agg(row_to_json(a.*))
				from (
					select * from ' ||v_vista||' 
					where id_stabilimento ';
					if v_id is not null then
						str=str || '= ' || v_id;
					else
						str= str || 'in (select id_stabilimento 
									from '|| v_vista ||' 
									where his_id_transazione ='|| v_id_transazione||')';
					end if;			
					str = str || ') a';
		else
			raise notice 'v_id:%',v_id;
			str='select json_agg(row_to_json(a.*))
				from (
					select * from ' ||v_vista||' 
					where id ';
					if v_id is not null then
						str=str || '= ' || v_id;
					else
						str= str || 'in (select id 
									from '|| v_vista ||' 
									where his_id_transazione ='|| v_id_transazione||')';
					end if;			
					str = str || ') a';
		end if;
			
		str_ui='select str_conf from rbac_ui.grid_definition where funct = '''||v_vista||''' ';
			
		raise notice 'str:%',str;
		raise notice 'str_ui:%',str_ui;
		
		execute str into rt;
	
		execute str_ui into rt_ui;
	
		raise notice 'rt_ui%',rt_ui;
	
		ret.esito:=true;
	 	ret.info:='{'||rt_ui||',"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION log.get_dettaglio_operazione(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_operazione_singolo(json, bigint); Type: FUNCTION; Schema: log; Owner: postgres
--

CREATE FUNCTION log.get_operazione_singolo(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;
	v_id_transazione bigint;
	proc_name varchar;
	rt json;
	
	begin
		proc_name:='log.get_operazione_singolo';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
	
		v_id_transazione:=v->'id_transazione';
		--and v_tipo_operazione = '%%'
	
		select json_agg(row_to_json(a.*)) into rt   
			from (select * from log.vw_operazioni vo
			where vo.id_transazione = v_id_transazione) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION log.get_operazione_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_operazioni_by_sel(json, bigint); Type: FUNCTION; Schema: log; Owner: postgres
--

CREATE FUNCTION log.get_operazioni_by_sel(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;
	v_id_funzione bigint;
	v_limite int;
	proc_name varchar;
	rt json;
	v_tipo_operazione varchar;
	v_data_inizio timestamp;
	v_data_fine timestamp;
	v_periodo json;	

	begin
		proc_name:='log.get_operazioni_by_sel';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');

		if v->>'id_tipo_operazione' is not null then
		v_id_funzione:=v->>'id_tipo_operazione';
		end if;	
	
		if v->>'periodo' != '' then
			v_periodo:=v->>'periodo';
			raise notice 'fine v_periodo%', v_periodo->>'end';
			if v_periodo->>'start' != '' then
				v_data_inizio:=to_timestamp(v_periodo->>'start'::varchar, 'YYYY-MM-DD"T"HH24:MI:SS');
			end if;
			if v_periodo->>'end' != '' then
				v_data_fine:=to_timestamp(v_periodo->>'end'::varchar, 'YYYY-MM-DD"T"HH24:MI:SS');
					if length(v_periodo->>'end')<=10 then
						v_data_fine:= v_data_fine + interval '1 day';
					end if;
			end if;

		end if;

		if v->>'limite' is not null then
		v_limite:=v->>'limite';
		end if;
	
		if v->>'tipo_operazione' is not null then
		v_tipo_operazione:=v->>'tipo_operazione';
		end if;
		--and v_tipo_operazione = '%%'
	
		raise notice 'id_funzione%',v_id_funzione;
		
		raise notice 'periodo%',v_periodo;
	
		raise notice 'start %',v_data_inizio;
		raise notice 'end %', v_data_fine;
	
		select json_agg(row_to_json(a.*)) into rt   
			from (select --distinct
					vo.*, ra.descr_oggetto, ra.his_id_transazione from "log".vw_operazioni vo
					left join  --cu_his.vw_ref_all 
				cu_his.vw_ref_all_cu_simple ra on vo.id_transazione = ra.his_id_transazione
			where (id_funzione = v_id_funzione or (v_id_funzione is null))
			and (tipo ilike v_tipo_operazione or (v_tipo_operazione is null))
			and (v_data_inizio is null or ts >= v_data_inizio)
			and (ts <= v_data_fine or v_data_fine is null )
			and (cod_area ilike 'AG' or cod_area ilike 'AN' or cod_area ilike 'CU' or cod_area ilike 'TRF')  
			order by ts desc limit v_limite) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION log.get_operazioni_by_sel(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: create_matrix_history(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_matrix_history() RETURNS text
    LANGUAGE plpgsql
    AS $_$
	declare
		curr_version text;
		C record;
		col record;
		i integer;
		dbname text;
		dbaddress text;
	    dbschema text;
   	   	str_DEL character varying;
	   	str_NEXTVAL character varying;
		str character varying;
		str_CREATE character varying;
		str_DECLARE character varying;
		str_PROC character varying;
		str_FETCH character varying;
		field_list character varying;
		fields character varying;
		str_CU character varying;
		str_INS_CU character varying;
		str_MVW character varying;
		str_VERS character varying;
		parentesi character varying;
		str_information_schema character varying;
	begin	
		
	  set search_path to matrix_h;
	
	for C in select * from matrix.tables_history  where status = 'D' loop
		STR_DEL := 'drop table if exists '||C.tname||'_h CASCADE';
		execute STR_DEL;
		STR_DEL := 'drop view if exists vw_'||C.tname||'_h CASCADE';
		execute STR_DEL;
	end loop;

  	   curr_version := '(SELECT last_value FROM "Analisi_dev".vers_seq)';

		str := '';
		str_CU := '';
		str_INS_CU := '';
		str_VERS := '';

		str_CREATE := 'CREATE OR REPLACE FUNCTION matrix.update_matrix_history(
						)
					RETURNS bigint
						LANGUAGE ''plpgsql''
						COST 100
						VOLATILE 
					AS $b$ ';
		str_DECLARE := 'DECLARE
							rec record;';
		str_FETCH := 'begin 
			set search_path to matrix_h;
		';
		for C in select * from matrix.tables_history where (status = 'A' or status = 'C') loop
			str = 'drop view if exists matrix_h.vw_'|| C.table || '_h;';
			execute str;
		
		
			str_information_schema :=  'select c.column_name as parameter_name, c.data_type, c.character_maximum_length
				from information_schema.columns c 
				where table_catalog = ''mdgm'' and table_schema = ''matrix'' and table_name = '''|| C.table ||''' ';
			
		
			str = ' create or replace view  matrix.vw_'|| C.table ||'_h'||
			' AS SELECT * from '||C.table||'';
			field_list := '';
			fields := '';
			i:=0;
		
		
			for col in select * FROM (select cc.column_name as parameter_name, cc.data_type, cc.character_maximum_length
				from information_schema.columns cc 
				where table_catalog = 'mdgm' and table_schema = 'matrix' and table_name = ''|| C.table ||'')as foo loop
			
				if (i>0) then field_list := field_list ||','; fields  = fields || ','; end if;
				field_list = field_list || col.parameter_name ||' '||col.data_type;
				--if col.character_maximum_length is not null then
				--	field_list:=field_list||'('||col.character_maximum_length||')';
				if col.data_type = 'character' then
					field_list:=field_list||' varying';
				end if;
				fields  = fields || col.parameter_name;
				i:=i+1;
			
			
			
			

			end loop;
			--str = str ||field_list||'); ';
			str_DECLARE = str_DECLARE || '
							curs_'||C.table||' CURSOR FOR 
								select count(*),max(rowid) as rowid,max(f),min(f),row(rng, '|| fields ||') as r 
								from
								(select ctid as rowid, ''m'' as f, int8range('||curr_version||', null ) as rng, '|| fields ||'
								from matrix_h.'||C.table||'_h m where upper(rng) is null
								union
								select null as rowid,''v'' as f, int8range('||curr_version||', null ) as rng, '||fields||'
								from matrix_h.vw_'||C.table||'_h vw) s
								group by '||fields||', rng
								order by count(*);

							rec_'||C.table||'  matrix_h.'||C.table||'_h%ROWTYPE; 
						';
			str_FETCH = str_FETCH || '
							open curs_'||C.table||';
							loop
								fetch curs_'||C.table||' into rec;
								EXIT WHEN NOT FOUND;
								if rec.count <2 then
									if rec.max = ''m'' then
										update matrix_h.'||C.table||'_h m set rng = int8range(lower(rng), '||curr_version||')
										where m.ctid = rec.rowid;
									end if;
									if rec.min = ''v'' then
										rec_'||C.table||' = rec.r;
										insert into matrix_h.'||C.table||'_h values (rec_'||C.table||'.*);
									end if;
								end if;
							end loop;
						';
			raise notice '%', str;
			begin
			EXECUTE str;
			exception when others then return str;
			end;
			
			if C.status = 'A' then
				EXECUTE 'drop table if exists matrix_h.'||C.table||'_h CASCADE';
				--exception when others then str:=str||'';
				--end;
				str = 'create table matrix_h.'||C.table ||'_h tablespace MDGM_DATA '||
				' AS select int8range(null,null) as rng, *  from matrix.vw_'|| C.table ||'_h where 1=0';
				--raise notice '%', str;
				EXECUTE str;
			end if;
			
		str_VERS = str_VERS ||' 
				drop view if exists matrix_h.'||C.table||' cascade;
				create view matrix_h.'||C.table||' as select * from matrix_h.'||C.table||'_h h join matrix_h.current_version v on 	 h.rng @> v.v;
		';
		
		end loop;
		
		str_PROC := str_CREATE || str_DECLARE || str_FETCH || str_VERS ||' return 1;
					end;
					$b$;';	
	
		EXECUTE str_PROC;

		update tables_history set status = 'C' where status = 'A';
	
		
		return str_PROC;
	end;
$_$;


ALTER FUNCTION matrix.create_matrix_history() OWNER TO postgres;

--
-- Name: create_nominativi(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_nominativi() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare
	ex bool;
begin	
	SELECT EXISTS into ex (
	   SELECT 1
	   FROM   information_schema.tables 
	   WHERE  table_schema = 'matrix'
	   AND    table_name = 'nominativi'
	   );
	  
	if ex = false then
		create table matrix.nominativi (id serial, id_anagrafica bigint, nominativo text, codice_fiscale text, qualifica text);
		create table matrix.nominativi_struttura (id serial, id_nominativo bigint, id_struttura bigint);
	--else
	--	truncate table matrix.nominativi;
	--	truncate table matrix.nominativi_struttura;
	end if;


	--insert into matrix.nominativi (id_nominativo_gisa, id_anagrafica, nominativo, codice_fiscale, qualifica) select distinct id_nominativo, id_anagrafica_nominativo, nominativo, codice_fiscale, qualifica from "Analisi_dev".vw_dpat_get_nominativi_validi vdgnv;
	
	/* aggiorno prima l'id_nominativo_gisa se cambia a parità di codice_fiscale e struttura, 
	 * in modo da non creare un nuovo matrix.id_nominativo
	 * modifica per fvg del 10/05/23 */
	/*with t as (
		select m.*, a.id as id_a, sa.id_gisa as id_struttura
		from matrix.nominativi a 
		join "Analisi_dev".vw_dpat_get_nominativi_validi m on a.id_nominativo_gisa = m.id_nominativo
		join matrix.struttura_asl sa on sa.id_gisa = m.id_struttura_semplice 
	)
	update matrix.nominativi a
	set  
	id_nominativo_gisa = t.id_nominativo 
	from t 
	join matrix.nominativi_struttura ns on ns.id_nominativo = t.id_a and ns.id_struttura = t.id_struttura
	where t.codice_fiscale = a.codice_fiscale and t.id_struttura = ns.id_struttura and t.codice_fiscale is not null and t.codice_fiscale != 'null';
*/
with t as (
		select m.*, a.id as id_a, sa.id_gisa as id_struttura, a.id_anagrafica 
		from matrix.nominativi a 
		join "Analisi_dev".vw_dpat_get_nominativi_validi m on a.id_nominativo_gisa = m.id_nominativo
		join matrix.struttura_asl sa on sa.id_gisa = m.id_struttura_semplice 
	)
	update matrix.nominativi a
	set  
	id_nominativo_gisa = t.id_nominativo 
	from t 
	join matrix.nominativi_struttura ns on ns.id_nominativo = t.id_a and ns.id_struttura = t.id_struttura
	where t.id_anagrafica = a.id_anagrafica and t.id_struttura = ns.id_struttura;


	with t as (
		select m.*, a.id as id_a from matrix.nominativi a join "Analisi_dev".vw_dpat_get_nominativi_validi m on a.id_nominativo_gisa = m.id_nominativo
	)
	update matrix.nominativi a
	set  nominativo = trim(t.nominativo), codice_fiscale = t.codice_fiscale, qualifica = t.qualifica, id_anagrafica = t.id_anagrafica_nominativo
	from t where t.id_nominativo = a.id_nominativo_gisa; --and t.anno = a.anno;
	
	insert into matrix.nominativi (id_nominativo_gisa, id_anagrafica, nominativo, codice_fiscale, qualifica) 
	select distinct id_nominativo, id_anagrafica_nominativo, trim(nominativo), codice_fiscale, qualifica
	from "Analisi_dev".vw_dpat_get_nominativi_validi m
		where (m.id_nominativo) not in (select a.id_nominativo_gisa from matrix.nominativi a);
		
	delete from matrix.nominativi a where (a.id_nominativo_gisa) not in (select m.id_nominativo from "Analisi_dev".vw_dpat_get_nominativi_validi m where m.anno is not null and m.anno > 0);
	delete from matrix.nominativi_struttura mn where mn.id_nominativo not in (select id from matrix.nominativi);
	
	insert into matrix.nominativi_struttura (id_nominativo , id_struttura) 
	select n.id, sa.id
	from matrix.nominativi n 
	join "Analisi_dev".vw_dpat_get_nominativi_validi d on n.id_nominativo_gisa = d.id_nominativo
	join matrix.struttura_asl sa on sa.id_gisa = d.id_struttura_semplice
	except select id_nominativo, id_struttura from matrix.nominativi_struttura;

	
	CREATE OR REPLACE VIEW matrix.vw_strutture_appartenenza_by_nominativo
	AS SELECT DISTINCT ns.id AS id_origin,
	    ns2.id,
	    upper((nv.desc_strutt_complessa || '->'::text) || sa.descrizione_breve) AS uos
	   FROM matrix.nominativi_struttura ns
	     JOIN matrix.nominativi n ON n.id = ns.id_nominativo
	     JOIN matrix.nominativi n2 ON n2.id_anagrafica = n.id_anagrafica
	     JOIN matrix.nominativi_struttura ns2 ON n2.id = ns2.id_nominativo
	     JOIN "Analisi_dev".vw_dpat_get_nominativi_validi nv ON nv.id_nominativo = n2.id_nominativo_gisa
	     JOIN "Analisi_dev".vw_dpat_get_nominativi_validi nv2 ON nv2.id_nominativo = n.id_nominativo_gisa
	     JOIN matrix.struttura_asl sa ON sa.id_gisa = nv.id_struttura_semplice AND sa.anno = nv.anno AND nv2.anno = nv.anno
	  ORDER BY ns2.id;

	

	/*delete from matrix.nominativi_struttura where (id_nominativo, id_struttura) 
	not in (select n.id, id_struttura_semplice
	from matrix.nominativi n join "Analisi_dev".vw_dpat_get_nominativi_validi d on n.id_nominativo_gisa = d.id_nominativo);*/
	 
	 delete 
        from matrix.nominativi_struttura where (id_nominativo, id_struttura) 
	not in (select n.id, sa.id
	from matrix.nominativi n
	join "Analisi_dev".vw_dpat_get_nominativi_validi d on n.id_nominativo_gisa = d.id_nominativo
	join matrix.struttura_asl sa on sa.id_gisa = d.id_struttura_semplice);

	delete from matrix.anagrafica;
	insert into matrix.anagrafica
		select  distinct id_anagrafica,nominativo,codice_fiscale,n.qualifica --,min(id_anagrafica),max(id_anagrafica)
		from matrix.nominativi n ;
	return 1;
	end;
$$;


ALTER FUNCTION matrix.create_nominativi() OWNER TO postgres;

--
-- Name: create_stabilimenti(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_stabilimenti() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare
	r bool;
begin
	
	  
   /*
    * ML ALLEVAMENTI
    */
	
   
select ret into r 
FROM public.dblink(((((('dbname='::text || ((( SELECT config.value
	           FROM "Analisi_dev".config
	          WHERE config.descr::text = 'GISA_DB'::text))::text)) || ' port='::text) || ((( SELECT config.value
	           FROM "Analisi_dev".config
	          WHERE config.descr::text = 'GISA_PORT'::text))::text)) || ' host='::text) || ((( SELECT config.value
	           FROM "Analisi_dev".config
	          WHERE config.descr::text = 'GISA_ADDRESS'::text))::text)) || ' user=postgres'::text, 'select *
	from conf_public.allinea_ml_allevamenti_livelli() o'::text) t(ret boolean);

truncate public.ml_allev_da_gisa;
insert into public.ml_allev_da_gisa select * from public.vw_ml_allev_da_gisa;

/*
 * IMPRESE
 */
	

drop table if exists matrix.tmp_stabilimenti_linee;
create table if not exists matrix.tmp_stabilimenti_linee as select * from matrix.vw_stabilimenti_linee;

drop table if exists matrix.tmp_stabilimenti;
create table if not exists matrix.tmp_stabilimenti as select * from matrix.vw_stabilimenti;

drop table if exists matrix.tmp_imprese;
create table if not exists matrix.tmp_imprese as select * from matrix.vw_imprese;

create or replace view matrix.vw_imprese
as select * 
from matrix.tmp_imprese m;

create or replace view matrix.vw_stabilimenti
as select * 
from matrix.tmp_stabilimenti m;

create or replace view matrix.vw_stabilimenti_linee
as select * 
from matrix.tmp_stabilimenti_linee m;
	
drop table if exists matrix.stabilimenti_linee;

drop table if exists  matrix.stabilimenti;

drop table if exists matrix.imprese;

create table matrix.imprese as select null::bigint id, v.* 
from  "Analisi_dev".vw_dbi_get_all_imprese__validi v where 1=0;

insert into matrix.imprese select coalesce(m.id, nextval('matrix.oid_matrix')), v.* from 
	"Analisi_dev".vw_dbi_get_all_imprese__validi v left  join 
	matrix.tmp_imprese m on v.riferimento_id_impresa = m.riferimento_id_impresa and m.riferimento_nome_tab_impresa = v.riferimento_nome_tab_impresa;

create or replace view matrix.vw_imprese
as select * 
from matrix.imprese m;

/*
 * STABILIMENTI
 */
	

create table matrix.stabilimenti as select null::bigint id, null::bigint id_impresa, v.* 
from  "Analisi_dev".vw_dbi_get_all_stabilimenti__validi v where 1=0;

insert into matrix.stabilimenti select coalesce(m.id, nextval('matrix.oid_matrix')), i.id, v.* from 
	"Analisi_dev".vw_dbi_get_all_stabilimenti__validi v 
	left  join matrix.tmp_stabilimenti m on v.riferimento_id = m.riferimento_id and m.riferimento_id_nome_tab = v.riferimento_id_nome_tab
	join matrix.imprese i on v.riferimento_id_impresa = i.riferimento_id_impresa and v.riferimento_nome_tab_impresa = i.riferimento_nome_tab_impresa;

create or replace view matrix.vw_stabilimenti
as select * 
from matrix.stabilimenti m;

create or replace view matrix.vw_stabilimenti
as select * 
from matrix.stabilimenti m;

/*
 * LINEE
 */

create table matrix.stabilimenti_linee as select null::bigint id, null::bigint id_stabilimento, v.* 
from  "Analisi_dev".vw_dbi_get_all_linee_validi v where 1=0;

insert into matrix.stabilimenti_linee select coalesce(m.id, nextval('matrix.oid_matrix')), i.id, v.* from 
	"Analisi_dev".vw_dbi_get_all_linee_validi v 
	left  join matrix.tmp_stabilimenti_linee m on v.id_linea = m.id_linea and v.riferimento_id = m.riferimento_id and v.riferimento_id_nome_tab = m.riferimento_id_nome_tab 
	join matrix.stabilimenti i on v.riferimento_id = i.riferimento_id and v.riferimento_id_nome_tab = i.riferimento_id_nome_tab;

update matrix.stabilimenti_linee v set id_attivita = lev.id
from  public.vw_ml_allev_da_gisa lev where replace(lev.path_cod, ' ', '') = replace(v.aggregazione|| '-'||v.attivita, ' ', '') 
and v.id_attivita is null;


create or replace view matrix.vw_stabilimenti_linee
as select * 
from matrix.stabilimenti_linee m;

CREATE INDEX stabilimenti_linee_id_idx ON matrix.stabilimenti_linee USING btree (id);



/*
 *  MASTERLIST
 */


    create table 
    if not exists 
    matrix.get_info_masterlist
    as 
    select * from 
    "Analisi_dev".vw_get_info_masterlist_validi 
    where 1=0;
   
   truncate table matrix.get_info_masterlist;
  
  insert into matrix.get_info_masterlist select * from 
      "Analisi_dev".vw_get_info_masterlist_validi;
    
     
     /*
 *  COMUNI
 */
     
     create table 
    if not exists 
    matrix.comuni
    as 
    select * from 
    "Analisi_dev".vw_comuni1_validi vcv  
    where 1=0;
   
   truncate table matrix.comuni;
  
  insert into matrix.comuni select * from 
      "Analisi_dev".vw_comuni1_validi;

    create or replace view matrix.vw_comuni as select * from matrix.comuni c where notused is not true;
   
 

    
return 1;
end;
$$;


ALTER FUNCTION matrix.create_stabilimenti() OWNER TO postgres;

--
-- Name: create_stabilimenti_old(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_stabilimenti_old() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare
	
begin
	
/*
 * IMPRESE
 */
create table if not exists matrix.imprese
as select nextval('matrix.oid_matrix'), * from (
	select distinct riferimento_id_impresa, riferimento_nome_tab_impresa from
	"Analisi_dev".vw_dbi_get_all_imprese__validi 
) b;

insert into matrix.imprese 
select nextval('matrix.oid_matrix'), * from (
	select distinct riferimento_id_impresa, riferimento_nome_tab_impresa from
	"Analisi_dev".vw_dbi_get_all_imprese__validi 
	) b
where (riferimento_id_impresa, riferimento_nome_tab_impresa) 
not in (select a.riferimento_id_impresa, a.riferimento_nome_tab_impresa from matrix.imprese a);

create or replace view matrix.vw_imprese
as select
m.id, g.*
from matrix.imprese m
join "Analisi_dev".vw_dbi_get_all_imprese__validi g on m.riferimento_id_impresa = g.riferimento_id_impresa and m.riferimento_nome_tab_impresa = g.riferimento_nome_tab_impresa ;


/*
 * STABILIMENTI
 */
	

create table if not exists matrix.stabilimenti
as
select nextval('matrix.oid_matrix')as id, m.id as id_impresa, riferimento_id, riferimento_id_nome_tab 
from
"Analisi_dev".vw_dbi_get_all_stabilimenti__validi s
join "Analisi_dev".vw_dbi_get_all_imprese__validi i on i.riferimento_id_impresa = s.riferimento_id_impresa and s.riferimento_nome_tab_impresa = i.riferimento_nome_tab_impresa 
join matrix.imprese m on m.riferimento_id_impresa = i.riferimento_id_impresa and m.riferimento_nome_tab_impresa = i.riferimento_nome_tab_impresa;

insert into matrix.stabilimenti 
select nextval('matrix.oid_matrix')as id, m.id as id_impresa, riferimento_id, riferimento_id_nome_tab 
from
"Analisi_dev".vw_dbi_get_all_stabilimenti__validi s
join "Analisi_dev".vw_dbi_get_all_imprese__validi i on i.riferimento_id_impresa = s.riferimento_id_impresa and s.riferimento_nome_tab_impresa = i.riferimento_nome_tab_impresa 
join matrix.imprese m on m.riferimento_id_impresa = i.riferimento_id_impresa and m.riferimento_nome_tab_impresa = i.riferimento_nome_tab_impresa
where (m.id, riferimento_id, riferimento_id_nome_tab) not in 
(select  a.id_impresa, a.riferimento_id, a.riferimento_id_nome_tab from matrix.stabilimenti a);

create or replace view matrix.vw_stabilimenti 
as select
m.id, m.id_impresa, g.*
from matrix.stabilimenti m
join "Analisi_dev".vw_dbi_get_all_stabilimenti__validi g on m.riferimento_id = g.riferimento_id and m.riferimento_id_nome_tab = g.riferimento_id_nome_tab ;



/*
 * LINEE
 */

create table if not exists matrix.stabilimenti_linee as 
 select nextval('matrix.oid_matrix') as id, m.id as id_stabilimento, l.id_linea as id_linea_gisa from
"Analisi_dev".vw_dbi_get_all_linee_validi l
join "Analisi_dev".vw_dbi_get_all_stabilimenti__validi s on l.riferimento_id = s.riferimento_id and l.riferimento_id_nome_tab = s.riferimento_id_nome_tab 
join matrix.stabilimenti m on m.riferimento_id = l.riferimento_id and m.riferimento_id_nome_tab = l.riferimento_id_nome_tab ;

insert into matrix.stabilimenti_linee 
select nextval('matrix.oid_matrix'), m.id, l.id_linea from
"Analisi_dev".vw_dbi_get_all_linee_validi l
join "Analisi_dev".vw_dbi_get_all_stabilimenti__validi s on l.riferimento_id = s.riferimento_id and l.riferimento_id_nome_tab = s.riferimento_id_nome_tab 
join matrix.stabilimenti m on m.riferimento_id = l.riferimento_id and m.riferimento_id_nome_tab = l.riferimento_id_nome_tab 
where (m.id, l.id_linea) not in (select a.id_stabilimento, a.id_linea_gisa from matrix.stabilimenti_linee a);


create or replace view matrix.vw_stabilimenti_linee
as select
m.id, m.id_stabilimento, g.*
from matrix.stabilimenti_linee m
join "Analisi_dev".vw_dbi_get_all_linee_validi g on m.id_linea_gisa  = g.id_linea;

/*
 *  MASTERLIST
 */


    create table 
    if not exists 
    matrix.get_info_masterlist
    as 
    select * from 
    "Analisi_dev".vw_get_info_masterlist_validi 
    where 1=0;
   
   truncate table matrix.get_info_masterlist;
  
  insert into matrix.get_info_masterlist select * from 
      "Analisi_dev".vw_get_info_masterlist_validi;


return 1;
end;
$$;


ALTER FUNCTION matrix.create_stabilimenti_old() OWNER TO postgres;

--
-- Name: create_struttura(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	
	drop table if exists matrix.dpat_sez_new;
	create table matrix.dpat_sez_new as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_sez_new where anno = 2019 and stato != 1 and data_scadenza is null')  AS remote
	(id bigint,
	cod_raggruppamento bigint,
	anno int4,
	descrizione text,
	ordinamento int4,
	data_scadenza timestamp,
	stato int4,
	codice_interno int4,
	color varchar(100));

	drop table if exists matrix.dpat_piano_attivita_new; 
	create table matrix.dpat_piano_attivita_new  as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_piano_attivita_new where anno = 2019 and stato != 1 and data_scadenza is null')  AS remote
	(
	id bigint,
	cod_raggruppamento bigint,
	id_sezione int4,
	anno int4,
	descrizione text,
	ordinamento int4,
	data_scadenza timestamp,
	stato int4,
	codice_esame text,
	tipo_attivita text,
	codice_interno_piano int4,
	codice_interno_attivita int4,
	alias_piano text,
	alias_attivita text,
	codice_alias_attivita text
	);

	drop table if exists matrix.dpat_indicatore_new; 
	create table matrix.dpat_indicatore_new  as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_indicatore_new where anno = 2019 and stato != 1 and data_scadenza is null')  AS remote
	(
	id bigint,
	cod_raggruppamento bigint,
	id_piano_attivita int4 ,
	anno int4  ,
	descrizione text ,
	ordinamento int4  ,
	data_scadenza timestamp ,
	stato int4  ,
	codice_esame text ,
	tipo_attivita text ,
	codice_interno_indicatore int4 ,
	alias_indicatore text ,
	codice_interno_piani_gestione_cu int4 ,
	codice_interno_attivita_gestione_cu text ,
	codice_interno_univoco_tipo_attivita_gestione_cu text ,
	codice_alias_indicatore text ,
	extra_gisa bool 
	);

	drop table if exists matrix.struttura_piani;
	create table matrix.struttura_piani (
		id bigint NOT NULL,
		cod_raggruppamento bigint,
		anno int4  NULL,
		descrizione text NULL,
		ordinamento int4  NULL,
		data_scadenza timestamp NULL,
		stato int4  NULL,
		codice_interno int4 NULL,
		color varchar(100) null,
		path text,
		livello bigint,
		parent bigint,
		alias text null,
		path_ord text
	);

	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato, ordinamento, path_ord )values(-1, 'TOTALE', 'TOTALE', 0, null, 2019, 2, 0, '000');
	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-2, 'PIANO', 'TOTALE-PIANO', 1, -1, 2019, 2, 0, '000-000');
	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-3, 'ATTIVITA', 'TOTALE-ATTIVITA', 1, -1, 2019, 2, 1, '000-001');
	
	insert into matrix.struttura_piani (
	select distinct s.id * (case when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' then -1 else 1 end), s.cod_raggruppamento, 2019, s.descrizione, s.ordinamento, s.data_scadenza, s.stato, s.codice_interno, s.color, sp.path||'-'||s.descrizione, 2,  sp.id, null, sp.path_ord||'-'||lpad(s.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.descrizione::text = substring(p.tipo_attivita from 1 for 8)::text 
	where i.anno = 2019 and p.anno = 2019 and s.anno = 2019 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);
	
	update matrix.struttura_piani set ordinamento = '0', path_ord = '000-000-000'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE A';
	update matrix.struttura_piani set ordinamento = '1', path_ord = '000-000-001'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE B';
	update matrix.struttura_piani set ordinamento = '2' , path_ord = '000-000-002'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE C';
	update matrix.struttura_piani set ordinamento = '3' , path_ord = '000-000-003'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE D';

	update matrix.struttura_piani set ordinamento = '0' , path_ord = '000-001-000'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE A';
	update matrix.struttura_piani set ordinamento = '1' , path_ord = '000-001-001'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE B';
	update matrix.struttura_piani set ordinamento = '2' , path_ord = '000-001-002'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE C';
	update matrix.struttura_piani set ordinamento = '3' , path_ord = '000-001-003'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE D';

	
	insert into matrix.struttura_piani (
	select distinct p.id, p.cod_raggruppamento, 2019, p.descrizione, p.ordinamento, p.data_scadenza, p.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 3,  sp.id, p.alias_piano, sp.path_ord||'-'||lpad(p.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.id = p.id_sezione * (case when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' then -1 else 1 end)
	where i.anno = 2019 and p.anno = 2019 and s.anno = 2019 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);
	
	insert into matrix.struttura_piani (
	select distinct i.id, i.cod_raggruppamento, 2019, i.descrizione, i.ordinamento,i.data_scadenza, i.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 4,  sp.id, i.alias_indicatore,sp.path_ord||'-'||lpad(i.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.id = i.id_piano_attivita
	where i.anno = 2019 and p.anno = 2019 and s.anno = 2019 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);

	alter table matrix.struttura_piani add column id_formula_ups bigint;
	alter table matrix.struttura_piani add column id_formula_uba bigint;

	alter table matrix.struttura_piani add column fattore_ups real;
	alter table matrix.struttura_piani add column fattore_uba real;

	
	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura() OWNER TO postgres;

--
-- Name: create_struttura_asl(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_asl() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare
	ex bool;
	rec record;
	cur_padre int8;
	old_padre int8;
	id_tree_val bigint;
begin
	
	select id into id_tree_val from matrix.trees where name = 'Struttura ASL';
	

	SELECT EXISTS into ex (
	   SELECT 1
	   FROM   information_schema.tables 
	   WHERE  table_schema = 'matrix'
	   AND    table_name = 'struttura_asl'
	   );
	  
  --	drop table if exists matrix.oia_nodo;
	--	create table matrix.oia_nodo as
		--select * from "Analisi_dev".vw_oia_nodo_validi where trashed_date is null and stato in (0,2) and (CURRENT_TIMESTAMP < DATA_SCADENZA or data_scadenza is null);
		--where stato != 1 and (data_scadenza is null or data_scadenza > current_timestamp) and not disabilitata;
	
	drop table if exists matrix.ups_uba_temp;

	
	if ex = false then
			
		--drop table if exists   matrix.struttura_asl;
		create table matrix.struttura_asl (id bigint, id_gisa bigint, id_asl bigint, codice_interno_fk bigint, descrizione text, n_livello int,
													anno int, descrizione_breve text, ups float8, uba float8);
												
ALTER TABLE matrix.struttura_asl ADD CONSTRAINT struttura_asl_un UNIQUE (id_gisa,anno);

		CREATE TABLE IF NOT exists matrix.struttura_asl_h ( 
		  rng int8range,
		  like matrix.struttura_asl including all
		);
	
	--	create table matrix.ups_uba_temp as select id_gisa, ups, uba, anno from matrix.struttura_asl;
	
	
	--else
	
	--	create table matrix.ups_uba_temp as select id_gisa, ups, uba, anno from matrix.struttura_asl;
	
	--	truncate table matrix.struttura_asl;
		
	end if;


CREATE OR REPLACE VIEW matrix.vw_tree_nodes_asl_descr
AS SELECT ta.name_tree,
    ta.id_node,
    ta.id_tree,
    ta.id_node_parent,
    a.id,
    a.id_gisa,
    a.id_asl,
    a.codice_interno_fk,
    a.descrizione,
    a.n_livello,
    a.descrizione_breve,
    a.ups,
    a.uba,
    a.anno,
    ap.id AS p_id,
    ap.id_gisa AS p_id_gisa,
    ap.id_asl AS p_id_asl,
    ap.codice_interno_fk as p_codice_interno_fk,
    ap.descrizione AS p_descrizione,
    ap.n_livello AS p_n_livello,
    ap.descrizione AS p_descrizione_breve,
    ap.uba as p_uba,
    ap.ups as p_ups,
    ap.anno as p_anno
   FROM matrix.vw_tree_nodes_asl ta
     JOIN matrix.struttura_asl a ON a.id = ta.id_node
     LEFT JOIN matrix.struttura_asl ap ON ap.id = ta.id_node_parent
         where (a.id_asl != 14 or a.id_asl is null);

	delete from matrix.tree_nodes where id in (select id from matrix.vw_tree_nodes_asl_descr where n_livello > 1 ); --and id_tree = (select id from matrix.trees where name = 'Struttura ASL') ;
	
	for rec in select distinct anno from "Analisi_dev".vw_oia_nodo_attivi where anno not in (select ta.anno from matrix.vw_tree_anno ta where ta.name = 'Struttura ASL') loop 

			INSERT INTO matrix.struttura_asl
			(id,id_gisa, id_asl, codice_interno_fk, descrizione, n_livello, anno, descrizione_breve, ups, uba)
			VALUES(nextval('matrix.oid_matrix'), -1, null, null, 'MINISTERO', -1, rec.anno, 'MINISTERO', NULL, NULL);
		
			cur_padre =  currval('matrix.oid_matrix');
			insert into matrix.tree_nodes values (cur_padre, id_tree_val, null);
		
			insert into matrix.tree_anno values (rec.anno, id_tree_val, cur_padre);
		
			old_padre = cur_padre;
		
			INSERT INTO matrix.struttura_asl
			(id,id_gisa, id_asl, codice_interno_fk, descrizione, n_livello, anno, descrizione_breve, ups, uba)
			VALUES(nextval('matrix.oid_matrix'), 8, null, null, 'REGIONE CAMPANIA', 0, rec.anno, 'REGIONE_CAMPANIA', NULL, NULL);
		
			cur_padre =  currval('matrix.oid_matrix');

			insert into matrix.tree_nodes values (cur_padre, id_tree_val, old_padre);

			INSERT INTO matrix.struttura_asl (id, id_gisa, id_asl, codice_interno_fk, descrizione, n_livello, anno, descrizione_breve, ups, uba)
			select 
			nextval('matrix.oid_matrix'), id, id_asl, codice_interno_fk, descrizione_lunga, n_livello, rec.anno, null, null, null
			from "Analisi_dev".vw_oia_nodo_attivi m where m.n_livello = 1;
		
			insert into matrix.tree_nodes (select id, id_tree_val, cur_padre from matrix.struttura_asl m where m.n_livello = 1 and m.anno = rec.anno);

	end loop;

	with t as (
		select m.*, a.id as id_a from matrix.struttura_asl a join "Analisi_dev".vw_oia_nodo_attivi m on a.id_gisa = m.id
	)
	update matrix.struttura_asl a
	set  id_asl = t.id_asl, codice_interno_fk = t.codice_interno_fk, descrizione = t.descrizione_lunga, n_livello = t.n_livello
	from t where t.id = a.id_gisa and t.anno = a.anno;

	delete from matrix.struttura_asl a where (a.id_gisa, a.anno) not in (select m.id, m.anno from "Analisi_dev".vw_oia_nodo_attivi m) and a.n_livello > 1;

	delete from matrix.tree_nodes t where id not in (select id from matrix.struttura_asl) and id_tree = id_tree_val;
	delete from matrix.tree_nodes t where id_parent not in (select id from matrix.struttura_asl) and id_tree = id_tree_val;

	insert into matrix.struttura_asl (id, id_gisa, id_asl, codice_interno_fk, descrizione, n_livello, anno, descrizione_breve, ups, uba) select nextval('matrix.oid_matrix'), id, id_asl, codice_interno_fk, descrizione_lunga, n_livello, anno, null, null, null 
	from "Analisi_dev".vw_oia_nodo_attivi  m
		where (m.id, m.anno) not in (select a.id_gisa, a.anno from matrix.struttura_asl a);
		

	insert into matrix.tree_nodes (select a.id, (select id from matrix.trees where name = 'Struttura ASL'), aa.id 
												from matrix.struttura_asl a join "Analisi_dev".vw_oia_nodo_attivi m on m.id = a.id_gisa and m.anno = a.anno 
																	join matrix.struttura_asl aa on aa.id_gisa = m.id_padre and m.anno = aa.anno 
																	where a.n_livello >1 
																);
												
	update matrix.struttura_asl set descrizione_breve = upper(descrizione);
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione),'UNITA'' OPERATIVA SEMPLICE DIPARTIMENTALE', 'UOSD') where upper(descrizione) like 'UNITA'' OPERATIVA SEMPLICE DIPARTIMENTALE%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione),'UNITA'' OPERATIVA COMPLESSA', 'UOC') where upper(descrizione) like 'UNITA'' OPERATIVA COMPLESSA%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione),'DIPARTIMENTO DI PREVENZIONE', 'D.D.P.') where upper(descrizione) like 'DIPARTIMENTO DI PREVENZIONE%';


	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_asl() OWNER TO postgres;

--
-- Name: create_struttura_asl(bigint); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_asl(_id_asl bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare
	ex bool;
	rec record;
	cur_padre int8;
	old_padre int8;
	id_tree_val bigint;
begin
	
	select id into id_tree_val from matrix.trees where name = 'Struttura ASL';
	

	SELECT EXISTS into ex (
	   SELECT 1
	   FROM   information_schema.tables 
	   WHERE  table_schema = 'matrix'
	   AND    table_name = 'struttura_asl'
	   );
	  
  --	drop table if exists matrix.oia_nodo;
	--	create table matrix.oia_nodo as
		--select * from "Analisi_dev".vw_oia_nodo_validi where trashed_date is null and stato in (0,2) and (CURRENT_TIMESTAMP < DATA_SCADENZA or data_scadenza is null);
		--where stato != 1 and (data_scadenza is null or data_scadenza > current_timestamp) and not disabilitata;
	
	drop table if exists matrix.ups_uba_temp;

	
	if ex = false then
			
		--drop table if exists   matrix.struttura_asl;
		create table matrix.struttura_asl (id bigint, id_gisa bigint, id_asl bigint, codice_interno_fk bigint, descrizione text, n_livello int,
													anno int, descrizione_breve text, ups float8, uba float8);
												
		ALTER TABLE matrix.struttura_asl ADD CONSTRAINT struttura_asl_un UNIQUE (id_gisa,anno);

		CREATE TABLE IF NOT exists matrix.struttura_asl_h ( 
		  rng int8range,
		  like matrix.struttura_asl including all
		);

		--nuova gestione con codice univoco 01/03/2023
		ALTER TABLE matrix.struttura_asl ADD codice_interno_univoco bigint NULL;

	
	--	create table matrix.ups_uba_temp as select id_gisa, ups, uba, anno from matrix.struttura_asl;
	
	
	--else
	
	--	create table matrix.ups_uba_temp as select id_gisa, ups, uba, anno from matrix.struttura_asl;
	
	--	truncate table matrix.struttura_asl;
		
	end if;

/*
CREATE OR REPLACE VIEW matrix.vw_tree_nodes_asl_descr
AS SELECT ta.name_tree,
    ta.id_node,
    ta.id_tree,
    ta.id_node_parent,
    a.id,
    a.id_gisa,
    a.id_asl,
    a.codice_interno_fk,
    a.descrizione,
    a.n_livello,
    a.descrizione_breve,
    a.ups,
    a.uba,
    a.anno,
    ap.id AS p_id,
    ap.id_gisa AS p_id_gisa,
    ap.id_asl AS p_id_asl,
    ap.codice_interno_fk as p_codice_interno_fk,
    ap.descrizione AS p_descrizione,
    ap.n_livello AS p_n_livello,
    ap.descrizione AS p_descrizione_breve,
    ap.uba as p_uba,
    ap.ups as p_ups,
    ap.anno as p_anno
   FROM matrix.vw_tree_nodes_asl ta
     JOIN matrix.struttura_asl a ON a.id = ta.id_node
     LEFT JOIN matrix.struttura_asl ap ON ap.id = ta.id_node_parent; */

	delete from matrix.tree_nodes where id in (select id from matrix.vw_tree_nodes_asl_descr where n_livello > 1 ); --and id_tree = (select id from matrix.trees where name = 'Struttura ASL') ;
	
	for rec in select distinct anno from "Analisi_dev".vw_oia_nodo_attivi where anno not in (select ta.anno from matrix.vw_tree_anno ta where ta.name = 'Struttura ASL') loop 

			INSERT INTO matrix.struttura_asl
			(id,id_gisa, id_asl, codice_interno_fk, descrizione, n_livello, anno, descrizione_breve, ups, uba)
			VALUES(nextval('matrix.oid_matrix'), -1, null, null, 'MINISTERO', -1, rec.anno, 'MINISTERO', NULL, NULL);
		
			cur_padre =  currval('matrix.oid_matrix');
			insert into matrix.tree_nodes values (cur_padre, id_tree_val, null);
		
			insert into matrix.tree_anno values (rec.anno, id_tree_val, cur_padre);
		
			old_padre = cur_padre;
		
			INSERT INTO matrix.struttura_asl
			(id,id_gisa, id_asl, codice_interno_fk, descrizione, n_livello, anno, descrizione_breve, ups, uba)
			VALUES(nextval('matrix.oid_matrix'), 8, null, null, 'REGIONE FRIULI VENEZIA GIULIA', 0, rec.anno, 'REGIONE FRIULI VENEZIA GIULIA', NULL, NULL);
		
			cur_padre =  currval('matrix.oid_matrix');

			insert into matrix.tree_nodes values (cur_padre, id_tree_val, old_padre);

			INSERT INTO matrix.struttura_asl (id, id_gisa, id_asl, codice_interno_fk, descrizione, n_livello, anno, descrizione_breve, ups, uba, codice_interno_univoco)
			select 
			nextval('matrix.oid_matrix'), id, id_asl, codice_interno_fk, descrizione_lunga, n_livello, rec.anno, null, null, null, codice_interno_univoco 
			from "Analisi_dev".vw_oia_nodo_validi m where m.n_livello = 1;
		
			insert into matrix.tree_nodes (select id, id_tree_val, cur_padre from matrix.struttura_asl m where m.n_livello = 1 and m.anno = rec.anno);

	end loop;

	with t as (
		select m.*, a.id as id_a, m.id as id_gisa 
		from matrix.struttura_asl a 
		join "Analisi_dev".vw_oia_nodo_attivi m 
		on a.codice_interno_univoco = m.codice_interno_univoco and a.anno = m.anno 
	)
	update matrix.struttura_asl a
	set id_gisa = t.id_gisa, id_asl = t.id_asl, codice_interno_fk = t.codice_interno_fk, descrizione = t.descrizione_lunga, n_livello = t.n_livello
	from t where t.codice_interno_univoco = a.codice_interno_univoco and t.anno = a.anno and (a.id_asl = _id_asl or _id_asl is null);

	delete from matrix.struttura_asl a where (a.codice_interno_univoco , a.anno) not in (select m.codice_interno_univoco, m.anno from "Analisi_dev".vw_oia_nodo_attivi m) and a.n_livello > 1 
	and (a.id_asl = _id_asl or _id_asl is null);
	
	delete from matrix.struttura_asl where id_gisa in (select id from "Analisi_dev".vw_oia_nodo_attivi
	where id_padre not in (select id from "Analisi_dev".vw_oia_nodo_attivi)) and n_livello > 1;

	delete from matrix.tree_nodes t where id not in (select id from matrix.struttura_asl) and id_tree = id_tree_val;
	delete from matrix.tree_nodes t where id_parent not in (select id from matrix.struttura_asl) and id_tree = id_tree_val;

	insert into matrix.struttura_asl (id, id_gisa, id_asl, codice_interno_fk, descrizione, n_livello, anno, descrizione_breve, ups, uba, codice_interno_univoco)
	select nextval('matrix.oid_matrix'), id, id_asl, codice_interno_fk, descrizione_lunga, n_livello, anno, null, null, null, codice_interno_univoco  
	from "Analisi_dev".vw_oia_nodo_attivi  m
		where (m.codice_interno_univoco , m.anno) not in (select a.codice_interno_univoco , a.anno from matrix.struttura_asl a where codice_interno_univoco is not null) and (id_asl = _id_asl or _id_asl is null)
		and (n_livello > 0 and id_padre in (select id from "Analisi_dev".vw_oia_nodo_attivi));
		

	insert into matrix.tree_nodes (select a.id, (select id from matrix.trees where name = 'Struttura ASL'), aa.id 
												from matrix.struttura_asl a join "Analisi_dev".vw_oia_nodo_attivi m on m.codice_interno_univoco = a.codice_interno_univoco and m.anno = a.anno 
																	join matrix.struttura_asl aa on aa.id_gisa = m.id_padre and m.anno = aa.anno 
																	where a.n_livello >1 
																);
												
/*	update matrix.struttura_asl set descrizione_breve = upper(descrizione);

	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'UNITA'' OPERATIVA SEMPLICE DIPARTIMENTALE', 'UOSD') where upper(descrizione_breve) like 'UNITA'' OPERATIVA SEMPLICE DIPARTIMENTALE%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'UNITA'' OPERATIVA COMPLESSA', 'UOC') where upper(descrizione_breve) like 'UNITA'' OPERATIVA COMPLESSA%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'DIPARTIMENTO DI PREVENZIONE', 'D.D.P.') where upper(descrizione_breve) like 'DIPARTIMENTO DI PREVENZIONE%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'AZIENDA SANITARIA UNIVERSITARIA', 'ASU') where upper(descrizione_breve) like 'AZIENDA SANITARIA UNIVERSITARIA%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'AZIENDA SANITARIA', 'AS') where upper(descrizione_breve) like 'AZIENDA SANITARIA%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'FRIULI OCCIDENTALE', 'FO') where upper(descrizione_breve) like '%FRIULI OCCIDENTALE%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'FRIULI CENTRALE', 'FC') where upper(descrizione_breve) like '%FRIULI CENTRALE%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'GIULIANO-ISONTINA', 'GI') where upper(descrizione_breve) like '%GIULIANO-ISONTINA%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'STRUTTURA SEMPLICE IGIENE ALIMENTI E NUTRIZIONE', 'SIAN') where upper(descrizione_breve) like '%STRUTTURA SEMPLICE IGIENE ALIMENTI E NUTRIZIONE%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'DISTRETTO DI ', '') where upper(descrizione_breve) like '%DISTRETTO DI %';
	--update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'DISTRETTO DI ', '') where upper(descrizione_breve)  ~ '.*-[^-]*AREA [ABC]'    

	update matrix.struttura_asl set descrizione_breve = regexp_replace(descrizione_breve,'-[^-]*AREA ([ABC])','- VET \1') where upper(descrizione_breve)  ~ '.*-[^-]*AREA [ABC]';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'DISTRETTO DELLE ', '') where upper(descrizione_breve) like '%DISTRETTO DELLE %';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),' E DELLE', '') where upper(descrizione_breve) like '%E DELLE%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'DISTRETTO DEL ', '') where upper(descrizione_breve) like '%DISTRETTO DEL %';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'DP SC IGIENE E SANITÀ PUBBLICA', 'ISP') where upper(descrizione_breve) like '%DP SC IGIENE E SANITÀ PUBBLICA%';



	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'DP AMMINISTRATIVI TECNICI DIP PREVENZIONE', 'AMM') where upper(descrizione_breve) like '%DP AMMINISTRATIVI TECNICI DIP PREVENZIONE%';

	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'DP SSD IGIENE DEGLI ALIMENTI E DELLA NUTRIZIONE', 'SIAN') where upper(descrizione_breve) like '%DP SSD IGIENE DEGLI ALIMENTI E DELLA NUTRIZIONE%';

	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'DISTRETTO ', '') where upper(descrizione_breve) like '%DISTRETTO %';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),' DS AREA TECNICA IGIENE PUBBLICA', ' ISP AT') where upper(descrizione_breve) like '% DS AREA TECNICA IGIENE PUBBLICA%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),' DS AREA TECNICA SERVIZIO IGIENE DEGLI ALIMENTI E DELLA NUTRIZIONE', ' SIAN AT') where upper(descrizione_breve) like '% DS AREA TECNICA SERVIZIO IGIENE DEGLI ALIMENTI E DELLA NUTRIZIONE%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),' DS AREA TECNICA VETERINARIA', ' SVET AT') where upper(descrizione_breve) like '% DS AREA TECNICA VETERINARIA%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),' DP SC IGIENE E SANITÀ PUBBLICA', ' ISP') where upper(descrizione_breve) like '% DP SC IGIENE E SANITÀ PUBBLICA%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'UNICO ', '') where upper(descrizione_breve) like '%UNICO %';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),' IGIENE ALIMENTI E NUTRIZIONE', ' SIAN') where upper(descrizione_breve) like '% IGIENE ALIMENTI E NUTRIZIONE%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),' SANITÀ ANIMALE, IGIENE DEGLI ALLEVAMENTI PRODUZIONI ZOOTECNICHE', ' VET A') where upper(descrizione_breve) like '% SANITÀ ANIMALE, IGIENE DEGLI ALLEVAMENTI PRODUZIONI ZOOTECNICHE%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),' SANITÀ PUBBLICA VETERINARIA', ' VET C') where upper(descrizione_breve) like '% SANITÀ PUBBLICA VETERINARIA%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),' IGIENE DEGLI ALIMENTI DI ORIGINE ANIMALE', ' VET B') where upper(descrizione_breve) like '% IGIENE DEGLI ALIMENTI DI ORIGINE ANIMALE%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),' CITTÀ ', ' ') where upper(descrizione_breve) like '% CITTÀ %';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione_breve),'TDP SIAN', 'SIAN') where upper(descrizione_breve) like '%TDP SIAN%';
*/
															
	perform "Analisi_dev".update_descrizioni_brevi('ASL');


	--fix 27/04/2022, descrizioni vuote in tree_nodes per strutture asl
	update matrix.tree_nodes t set node_descr = sa.descrizione_breve
	from matrix.struttura_asl sa where t.id = sa.id and id_tree = (select id from matrix.trees where name = 'Struttura ASL');

create or replace VIEW matrix.vw_tree_nodes_down_asl_descr AS
 SELECT d.name_tree,
    d.id_node,
    d.id_tree,
    d.id_node_parent,
    d.id_node_ref,
    a.id,
    a.id_gisa,
    a.id_asl,
    a.codice_interno_fk,
    a.descrizione,
    a.n_livello,
    a.anno,
    a.descrizione_breve,
    a.ups,
    a.uba,
    oia.data_scadenza,
    oia.trashed_date
   FROM ((matrix.vw_tree_nodes_down d
     JOIN matrix.struttura_asl a ON ((a.id = d.id_node)))
     LEFT JOIN "Analisi_dev".vw_oia_nodo_validi oia ON ((oia.id = a.id_gisa)))
  WHERE ((a.id_asl <> 14) OR (a.id_asl IS NULL));


	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_asl(_id_asl bigint) OWNER TO postgres;

--
-- Name: create_struttura_asl2(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_asl2() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare
	ex bool;
	rec record;
	cur_padre int8;
	old_padre int8;
	id_tree_val bigint;
begin
	
	select id into id_tree_val from matrix.trees where name = 'Struttura ASL';
	

	SELECT EXISTS into ex (
	   SELECT 1
	   FROM   information_schema.tables 
	   WHERE  table_schema = 'matrix'
	   AND    table_name = 'struttura_asl'
	   );
	  
  --	drop table if exists matrix.oia_nodo;
	--	create table matrix.oia_nodo as
		--select * from "Analisi_dev".vw_oia_nodo_validi where trashed_date is null and stato in (0,2) and (CURRENT_TIMESTAMP < DATA_SCADENZA or data_scadenza is null);
		--where stato != 1 and (data_scadenza is null or data_scadenza > current_timestamp) and not disabilitata;
	
	drop table if exists matrix.ups_uba_temp;

	
	if ex = false then
			
		--drop table if exists   matrix.struttura_asl;
		create table matrix.struttura_asl (id bigint, id_gisa bigint, id_asl bigint, codice_interno_fk bigint, descrizione text, n_livello int,
													anno int, descrizione_breve text, ups float8, uba float8);
												
ALTER TABLE matrix.struttura_asl ADD CONSTRAINT struttura_asl_un UNIQUE (id_gisa,anno);

		CREATE TABLE IF NOT exists matrix.struttura_asl_h ( 
		  rng int8range,
		  like matrix.struttura_asl including all
		);
	
	--	create table matrix.ups_uba_temp as select id_gisa, ups, uba, anno from matrix.struttura_asl;
	
	
	--else
	
	--	create table matrix.ups_uba_temp as select id_gisa, ups, uba, anno from matrix.struttura_asl;
	
	--	truncate table matrix.struttura_asl;
		
	end if;


CREATE OR REPLACE VIEW matrix.vw_tree_nodes_asl_descr
AS SELECT ta.name_tree,
    ta.id_node,
    ta.id_tree,
    ta.id_node_parent,
    a.id,
    a.id_gisa,
    a.id_asl,
    a.codice_interno_fk,
    a.descrizione,
    a.n_livello,
    a.descrizione_breve,
    a.ups,
    a.uba,
    a.anno,
    ap.id AS p_id,
    ap.id_gisa AS p_id_gisa,
    ap.id_asl AS p_id_asl,
    ap.codice_interno_fk as p_codice_interno_fk,
    ap.descrizione AS p_descrizione,
    ap.n_livello AS p_n_livello,
    ap.descrizione AS p_descrizione_breve,
    ap.uba as p_uba,
    ap.ups as p_ups,
    ap.anno as p_anno
   FROM matrix.vw_tree_nodes_asl ta
     JOIN matrix.struttura_asl a ON a.id = ta.id_node
     LEFT JOIN matrix.struttura_asl ap ON ap.id = ta.id_node_parent;

	delete from matrix.tree_nodes where id in (select id from matrix.vw_tree_nodes_asl_descr where n_livello > 1 ); --and id_tree = (select id from matrix.trees where name = 'Struttura ASL') ;
	
	for rec in select distinct anno from "Analisi_dev".vw_oia_nodo_attivi where anno not in (select ta.anno from matrix.vw_tree_anno ta where ta.name = 'Struttura ASL') loop 

			INSERT INTO matrix.struttura_asl
			(id,id_gisa, id_asl, codice_interno_fk, descrizione, n_livello, anno, descrizione_breve, ups, uba)
			VALUES(nextval('matrix.oid_matrix'), -1, null, null, 'MINISTERO', -1, rec.anno, 'MINISTERO', NULL, NULL);
		
			cur_padre =  currval('matrix.oid_matrix');
			insert into matrix.tree_nodes values (cur_padre, id_tree_val, null);
		
			insert into matrix.tree_anno values (rec.anno, id_tree_val, cur_padre);
		
			old_padre = cur_padre;
		
			INSERT INTO matrix.struttura_asl
			(id,id_gisa, id_asl, codice_interno_fk, descrizione, n_livello, anno, descrizione_breve, ups, uba)
			VALUES(nextval('matrix.oid_matrix'), 8, null, null, 'REGIONE CAMPANIA', 0, rec.anno, 'REGIONE_CAMPANIA', NULL, NULL);
		
			cur_padre =  currval('matrix.oid_matrix');

			insert into matrix.tree_nodes values (cur_padre, id_tree_val, old_padre);

			INSERT INTO matrix.struttura_asl (id, id_gisa, id_asl, codice_interno_fk, descrizione, n_livello, anno, descrizione_breve, ups, uba)
			select 
			nextval('matrix.oid_matrix'), id, id_asl, codice_interno_fk, descrizione_lunga, n_livello, rec.anno, null, null, null
			from "Analisi_dev".vw_oia_nodo_attivi m where m.n_livello = 1;
		
			insert into matrix.tree_nodes (select id, id_tree_val, cur_padre from matrix.struttura_asl m where m.n_livello = 1 and m.anno = rec.anno);

	end loop;

	with t as (
		select m.*, a.id as id_a from matrix.struttura_asl a join "Analisi_dev".vw_oia_nodo_attivi m on a.id_gisa = m.id
	)
	update matrix.struttura_asl a
	set  id_asl = t.id_asl, codice_interno_fk = t.codice_interno_fk, descrizione = t.descrizione_lunga, n_livello = t.n_livello
	from t where t.id = a.id_gisa and t.anno = a.anno;

	delete from matrix.struttura_asl a where (a.id_gisa, a.anno) not in (select m.id, m.anno from "Analisi_dev".vw_oia_nodo_attivi m) and a.n_livello > 1;

	delete from matrix.tree_nodes t where id not in (select id from matrix.struttura_asl) and id_tree = id_tree_val;
	delete from matrix.tree_nodes t where id_parent not in (select id from matrix.struttura_asl) and id_tree = id_tree_val;

	insert into matrix.struttura_asl (id, id_gisa, id_asl, codice_interno_fk, descrizione, n_livello, anno, descrizione_breve, ups, uba) select nextval('matrix.oid_matrix'), id, id_asl, codice_interno_fk, descrizione_lunga, n_livello, anno, null, null, null 
	from "Analisi_dev".vw_oia_nodo_attivi  m
		where (m.id, m.anno) not in (select a.id_gisa, a.anno from matrix.struttura_asl a);
		

	insert into matrix.tree_nodes (select a.id, (select id from matrix.trees where name = 'Struttura ASL'), aa.id 
												from matrix.struttura_asl a join "Analisi_dev".vw_oia_nodo_attivi m on m.id = a.id_gisa and m.anno = a.anno 
																	join matrix.struttura_asl aa on aa.id_gisa = m.id_padre and m.anno = aa.anno 
																	where a.n_livello >1 
																);
												
	update matrix.struttura_asl set descrizione_breve = upper(descrizione);
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione),'UNITA'' OPERATIVA SEMPLICE DIPARTIMENTALE', 'UOSD') where upper(descrizione) like 'UNITA'' OPERATIVA SEMPLICE DIPARTIMENTALE%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione),'UNITA'' OPERATIVA COMPLESSA', 'UOC') where upper(descrizione) like 'UNITA'' OPERATIVA COMPLESSA%';
	update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione),'DIPARTIMENTO DI PREVENZIONE', 'D.D.P.') where upper(descrizione) like 'DIPARTIMENTO DI PREVENZIONE%';


	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_asl2() OWNER TO postgres;

--
-- Name: create_struttura_asl_2019_new(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_asl_2019_new() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	
	drop table  if exists matrix.oia_nodo_2019_new;
	create table matrix.oia_nodo_2019_new as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.oia_nodo where (anno = 2019 and stato != 1 and data_scadenza < current_timestamp and not disabilitata)')  AS remote
	(id	integer,
	id_padre	integer,
	id_asl	integer,
	descrizione_lunga	character varying,
	n_livello	smallint,
	entered	timestamp with time zone,
	entered_by	integer,
	modified	timestamp with time zone,
	modified_by	integer,
	trashed_date	timestamp with time zone,
	tipologia_struttura	integer,
	comune	text,
	enabled	boolean,
	obsoleto	boolean,
	confermato	boolean,
	id_strumento_calcolo	integer,
	codice_interno_fk	integer,
	nome	character varying,
	id_utente	integer,
	mail	text,
	indirizzo	text,
	delegato	integer,
	descrizione_comune	text,
	id_oia_nodo_temp	integer,
	data_scadenza	timestamp without time zone,
	disabilitata	boolean,
	stato	integer,
	anno	integer,
	descrizione_area_struttura_complessa	text,
	id_lookup_area_struttura_asl	integer,
	ui_struttura_foglio_att_iniziale	integer,
	ui_struttura_foglio_att_finale	integer,
	id_utente_edit	integer,
	percentuale_area_a	integer,
	stato_all2	integer,
	stato_all6	integer,
	codice_interno_univoco	integer,
	descrizione_area_struttura	character varying);


	drop table  if exists matrix.struttura_asl_2019_new;

	create table matrix.struttura_asl_2019_new as select id, id_padre, id_asl, descrizione_lunga as descrizione, n_livello, stato
	from matrix.oia_nodo_2019_new;



	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_asl_2019_new() OWNER TO postgres;

--
-- Name: create_struttura_asl_2020(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_asl_2020() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	
	drop table  if exists matrix.oia_nodo_2020;
	create table matrix.oia_nodo_2020 as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.oia_nodo where (anno = 2020 and stato != 1 and data_scadenza < current_timestamp and not disabilitata)')  AS remote
	(id	integer,
	id_padre	integer,
	id_asl	integer,
	descrizione_lunga	character varying,
	n_livello	smallint,
	entered	timestamp with time zone,
	entered_by	integer,
	modified	timestamp with time zone,
	modified_by	integer,
	trashed_date	timestamp with time zone,
	tipologia_struttura	integer,
	comune	text,
	enabled	boolean,
	obsoleto	boolean,
	confermato	boolean,
	id_strumento_calcolo	integer,
	codice_interno_fk	integer,
	nome	character varying,
	id_utente	integer,
	mail	text,
	indirizzo	text,
	delegato	integer,
	descrizione_comune	text,
	id_oia_nodo_temp	integer,
	data_scadenza	timestamp without time zone,
	disabilitata	boolean,
	stato	integer,
	anno	integer,
	descrizione_area_struttura_complessa	text,
	id_lookup_area_struttura_asl	integer,
	ui_struttura_foglio_att_iniziale	integer,
	ui_struttura_foglio_att_finale	integer,
	id_utente_edit	integer,
	percentuale_area_a	integer,
	stato_all2	integer,
	stato_all6	integer,
	codice_interno_univoco	integer,
	descrizione_area_struttura	character varying);

	drop table  if exists matrix.struttura_asl_2020;
	create table matrix.struttura_asl_2020 as select id, id_padre, id_asl, descrizione_lunga as descrizione, n_livello
	from matrix.oia_nodo_2020;



	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_asl_2020() OWNER TO postgres;

--
-- Name: create_struttura_asl_old(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_asl_old() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	
	drop table if exists matrix.oia_nodo;
	create table matrix.oia_nodo as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.oia_nodo where (anno = 2019 and stato != 1 and data_scadenza is null and not disabilitata) or (n_livello < 2 and data_Scadenza is null)')  AS remote
	(id	integer,
	id_padre	integer,
	id_asl	integer,
	descrizione_lunga	character varying,
	n_livello	smallint,
	entered	timestamp with time zone,
	entered_by	integer,
	modified	timestamp with time zone,
	modified_by	integer,
	trashed_date	timestamp with time zone,
	tipologia_struttura	integer,
	comune	text,
	enabled	boolean,
	obsoleto	boolean,
	confermato	boolean,
	id_strumento_calcolo	integer,
	carico_lavoro_annuo	integer,
	percentuale_da_sottrarre	integer,
	carico_lavoro_effettivo	integer,
	fattori_incidenti_su_carico	text,
	codice_interno_fk	integer,
	nome	character varying,
	id_utente	integer,
	mail	text,
	indirizzo	text,
	delegato	integer,
	descrizione_comune	text,
	id_oia_nodo_temp	integer,
	data_scadenza	timestamp without time zone,
	disabilitata	boolean,
	stato	integer,
	anno	integer,
	descrizione_area_struttura_complessa	text,
	uba_ui	integer,
	somma_ui_area	integer,
	somma_uba_area	integer,
	id_lookup_area_struttura_asl	integer,
	ui_struttura_foglio_att_iniziale	integer,
	ui_struttura_foglio_att_finale	integer,
	id_utente_edit	integer,
	percentuale_area_a	integer,
	stato_all2	integer,
	stato_all6	integer,
	codice_interno_univoco	integer,
	descrizione_area_struttura	character varying);

	drop table if exists   matrix.struttura_asl;
	create table matrix.struttura_asl as select id, id_padre, id_asl, descrizione_lunga as descrizione, n_livello, somma_ui_area as ups, somma_uba_area as uba
	from matrix.oia_nodo where (anno = 2019 and stato != 1 and data_scadenza is null and not disabilitata) or (n_livello < 2 and data_Scadenza is null);

	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_asl_old() OWNER TO postgres;

--
-- Name: create_struttura_asl_test(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_asl_test() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare
	anno_corrente text;
	ex bool;
	rec record;
begin
	
	select value into anno_corrente from "Analisi_dev".config where descr = 'ANNO CORRENTE';

	SELECT EXISTS into ex (
	   SELECT 1
	   FROM   information_schema.tables 
	   WHERE  table_schema = 'matrix'
	   AND    table_name = 'struttura_asl_test'
	   );
	  
  	drop table if exists matrix.oia_nodo;
		create table matrix.oia_nodo as
		select * from "Analisi_dev".vw_oia_nodo_validi where stato != 1 and (data_scadenza is null or data_scadenza > current_timestamp) and not disabilitata;
	
	drop table if exists matrix.ups_uba_temp;

	
	if ex = false then
			
		drop table if exists   matrix.struttura_asl_test;
		create table matrix.struttura_asl_test as select m.codice_interno_fk as id, m.id as id_gisa, 
										 				mp.codice_interno_fk as id_padre,
														m.id_asl, m.descrizione_lunga as descrizione, m.n_livello,
														m.anno
		from matrix.oia_nodo m left join matrix.oia_nodo mp on m.id_padre = mp.id;
	
		alter table matrix.struttura_asl_test add column descrizione_breve text;

		ALTER TABLE matrix.struttura_asl_test ADD COLUMN ups float8;

		ALTER TABLE matrix.struttura_asl_test ADD COLUMN uba float8;

		CREATE TABLE IF NOT exists matrix.struttura_asl_h ( 
		  rng int8range,
		  like matrix.struttura_asl_test including all
		);
	
		create table matrix.ups_uba_temp as select id_gisa, ups, uba, anno from matrix.struttura_asl_test;

	
	else
	
		create table matrix.ups_uba_temp as select id_gisa, ups, uba, anno from matrix.struttura_asl_test;
	
		truncate table matrix.struttura_asl_test;
		
	end if;

	for rec in select distinct anno from matrix.oia_nodo where anno > 0 loop 
			INSERT INTO matrix.struttura_asl_test
			(id, id_gisa, id_padre, id_asl, descrizione, n_livello, anno, descrizione_breve, ups, uba)
			VALUES((8*10000+rec.anno)*-1, (8*10000+rec.anno)*-1, null, null, 'REGIONE CAMPANIA', 0, rec.anno, 'REGIONE_CAMPANIA', NULL, NULL);
			
			INSERT INTO matrix.struttura_asl_test select 
			(m.codice_interno_fk*10000+rec.anno)*-1 as id, (m.id*10000+rec.anno)*-1 as id_gisa, (8*10000+rec.anno)*-1 as id_padre, id_asl, descrizione_lunga, n_livello, rec.anno, null, null, null
			from matrix.oia_nodo m where m.n_livello = 1;
			
	end loop;

	
	insert into matrix.struttura_asl_test select m.codice_interno_fk as id, m.id as id_gisa, 
									 				case when m.n_livello = 2 then (mp.codice_interno_fk*10000+m.anno)*-1 else mp.codice_interno_fk end as id_padre,
													m.id_asl, m.descrizione_lunga as descrizione, m.n_livello,
													m.anno, null, null, null
	from matrix.oia_nodo m left join matrix.oia_nodo mp on m.id_padre = mp.id and (m.anno = mp.anno or m.n_livello = 2) where m.n_livello > 1;
		

	update matrix.struttura_asl_test set descrizione_breve = upper(descrizione);
	update matrix.struttura_asl_test set descrizione_breve = replace(upper(descrizione),'UNITA'' OPERATIVA SEMPLICE DIPARTIMENTALE', 'UOSD') where upper(descrizione) like 'UNITA'' OPERATIVA SEMPLICE DIPARTIMENTALE%';
	update matrix.struttura_asl_test set descrizione_breve = replace(upper(descrizione),'UNITA'' OPERATIVA COMPLESSA', 'UOC') where upper(descrizione) like 'UNITA'' OPERATIVA COMPLESSA%';
	update matrix.struttura_asl_test set descrizione_breve = replace(upper(descrizione),'DIPARTIMENTO DI PREVENZIONE', 'D.D.P.') where upper(descrizione) like 'DIPARTIMENTO DI PREVENZIONE%';

	--delete from matrix.tree_nodes where id_tree = (select id from matrix.trees where name = 'Struttura ASL');
	--insert into matrix.tree_nodes (select id, (select id from matrix.trees where name = 'Struttura ASL'), id_parent from matrix.struttura_asl_test);

	--update matrix.struttura_asl_test set id_padre = 8 where n_livello=1;


	update matrix.struttura_asl_test t set ups = p.ups, uba = p.uba 
	from matrix.ups_uba_temp p where p.id_gisa = t.id_gisa and t.anno = p.anno;

	
	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_asl_test() OWNER TO postgres;

--
-- Name: create_struttura_piani(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_piani() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare
	ex bool;
	rec record;
	rec_sez matrix.struttura_piani%ROWTYPE;
	i int;
	id_tree_val bigint;
	old_val bigint;
	cur_padre bigint;
	n int;
begin
	
	select id into id_tree_val from matrix.trees where name = 'Struttura Piani';

	SELECT EXISTS into ex (
		   SELECT 1
		   FROM   information_schema.tables 
		   WHERE  table_schema = 'matrix'
		   AND    table_name = 'struttura_piani'
		   );

	
	if ex = false then
		drop table if exists matrix.struttura_piani;
		create table matrix.struttura_piani (
			id bigint, --cod raggruppamento
			id_gisa bigint, --id
			cod_raggruppamento bigint,
			anno int4  NULL,
			descrizione text NULL,
			ordinamento int4  NULL,
			data_scadenza timestamp NULL,
			stato int4  NULL,
			codice_interno int4 NULL,
			color varchar(100) null,
			path text,
			livello bigint,
			--parent bigint,
			alias text null,
			path_ord text,
			codice_interno_univoco text
		);
	
	
	CREATE OR REPLACE VIEW matrix.vw_tree_nodes_piani_descr
	AS SELECT ta.name_tree,
	    ta.id_node,
	    ta.id_tree,
	    ta.id_node_parent,
	    a.id,
	    a.id_gisa,
	    a.cod_raggruppamento,
	    a.anno,
	    a.descrizione,
	    a.ordinamento,
	    a.data_scadenza,
	    a.stato,
	    a.codice_interno,
	    a.color,
	    a.path,
	    a.livello,
	    a.alias,
	    a.path_ord,
	    a.codice_interno_univoco,
	   -- a.id_formula_ups,
	   -- a.id_formula_uba,
	  --  a.descrizione_breve,
	    ap.id AS p_id,
	    ap.id_gisa AS p_id_gisa,
	    ap.cod_raggruppamento as p_cod_raggruppamento,
	    ap.anno AS p_anno,
	    ap.descrizione AS p_descrizione,
	    ap.ordinamento AS p_ordinamento,
	    ap.data_scadenza AS p_data_scadenza,
	    ap.stato AS p_stato,
	    ap.codice_interno AS p_codice_interno,
	    ap.color AS p_color,
	    ap.path AS p_path,
	    ap.livello AS p_livello,
	    ap.alias AS p_alias,
	   -- ap.path_ord AS p_path_ord,
	    ap.codice_interno_univoco as p_codice_interno_univoco
	   -- ap.id_formula_ups AS p_id_formula_ups,
	 --   ap.id_formula_uba AS p_id_formula_uba,
	 --   ap.descrizione_breve AS p_descrizione_breve
	   FROM matrix.vw_tree_nodes_piani ta
	     JOIN matrix.struttura_piani a ON a.id = ta.id_node
	     LEFT JOIN matrix.struttura_piani ap ON ap.id = ta.id_node_parent;
	--else
	--	truncate table matrix.struttura_piani;
	end if;

	for rec in select distinct anno from "Analisi_dev".vw_dpat_sez_new_attivi 
		where  anno not in (select ta.anno from matrix.vw_tree_anno ta where ta.name = 'Struttura Piani') loop 
			
		raise notice 'loop rec sezioni %', rec;

		insert into matrix.struttura_piani (id, id_gisa, cod_raggruppamento, descrizione, path, livello, anno, stato, ordinamento)
					values(nextval('matrix.oid_matrix'), -1, -1, 'TOTALE', 'TOTALE', 0, rec.anno, 2, 0);
				
		cur_padre =  currval('matrix.oid_matrix');
		
		insert into matrix.tree_nodes values (cur_padre, id_tree_val, null, '000', 'TOTALE');
		insert into matrix.tree_anno values (rec.anno, id_tree_val, cur_padre);
	

		/*for rec_sez in
			select nextval('matrix.oid_matrix') as id, s.id as id_gisa, s.cod_raggruppamento, s.anno, s.descrizione, 
			ROW_NUMBER() OVER( ORDER BY s.descrizione) as ordinamento,
			s.data_scadenza, s.stato, s.codice_interno, s.color, sp.path||'-'||s.descrizione, 1, '' 
			from "Analisi_dev".vw_dpat_sez_new_attivi s --join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
			join matrix.struttura_piani sp on sp.descrizione::text = 'TOTALE' and s.anno = rec.anno and sp.anno = rec.anno
			 loop
				 
				 raise notice 'loop rec sezioni %', rec_sez;

			 	--rec_sez.path_ord='000-'||lpad(rec_sez.ordinamento::text,'3','0');
				insert into matrix.struttura_piani values (rec_sez.*);
			    insert into matrix.tree_nodes values(rec_sez.id,id_tree_val,cur_padre, lpad(rec_sez.ordinamento::text, 3, '0'), rec_sez.descrizione);
			    
			    
				/*insert into matrix.struttura_piani (id, id_gisa, cod_raggruppamento, descrizione, path, livello, anno, stato , ordinamento, color) values
					( nextval('matrix.oid_matrix'),	(rec_sez.ordinamento *-2), (rec_sez.ordinamento *-2), 'PIANO', 'TOTALE-'||rec_sez.descrizione||'-PIANO', 2, rec_sez.anno, 2, 0, rec_sez.color);
			   
				insert into matrix.tree_nodes values (currval('matrix.oid_matrix'), id_tree_val,rec_sez.id, '000', 'PIANO');
			
				insert into matrix.struttura_piani (id, id_gisa, cod_raggruppamento, descrizione, path, livello, anno, stato , ordinamento, color) values
					( nextval('matrix.oid_matrix'),	(rec_sez.ordinamento *-2)-1, (rec_sez.ordinamento *-2)-1, 'ATTIVITA', 'TOTALE-'||rec_sez.descrizione||'-ATTIVITA', 2, rec_sez.anno, 2, 1, rec_sez.color);
			   
				insert into matrix.tree_nodes values (currval('matrix.oid_matrix'), id_tree_val,rec_sez.id, '001', 'ATTIVITA');*/
		end loop;*/
	end loop;

	for rec_sez in
			select nextval('matrix.oid_matrix') as id, s.id as id_gisa, s.cod_raggruppamento, s.anno, s.descrizione, 
			ROW_NUMBER() OVER( ORDER BY s.ordinamento,s.descrizione) as ordinamento,
			s.data_scadenza, s.stato, s.codice_interno, s.color, sp.path||'-'||s.descrizione, 1, '' 
			from "Analisi_dev".vw_dpat_sez_new_attivi s --join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
			join matrix.struttura_piani sp on sp.descrizione::text = 'TOTALE' and s.anno = sp.anno and sp.livello = 0
			where (s.anno, s.cod_raggruppamento, 1) not in (select anno, cod_raggruppamento, livello from matrix.struttura_piani sp2)
			 loop
				 
				raise notice 'loop rec sezioni_2 %', rec_sez;
				cur_padre = (select id from matrix.struttura_piani sp where sp.descrizione::text = 'TOTALE' and rec_sez.anno = sp.anno and sp.livello = 0);
				raise notice 'loop sezioni_2 cur_padre %', cur_padre;
 	
			--rec_sez.path_ord='000-'||lpad(rec_sez.ordinamento::text,'3','0');
				insert into matrix.struttura_piani select rec_sez.* 
					where not exists (select * from matrix.struttura_piani where anno = rec_sez.anno and livello = 1 and cod_raggruppamento = rec_sez.cod_raggruppamento);
			    insert into matrix.tree_nodes values (rec_sez.id, id_tree_val, cur_padre, lpad(rec_sez.ordinamento::text, 3, '0'), rec_sez.descrizione);
			   		--where not exists (select * from matrix.tree_nodes where id = rec_sez.id and id_tree = id_tree_val);
			    
			    
				/*insert into matrix.struttura_piani (id, id_gisa, cod_raggruppamento, descrizione, path, livello, anno, stato , ordinamento, color) values
					( nextval('matrix.oid_matrix'),	(rec_sez.ordinamento *-2), (rec_sez.ordinamento *-2), 'PIANO', 'TOTALE-'||rec_sez.descrizione||'-PIANO', 2, rec_sez.anno, 2, 0, rec_sez.color);
			   
				insert into matrix.tree_nodes values (currval('matrix.oid_matrix'), id_tree_val,rec_sez.id, '000', 'PIANO');
			
				insert into matrix.struttura_piani (id, id_gisa, cod_raggruppamento, descrizione, path, livello, anno, stato , ordinamento, color) values
					( nextval('matrix.oid_matrix'),	(rec_sez.ordinamento *-2)-1, (rec_sez.ordinamento *-2)-1, 'ATTIVITA', 'TOTALE-'||rec_sez.descrizione||'-ATTIVITA', 2, rec_sez.anno, 2, 1, rec_sez.color);
			   
				insert into matrix.tree_nodes values (currval('matrix.oid_matrix'), id_tree_val,rec_sez.id, '001', 'ATTIVITA');*/
	end loop;

	
	raise notice 'fine loop';

with t as (
		select m.* from matrix.struttura_piani a join (
			select  nextval('matrix.oid_matrix') as id, i.id as id_gisa, i.anno, i.descrizione, i.data_scadenza, i.stato, 
			null, 	null, null, 1 as livello,  cod_raggruppamento,
			ROW_NUMBER() OVER( ORDER BY i.ordinamento, i.descrizione) as ordinamento
				from  "Analisi_dev".vw_dpat_sez_new_attivi i
			 ) m on a.cod_raggruppamento = m.cod_raggruppamento and a.livello =m.livello and m.anno = a.anno
	)
	update matrix.struttura_piani a
	set  id_gisa = t.id_gisa, descrizione=t.descrizione, ordinamento=t.ordinamento, 
	     data_scadenza=t.data_scadenza, stato=t.stato
	from t where t.cod_raggruppamento = a.cod_raggruppamento and t.anno = a.anno and t.livello = a.livello;

	with t as (
		select m.* from matrix.struttura_piani a join (
			select  nextval('matrix.oid_matrix') as id, p.id as id_gisa, p.anno, p.descrizione, p.ordinamento, p.data_scadenza, p.stato, 
			null::bigint as codice_interno, null as color, null as path, 2 as livello, p.alias_piano as alias,
			alias_attivita , cod_raggruppamento, codice_alias_attivita as codice_interno_univoco
				from  "Analisi_dev".vw_dpat_piano_attivita_new_attivi p
			union
			select  nextval('matrix.oid_matrix') as id, i.id as id_gisa, i.anno, i.descrizione, i.ordinamento, i.data_scadenza, i.stato, 
			null, 									null, null, 3, i.alias_indicatore as alias, 
			i.alias_indicatore, cod_raggruppamento, codice_alias_indicatore
				from  "Analisi_dev".vw_dpat_indicatore_new_attivi i
			 ) m on a.cod_raggruppamento = m.cod_raggruppamento and a.livello =m.livello and m.anno = a.anno
	)
	update matrix.struttura_piani a
	set  id_gisa = t.id_gisa , anno=t.anno, descrizione=t.descrizione, ordinamento=t.ordinamento, 
	     data_scadenza=t.data_scadenza, stato=t.stato, codice_interno=t.codice_interno, color=t.color, path=t.path, 
	     livello=t.livello, alias=t.alias, codice_interno_univoco = t.codice_interno_univoco
	from t where t.cod_raggruppamento = a.cod_raggruppamento and t.anno = a.anno and t.livello = a.livello;

    get diagnostics n = row_count;
	raise notice 'aggornati % record', n;


	/*update matrix.tree_nodes set id_parent = t.id
	from matrix.struttura_piani p join "Analisi_dev".vw_dpat_piano_attivita_new_attivi a on p.cod_raggruppamento = a.cod_raggruppamento and p.anno = a.anno
	join matrix.vw_tree_nodes_piani_descr pp on a.id_sezione = pp.p_id
	join matrix.tree_nodes t on t.id = pp.id;

	update matrix.tree_nodes set id_parent = t.id
	from matrix.struttura_piani p join "Analisi_dev".vw_dpat_indicatore_new_attivi a on p.cod_raggruppamento = a.cod_raggruppamento and p.anno = a.anno
	join matrix.vw_tree_nodes_piani_descr pp on a.id_piano_attivita = pp.p_id
	join matrix.tree_nodes t on t.id = pp.id;*/


	raise notice 'fine update';


	delete from matrix.struttura_piani a where livello not in (0) and (a.cod_raggruppamento, a.anno, a.livello) not in 
																			(select cod_raggruppamento, anno, 1 from "Analisi_dev".vw_dpat_sez_new_attivi
																				union
																			select cod_raggruppamento, anno, 2 from "Analisi_dev".vw_dpat_piano_attivita_new_attivi
																				union
																			select cod_raggruppamento, anno, 3 from "Analisi_dev".vw_dpat_indicatore_new_attivi
																				);
																			
	delete from matrix.tree_nodes t where t.id not in (select p.id from matrix.struttura_piani p) and id_tree = id_tree_val;
	delete from matrix.tree_nodes t where t.id_parent not in (select p.id from matrix.struttura_piani p) and id_tree = id_tree_val;

	delete from matrix.tree_nodes t where id in (
	select p.id from matrix.struttura_piani p join "Analisi_dev".vw_dpat_piano_attivita_new_attivi d on p.cod_raggruppamento = d.cod_raggruppamento and d.anno = p.anno and p.livello = 2
			join matrix.vw_tree_nodes_piani_descr v on v.p_id_gisa = d.id_sezione and d.anno = v.anno  --and v.descrizione = split_part(d.tipo_attivita, '-', 1)
			where (p.id, v.id) not in (select a.id, a.id_parent from matrix.tree_nodes a where id_tree = id_tree_val)
	);
	
	delete from matrix.tree_nodes t where id in (
	select p.id from matrix.struttura_piani p join "Analisi_dev".vw_dpat_indicatore_new_attivi i on i.cod_raggruppamento = p.cod_raggruppamento and i.anno=p.anno  and p.livello = 3
			join matrix.struttura_piani pp on pp.id_gisa = i.id_piano_attivita and pp.anno = i.anno 
			where (p.id, pp.id) not in (select a.id, a.id_parent from matrix.tree_nodes a where id_tree = id_tree_val)
	);

	
	insert into matrix.struttura_piani (id, id_gisa, cod_raggruppamento, anno, descrizione, ordinamento, data_scadenza, 
												stato, codice_interno, color, path, livello, alias, codice_interno_univoco) 
		select nextval('matrix.oid_matrix'), p.id, p.cod_raggruppamento, p.anno, p.descrizione, p.ordinamento, p.data_scadenza, 
				p.stato, null::bigint as codice_interno, null as color, null as path, 2 as livello, p.alias_piano as alias, codice_alias_attivita
			from  "Analisi_dev".vw_dpat_piano_attivita_new_attivi p
			where (cod_raggruppamento, anno, 2) not in (select a.cod_raggruppamento, a.anno, a.livello  from matrix.struttura_piani a)
		union
		select nextval('matrix.oid_matrix'), i.id, i.cod_raggruppamento, i.anno, i.descrizione, i.ordinamento, i.data_scadenza, i.stato, null, null, null, 3, i.alias_indicatore as alias , codice_alias_indicatore
			from  "Analisi_dev".vw_dpat_indicatore_new_attivi i
			where (cod_raggruppamento, anno, 3) not in (select a.cod_raggruppamento, a.anno, a.livello  from matrix.struttura_piani a);
	
		raise notice 'fine inert';
	
	get diagnostics n = row_count;
	raise notice 'inseriti in struttura piani % record', n;

		
	insert into matrix.tree_nodes (
		select p.id,id_tree_val, v.id, lpad(p.ordinamento::text, 3,'0'), p.descrizione
		from matrix.struttura_piani p 
		join "Analisi_dev".vw_dpat_piano_attivita_new_attivi d on p.cod_raggruppamento = d.cod_raggruppamento and d.anno = p.anno and p.livello = 2
		join matrix.vw_tree_nodes_piani_descr v on v.id_gisa = d.id_sezione and d.anno = v.anno and v.livello = 1
		
		-- and v.descrizione = split_part(d.tipo_attivita, '-', 1)
		where (p.id/*, v.id*/) not in (select a.id/*, a.id_parent*/ from matrix.tree_nodes a where id_tree = id_tree_val)
	);

	get diagnostics n = row_count;
	raise notice 'inseriti in tree_nodes per piani/attvitia % record', n;
	
	insert into matrix.tree_nodes (
		select p.id, id_tree_val, pp.id, lpad(p.ordinamento::text, 3,'0'), p.descrizione 
		from matrix.struttura_piani p 
		join "Analisi_dev".vw_dpat_indicatore_new_attivi i on i.cod_raggruppamento = p.cod_raggruppamento and i.anno=p.anno  and p.livello = 3
		join matrix.struttura_piani pp on pp.id_gisa = i.id_piano_attivita and pp.anno = i.anno and pp.livello = 2
		where (p.id/*, pp.id*/) not in (select a.id/*, a.id_parent*/ from matrix.tree_nodes a where id_tree = id_tree_val)
	);

	get diagnostics n = row_count;
	raise notice 'inseriti in tree_nodes per indicatori % record', n;	
		
	update matrix.tree_nodes t set ordinamento = lpad(sp.ordinamento::text, 3, '0') 
	from  matrix.struttura_piani sp where t.id = sp.id; --aggiorno eventuali cambi di ordinamento che in tree_nodes non venivano propagati
/*	
if ex = false then
	alter table matrix.struttura_piani add column id_formula_ups bigint;
	alter table matrix.struttura_piani add column id_formula_uba bigint;

	alter table matrix.struttura_piani add column descrizione_breve text;

end if;*/

update matrix.struttura_piani set descrizione_breve = upper(descrizione);
update matrix.struttura_piani set descrizione_breve = replace(upper(descrizione),'PIANO  DI MONIOTORAGGIO', 'P.M.') where upper(descrizione) like '%PIANO  DI MONIOTORAGGIO%';
update matrix.struttura_piani set descrizione_breve = replace(upper(descrizione),'PIANO DI MONIOTORAGGIO', 'P.M.') where upper(descrizione) like '%PIANO DI MONIOTORAGGIO%';
update matrix.struttura_piani set descrizione_breve = replace(upper(descrizione),'PIANO DI MONITORAGGIO', 'P.M.') where upper(descrizione) like '%PIANO DI MONITORAGGIO%';
update matrix.struttura_piani set descrizione_breve = replace(upper(descrizione),'ATTIVITA', 'ATT.') where LIVELLO != 2 and upper(descrizione) like '%ATTIVITA%';
update matrix.struttura_piani set descrizione_breve = replace(upper(descrizione),'ATTIVIT ', 'ATT. ') where upper(descrizione) like '%ATTIVIT %';
update matrix.struttura_piani set descrizione_breve = replace(upper(descrizione),'ISPEZIONI ', 'ISP. ') where upper(descrizione) like 'ISPEZIONI%';

/*
--update matrix.struttura_piani p set color = (select v.p_color from matrix.vw_tree_nodes_piani_descr v where v.id_node_parent = p.id );

--select * from matrix.vw_tree_nodes_down_piani v where id_node_ref in (select id from matrix.struttura_piani where livello =1)
--	alter table matrix.struttura_piani add column fattore_ups real;
--	alter table matrix.struttura_piani add column fattore_uba real;
*/


update matrix.struttura_piani p 
set color = i.color
from "Analisi_dev".vw_dpat_sez_new_attivi i where p.id_gisa = i.id and p.livello = 1;

with t as (
select distinct p.id,pc.color 
from matrix.struttura_piani p 
join matrix.vw_tree_nodes_down t on p.id = t.id_node 
join matrix.struttura_piani pc on t.id_node_REF = pc.id and pc.livello = 1
where pc.color is not null 
) 
update matrix.struttura_piani a set color = t.color from t where t.id = a.id;


	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_piani() OWNER TO postgres;

--
-- Name: create_struttura_piani_2019_new(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_piani_2019_new() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin



drop table if exists matrix.dpat_sez_new_2019_new;
	create table matrix.dpat_sez_new_2019_new as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_sez_new where anno = 2019 and stato != 1 and data_scadenza < current_timestamp')  AS remote
	(id bigint,
	cod_raggruppamento bigint,
	anno int4,
	descrizione text,
	ordinamento int4,
	data_scadenza timestamp,
	stato int4,
	codice_interno int4,
	color varchar(100));

	drop table if exists matrix.dpat_piano_attivita_new_2019_new; 
	create table matrix.dpat_piano_attivita_new_2019_new  as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_piano_attivita_new where anno = 2019 and stato != 1 and data_scadenza < current_timestamp')  AS remote
	(
	id bigint,
	cod_raggruppamento bigint,
	id_sezione int4,
	anno int4,
	descrizione text,
	ordinamento int4,
	data_scadenza timestamp,
	stato int4,
	codice_esame text,
	tipo_attivita text,
	codice_interno_piano int4,
	codice_interno_attivita int4,
	alias_piano text,
	alias_attivita text,
	codice_alias_attivita text
	);

	drop table if exists matrix.dpat_indicatore_new_2019_new; 
	create table matrix.dpat_indicatore_new_2019_new  as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_indicatore_new where anno = 2019 and stato != 1 and data_scadenza < current_timestamp')  AS remote
	(
	id bigint,
	cod_raggruppamento bigint,
	id_piano_attivita int4 ,
	anno int4  ,
	descrizione text ,
	ordinamento int4  ,
	data_scadenza timestamp ,
	stato int4  ,
	codice_esame text ,
	codice_interno_indicatore int4 ,
	alias_indicatore text ,
	codice_interno_piani_gestione_cu int4 ,
	codice_interno_attivita_gestione_cu text ,
	codice_interno_univoco_tipo_attivita_gestione_cu text ,
	codice_alias_indicatore text ,
	extra_gisa bool,
	flag_benessere bool 
	);

	--truncate table matrix.struttura_piani_2020;

	drop table if exists matrix.struttura_piani_2019_new;
	create table matrix.struttura_piani_2019_new (
		id bigint NOT NULL,
		cod_raggruppamento bigint,
		anno int4  NULL,
		descrizione text NULL,
		ordinamento int4  NULL,
		data_scadenza timestamp NULL,
		stato int4  NULL,
		codice_interno int4 NULL,
		color varchar(100) null,
		path text,
		livello bigint,
		parent bigint,
		alias text null,
		path_ord text
	);



	insert into matrix.struttura_piani_2019_new (id, descrizione, path, livello, parent, anno, stato, ordinamento, path_ord )values(-1, 'TOTALE', 'TOTALE', 0, null, 2019, 2, 0, '000');
--	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-2, 'PIANO', 'TOTALE-PIANO', 1, -1, 2020, 2, 0, '000-000');
--	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-3, 'ATTIVITA', 'TOTALE-ATTIVITA', 1, -1, 2020, 2, 1, '000-001');
	
	insert into matrix.struttura_piani_2019_new (
	select distinct s.id, s.cod_raggruppamento, 2019, s.descrizione, s.ordinamento, s.data_scadenza, s.stato, s.codice_interno, s.color, sp.path||'-'||s.descrizione, 1,  sp.id, null, sp.path_ord||'-'||lpad(s.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new_2019_new s join matrix.dpat_piano_attivita_new_2019_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new_2019_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani_2019_new sp on sp.descrizione::text = 'TOTALE');
	

	update matrix.struttura_piani_2019_new set ordinamento = '0' , path_ord = '000-000'  where livello = 1 and path = 'TOTALE-SEZIONE A';
	update matrix.struttura_piani_2019_new set ordinamento = '1' , path_ord = '000-001'  where livello = 1 and path = 'TOTALE-SEZIONE B';
	update matrix.struttura_piani_2019_new set ordinamento = '2' , path_ord = '000-002'  where livello = 1 and path = 'TOTALE-SEZIONE C';
	update matrix.struttura_piani_2019_new set ordinamento = '3' , path_ord = '000-003'  where livello = 1 and path = 'TOTALE-SEZIONE D';


	insert into matrix.struttura_piani_2019_new (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-2, 'PIANO', 'TOTALE-SEZIONE A-PIANO', 2, 77, 2019, 2, 0, '000-000-000');
	insert into matrix.struttura_piani_2019_new (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-3, 'ATTIVITA', 'TOTALE-SEZIONE A-ATTIVITA', 2, 77, 2019, 2, 1, '000-000-001');
	insert into matrix.struttura_piani_2019_new (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-4, 'PIANO', 'TOTALE-SEZIONE B-PIANO', 2, 78, 2019, 2, 0, '000-001-000');
	insert into matrix.struttura_piani_2019_new (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-5, 'ATTIVITA', 'TOTALE-SEZIONE B-ATTIVITA', 2, 78, 2019, 2, 1, '000-001-001');
	insert into matrix.struttura_piani_2019_new (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-6, 'PIANO', 'TOTALE-SEZIONE C-PIANO', 2, 79, 2019, 2, 0, '000-002-000');
	insert into matrix.struttura_piani_2019_new (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-7, 'ATTIVITA', 'TOTALE-SEZIONE C-ATTIVITA', 2, 79, 2019, 2, 1, '000-002-001');
	insert into matrix.struttura_piani_2019_new (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-8, 'PIANO', 'TOTALE-SEZIONE D-PIANO', 2, 80, 2019, 2, 0, '000-003-000');
	insert into matrix.struttura_piani_2019_new (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-9, 'ATTIVITA', 'TOTALE-SEZIONE D-ATTIVITA', 2, 80, 2019, 2, 1, '000-003-001');
	

	/*update matrix.struttura_piani set ordinamento = '0', path_ord = '000-000-000'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE A';
	update matrix.struttura_piani set ordinamento = '1', path_ord = '000-000-001'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE B';
	update matrix.struttura_piani set ordinamento = '2' , path_ord = '000-000-002'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE C';
	update matrix.struttura_piani set ordinamento = '3' , path_ord = '000-000-003'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE D';

	update matrix.struttura_piani set ordinamento = '0' , path_ord = '000-001-000'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE A';
	update matrix.struttura_piani set ordinamento = '1' , path_ord = '000-001-001'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE B';
	update matrix.struttura_piani set ordinamento = '2' , path_ord = '000-001-002'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE C';
	update matrix.struttura_piani set ordinamento = '3' , path_ord = '000-001-003'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE D';*/

	insert into matrix.struttura_piani_2019_new (
	select distinct p.id, p.cod_raggruppamento, 2019, p.descrizione, p.ordinamento, p.data_scadenza, p.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 3,  sp.id, p.alias_piano, sp.path_ord||'-'||lpad(p.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new_2019_new s join matrix.dpat_piano_attivita_new_2019_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new_2019_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani_2019_new sp on sp.id = case when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'A' then -2
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'A' then -3
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'B' then -4
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'B' then -5
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'C' then -6
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'C' then -7
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'D' then -8
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'D' then -9
												   END);
	
	insert into matrix.struttura_piani_2019_new (
	select distinct i.id, i.cod_raggruppamento, 2019, i.descrizione, i.ordinamento,i.data_scadenza, i.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 4,  sp.id, i.alias_indicatore,sp.path_ord||'-'||lpad(i.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new_2019_new s join matrix.dpat_piano_attivita_new_2019_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new_2019_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani_2019_new sp on sp.id = i.id_piano_attivita);

--	alter table matrix.struttura_piani add column id_formula_ups bigint;
--	alter table matrix.struttura_piani add column id_formula_uba bigint;

--	alter table matrix.struttura_piani add column fattore_ups real;
--	alter table matrix.struttura_piani add column fattore_uba real;



	
	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_piani_2019_new() OWNER TO postgres;

--
-- Name: create_struttura_piani_2020(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_piani_2020() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin



drop table if exists matrix.dpat_sez_new_2020;
	create table matrix.dpat_sez_new_2020 as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_sez_new where anno = 2020 and stato != 1 and data_scadenza is null')  AS remote
	(id bigint,
	cod_raggruppamento bigint,
	anno int4,
	descrizione text,
	ordinamento int4,
	data_scadenza timestamp,
	stato int4,
	codice_interno int4,
	color varchar(100));

	drop table if exists matrix.dpat_piano_attivita_new_2020; 
	create table matrix.dpat_piano_attivita_new_2020  as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_piano_attivita_new where anno = 2020 and stato != 1 and data_scadenza is null')  AS remote
	(
	id bigint,
	cod_raggruppamento bigint,
	id_sezione int4,
	anno int4,
	descrizione text,
	ordinamento int4,
	data_scadenza timestamp,
	stato int4,
	codice_esame text,
	tipo_attivita text,
	codice_interno_piano int4,
	codice_interno_attivita int4,
	alias_piano text,
	alias_attivita text,
	codice_alias_attivita text
	);

	drop table if exists matrix.dpat_indicatore_new_2020; 
	create table matrix.dpat_indicatore_new_2020  as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_indicatore_new where anno = 2020 and stato != 1 and data_scadenza is null')  AS remote
	(
	id bigint,
	cod_raggruppamento bigint,
	id_piano_attivita int4 ,
	anno int4  ,
	descrizione text ,
	ordinamento int4  ,
	data_scadenza timestamp ,
	stato int4  ,
	codice_esame text ,
	codice_interno_indicatore int4 ,
	alias_indicatore text ,
	codice_interno_piani_gestione_cu int4 ,
	codice_interno_attivita_gestione_cu text ,
	codice_interno_univoco_tipo_attivita_gestione_cu text ,
	codice_alias_indicatore text ,
	extra_gisa bool,
	flag_benessere bool 
	);

	--truncate table matrix.struttura_piani_2020;

	drop table if exists matrix.struttura_piani_2020;
	create table matrix.struttura_piani_2020 (
		id bigint NOT NULL,
		cod_raggruppamento bigint,
		anno int4  NULL,
		descrizione text NULL,
		ordinamento int4  NULL,
		data_scadenza timestamp NULL,
		stato int4  NULL,
		codice_interno int4 NULL,
		color varchar(100) null,
		path text,
		livello bigint,
		parent bigint,
		alias text null,
		path_ord text
	);



	insert into matrix.struttura_piani_2020 (id, descrizione, path, livello, parent, anno, stato, ordinamento, path_ord )values(-1, 'TOTALE', 'TOTALE', 0, null, 2020, 2, 0, '000');
--	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-2, 'PIANO', 'TOTALE-PIANO', 1, -1, 2020, 2, 0, '000-000');
--	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-3, 'ATTIVITA', 'TOTALE-ATTIVITA', 1, -1, 2020, 2, 1, '000-001');
	
	insert into matrix.struttura_piani_2020 (
	select distinct s.id, s.cod_raggruppamento, 2020, s.descrizione, s.ordinamento, s.data_scadenza, s.stato, s.codice_interno, s.color, sp.path||'-'||s.descrizione, 1,  sp.id, null, sp.path_ord||'-'||lpad(s.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.descrizione::text = 'TOTALE'
	where i.anno = 2020 and p.anno = 2020 and s.anno = 2020 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);
	

	update matrix.struttura_piani_2020 set ordinamento = '0' , path_ord = '000-000'  where livello = 1 and path = 'TOTALE-SEZIONE A';
	update matrix.struttura_piani_2020 set ordinamento = '1' , path_ord = '000-001'  where livello = 1 and path = 'TOTALE-SEZIONE B';
	update matrix.struttura_piani_2020 set ordinamento = '2' , path_ord = '000-002'  where livello = 1 and path = 'TOTALE-SEZIONE C';
	update matrix.struttura_piani_2020 set ordinamento = '3' , path_ord = '000-003'  where livello = 1 and path = 'TOTALE-SEZIONE D';


	insert into matrix.struttura_piani_2020 (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-2, 'PIANO', 'TOTALE-SEZIONE A-PIANO', 2, 77, 2020, 2, 0, '000-000-000');
	insert into matrix.struttura_piani_2020 (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-3, 'ATTIVITA', 'TOTALE-SEZIONE A-ATTIVITA', 2, 77, 2020, 2, 1, '000-000-001');
	insert into matrix.struttura_piani_2020 (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-4, 'PIANO', 'TOTALE-SEZIONE B-PIANO', 2, 78, 2020, 2, 0, '000-001-000');
	insert into matrix.struttura_piani_2020 (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-5, 'ATTIVITA', 'TOTALE-SEZIONE B-ATTIVITA', 2, 78, 2020, 2, 1, '000-001-001');
	insert into matrix.struttura_piani_2020 (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-6, 'PIANO', 'TOTALE-SEZIONE C-PIANO', 2, 79, 2020, 2, 0, '000-002-000');
	insert into matrix.struttura_piani_2020 (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-7, 'ATTIVITA', 'TOTALE-SEZIONE C-ATTIVITA', 2, 79, 2020, 2, 1, '000-002-001');
	insert into matrix.struttura_piani_2020 (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-8, 'PIANO', 'TOTALE-SEZIONE D-PIANO', 2, 80, 2020, 2, 0, '000-003-000');
	insert into matrix.struttura_piani_2020 (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-9, 'ATTIVITA', 'TOTALE-SEZIONE D-ATTIVITA', 2, 80, 2020, 2, 1, '000-003-001');
	

	/*update matrix.struttura_piani set ordinamento = '0', path_ord = '000-000-000'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE A';
	update matrix.struttura_piani set ordinamento = '1', path_ord = '000-000-001'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE B';
	update matrix.struttura_piani set ordinamento = '2' , path_ord = '000-000-002'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE C';
	update matrix.struttura_piani set ordinamento = '3' , path_ord = '000-000-003'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE D';

	update matrix.struttura_piani set ordinamento = '0' , path_ord = '000-001-000'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE A';
	update matrix.struttura_piani set ordinamento = '1' , path_ord = '000-001-001'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE B';
	update matrix.struttura_piani set ordinamento = '2' , path_ord = '000-001-002'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE C';
	update matrix.struttura_piani set ordinamento = '3' , path_ord = '000-001-003'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE D';*/

	insert into matrix.struttura_piani_2020 (
	select distinct p.id, p.cod_raggruppamento, 2020, p.descrizione, p.ordinamento, p.data_scadenza, p.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 3,  sp.id, p.alias_piano, sp.path_ord||'-'||lpad(p.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.id = case when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'A' then -2
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'A' then -3
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'B' then -4
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'B' then -5
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'C' then -6
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'C' then -7
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'D' then -8
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'D' then -9
												   END
	where i.anno = 2020 and p.anno = 2020 and s.anno = 2020 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);
	
	insert into matrix.struttura_piani_2020 (
	select distinct i.id, i.cod_raggruppamento, 2020, i.descrizione, i.ordinamento,i.data_scadenza, i.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 4,  sp.id, i.alias_indicatore,sp.path_ord||'-'||lpad(i.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.id = i.id_piano_attivita
	where i.anno = 2020 and p.anno = 2020 and s.anno = 2020 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);

--	alter table matrix.struttura_piani add column id_formula_ups bigint;
--	alter table matrix.struttura_piani add column id_formula_uba bigint;

--	alter table matrix.struttura_piani add column fattore_ups real;
--	alter table matrix.struttura_piani add column fattore_uba real;



	
	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_piani_2020() OWNER TO postgres;

--
-- Name: create_struttura_piani_old(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_piani_old() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	
	drop table if exists matrix.dpat_sez_new;
	create table matrix.dpat_sez_new as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_sez_new where anno = 2019 and stato != 1 and data_scadenza is null')  AS remote
	(id bigint,
	cod_raggruppamento bigint,
	anno int4,
	descrizione text,
	ordinamento int4,
	data_scadenza timestamp,
	stato int4,
	codice_interno int4,
	color varchar(100));

	drop table if exists matrix.dpat_piano_attivita_new; 
	create table matrix.dpat_piano_attivita_new  as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_piano_attivita_new where anno = 2019 and stato != 1 and data_scadenza is null')  AS remote
	(
	id bigint,
	cod_raggruppamento bigint,
	id_sezione int4,
	anno int4,
	descrizione text,
	ordinamento int4,
	data_scadenza timestamp,
	stato int4,
	codice_esame text,
	tipo_attivita text,
	codice_interno_piano int4,
	codice_interno_attivita int4,
	alias_piano text,
	alias_attivita text,
	codice_alias_attivita text
	);

	drop table if exists matrix.dpat_indicatore_new; 
	create table matrix.dpat_indicatore_new  as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_indicatore_new where anno = 2019 and stato != 1 and data_scadenza is null')  AS remote
	(
	id bigint,
	cod_raggruppamento bigint,
	id_piano_attivita int4 ,
	anno int4  ,
	descrizione text ,
	ordinamento int4  ,
	data_scadenza timestamp ,
	stato int4  ,
	codice_esame text ,
	tipo_attivita text ,
	codice_interno_indicatore int4 ,
	alias_indicatore text ,
	codice_interno_piani_gestione_cu int4 ,
	codice_interno_attivita_gestione_cu text ,
	codice_interno_univoco_tipo_attivita_gestione_cu text ,
	codice_alias_indicatore text ,
	extra_gisa bool 
	);

	drop table if exists matrix.struttura_piani;
	create table matrix.struttura_piani (
		id bigint NOT NULL,
		cod_raggruppamento bigint,
		anno int4  NULL,
		descrizione text NULL,
		ordinamento int4  NULL,
		data_scadenza timestamp NULL,
		stato int4  NULL,
		codice_interno int4 NULL,
		color varchar(100) null,
		path text,
		livello bigint,
		parent bigint,
		alias text null
	);

	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato, ordinamento )values(-1, 'TOTALE', 'TOTALE', 0, null, 2019, 2, 0);
	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento)values(-2, 'PIANO', 'TOTALE-PIANO', 1, -1, 2019, 2, 0);
	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento)values(-3, 'ATTIVITA', 'TOTALE-ATTIVITA', 1, -1, 2019, 2, 1);
	
	insert into matrix.struttura_piani (
	select distinct s.id * (case when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' then -1 else 1 end), s.cod_raggruppamento, 2019, s.descrizione, s.ordinamento, s.data_scadenza, s.stato, s.codice_interno, s.color, sp.path||'-'||s.descrizione, 2,  sp.id, null 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.descrizione::text = substring(p.tipo_attivita from 1 for 8)::text 
	where i.anno = 2019 and p.anno = 2019 and s.anno = 2019 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);
	
	
	insert into matrix.struttura_piani (
	select distinct p.id, p.cod_raggruppamento, 2019, p.descrizione, p.ordinamento, p.data_scadenza, p.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 3,  sp.id, p.alias_piano
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.id = p.id_sezione * (case when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' then -1 else 1 end)
	where i.anno = 2019 and p.anno = 2019 and s.anno = 2019 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);
	
	insert into matrix.struttura_piani (
	select distinct i.id, i.cod_raggruppamento, 2019, i.descrizione, i.ordinamento,i.data_scadenza, i.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 4,  sp.id, i.alias_indicatore
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.id = i.id_piano_attivita
	where i.anno = 2019 and p.anno = 2019 and s.anno = 2019 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);

	alter table matrix.struttura_piani add column id_formula_ups bigint;
	alter table matrix.struttura_piani add column id_formula_uba bigint;

	alter table matrix.struttura_piani add column fattore_ups real;
	alter table matrix.struttura_piani add column fattore_uba real;

	
	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_piani_old() OWNER TO postgres;

--
-- Name: create_struttura_piani_test(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_piani_test() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare
	anno_corrente text;
	ex bool;
	rec record;
	sez record;
	i int;
begin
	
	select value into anno_corrente from "Analisi_dev".config where descr = 'ANNO CORRENTE';
	
	drop table if exists matrix.dpat_sez_new;
	create table matrix.dpat_sez_new as
	select * from "Analisi_dev".vw_dpat_sez_new_validi vdsnv where stato != 1 and (data_scadenza is null or data_scadenza > current_timestamp) and descrizione != 'SEZIONE E';

	drop table if exists matrix.dpat_piano_attivita_new; 
	create table matrix.dpat_piano_attivita_new  as
	select * from "Analisi_dev".vw_dpat_piano_attivita_new_validi vdpanv  where stato != 1 and (data_scadenza is null or data_scadenza > current_timestamp);
	drop table if exists matrix.dpat_indicatore_new; 
	create table matrix.dpat_indicatore_new  as
	select * from "Analisi_dev".vw_dpat_indicatore_new_validi vdinv  where stato != 1 and (data_scadenza is null or data_scadenza > current_timestamp);

	SELECT EXISTS into ex (
		   SELECT 1
		   FROM   information_schema.tables 
		   WHERE  table_schema = 'matrix'
		   AND    table_name = 'struttura_piani_test'
		   );

	
	if ex = false then
		drop table if exists matrix.struttura_piani_test;
		create table matrix.struttura_piani_test (
			id bigint NOT NULL, --cod raggruppamento
			id_gisa bigint, --id
			anno int4  NULL,
			descrizione text NULL,
			ordinamento int4  NULL,
			data_scadenza timestamp NULL,
			stato int4  NULL,
			codice_interno int4 NULL,
			color varchar(100) null,
			path text,
			livello bigint,
			parent bigint,
			alias text null,
			path_ord text
		);
	else
		truncate table matrix.struttura_piani_test;
	end if;

	for rec in select distinct anno from matrix.oia_nodo where anno > 0 loop 

		insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato, ordinamento, path_ord )values(-1*10000-rec.anno, -1*10000-rec.anno, 'TOTALE', 'TOTALE', 0, null, rec.anno, 2, 0, '000');

	end loop;
	
	insert into matrix.struttura_piani_test (
	select distinct s.cod_raggruppamento, s.id, s.anno, s.descrizione, s.ordinamento, s.data_scadenza, s.stato, s.codice_interno, s.color, sp.path||'-'||s.descrizione, 1,  sp.id, null, sp.path_ord||'-'||lpad(s.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani_test sp on sp.descrizione::text = 'TOTALE' and sp.anno = s.anno
	);
	

	update matrix.struttura_piani_test set ordinamento = '0' , path_ord = '000-000'  where livello = 1 and path = 'TOTALE-SEZIONE A';
	update matrix.struttura_piani_test set ordinamento = '1' , path_ord = '000-001'  where livello = 1 and path = 'TOTALE-SEZIONE B';
	update matrix.struttura_piani_test set ordinamento = '2' , path_ord = '000-002'  where livello = 1 and path = 'TOTALE-SEZIONE C';
	update matrix.struttura_piani_test set ordinamento = '3' , path_ord = '000-003'  where livello = 1 and path = 'TOTALE-SEZIONE D';


	insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord) select 	-2*10000-anno, -2*10000-anno, 'PIANO', 'TOTALE-SEZIONE A-PIANO', 2, id,anno, 2, 0, '000-000-000' from matrix.struttura_piani_test where path = 'TOTALE-SEZIONE A';
	insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord) select 	-3*10000-anno, -3*10000-anno, 'ATTIVITA', 'TOTALE-SEZIONE A-ATTIVITA', 2, id,anno, 2, 0, '000-000-001' from matrix.struttura_piani_test where path = 'TOTALE-SEZIONE A';
	insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord) select 	-4*10000-anno, -4*10000-anno, 'PIANO', 'TOTALE-SEZIONE B-PIANO', 2, id,anno, 2, 0, '000-001-000' from matrix.struttura_piani_test where path = 'TOTALE-SEZIONE B';
	insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord) select 	-5*10000-anno, -5*10000-anno, 'ATTIVITA', 'TOTALE-SEZIONE B-ATTIVITA', 2, id,anno, 2, 0, '000-001-001' from matrix.struttura_piani_test where path = 'TOTALE-SEZIONE B';
	insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord) select 	-6*10000-anno, -6*10000-anno, 'PIANO', 'TOTALE-SEZIONE C-PIANO', 2, id,anno, 2, 0, '000-002-000' from matrix.struttura_piani_test where path = 'TOTALE-SEZIONE C';
	insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord) select 	-7*10000-anno, -7*10000-anno, 'ATTIVITA', 'TOTALE-SEZIONE C-ATTIVITA', 2, id,anno, 2, 0, '000-002-001' from matrix.struttura_piani_test where path = 'TOTALE-SEZIONE C';
	insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord) select 	-8*10000-anno, -8*10000-anno, 'PIANO', 'TOTALE-SEZIONE D-PIANO', 2, id,anno, 2, 0, '000-003-000' from matrix.struttura_piani_test where path = 'TOTALE-SEZIONE D';
	insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord) select 	-9*10000-anno, -9*10000-anno, 'ATTIVITA', 'TOTALE-SEZIONE D-ATTIVITA', 2, id,anno, 2, 0, '000-003-001' from matrix.struttura_piani_test where path = 'TOTALE-SEZIONE D';

	/*
		insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-3*10000+rec.anno, -3*10000+rec.anno, 'ATTIVITA', 'TOTALE-SEZIONE B-ATTIVITA', 2, 77, anno_corrente::bigint, 2, 0, '000-001-000');
		insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-4*10000+rec.anno, -4*10000+rec.anno, 'PIANO', 'TOTALE-SEZIONE B-PIANO', 2, 78, anno_corrente::bigint, 2, 0, '000-001-000');
		insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-5*10000+rec.anno, -5*10000+rec.anno, 'ATTIVITA', 'TOTALE-SEZIONE B-ATTIVITA', 2, 78, anno_corrente::bigint, 2, 1, '000-001-001');
		insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-6*10000+rec.anno, -6*10000+rec.anno, 'PIANO', 'TOTALE-SEZIONE C-PIANO', 2, 79, anno_corrente::bigint, 2, 0, '000-002-000');
		insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-7*10000+rec.anno, -7*10000+rec.anno, 'ATTIVITA', 'TOTALE-SEZIONE C-ATTIVITA', 2, 79, anno_corrente::bigint, 2, 1, '000-002-001');
		insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-8*10000+rec.anno, -8*10000+rec.anno, 'PIANO', 'TOTALE-SEZIONE D-PIANO', 2, 80, anno_corrente::bigint, 2, 0, '000-003-000');
		insert into matrix.struttura_piani_test (id, id_gisa, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-9*10000+rec.anno, -9*10000+rec.anno, 'ATTIVITA', 'TOTALE-SEZIONE D-ATTIVITA', 2, 80, anno_corrente::bigint, 2, 1, '000-003-001');
*/


 

	insert into matrix.struttura_piani_test (
	select distinct p.cod_raggruppamento, p.id, p.anno, p.descrizione, p.ordinamento, p.data_scadenza, p.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 3,  sp.id, p.alias_piano, sp.path_ord||'-'||lpad(p.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani_test sp on sp.anno = p.anno and sp.id = case when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'A' then -2*10000-p.anno
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'A' then -3*10000-p.anno
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'B' then -4*10000-p.anno
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'B' then -5*10000-p.anno
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'C' then -6*10000-p.anno
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'C' then -7*10000-p.anno
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'D' then -8*10000-p.anno
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'D' then -9*10000-p.anno
												   end
												  ) ;
	
	insert into matrix.struttura_piani_test (
	select distinct i.cod_raggruppamento, i.id, i.anno, i.descrizione, i.ordinamento,i.data_scadenza, i.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 4,  sp.id, i.alias_indicatore,sp.path_ord||'-'||lpad(i.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani_test sp on sp.id_gisa = i.id_piano_attivita and sp.anno = i.anno
	);

if ex = false then
	alter table matrix.struttura_piani_test add column id_formula_ups bigint;
	alter table matrix.struttura_piani_test add column id_formula_uba bigint;

	alter table matrix.struttura_piani_test add column descrizione_breve text;

end if;

update matrix.struttura_piani_test set descrizione_breve = upper(descrizione);
update matrix.struttura_piani_test set descrizione_breve = replace(upper(descrizione),'PIANO  DI MONIOTORAGGIO', 'P.M.') where upper(descrizione) like '%PIANO  DI MONIOTORAGGIO%';
update matrix.struttura_piani_test set descrizione_breve = replace(upper(descrizione),'PIANO DI MONIOTORAGGIO', 'P.M.') where upper(descrizione) like '%PIANO DI MONIOTORAGGIO%';
update matrix.struttura_piani_test set descrizione_breve = replace(upper(descrizione),'PIANO DI MONITORAGGIO', 'P.M.') where upper(descrizione) like '%PIANO DI MONITORAGGIO%';
update matrix.struttura_piani_test set descrizione_breve = replace(upper(descrizione),'ATTIVITA', 'ATT.') where LIVELLO != 2 and upper(descrizione) like '%ATTIVITA%';
update matrix.struttura_piani_test set descrizione_breve = replace(upper(descrizione),'ATTIVIT ', 'ATT. ') where upper(descrizione) like '%ATTIVIT %';
update matrix.struttura_piani_test set descrizione_breve = replace(upper(descrizione),'ISPEZIONI ', 'ISP. ') where upper(descrizione) like 'ISPEZIONI%';


--	alter table matrix.struttura_piani add column fattore_ups real;
--	alter table matrix.struttura_piani add column fattore_uba real;


	/*delete from matrix.tree_nodes where id_tree = (select id from matrix.trees where name = 'Struttura Piani');
	insert into matrix.tree_nodes (select id_gisa, (select id from matrix.trees where name = 'Struttura Piani'), parent from matrix.struttura_piani_test);
	*/

drop table if exists matrix.id_formule_temp;
create table matrix.id_formule_temp as select id_gisa, id_formula_ups, id_formula_uba, anno from matrix.struttura_piani_test;

update matrix.struttura_piani_test t set id_formula_ups = p.id_formula_ups, id_formula_uba = p.id_formula_uba 
from matrix.id_formule_temp p where p.id_gisa = t.id_gisa and t.anno = p.anno;
	
	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_piani_test() OWNER TO postgres;

--
-- Name: create_struttura_piano_ordinamento(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_piano_ordinamento() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	
	drop table if exists matrix.dpat_sez_new;
	create table matrix.dpat_sez_new as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_sez_new where anno = 2019 and stato != 1 and data_scadenza is null')  AS remote
	(id bigint,
	cod_raggruppamento bigint,
	anno int4,
	descrizione text,
	ordinamento int4,
	data_scadenza timestamp,
	stato int4,
	codice_interno int4,
	color varchar(100));

	drop table if exists matrix.dpat_piano_attivita_new; 
	create table matrix.dpat_piano_attivita_new  as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_piano_attivita_new where anno = 2019 and stato != 1 and data_scadenza is null')  AS remote
	(
	id bigint,
	cod_raggruppamento bigint,
	id_sezione int4,
	anno int4,
	descrizione text,
	ordinamento int4,
	data_scadenza timestamp,
	stato int4,
	codice_esame text,
	tipo_attivita text,
	codice_interno_piano int4,
	codice_interno_attivita int4,
	alias_piano text,
	alias_attivita text,
	codice_alias_attivita text
	);

	drop table if exists matrix.dpat_indicatore_new; 
	create table matrix.dpat_indicatore_new  as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_indicatore_new where anno = 2019 and stato != 1 and data_scadenza is null')  AS remote
	(
	id bigint,
	cod_raggruppamento bigint,
	id_piano_attivita int4 ,
	anno int4  ,
	descrizione text ,
	ordinamento int4  ,
	data_scadenza timestamp ,
	stato int4  ,
	codice_esame text ,
	tipo_attivita text ,
	codice_interno_indicatore int4 ,
	alias_indicatore text ,
	codice_interno_piani_gestione_cu int4 ,
	codice_interno_attivita_gestione_cu text ,
	codice_interno_univoco_tipo_attivita_gestione_cu text ,
	codice_alias_indicatore text ,
	extra_gisa bool 
	);

	drop table if exists matrix.struttura_piani;
	create table matrix.struttura_piani (
		id bigint NOT NULL,
		cod_raggruppamento bigint,
		anno int4  NULL,
		descrizione text NULL,
		ordinamento int4  NULL,
		data_scadenza timestamp NULL,
		stato int4  NULL,
		codice_interno int4 NULL,
		color varchar(100) null,
		path text,
		livello bigint,
		parent bigint,
		alias text null,
		path_ord text
	);

	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato, ordinamento, path_ord )values(-1, 'TOTALE', 'TOTALE', 0, null, 2019, 2, 0, '000');
	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-2, 'PIANO', 'TOTALE-PIANO', 1, -1, 2019, 2, 0, '000-000');
	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-3, 'ATTIVITA', 'TOTALE-ATTIVITA', 1, -1, 2019, 2, 1, '000-001');
	
	insert into matrix.struttura_piani (
	select distinct s.id * (case when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' then -1 else 1 end), s.cod_raggruppamento, 2019, s.descrizione, s.ordinamento, s.data_scadenza, s.stato, s.codice_interno, s.color, sp.path||'-'||s.descrizione, 2,  sp.id, null, sp.path_ord||'-'||lpad(s.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.descrizione::text = substring(p.tipo_attivita from 1 for 8)::text 
	where i.anno = 2019 and p.anno = 2019 and s.anno = 2019 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);
	
	update matrix.struttura_piani set ordinamento = '0', path_ord = '000-000-000'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE A';
	update matrix.struttura_piani set ordinamento = '1', path_ord = '000-000-001'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE B';
	update matrix.struttura_piani set ordinamento = '2' , path_ord = '000-000-002'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE C';
	update matrix.struttura_piani set ordinamento = '3' , path_ord = '000-000-003'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE D';

	update matrix.struttura_piani set ordinamento = '0' , path_ord = '000-001-000'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE A';
	update matrix.struttura_piani set ordinamento = '1' , path_ord = '000-001-001'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE B';
	update matrix.struttura_piani set ordinamento = '2' , path_ord = '000-001-002'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE C';
	update matrix.struttura_piani set ordinamento = '3' , path_ord = '000-001-003'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE D';

	
	insert into matrix.struttura_piani (
	select distinct p.id, p.cod_raggruppamento, 2019, p.descrizione, p.ordinamento, p.data_scadenza, p.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 3,  sp.id, p.alias_piano, sp.path_ord||'-'||lpad(p.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.id = p.id_sezione * (case when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' then -1 else 1 end)
	where i.anno = 2019 and p.anno = 2019 and s.anno = 2019 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);
	
	insert into matrix.struttura_piani (
	select distinct i.id, i.cod_raggruppamento, 2019, i.descrizione, i.ordinamento,i.data_scadenza, i.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 4,  sp.id, i.alias_indicatore,sp.path_ord||'-'||lpad(i.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.id = i.id_piano_attivita
	where i.anno = 2019 and p.anno = 2019 and s.anno = 2019 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);

	alter table matrix.struttura_piani add column id_formula_ups bigint;
	alter table matrix.struttura_piani add column id_formula_uba bigint;

	alter table matrix.struttura_piani add column fattore_ups real;
	alter table matrix.struttura_piani add column fattore_uba real;

	
	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_piano_ordinamento() OWNER TO postgres;

--
-- Name: create_struttura_piano_ordinamento_new(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_piano_ordinamento_new() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	
	drop table if exists matrix.dpat_sez_new;
	create table matrix.dpat_sez_new as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_sez_new where anno = 2019 and stato != 1 and data_scadenza is null')  AS remote
	(id bigint,
	cod_raggruppamento bigint,
	anno int4,
	descrizione text,
	ordinamento int4,
	data_scadenza timestamp,
	stato int4,
	codice_interno int4,
	color varchar(100));

	drop table if exists matrix.dpat_piano_attivita_new; 
	create table matrix.dpat_piano_attivita_new  as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_piano_attivita_new where anno = 2019 and stato != 1 and data_scadenza is null')  AS remote
	(
	id bigint,
	cod_raggruppamento bigint,
	id_sezione int4,
	anno int4,
	descrizione text,
	ordinamento int4,
	data_scadenza timestamp,
	stato int4,
	codice_esame text,
	tipo_attivita text,
	codice_interno_piano int4,
	codice_interno_attivita int4,
	alias_piano text,
	alias_attivita text,
	codice_alias_attivita text
	);

	drop table if exists matrix.dpat_indicatore_new; 
	create table matrix.dpat_indicatore_new  as
	select * from dblink('host=127.0.0.1 user=postgres dbname=gisa',
	'select *  from public.dpat_indicatore_new where anno = 2019 and stato != 1 and data_scadenza is null')  AS remote
	(
	id bigint,
	cod_raggruppamento bigint,
	id_piano_attivita int4 ,
	anno int4  ,
	descrizione text ,
	ordinamento int4  ,
	data_scadenza timestamp ,
	stato int4  ,
	codice_esame text ,
	tipo_attivita text ,
	codice_interno_indicatore int4 ,
	alias_indicatore text ,
	codice_interno_piani_gestione_cu int4 ,
	codice_interno_attivita_gestione_cu text ,
	codice_interno_univoco_tipo_attivita_gestione_cu text ,
	codice_alias_indicatore text ,
	extra_gisa bool 
	);

	truncate table matrix.struttura_piani;

	/*drop table if exists matrix.struttura_piani;
	create table matrix.struttura_piani (
		id bigint NOT NULL,
		cod_raggruppamento bigint,
		anno int4  NULL,
		descrizione text NULL,
		ordinamento int4  NULL,
		data_scadenza timestamp NULL,
		stato int4  NULL,
		codice_interno int4 NULL,
		color varchar(100) null,
		path text,
		livello bigint,
		parent bigint,
		alias text null,
		path_ord text
	);*/



	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato, ordinamento, path_ord )values(-1, 'TOTALE', 'TOTALE', 0, null, 2019, 2, 0, '000');
--	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-2, 'PIANO', 'TOTALE-PIANO', 1, -1, 2019, 2, 0, '000-000');
--	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-3, 'ATTIVITA', 'TOTALE-ATTIVITA', 1, -1, 2019, 2, 1, '000-001');
	
	insert into matrix.struttura_piani (
	select distinct s.id, s.cod_raggruppamento, 2019, s.descrizione, s.ordinamento, s.data_scadenza, s.stato, s.codice_interno, s.color, sp.path||'-'||s.descrizione, 1,  sp.id, null, sp.path_ord||'-'||lpad(s.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.descrizione::text = 'TOTALE'
	where i.anno = 2019 and p.anno = 2019 and s.anno = 2019 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);
	

	update matrix.struttura_piani set ordinamento = '0' , path_ord = '000-000'  where livello = 1 and path = 'TOTALE-SEZIONE A';
	update matrix.struttura_piani set ordinamento = '1' , path_ord = '000-001'  where livello = 1 and path = 'TOTALE-SEZIONE B';
	update matrix.struttura_piani set ordinamento = '2' , path_ord = '000-002'  where livello = 1 and path = 'TOTALE-SEZIONE C';
	update matrix.struttura_piani set ordinamento = '3' , path_ord = '000-003'  where livello = 1 and path = 'TOTALE-SEZIONE D';


	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-2, 'PIANO', 'TOTALE-SEZIONE A-PIANO', 2, 77, 2019, 2, 0, '000-000-000');
	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-3, 'ATTIVITA', 'TOTALE-SEZIONE A-ATTIVITA', 2, 77, 2019, 2, 1, '000-000-001');
	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-4, 'PIANO', 'TOTALE-SEZIONE B-PIANO', 2, 78, 2019, 2, 0, '000-001-000');
	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-5, 'ATTIVITA', 'TOTALE-SEZIONE B-ATTIVITA', 2, 78, 2019, 2, 1, '000-001-001');
	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-6, 'PIANO', 'TOTALE-SEZIONE C-PIANO', 2, 79, 2019, 2, 0, '000-002-000');
	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-7, 'ATTIVITA', 'TOTALE-SEZIONE C-ATTIVITA', 2, 79, 2019, 2, 1, '000-002-001');
	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-8, 'PIANO', 'TOTALE-SEZIONE D-PIANO', 2, 80, 2019, 2, 0, '000-003-000');
	insert into matrix.struttura_piani (id, descrizione, path, livello, parent, anno, stato , ordinamento, path_ord )values(-9, 'ATTIVITA', 'TOTALE-SEZIONE D-ATTIVITA', 2, 80, 2019, 2, 1, '000-003-001');
	

	/*update matrix.struttura_piani set ordinamento = '0', path_ord = '000-000-000'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE A';
	update matrix.struttura_piani set ordinamento = '1', path_ord = '000-000-001'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE B';
	update matrix.struttura_piani set ordinamento = '2' , path_ord = '000-000-002'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE C';
	update matrix.struttura_piani set ordinamento = '3' , path_ord = '000-000-003'  where livello = 2 and path = 'TOTALE-PIANO-SEZIONE D';

	update matrix.struttura_piani set ordinamento = '0' , path_ord = '000-001-000'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE A';
	update matrix.struttura_piani set ordinamento = '1' , path_ord = '000-001-001'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE B';
	update matrix.struttura_piani set ordinamento = '2' , path_ord = '000-001-002'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE C';
	update matrix.struttura_piani set ordinamento = '3' , path_ord = '000-001-003'  where livello = 2 and path = 'TOTALE-ATTIVITA-SEZIONE D';*/

	insert into matrix.struttura_piani (
	select distinct p.id, p.cod_raggruppamento, 2019, p.descrizione, p.ordinamento, p.data_scadenza, p.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 3,  sp.id, p.alias_piano, sp.path_ord||'-'||lpad(p.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.id = case when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'A' then -2
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'A' then -3
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'B' then -4
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'B' then -5
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'C' then -6
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'C' then -7
												   when p.tipo_attivita = 'PIANO' and right(UPPER(s.descrizione),1) = 'D' then -8
												   when substring(p.tipo_attivita from 1 for 8) = 'ATTIVITA' and right(UPPER(s.descrizione),1) = 'D' then -9
												   END
	where i.anno = 2019 and p.anno = 2019 and s.anno = 2019 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);
	
	insert into matrix.struttura_piani (
	select distinct i.id, i.cod_raggruppamento, 2019, i.descrizione, i.ordinamento,i.data_scadenza, i.stato, s.codice_interno, s.color, sp.path||'-'||p.descrizione, 4,  sp.id, i.alias_indicatore,sp.path_ord||'-'||lpad(i.ordinamento::text,'3','0') 
	from matrix.dpat_sez_new s join matrix.dpat_piano_attivita_new p on s.id = p.id_sezione join matrix.dpat_indicatore_new i on p.id = i.id_piano_attivita 
	join matrix.struttura_piani sp on sp.id = i.id_piano_attivita
	where i.anno = 2019 and p.anno = 2019 and s.anno = 2019 
	and i.stato != 1 and s.stato != 1 and p.stato !=1 and s.data_scadenza is null and p.data_scadenza is null and i.data_scadenza is null);

--	alter table matrix.struttura_piani add column id_formula_ups bigint;
--	alter table matrix.struttura_piani add column id_formula_uba bigint;

--	alter table matrix.struttura_piani add column fattore_ups real;
--	alter table matrix.struttura_piani add column fattore_uba real;

	
	return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_piano_ordinamento_new() OWNER TO postgres;

--
-- Name: create_struttura_piano_target(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_struttura_piano_target() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin

CREATE TABLE IF NOT EXISTS IF NOT EXISTS matrix.struttura_piano_target (
	id int4 NOT NULL GENERATED ALWAYS AS IDENTITY,
	id_struttura int4 NULL,
	id_piano int4 NULL,
	target float4 NULL,
	valore float4 NULL,
	ups_impegnati float4 NULL,
	uba_impegnati float4 NULL,
	ups_target float4 NULL,
	uba_target float4 NULL,
	CONSTRAINT struttura_piano_target_un UNIQUE (id_struttura, id_piano)
);

return 1;
end;
$$;


ALTER FUNCTION matrix.create_struttura_piano_target() OWNER TO postgres;

--
-- Name: create_view_consuntivati(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.create_view_consuntivati() RETURNS integer
    LANGUAGE plpgsql
    AS $$
 begin
 create or replace view  "Analisi_dev".vw_conteggio_cu_grouped as
 SELECT count(v.id_controllo) AS effettuati,
    p.id AS id_indicatore,
    a.id::integer AS id_struttura_uo
   FROM "ra".vw_gisa_controlli_ufficiali v
     JOIN matrix.struttura_asl a ON a.id_gisa = v.id_unita_operativa and extract(year from v.data_inizio_controllo) = a.anno 
     JOIN matrix.struttura_piani p ON p.id_gisa = v.id_motivo and extract(year from v.data_inizio_controllo) = p.anno 
  GROUP BY a.id, p.id;
  
   	 CREATE OR REPLACE VIEW matrix.vw_struttura_piano_consuntivati_tree
	AS SELECT a.id_node_ref::int AS id_struttura,
	    pp.descrizione,
	    d.id_node_ref,
	    u.path_ord,
	    sum(t.effettuati) AS sum,
	    sum(t.effettuati::double precision * p.fattore_ups) AS effettuati_ups
	   FROM "Analisi_dev".vw_conteggio_cu_grouped t
	     JOIN matrix.vw_tree_nodes_down d ON t.id_indicatore = d.id_node
	     JOIN matrix.vw_struttura_piani p ON d.id_node = p.id
	     JOIN matrix.vw_struttura_piani pp ON d.id_node_ref = pp.id
	     JOIN matrix.vw_tree_nodes_up_piani u ON u.id_node = pp.id
	     join matrix.vw_tree_nodes_down_asl a on a.id_node = t.id_struttura_uo 
	  GROUP by a.id_node_ref, pp.descrizione, d.id_node_ref, u.path_ord
	  ORDER BY u.path_ord;
	  
	  	CREATE OR REPLACE VIEW "Analisi_dev".vw_monitoraggio as
	   select c.id_struttura, c.id_node_ref 
	 ,c.sum as effettuati, t.sum as target, c.effettuati_ups, t.target_ups , t.target_uba , i.sum as impegnati, i.target_ups as impengati_ups,
	 i.target_uba as impegnati_uba, 
	 a.*  
	from matrix.vw_struttura_piano_consuntivati_tree c 
	left join matrix.vw_struttura_piano_target_tree t on c.id_node_ref = t.id_node_ref and c.id_struttura = t.id_struttura 
	left join matrix.vw_struttura_piano_impegnato_tree i on c.id_node_ref = i.id_node_ref and t.id_struttura = i.id_struttura 
	join matrix.struttura_asl a on a.id = c.id_struttura;
	
	
	create or replace view  matrix.vw_consuntivati_fuori_piano_struttura AS
	 SELECT 
	 p.id_unita_operativa,
	    CASE
	        WHEN a.id_gisa IS NULL AND pi.id_gisa IS null and c.id_controllo < 10000000 then - 100000000
	        WHEN a.id_gisa IS NULL AND pi.id_gisa IS null then - 10000000
	        WHEN pi.id_gisa IS NULL THEN p.id_unita_operativa * -100000
	        else m.id_motivo * -1
	    END AS id_piano,
	    CASE
	        WHEN a.id_gisa IS NULL AND pi.id_gisa IS null and c.id_controllo < 10000000 THEN 'FORZE ORDINE (id < 10M)'
	        WHEN a.id_gisa IS NULL AND pi.id_gisa IS NULL THEN 'FORZE ORDINE' 
	        WHEN pi.id_gisa IS NULL THEN ('PIANO NON PRESENTE |'|| COALESCE(m.id_motivo::text, '') || ' | ' || coalesce(a.descrizione_breve,''))
	        ELSE ('UO NON PRESENTE |'|| COALESCE(p.id_unita_operativa::text, '') || ' | ' || coalesce(pi.descrizione_breve, '' ))
	    END AS descr_p,
	    'white' as color,
	     CASE
	        WHEN a.id_gisa IS NULL AND pi.id_gisa IS NULL THEN '999'::text
	        WHEN pi.id_gisa IS NULL THEN '998'::text
	        ELSE '997'
	    end as path,
	    null::float as target, null::float as distribuiti,
	    count(c.id_controllo) as effettuati,
	    null::float as da_fare, null::float as perc, 0 as livello,
	    '',
	    EXTRACT(year FROM c.data_inizio_controllo)::int as anno,
	   COALESCE(a.descrizione_breve, ('NON ASL'::character varying::text || p.id_unita_operativa)::character varying) AS descr_a
	   from "Analisi_dev".vw_get_controlli_ispezioni_semplici_validi c 
	   left join (select *,  COALESCE(NULLIF(id_piano, '-1'::integer), id_motivo_ispezione) as id_motivo from "Analisi_dev".vw_get_controlli_ispezioni_semplici_motivi_validi) m on m.id_controllo = c.id_controllo 
	   left join "Analisi_dev".vw_get_controlli_ispezioni_semplici_percontodi_validi p on p.id_controllo = c.id_controllo 
	   left join matrix.struttura_asl a on a.id_gisa = p.id_unita_operativa 
	   left join matrix.struttura_piani pi on pi.id_gisa  = m.id_motivo
	   where (p.id_unita_operativa is null or m.id_motivo is null) 
	   GROUP by 1,2,3,4,5,6,7,9,10,11,12,13,14;
	   
	  return 1;
	 end; $$;


ALTER FUNCTION matrix.create_view_consuntivati() OWNER TO postgres;

--
-- Name: createtables_matrix(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.createtables_matrix() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare 
 conn record;
begin

	SELECT dblink_connect('host=127.0.0.1 user=postgres dbname=digemon_u') into conn;
	
	SELECT dblink('
	create table dbi_get_strumento_calcolo as
	select * from dblink(''host=10.1.15.6 user=postgres dbname=gisa'',
	''select * from public_functions.dbi_get_strumento_calcolo(2019)'')   AS remote
	(cammino text, livello integer, anno integer, id_asl integer, descrizione_asl text, id_struttura integer, tipo_struttura text, 
descrizione_struttura text, qualifica text, nominativo text, codice_fiscale_nominativo text, telefono_nominativo text, mail_nominativo text, 
carico_lavoro_annuale_nominativo integer, fattori_incidenti_su_carico_nominativo text, carico_lavoro_effettivo_annuale_nominativo integer, 
percentuale_ui_da_sottrarre_nominativo integer, carico_lavoro_annuo integer, fattori_incidenti_su_carico text, percentuale_da_sottrarre integer, 
carico_lavoro_effettivo integer, livello_qual integer);')into conn;

SELECT dblink_connect('host=127.0.0.1 user=postgres dbname=digemon_u') into conn;
	
	SELECT dblink('
	create table dbi_monitoraggio_get_lista_piani as
	select * from dblink(''host=10.1.15.6 user=postgres dbname=gisa'',
	''select * from public_functions.dbi_monitoraggio_get_lista_piani()'')   AS remote
	(code integer, description text, level integer, id_sezione_dpat integer, id_sezione integer, 
id_padre integer, enabled boolean, codice_esame text, ordinamento integer, ordinamento_figli integer, 
anno integer, codice_interno_ind integer, codice_interno_univoco text);')into conn;

	SELECT dblink_connect('host=127.0.0.1 user=postgres dbname=digemon_u') into conn;
	
	SELECT dblink('
	create table dbi_monitoraggio_get_strutture_oia_nodo as
	select * from dblink(''host=10.1.15.6 user=postgres dbname=gisa'',
	''select * from public_functions.dbi_monitoraggio_get_strutture_oia_nodo() where anno= 2019 and enabled'')   AS remote
	(id integer, id_padre integer, id_asl integer, nome text, descrizione_lunga text, n_livello integer, id_utente integer, 
entered timestamp without time zone, entered_by integer, modified timestamp without time zone, modified_by integer, trashed_date timestamp without time zone, 
tipologia_struttura integer, mail text, comune text, indirizzo text, delegato integer, descrizione_comune text, enabled boolean,
 descrizione_area_struttura  text, codice_interno_univoco integer, anno integer );')into conn; 

SELECT dblink_connect('host=127.0.0.1 user=postgres dbname=digemon_u') into conn;
	
	SELECT dblink('
	create table dbi_get_sezioni as
	select * from dblink(''host=10.1.15.6 user=postgres dbname=gisa'',
	''select * from public_functions.dbi_get_sezioni(2019)'')   AS remote
	( id    integer     ,
 cod_raggruppamento  integer                     ,
 anno                integer                     ,
 descrizione         text                        ,
 ordinamento         integer                     ,
 data_scadenza       timestamp without time zone ,
 stato               integer                     ,
 codice_interno      integer );')into conn;


SELECT dblink_connect('host=127.0.0.1 user=postgres dbname=digemon_u') into conn;
	
	SELECT dblink('
	create table dbi_get_attivita as
	select * from dblink(''host=10.1.15.6 user=postgres dbname=gisa'',
	''select * from public_functions.dbi_get_attivita(2019)'')   AS remote
	(anno 
integer, sezione_dpat text, id_sezione integer, nome_attivita_dpat text, 
id_attivita_dpat integer, attivita_dpat text, id_indicatore integer, 
indicatore_dpat text, id_motivo_ispezione_cu integer, 
motivo_ispezione_cu character varying, codice_esame text, disabilitato 
boolean, codice_interno_univoco text);')into conn;



	RETURN 1;
END; 

$$;


ALTER FUNCTION matrix.createtables_matrix() OWNER TO postgres;

--
-- Name: descrizioni_brevi(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.descrizioni_brevi() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
update matrix.struttura_piani set descrizione_breve = upper(descrizione);
update matrix.struttura_piani set descrizione_breve = replace(upper(descrizione),'PIANO  DI MONIOTORAGGIO', 'P.M.') where upper(descrizione) like '%PIANO  DI MONIOTORAGGIO%';
update matrix.struttura_piani set descrizione_breve = replace(upper(descrizione),'PIANO DI MONIOTORAGGIO', 'P.M.') where upper(descrizione) like '%PIANO DI MONIOTORAGGIO%';
update matrix.struttura_piani set descrizione_breve = replace(upper(descrizione),'PIANO DI MONITORAGGIO', 'P.M.') where upper(descrizione) like '%PIANO DI MONITORAGGIO%';
update matrix.struttura_piani set descrizione_breve = replace(upper(descrizione),'ATTIVITA', 'ATT.') where LIVELLO != 2 and upper(descrizione) like '%ATTIVITA%';
update matrix.struttura_piani set descrizione_breve = replace(upper(descrizione),'ATTIVIT ', 'ATT. ') where upper(descrizione) like '%ATTIVIT %';
update matrix.struttura_piani set descrizione_breve = replace(upper(descrizione),'ISPEZIONI ', 'ISP. ') where upper(descrizione) like 'ISPEZIONI%';

update matrix.struttura_asl set descrizione_breve = upper(descrizione);
update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione),'UNITA'' OPERATIVA SEMPLICE DIPARTIMENTALE', 'UOSD') where upper(descrizione) like 'UNITA'' OPERATIVA SEMPLICE DIPARTIMENTALE%';
update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione),'UNITA'' OPERATIVA COMPLESSA', 'UOC') where upper(descrizione) like 'UNITA'' OPERATIVA COMPLESSA%';
update matrix.struttura_asl set descrizione_breve = replace(upper(descrizione),'DIPARTIMENTO DI PREVENZIONE', 'D.D.P.') where upper(descrizione) like 'DIPARTIMENTO DI PREVENZIONE%';
return 1;
end;
$$;


ALTER FUNCTION matrix.descrizioni_brevi() OWNER TO postgres;

--
-- Name: get_consuntivati_per_piano(bigint, boolean); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.get_consuntivati_per_piano(_id_struttura bigint, get_all_consuntivati boolean DEFAULT false) RETURNS TABLE(id_struttura integer, id_piano bigint, descr_p text, color character varying, path_ord character varying, target double precision, distribuiti double precision, effettuati numeric, da_fare double precision, perc double precision, livello bigint, path text, anno integer, descr_a text, id_asl bigint)
    LANGUAGE plpgsql
    AS $$
declare 
is_regione boolean;
rec record;
anno int;
str text;
where_condition text;
begin
	str = '';
	where_condition = '';
	if get_all_consuntivati = false then 
		where_condition = 'where id_Struttura = '|| _id_struttura ||'';
	end if;
	
	is_regione = false;
	for rec in select * from matrix.struttura_asl where id = _id_struttura limit 1 loop 
		anno = rec.anno;
		if(rec.n_livello < 1) then
			is_regione = true;
		end if;
	end loop;

	if is_regione = true then
		str = 'select * from (
				select * from  matrix.vw_consuntivati_per_piano
				'|| where_condition ||'
				UNION
				select *  from matrix.vw_consuntivati_fuori_piano_struttura
				where anno = '|| rec.anno ||'
				)a order by path_ord, id_piano';
	else 
		str = 'select * from (
				select * from  matrix.vw_consuntivati_per_piano
				'|| where_condition ||'
				)a order by path_ord, id_piano';
	end if;
	
	RETURN QUERY execute str;
END; $$;


ALTER FUNCTION matrix.get_consuntivati_per_piano(_id_struttura bigint, get_all_consuntivati boolean) OWNER TO postgres;

--
-- Name: get_utente_info(bigint); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.get_utente_info(idutente bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare
	j_user_info json;
begin
	select row_to_json(a.*) into j_user_info from
		(select u.*,a.n_livello, 
		a.descrizione_breve as descr_struttura_root,
		ns.id as id_nominativo_struttura
		from public.get_utente_info_from_gisa(idutente) u
			left join matrix.vw_tree_nodes_up_asl a on a.id_node=u.id_struttura_root 
			left join matrix.vw_nominativi_struttura ns on ns.id_anagrafica = idutente and ns.id_struttura = u.id_struttura_root
		order by n_livello limit 1) a;
	return j_user_info;
end;
end
$$;


ALTER FUNCTION matrix.get_utente_info(idutente bigint) OWNER TO postgres;

--
-- Name: init_struttura_piano_target(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.init_struttura_piano_target() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
delete from struttura_piano_target;

insert into struttura_piano_target overriding system VALUE
select nextval('struttura_piano_target_id_seq'),1,id_struttura_piani,av from JoinGisaDPAR union
select nextval('struttura_piano_target_id_seq'),2,id_struttura_piani,bn from JoinGisaDPAR union
select nextval('struttura_piano_target_id_seq'),3,id_struttura_piani,ca from JoinGisaDPAR union
select nextval('struttura_piano_target_id_seq'),4,id_struttura_piani,n1 from JoinGisaDPAR union
select nextval('struttura_piano_target_id_seq'),5,id_struttura_piani,n2 from JoinGisaDPAR union
select nextval('struttura_piano_target_id_seq'),6,id_struttura_piani,n3 from JoinGisaDPAR union
select nextval('struttura_piano_target_id_seq'),7,id_struttura_piani,sa from JoinGisaDPAR;

insert into struttura_piano_target overriding system VALUE
select nextval('struttura_piano_target_id_seq'),8,b,c from (select id_piano b,sum(target) c from struttura_piano_target group by 1 ) z;
return 0;
end;
$$;


ALTER FUNCTION matrix.init_struttura_piano_target() OWNER TO postgres;

--
-- Name: update_matrix(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.update_matrix() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	
	perform matrix.create_struttura_asl_test2();
	perform matrix.create_struttura_piani_test2();
	perform matrix.create_nominativi();
	perform matrix.update_matrix_history();
	return 1;
end;

$$;


ALTER FUNCTION matrix.update_matrix() OWNER TO postgres;

--
-- Name: update_matrix_history(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.update_matrix_history() RETURNS bigint
    LANGUAGE plpgsql
    AS $$ DECLARE
							rec record;
							curs_struttura_piani_test CURSOR FOR 
								select count(*),max(rowid) as rowid,max(f),min(f),row(rng, id,id_gisa,anno,descrizione,ordinamento,data_scadenza,stato,codice_interno,color,path,livello,parent,alias,path_ord,id_formula_ups,id_formula_uba,descrizione_breve) as r 
								from
								(select ctid as rowid, 'm' as f, int8range((SELECT last_value FROM "Analisi_dev".vers_seq), null ) as rng, id,id_gisa,anno,descrizione,ordinamento,data_scadenza,stato,codice_interno,color,path,livello,parent,alias,path_ord,id_formula_ups,id_formula_uba,descrizione_breve
								from matrix.struttura_piani_test_h m where upper(rng) is null
								union
								select null as rowid,'v' as f, int8range((SELECT last_value FROM "Analisi_dev".vers_seq), null ) as rng, id,id_gisa,anno,descrizione,ordinamento,data_scadenza,stato,codice_interno,color,path,livello,parent,alias,path_ord,id_formula_ups,id_formula_uba,descrizione_breve
								from matrix.vw_struttura_piani_test_h vw) s
								group by id,id_gisa,anno,descrizione,ordinamento,data_scadenza,stato,codice_interno,color,path,livello,parent,alias,path_ord,id_formula_ups,id_formula_uba,descrizione_breve, rng
								order by count(*);

							rec_struttura_piani_test  matrix.struttura_piani_test_h%ROWTYPE; 
						
							curs_struttura_asl_test CURSOR FOR 
								select count(*),max(rowid) as rowid,max(f),min(f),row(rng, id,id_gisa,id_padre,id_asl,descrizione,n_livello,descrizione_breve) as r 
								from
								(select ctid as rowid, 'm' as f, int8range((SELECT last_value FROM "Analisi_dev".vers_seq), null ) as rng, id,id_gisa,id_padre,id_asl,descrizione,n_livello,descrizione_breve
								from matrix.struttura_asl_test_h m where upper(rng) is null
								union
								select null as rowid,'v' as f, int8range((SELECT last_value FROM "Analisi_dev".vers_seq), null ) as rng, id,id_gisa,id_padre,id_asl,descrizione,n_livello,descrizione_breve
								from matrix.vw_struttura_asl_test_h vw) s
								group by id,id_gisa,id_padre,id_asl,descrizione,n_livello,descrizione_breve, rng
								order by count(*);

							rec_struttura_asl_test  matrix.struttura_asl_test_h%ROWTYPE; 
						
							curs_struttura_piano_target CURSOR FOR 
								select count(*),max(rowid) as rowid,max(f),min(f),row(rng, id,id_struttura,id_piano,target,valore,ups_impegnati,uba_impegnati,ups_target,uba_target) as r 
								from
								(select ctid as rowid, 'm' as f, int8range((SELECT last_value FROM "Analisi_dev".vers_seq), null ) as rng, id,id_struttura,id_piano,target,valore,ups_impegnati,uba_impegnati,ups_target,uba_target
								from matrix.struttura_piano_target_h m where upper(rng) is null
								union
								select null as rowid,'v' as f, int8range((SELECT last_value FROM "Analisi_dev".vers_seq), null ) as rng, id,id_struttura,id_piano,target,valore,ups_impegnati,uba_impegnati,ups_target,uba_target
								from matrix.vw_struttura_piano_target_h vw) s
								group by id,id_struttura,id_piano,target,valore,ups_impegnati,uba_impegnati,ups_target,uba_target, rng
								order by count(*);

							rec_struttura_piano_target  matrix.struttura_piano_target_h%ROWTYPE; 
						
							curs_mod4_nominativi CURSOR FOR 
								select count(*),max(rowid) as rowid,max(f),min(f),row(rng, id,id_nominativo_struttura,livello_formativo,carico_annuale,perc_sottr,perc_sottr2,fattore1,fattore2,fattore3,uba_ora,fattori_text,ups,uba) as r 
								from
								(select ctid as rowid, 'm' as f, int8range((SELECT last_value FROM "Analisi_dev".vers_seq), null ) as rng, id,id_nominativo_struttura,livello_formativo,carico_annuale,perc_sottr,perc_sottr2,fattore1,fattore2,fattore3,uba_ora,fattori_text,ups,uba
								from matrix.mod4_nominativi_h m where upper(rng) is null
								union
								select null as rowid,'v' as f, int8range((SELECT last_value FROM "Analisi_dev".vers_seq), null ) as rng, id,id_nominativo_struttura,livello_formativo,carico_annuale,perc_sottr,perc_sottr2,fattore1,fattore2,fattore3,uba_ora,fattori_text,ups,uba
								from matrix.vw_mod4_nominativi_h vw) s
								group by id,id_nominativo_struttura,livello_formativo,carico_annuale,perc_sottr,perc_sottr2,fattore1,fattore2,fattore3,uba_ora,fattori_text,ups,uba, rng
								order by count(*);

							rec_mod4_nominativi  matrix.mod4_nominativi_h%ROWTYPE; 
						
							curs_mod4_strutture CURSOR FOR 
								select count(*),max(rowid) as rowid,max(f),min(f),row(rng, id,id_struttura,sottr,fattore1,fattore2,ups,uba) as r 
								from
								(select ctid as rowid, 'm' as f, int8range((SELECT last_value FROM "Analisi_dev".vers_seq), null ) as rng, id,id_struttura,sottr,fattore1,fattore2,ups,uba
								from matrix.mod4_strutture_h m where upper(rng) is null
								union
								select null as rowid,'v' as f, int8range((SELECT last_value FROM "Analisi_dev".vers_seq), null ) as rng, id,id_struttura,sottr,fattore1,fattore2,ups,uba
								from matrix.vw_mod4_strutture_h vw) s
								group by id,id_struttura,sottr,fattore1,fattore2,ups,uba, rng
								order by count(*);

							rec_mod4_strutture  matrix.mod4_strutture_h%ROWTYPE; 
						
							curs_formule CURSOR FOR 
								select count(*),max(rowid) as rowid,max(f),min(f),row(rng, id,descrizione,testo,contiene_uba,valida_ups,valida_uba,fattore_fin) as r 
								from
								(select ctid as rowid, 'm' as f, int8range((SELECT last_value FROM "Analisi_dev".vers_seq), null ) as rng, id,descrizione,testo,contiene_uba,valida_ups,valida_uba,fattore_fin
								from matrix.formule_h m where upper(rng) is null
								union
								select null as rowid,'v' as f, int8range((SELECT last_value FROM "Analisi_dev".vers_seq), null ) as rng, id,descrizione,testo,contiene_uba,valida_ups,valida_uba,fattore_fin
								from matrix.vw_formule_h vw) s
								group by id,descrizione,testo,contiene_uba,valida_ups,valida_uba,fattore_fin, rng
								order by count(*);

							rec_formule  matrix.formule_h%ROWTYPE; 
						
							curs_nominativi CURSOR FOR 
								select count(*),max(rowid) as rowid,max(f),min(f),row(rng, id,id_nominativo_gisa,id_anagrafica,nominativo,codice_fiscale,qualifica) as r 
								from
								(select ctid as rowid, 'm' as f, int8range((SELECT last_value FROM "Analisi_dev".vers_seq), null ) as rng, id,id_nominativo_gisa,id_anagrafica,nominativo,codice_fiscale,qualifica
								from matrix.nominativi_h m where upper(rng) is null
								union
								select null as rowid,'v' as f, int8range((SELECT last_value FROM "Analisi_dev".vers_seq), null ) as rng, id,id_nominativo_gisa,id_anagrafica,nominativo,codice_fiscale,qualifica
								from matrix.vw_nominativi_h vw) s
								group by id,id_nominativo_gisa,id_anagrafica,nominativo,codice_fiscale,qualifica, rng
								order by count(*);

							rec_nominativi  matrix.nominativi_h%ROWTYPE; 
						begin 
			set search_path to matrix;
		
							open curs_struttura_piani_test;
							loop
								fetch curs_struttura_piani_test into rec;
								EXIT WHEN NOT FOUND;
								if rec.count <2 then
									if rec.max = 'm' then
										update matrix.struttura_piani_test_h m set rng = int8range(lower(rng), (SELECT last_value FROM "Analisi_dev".vers_seq))
										where m.ctid = rec.rowid;
									end if;
									if rec.min = 'v' then
										rec_struttura_piani_test = rec.r;
										insert into matrix.struttura_piani_test_h values (rec_struttura_piani_test.*);
									end if;
								end if;
							end loop;
						
							open curs_struttura_asl_test;
							loop
								fetch curs_struttura_asl_test into rec;
								EXIT WHEN NOT FOUND;
								if rec.count <2 then
									if rec.max = 'm' then
										update matrix.struttura_asl_test_h m set rng = int8range(lower(rng), (SELECT last_value FROM "Analisi_dev".vers_seq))
										where m.ctid = rec.rowid;
									end if;
									if rec.min = 'v' then
										rec_struttura_asl_test = rec.r;
										insert into matrix.struttura_asl_test_h values (rec_struttura_asl_test.*);
									end if;
								end if;
							end loop;
						
							open curs_struttura_piano_target;
							loop
								fetch curs_struttura_piano_target into rec;
								EXIT WHEN NOT FOUND;
								if rec.count <2 then
									if rec.max = 'm' then
										update matrix.struttura_piano_target_h m set rng = int8range(lower(rng), (SELECT last_value FROM "Analisi_dev".vers_seq))
										where m.ctid = rec.rowid;
									end if;
									if rec.min = 'v' then
										rec_struttura_piano_target = rec.r;
										insert into matrix.struttura_piano_target_h values (rec_struttura_piano_target.*);
									end if;
								end if;
							end loop;
						
							open curs_mod4_nominativi;
							loop
								fetch curs_mod4_nominativi into rec;
								EXIT WHEN NOT FOUND;
								if rec.count <2 then
									if rec.max = 'm' then
										update matrix.mod4_nominativi_h m set rng = int8range(lower(rng), (SELECT last_value FROM "Analisi_dev".vers_seq))
										where m.ctid = rec.rowid;
									end if;
									if rec.min = 'v' then
										rec_mod4_nominativi = rec.r;
										insert into matrix.mod4_nominativi_h values (rec_mod4_nominativi.*);
									end if;
								end if;
							end loop;
						
							open curs_mod4_strutture;
							loop
								fetch curs_mod4_strutture into rec;
								EXIT WHEN NOT FOUND;
								if rec.count <2 then
									if rec.max = 'm' then
										update matrix.mod4_strutture_h m set rng = int8range(lower(rng), (SELECT last_value FROM "Analisi_dev".vers_seq))
										where m.ctid = rec.rowid;
									end if;
									if rec.min = 'v' then
										rec_mod4_strutture = rec.r;
										insert into matrix.mod4_strutture_h values (rec_mod4_strutture.*);
									end if;
								end if;
							end loop;
						
							open curs_formule;
							loop
								fetch curs_formule into rec;
								EXIT WHEN NOT FOUND;
								if rec.count <2 then
									if rec.max = 'm' then
										update matrix.formule_h m set rng = int8range(lower(rng), (SELECT last_value FROM "Analisi_dev".vers_seq))
										where m.ctid = rec.rowid;
									end if;
									if rec.min = 'v' then
										rec_formule = rec.r;
										insert into matrix.formule_h values (rec_formule.*);
									end if;
								end if;
							end loop;
						
							open curs_nominativi;
							loop
								fetch curs_nominativi into rec;
								EXIT WHEN NOT FOUND;
								if rec.count <2 then
									if rec.max = 'm' then
										update matrix.nominativi_h m set rng = int8range(lower(rng), (SELECT last_value FROM "Analisi_dev".vers_seq))
										where m.ctid = rec.rowid;
									end if;
									if rec.min = 'v' then
										rec_nominativi = rec.r;
										insert into matrix.nominativi_h values (rec_nominativi.*);
									end if;
								end if;
							end loop;
						 
				drop view if exists matrix_h.struttura_piani_test cascade;
				create view matrix_h.struttura_piani_test as select * from matrix_h.struttura_piani_test_h h join matrix_h.current_version v on 	 h.rng @> v.v;
		 
				drop view if exists matrix_h.struttura_asl_test cascade;
				create view matrix_h.struttura_asl_test as select * from matrix_h.struttura_asl_test_h h join matrix_h.current_version v on 	 h.rng @> v.v;
		 
				drop view if exists matrix_h.struttura_piano_target cascade;
				create view matrix_h.struttura_piano_target as select * from matrix_h.struttura_piano_target_h h join matrix_h.current_version v on 	 h.rng @> v.v;
		 
				drop view if exists matrix_h.mod4_nominativi cascade;
				create view matrix_h.mod4_nominativi as select * from matrix_h.mod4_nominativi_h h join matrix_h.current_version v on 	 h.rng @> v.v;
		 
				drop view if exists matrix_h.mod4_strutture cascade;
				create view matrix_h.mod4_strutture as select * from matrix_h.mod4_strutture_h h join matrix_h.current_version v on 	 h.rng @> v.v;
		 
				drop view if exists matrix_h.formule cascade;
				create view matrix_h.formule as select * from matrix_h.formule_h h join matrix_h.current_version v on 	 h.rng @> v.v;
		 
				drop view if exists matrix_h.nominativi cascade;
				create view matrix_h.nominativi as select * from matrix_h.nominativi_h h join matrix_h.current_version v on 	 h.rng @> v.v;
		 return 1;
					end;
					$$;


ALTER FUNCTION matrix.update_matrix_history() OWNER TO postgres;

--
-- Name: update_valori(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.update_valori() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare
	r record;
	r2 record;
begin
	update matrix.struttura_asl set ups = 0, uba = 0;
	for r in select * from matrix.vw_join_alias_fogli loop
		update matrix.struttura_asl set ups = case when r.carico_effettivo_uos_ups = '' or r.carico_effettivo_uos_ups is null then 0 else r.carico_effettivo_uos_ups::real end,
										uba = case when r.carico_effettivo_uos_uba = '' or r.carico_effettivo_uos_uba is null then 0 else r.carico_effettivo_uos_uba::real end
										where id = r.id_s::bigint;
	end loop;


	for r2 in
			with recursive struttura_asl_from_leafs as
			(
		      select a.id, a.ups, a.uba, a.id_padre, a.descrizione_breve
		      from matrix.struttura_asl a
		       where not exists (select  null from matrix.struttura_asl x where x.id_padre = a.id)
		   union all
		      select a.id, l.ups, l.uba, a.id_padre, a.descrizione_breve
		        from  struttura_asl_from_leafs l
		             join matrix.struttura_asl a on l.id_padre = a.id
		       where a.id is not null
			) select id, sum(ups) as ups, sum(uba) as uba
			from struttura_asl_from_leafs l  group by 1 
			loop 
			update matrix.struttura_asl set ups = r2.ups,
										uba = r2.uba
										where id = r2.id::bigint;
			end loop;
			 
	return 1;
end;
$$;


ALTER FUNCTION matrix.update_valori() OWNER TO postgres;

--
-- Name: update_valori_somme(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.update_valori_somme() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare
	r2 record;
begin


	for r2 in
			  with recursive struttura_asl_from_leafs as
				(
			      select a.id, a.ups, a.uba, a.p_id, a.descrizione_breve
			      from matrix.vw_tree_nodes_asl_descr a
			       where not exists (select  null from matrix.vw_tree_nodes_asl_descr x 
			 
			       							where x.p_id = a.id)
			   union all
			      select a.id, l.ups, l.uba, a.p_id, a.descrizione_breve
			        from  struttura_asl_from_leafs l
			             join matrix.vw_tree_nodes_asl_descr a on l.p_id = a.id
			       where a.id is not null
				) select id, sum(ups) as ups, sum(uba) as uba
				from struttura_asl_from_leafs l  group by 1 
			loop 
			update matrix.struttura_asl set ups = r2.ups,
										uba = r2.uba
										where id = r2.id::bigint;
			end loop;
			 
	return 1;
end;
$$;


ALTER FUNCTION matrix.update_valori_somme() OWNER TO postgres;

--
-- Name: update_valori_somme_old(); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.update_valori_somme_old() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare
	r2 record;
begin


	for r2 in
			with recursive struttura_asl_from_leafs as
			(
		      select a.id, a.ups, a.uba, a.id_padre, a.descrizione_breve
		      from matrix.struttura_asl a
		       where not exists (select  null from matrix.struttura_asl x where x.id_padre = a.id)
		   union all
		      select a.id, l.ups, l.uba, a.id_padre, a.descrizione_breve
		        from  struttura_asl_from_leafs l
		             join matrix.struttura_asl a on l.id_padre = a.id
		       where a.id is not null
			) select id, sum(ups) as ups, sum(uba) as uba
			from struttura_asl_from_leafs l  group by 1 
			loop 
			update matrix.struttura_asl set ups = r2.ups,
										uba = r2.uba
										where id = r2.id::bigint;
			end loop;
			 
	return 1;
end;
$$;


ALTER FUNCTION matrix.update_valori_somme_old() OWNER TO postgres;

--
-- Name: updateformula(bigint, text, text, boolean, boolean, boolean, double precision); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.updateformula(id_f bigint, descrizione_f text, testo_f text, contiene_uba_f boolean, valida_ups_f boolean, valida_uba_f boolean, fattore_fin_f double precision) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	if contiene_uba_f and valida_uba_f then
		return -1;
	end if;
	if id_f is null then
		insert into matrix.formule  
		(id,descrizione,testo,contiene_uba,valida_uba,valida_ups,fattore_fin ) values
				(nextval('matrix.oid_matrix'),descrizione_f,testo_f,contiene_uba_f,valida_uba_f,valida_ups_f,fattore_fin_f );
		return 0;
	end if;
	update matrix.formule set descrizione=descrizione_f,testo=testo_f,contiene_uba=contiene_uba_f,valida_uba=valida_uba_f,
						valida_ups=valida_ups_f,fattore_fin =fattore_fin_f  where id=id_f;
	--update matrix.struttura_piani set fattore_uba=fattore_fin_f where id_formula_uba=id_f;

	--update matrix.struttura_piani set fattore_ups=fattore_fin_f * (case when contiene_uba_f then fattore_uba else 1 end )
	--				where id_formula_uba=id_f;

	return 1;
end;
$$;


ALTER FUNCTION matrix.updateformula(id_f bigint, descrizione_f text, testo_f text, contiene_uba_f boolean, valida_ups_f boolean, valida_uba_f boolean, fattore_fin_f double precision) OWNER TO postgres;

--
-- Name: updatepianoformula(bigint, bigint, boolean, boolean); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.updatepianoformula(id_piano bigint, id_formula bigint, is_uba boolean, force boolean) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare 
 f_rec record;
 old_f_rec record;
 u_rec record;
begin

	select * into f_rec from matrix.formule where id= id_formula;
	if f_rec.id is null then return -1; end if;
	if is_uba and not f_rec.valida_uba then return -2; end if;
	if not is_uba and not f_rec.valida_ups then return -3; end if;
	select * into old_f_rec from matrix.struttura_piani where id= id_piano;
	if is_uba then

		update matrix.struttura_piani set id_formula_uba=id_formula where id in 
		
		(WITH RECURSIVE piani_upd as (
    		select id from matrix.struttura_piani where id=id_piano
    		UNION
    		select pf.id from matrix.vw_tree_nodes_piani_descr pf inner join piani_upd pp on pf.p_id=pp.id
    		join matrix.struttura_piani p on p.id = pf.id
    		where p.id_formula_uba=old_f_rec.id_formula_uba or force
		) SELECT id FROM piani_upd);
	 
	else	
		update matrix.struttura_piani set id_formula_ups=id_formula where id in 
		
		(WITH RECURSIVE piani_upd as (
    		select id from matrix.struttura_piani where id=id_piano
    		UNION
    		select pf.id from matrix.vw_tree_nodes_piani_descr pf inner join piani_upd pp on pf.p_id=pp.id
    		join matrix.struttura_piani p on p.id = pf.id
    		where p.id_formula_ups=old_f_rec.id_formula_ups or force
		) SELECT id FROM piani_upd);
	end if;

	return 1;
end;
$$;


ALTER FUNCTION matrix.updatepianoformula(id_piano bigint, id_formula bigint, is_uba boolean, force boolean) OWNER TO postgres;

--
-- Name: upsert_target(bigint, bigint, real, text); Type: FUNCTION; Schema: matrix; Owner: postgres
--

CREATE FUNCTION matrix.upsert_target(id_pia bigint, id_strutt bigint, val real, utente text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
declare 
r record;
  begin
						
		INSERT INTO matrix.STRUTTURA_PIANO_TARGET (id_piano, id_struttura, target)
		VALUES (id_pia, id_strutt, val)
		ON CONFLICT (id_piano, id_struttura) DO update set target = val;
	
		select count(*) as c, min(id) as id into r from matrix.vw_tree_nodes_asl_descr where p_id = id_strutt;
		insert into matrix.operation_log values (id_pia, id_strutt, val, utente, current_timestamp);	

		if r.c = 1 then
			INSERT INTO matrix.STRUTTURA_PIANO_TARGET (id_piano, id_struttura, target)
			VALUES (id_pia, r.id, val)
			ON CONFLICT (id_piano, id_struttura) DO update set target = val;
		
			insert into matrix.operation_log values (id_pia, r.id, val, utente, current_timestamp);	

		end if;
		return 1; 
  end;
 $$;


ALTER FUNCTION matrix.upsert_target(id_pia bigint, id_strutt bigint, val real, utente text) OWNER TO postgres;

--
-- Name: crea_master_list_allevamenti(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.crea_master_list_allevamenti() RETURNS integer
    LANGUAGE plpgsql
    AS $$
	declare
	begin
		create table public.master_list_allevamenti_full as
			select distinct sl.macroarea ,sl.aggregazione ,attivita,
				trim(split_part(aggregazione,'-',1)) specie, trim(split_part(aggregazione,'-',2)) tipo,
				coalesce(t.descrizione_gruppo_specie,aggregazione) gruppo_specie,
				case when attivita ='M' then 'MISTO' when attivita ='L' then 'LATTE' when attivita ='C' then 'CARNE' else attivita end att
			from matrix.stabilimenti_linee sl 
				left join (
					select * from public.dblink('dbname=bdn_fvg',
					'select * from bdn_types.vw_specie')
						t (id_specie int4,id int4,spe_id int4,istat int4,codice int4,descrizione varchar,dt_timerange varchar,
					ref_id int4,utente_id int4,id_gruppospecie int4,descrizione_gruppo_specie text)) t 
					on trim(split_part(sl.aggregazione,'-',1))=t.codice::varchar
			where riferimento_id_nome_tab ='organization';
		
create table public.master_list_allevamenti as select  -(row_number()  over ())*10 -3 from
(select distinct macroarea,gruppo_specie,att from public.mater_list_allevamenti_full mlaf) t;

create table public.ml_allevamenti_lev_1 as 
select -(row_number()  over ())*10 -1  id , null id_parent, macroarea descr from (
select distinct macroarea from public.master_list_allevamenti mla ) t;

create table public.ml_allevamenti_lev_2 as 
select -(row_number()  over ())*10 -2  id , id_parent,gruppo_specie descr from (
select distinct gruppo_specie,l1.id id_parent from public.master_list_allevamenti mla join public.ml_allevamenti_lev_1 l1 on l1.descr=mla.macroarea  ) t;

create table public.master_list_allevamenti as
select -row_number() over ()  id_attivita,* from (
select distinct macroarea, gruppo_specie,att from public.master_list_allevamenti_full) a;

CREATE OR REPLACE VIEW public.vw_master_list_allevamenti
AS SELECT master_list_allevamenti.id_attivita,
    master_list_allevamenti.macroarea,
    master_list_allevamenti.gruppo_specie,
    master_list_allevamenti.gruppo_specie || ' - ' || master_list_allevamenti.att att, l2.id as id_parent
   FROM master_list_allevamenti  join public.ml_allevamenti_lev_2 l2 on l2.descr = gruppo_specie;

create or replace view public.vw_master_list_allevamenti_full  as 
select mlaf.*,ml.id_attivita ,l2.id as id_parent
from public.master_list_allevamenti_full mlaf 
join public.ml_allevamenti_lev_2 l2 on l2.descr =mlaf.gruppo_specie 
join public.vw_master_list_allevamenti ml on
ml.macroarea=mlaf.macroarea and
ml.gruppo_specie = mlaf.gruppo_specie and
ml.att = mlaf.gruppo_specie || ' - ' || mlaf.att;
				
					return 0;
	end;
$$;


ALTER FUNCTION public.crea_master_list_allevamenti() OWNER TO postgres;

--
-- Name: get_utente_info_2(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_utente_info_2(_username text, _password text, _codice_fiscale text DEFAULT NULL::text) RETURNS TABLE(id_utente_struttura_ruolo bigint, nome text, ruolo text, id_ruolo bigint, id_utente bigint, username text, codice_interno_struttura bigint, id_asl integer, id_struttura_root bigint, responsabile boolean, livello integer, id_nominativo_struttura integer, "hideProfilassi" boolean)
    LANGUAGE plpgsql
    AS $$
begin
	return QUERY
	
	
select * from ( 
		select  
				usr.id_utente_struttura_ruolo,
				usr.nome||' '||usr.cognome::text,
				usr.ruolo_descr::text,
				usr.id_ruolo, 
				usr.id_utente, 
				_username::text as username,
				ns.codice_interno_fk::bigint as codice_interno_struttura,
				usr.id_asl::integer,
				usr.id_struttura::bigint as id_struttura_root, 
				usr.responsabile::boolean,
 				usr.livello::integer,
				ns.id::integer as id_nominativo_struttura,
				case when usr.cf in (select codice_fiscale
						from matrix.vw_nominativi
						where nominativo in (
						'ANDREA PERESSON',
						'MATTEO COLAUTTI',
						'ROBERTO LEVAN',
						'GIAMPAOLO BARACETTI',
						'MASSIMO ERARIO',
						'MARIA TERESA COLASANTO',
						'SILVIA CAPPETTA',
						'MARTA DAL CIN',
						'GIOVANNI SAITTA',
						'MARIA RITA MARAGONI',
						'ALICE MARTINI')) then false else true end as "hideProfilassi"
		from rbac.vw_utente_strutture us
		join rbac.vw_utente_strutture_ruoli usr on us.id_utente_struttura = usr.id_utente_struttura
		join matrix.vw_nominativi_struttura ns on ns.id_anagrafica  = usr.id_utente and ns.id_struttura = usr.id_struttura
		--where (us.username = 'Nardon Denis' and ( 'password' = md5('password') or 'password' = 'password') or md5('GISA-'||usr.cf)='f29ad894e877ef69822852d8fa3a4200')
		where ((_username = usr.cognome||' '||usr.nome::text and  _password = 'password') or md5('GISA-'||usr.cf)= _codice_fiscale)
		and validita @> localtimestamp

	) a 

;
END
$$;


ALTER FUNCTION public.get_utente_info_2(_username text, _password text, _codice_fiscale text) OWNER TO postgres;

--
-- Name: get_utente_info_3(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_utente_info_3(_idutentestrutturaruolo bigint) RETURNS TABLE(id_utente_struttura_ruolo bigint, id bigint, id_utente_struttura bigint, id_ruolo bigint, ruolo_sigla character varying, ruolo_descr character varying, id_utente bigint, nome character varying, cognome character varying, cf character varying, id_asl bigint, descrizione_breve text, id_struttura bigint, id_qualifica bigint, sigla_qualifica character varying, descr_qualifica character varying, responsabile boolean, livello bigint, "hideProfilassi" boolean)
    LANGUAGE plpgsql
    AS $$
begin
	return QUERY
	
	
select * from ( 
		select usr.id_utente_struttura_ruolo,
		usr.id,
		usr.id_utente_struttura,
		usr.id_ruolo,
		usr.ruolo_sigla,
		usr.ruolo_descr,
		usr.id_utente,
		usr.nome,
		usr.cognome,
		usr.cf,
		usr.id_asl,
		usr.descrizione_breve,
		case
		when usr.id_asl = -1 then (select a.ID from matrix.struttura_asl a where a.n_livello = 0 and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
		when usr.id_asl != -1 and usr.id_struttura is null then (select a.ID from matrix.struttura_asl a where a.id_asl = usr.id_asl and n_livello = 1 and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
		when usr.id_struttura is not null and usr.livello = 2 then (select a.p_ID from matrix.vw_tree_nodes_asl_descr a where a.id = usr.id_struttura and validita @> localtimestamp)
		when usr.id_struttura is not null then (select a.ID from matrix.struttura_asl a where a.id = usr.id_struttura and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
		end as id_struttura,
		usr.id_qualifica,
		usr.sigla_qualifica,
		usr.descr_qualifica,
		usr.responsabile,
		usr.livello,
		case when usr.cf in (select codice_fiscale
		from matrix.vw_nominativi
		where nominativo in (
		'ANDREA PERESSON',
		'MATTEO COLAUTTI',
		'ROBERTO LEVAN',
		'GIAMPAOLO BARACETTI',
		'MASSIMO ERARIO',
		'MARIA TERESA COLASANTO',
		'SILVIA CAPPETTA',
		'MARTA DAL CIN',
		'GIOVANNI SAITTA',
		'MARIA RITA MARAGONI',
		'ALICE MARTINI') )
		or usr.cf in ('BOONDR85A25C890D','PLCGLC92B23M289F', 'MRTMTT80S25E098R', 'DNGRSL89T63F839W', 'VCCGDI97C68B963B', 'RNGCRS02E08F839N', 'PSNRTI00P67F839Z', 'LCCSMN00E05E054Y') then false else true end as "hideProfilassi"
		from rbac.vw_utente_strutture_ruoli usr
		where usr.id_utente_struttura_ruolo = _idutentestrutturaruolo

	) a 

;
END
$$;


ALTER FUNCTION public.get_utente_info_3(_idutentestrutturaruolo bigint) OWNER TO postgres;

--
-- Name: get_utente_info_3(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_utente_info_3(_username text, _password text, _codice_fiscale text DEFAULT NULL::text) RETURNS TABLE(id_utente_struttura_ruolo bigint, id bigint, id_utente_struttura bigint, id_ruolo bigint, ruolo_sigla character varying, ruolo_descr character varying, id_utente bigint, nome character varying, cognome character varying, cf character varying, id_asl bigint, descrizione_breve text, id_struttura bigint, id_qualifica bigint, sigla_qualifica character varying, descr_qualifica character varying, responsabile boolean, livello bigint, "hideProfilassi" boolean)
    LANGUAGE plpgsql
    AS $$
begin
	return QUERY
	
	
select * from ( 
		select usr.id_utente_struttura_ruolo,
		usr.id,
		usr.id_utente_struttura,
		usr.id_ruolo,
		usr.ruolo_sigla,
		usr.ruolo_descr,
		usr.id_utente,
		usr.nome,
		usr.cognome,
		usr.cf,
		usr.id_asl,
		usr.descrizione_breve,
		case
		when usr.id_asl = -1 then (select a.ID from matrix.struttura_asl a where a.n_livello = 0 and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
		when usr.id_asl != -1 and usr.id_struttura is null then (select a.ID from matrix.struttura_asl a where a.id_asl = usr.id_asl and n_livello = 1 and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
		when usr.id_struttura is not null and usr.livello = 2 then (select a.p_ID from matrix.vw_tree_nodes_asl_descr a where a.id = usr.id_struttura and validita @> localtimestamp)
		when usr.id_struttura is not null then (select a.ID from matrix.struttura_asl a where a.id = usr.id_struttura and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
		end as id_struttura,
		usr.id_qualifica,
		usr.sigla_qualifica,
		usr.descr_qualifica,
		usr.responsabile,
		usr.livello,
		case when usr.cf in (select codice_fiscale
		from matrix.vw_nominativi
		where nominativo in (
		'ANDREA PERESSON',
		'MATTEO COLAUTTI',
		'ROBERTO LEVAN',
		'GIAMPAOLO BARACETTI',
		'MASSIMO ERARIO',
		'MARIA TERESA COLASANTO',
		'SILVIA CAPPETTA',
		'MARTA DAL CIN',
		'GIOVANNI SAITTA',
		'MARIA RITA MARAGONI',
		'ALICE MARTINI') )
		or usr.cf in ('BOONDR85A25C890D','PLCGLC92B23M289F', 'MRTMTT80S25E098R', 'DNGRSL89T63F839W', 'VCCGDI97C68B963B', 'RNGCRS02E08F839N', 'PSNRTI00P67F839Z', 'LCCSMN00E05E054Y') then false else true end as "hideProfilassi"
		from rbac.vw_utente_strutture us
		join rbac.vw_utente_strutture_ruoli usr on us.id_utente_struttura = usr.id_utente_struttura
		--join matrix.vw_nominativi_struttura ns on ns.id_anagrafica  = usr.id_utente and ns.id_struttura = usr.id_struttura
		where ((_username = usr.cognome||' '||usr.nome::text and  _password = 'password') or md5('GISA-'||usr.cf)= _codice_fiscale)
		and validita @> localtimestamp

	) a 

;
END
$$;


ALTER FUNCTION public.get_utente_info_3(_username text, _password text, _codice_fiscale text) OWNER TO postgres;

--
-- Name: get_utente_info_from_gisa(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_utente_info_from_gisa(_id_utente bigint) RETURNS TABLE(nome text, ruolo text, id_ruolo bigint, id_utente bigint, username text, codice_interno_struttura bigint, id_asl integer, id_struttura_root bigint, responsabile boolean, livello integer)
    LANGUAGE plpgsql
    AS $$
begin
	return QUERY
	select * from (
	   SELECT t.nome, t.ruolo,t.id_ruolo, t.id_utente, t.username, t.codice_interno_struttura, t.id_asl,
	   case 
		   when t.id_asl = -1 then (select ID from matrix.struttura_asl a where a.n_livello = 0 and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
		   when t.id_asl != -1 and t.codice_interno_struttura is null then (select ID from matrix.struttura_asl a where a.id_asl = t.id_asl and n_livello = 1 and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
	   	   when t.codice_interno_struttura is not null and ri.livello = 2 then  (select p_ID from matrix.vw_tree_nodes_asl_descr a where a.codice_interno_fk = t.codice_interno_struttura and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
	   	   when t.codice_interno_struttura is not null then  (select ID from matrix.struttura_asl a where a.codice_interno_fk = t.codice_interno_struttura and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
	   end as id_struttura_root, 
	   coalesce(ri.responsabile, false) as responsabile,
	   ri.livello--,c.value ambiente
	   FROM dblink('dbname='||(select value from "Analisi_dev".config where descr = 'GISA_DB')||' 
					port=5432 
					host='||(select value from "Analisi_dev".config where descr = 'GISA_ADDRESS_PROD')||'
					user=postgres'::text, 'select * from public.get_utente_info where id_utente='||_id_utente ) t(nome text, ruolo text, id_ruolo bigint, id_utente bigint, username text, codice_interno_struttura bigint, id_asl integer, "password" text, codice_fiscale text)
		left join public.role_info ri on ri.role_id=t.id_ruolo
		--left join "Analisi_dev".config c on upper(c.descr)='AMBIENTE'
	) a 
	where a.id_struttura_root is not null;
END
$$;


ALTER FUNCTION public.get_utente_info_from_gisa(_id_utente bigint) OWNER TO postgres;

--
-- Name: get_utente_info_from_gisa(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_utente_info_from_gisa(_username text, _password text, _codice_fiscale text DEFAULT NULL::text) RETURNS TABLE(nome text, ruolo text, id_ruolo bigint, id_utente bigint, username text, codice_interno_struttura bigint, id_asl integer, id_struttura_root bigint, responsabile boolean, livello integer, id_nominativo_struttura integer, "hideProfilassi" boolean)
    LANGUAGE plpgsql
    AS $$
begin
	return QUERY
	select * from (
	   SELECT t.nome, t.ruolo,t.id_ruolo, t.id_utente, t.username, t.codice_interno_struttura, t.id_asl,
	   case 
		   when t.id_asl = -1 then (select ID from matrix.struttura_asl a where a.n_livello = 0 and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
		   when t.id_asl != -1 and t.codice_interno_struttura is null then (select ID from matrix.struttura_asl a where a.id_asl = t.id_asl and n_livello = 1 and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
	   	   when t.codice_interno_struttura is not null and ri.livello = 2 then  (select p_ID from matrix.vw_tree_nodes_asl_descr a where a.codice_interno_fk = t.codice_interno_struttura and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
	   	   when t.codice_interno_struttura is not null then  (select ID from matrix.struttura_asl a where a.codice_interno_fk = t.codice_interno_struttura and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
	   end as id_struttura_root, 
	   coalesce(ri.responsabile, false) as responsabile,
	   ri.livello,
	   ns.id as id_nominativo_struttura,
	   case when t.codice_fiscale in (select codice_fiscale
			from matrix.vw_nominativi
			where nominativo in (
			'ANDREA PERESSON',
			'MATTEO COLAUTTI',
			'ROBERTO LEVAN',
			'GIAMPAOLO BARACETTI',
			'MASSIMO ERARIO',
			'MARIA TERESA COLASANTO',
			'SILVIA CAPPETTA',
			'MARTA DAL CIN',
			'GIOVANNI SAITTA',
			'MARIA RITA MARAGONI',
			'ALICE MARTINI')) or t.codice_fiscale in ('PLCGLC92B23M289F', 'MRTMTT80S25E098R', 'DNGRSL89T63F839W', 'VCCGDI97C68B963B' ) then false else true end as "hideProfilassi"
	   FROM public.dblink('dbname='||(select value from "Analisi_dev".config where descr = 'GISA_DB')||' 
					port=5432 
					host='||(select value from "Analisi_dev".config where descr = 'GISA_ADDRESS_PROD')||'
					user=postgres'::text, format('select * from public.get_utente_info where (username=%L and (password=md5(%L) or password=%L)) or md5(''GISA-''||codice_fiscale)=%L ', _username, _password , _password, _codice_fiscale)) t(nome text, ruolo text, id_ruolo bigint, id_utente bigint, username text, codice_interno_struttura bigint, id_asl integer, "password" text, codice_fiscale text)
		left join public.role_info ri on ri.role_id = t.id_ruolo
		left join matrix.vw_nominativi_struttura ns on ns.id_anagrafica  = t.id_utente and ns.codice_interno_fk  = t.codice_interno_struttura
	) a 
	where a.id_struttura_root is not null
;
END
$$;


ALTER FUNCTION public.get_utente_info_from_gisa(_username text, _password text, _codice_fiscale text) OWNER TO postgres;

--
-- Name: get_utente_info_from_gisa_ext(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_utente_info_from_gisa_ext(_id_utente bigint) RETURNS TABLE(nome text, ruolo text, id_ruolo bigint, id_utente bigint, username text, codice_interno_struttura bigint, id_asl integer, id_struttura_root bigint, responsabile boolean, livello integer, ambiente text)
    LANGUAGE plpgsql
    AS $$
begin
	return QUERY
	select * from (
	   SELECT t.nome, t.ruolo,t.id_ruolo, t.id_utente, t.username, t.codice_interno_struttura, t.id_asl,
	   case 
		   when t.id_asl = -1 then (select ID from matrix.struttura_asl a where a.n_livello = 0 and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
		   when t.id_asl != -1 and t.codice_interno_struttura is null then (select ID from matrix.struttura_asl a where a.id_asl = t.id_asl and n_livello = 1 and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
	   	   when t.codice_interno_struttura is not null and ri.livello = 2 then  (select p_ID from matrix.vw_tree_nodes_asl_descr a where a.codice_interno_fk = t.codice_interno_struttura and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
	   	   when t.codice_interno_struttura is not null then  (select ID from matrix.struttura_asl a where a.codice_interno_fk = t.codice_interno_struttura and anno = (select value from "Analisi_dev".config where descr = 'ANNO CORRENTE')::int)
	   end as id_struttura_root, 
	   coalesce(ri.responsabile, false) as responsabile,
	   ri.livello,(case when  c.value ='local' or c.value='dev' then 'local' else '' end)::text ambiente
	   FROM dblink('dbname='||(select value from "Analisi_dev".config where descr = 'GISA_DB')||' 
					port=5432 
					host='||(select value from "Analisi_dev".config where descr = 'GISA_ADDRESS_PROD')||'
					user=postgres'::text, 'select * from public.get_utente_info where id_utente='||_id_utente ) t(nome text, ruolo text, id_ruolo bigint, id_utente bigint, username text, codice_interno_struttura bigint, id_asl integer, "password" text, codice_fiscale text)
		left join public.role_info ri on ri.role_id=t.id_ruolo
		left join "Analisi_dev".config c on upper(c.descr)='AMBIENTE'
	) a 
	where a.id_struttura_root is not null;
END
$$;


ALTER FUNCTION public.get_utente_info_from_gisa_ext(_id_utente bigint) OWNER TO postgres;

--
-- Name: create_mvw(); Type: FUNCTION; Schema: ra; Owner: postgres
--

CREATE FUNCTION ra.create_mvw() RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin

	set search_path to "Analisi_dev";
	drop materialized view if exists mvw_get_cu;

	create materialized view mvw_get_cu as
	select i.codice::bigint as id_controllo, cl.desc_tipo_linea as codice_linea, id_piano as id_motivo, per_conto as id_unita_operativa, i.dt as data_inizio_controllo,
	id_stabilimento as riferimento_id, null as rifetimento_nome_tab, 1 as eseguiti, 'cu' as fonte, id_piano as id_motivo_originale, t.id as id_norma
	from cu.vw_cu_info_reportistica i
	left join cu_types.vw_tipologie_struttura t on i.cod_tipologia_struttura = t.codice 
	left join cu.cu c on c.codice = i.codice
    left join cu.vw_cu_linee cl on cl.id_cu = c.id
    where i.chiuso 
	with data;
	
	
	--create or replace view vw_gisa_controlli_ufficiali as 
	delete from ra.vw_gisa_controlli_ufficiali;
	insert into ra.vw_gisa_controlli_ufficiali
	select * from mvw_get_cu;
	
	
	delete from ra.lookup_norme;
	insert into ra.lookup_norme select distinct descrizione, id from cu_types.vw_tipologie_struttura;
	
	
	CREATE TABLE IF NOT EXISTS ra.h_gisa_controlli_ufficiali (id_controllo bigint, codice_linea text, id_motivo bigint, id_unita_operativa bigint, data_inizio_controllo timestamp, riferimento_id bigint, riferimento_nome_tab bigint, eseguiti bigint, fonte text, rng int8range);
	

return 1;
end;
$$;


ALTER FUNCTION ra.create_mvw() OWNER TO postgres;

--
-- Name: create_mvw_adhoc(); Type: FUNCTION; Schema: ra; Owner: postgres
--

CREATE FUNCTION ra.create_mvw_adhoc() RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare 
	rec record;
	i integer;
	union_ text;
	str_create text;
	str_drop text;
	str_query text;
begin
	i := 0;
	union_ := '';

    str_drop := 'truncate table ra.mvw_adhoc;';
	str_create := 'insert into ra.mvw_adhoc ';

	for rec in select * from ra.config_adhoc where enabled loop
		if i > 0 then	
			union_ := '
				union
				';
		end if;
		if rec.motivo is false then 
			str_query := rec.query;
			str_query := replace(str_query, '$cod_raggruppamento', rec.cod_raggruppamento::text);
			str_query := replace(str_query, '$id', rec.id::text);
			str_create := str_create || union_ || str_query;
		else
			str_query = 'select distinct p.id_asl_struttura as id_asl , $cod_raggruppamento as cod_raggruppamento, data_inizio_controllo as data, count(*) as eseguiti, $id as fonte from "Analisi_dev".vw_get_controlli_ispezioni_semplici_validi i join "Analisi_dev".vw_get_controlli_ispezioni_semplici_percontodi_validi p on p.id_controllo = i.id_controllo  join "Analisi_dev".vw_dpat_indicatore_new_validi pp on coalesce(nullif(p.id_piano_ispezione,-1),p.id_motivo_ispezione) = pp.id where pp.cod_raggruppamento = $cod_raggruppamento and data_inizio_controllo > ''2017-01-01'' group by 1,2,3,5';
			str_query := replace(str_query, '$cod_raggruppamento', rec.cod_raggruppamento::text);
			str_query := replace(str_query, '$id', rec.id::text);
			str_create := str_create || union_ || str_query;
		end if;
		i = i +1;	
	end loop;

	SET enable_seqscan = OFF;

	raise notice '%', str_create;
	execute str_drop;
	execute str_create;
	return 1;
end;
$_$;


ALTER FUNCTION ra.create_mvw_adhoc() OWNER TO postgres;

--
-- Name: create_mvw_iuv(); Type: FUNCTION; Schema: ra; Owner: postgres
--

CREATE FUNCTION ra.create_mvw_iuv() RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare 
	rec record;
	i integer;
	union_ text;
	str_create text;
	str_drop text;
	str_query text;
begin
	i := 0;
	union_ := '';

    str_drop := 'delete from ra.mvw_iuv;';
	str_create := 'insert into ra.mvw_iuv ';

	for rec in select * from ra.config_iuv where enabled loop
		if i > 0 then	
			union_ := '
				union
				';
		end if;
		if rec.motivo is false then 
			str_query := rec.query;
			str_query := replace(str_query, '$cod_raggruppamento', rec.cod_raggruppamento::text);
			str_query := replace(str_query, '$id', rec.id::text);
			str_create := str_create || union_ || str_query;
		else
			str_query = 'select distinct p.id_asl_struttura as id_asl , $cod_raggruppamento as cod_raggruppamento, data_inizio_controllo as data, count(*) as eseguiti, $id as fonte, null as nucleo from "Analisi_dev".vw_get_controlli_ispezioni_semplici_validi i join "Analisi_dev".vw_get_controlli_ispezioni_semplici_percontodi_validi p on p.id_controllo = i.id_controllo  join "Analisi_dev".vw_dpat_indicatore_new_validi pp on coalesce(nullif(p.id_piano_ispezione,-1),p.id_motivo_ispezione) = pp.id where pp.cod_raggruppamento = $cod_raggruppamento and data_inizio_controllo > ''2017-01-01'' group by 1,2,3,5';
			str_query := replace(str_query, '$cod_raggruppamento', rec.cod_raggruppamento::text);
			str_query := replace(str_query, '$id', rec.id::text);
			str_create := str_create || union_ || str_query;
		end if;
		i = i +1;	
	end loop;

	SET enable_seqscan = OFF;

	raise notice '%', str_create;
	execute str_drop;
	execute str_create;
	return 1;
end;
$_$;


ALTER FUNCTION ra.create_mvw_iuv() OWNER TO postgres;

--
-- Name: update_h_gisa_controlli_ufficiali(); Type: FUNCTION; Schema: ra; Owner: postgres
--

CREATE FUNCTION ra.update_h_gisa_controlli_ufficiali() RETURNS bigint
    LANGUAGE plpgsql
    AS $$ 
declare

	rec record;

	versione_corrente bigint;

	curs_gisa_controlli_ufficiali CURSOR FOR 
		select count(*),max(rowid) as rowid,max(f),min(f),row(id_controllo , codice_linea , id_motivo , id_unita_operativa , data_inizio_controllo , riferimento_id , riferimento_nome_tab , eseguiti , fonte, rng) as r 
		from
		(select ctid as rowid, 'm' as f,id_controllo , codice_linea , id_motivo , id_unita_operativa , data_inizio_controllo , riferimento_id , riferimento_nome_tab , eseguiti , fonte , int8range(versione_corrente, null ) as rng
		from ra.h_gisa_controlli_ufficiali m where upper(rng) is null
		union
		select null as rowid,'v' as f,id_controllo , codice_linea , id_motivo , id_unita_operativa , data_inizio_controllo , riferimento_id , riferimento_nome_tab , eseguiti , fonte  , int8range(versione_corrente, null ) as rng
		from ra.vw_gisa_controlli_ufficiali vw) s
		group by id_controllo , codice_linea , id_motivo , id_unita_operativa , data_inizio_controllo , riferimento_id , riferimento_nome_tab , eseguiti , fonte , rng 
		order by count(*);
	rec_gisa_controlli_ufficiali  ra.h_gisa_controlli_ufficiali%ROWTYPE;

begin
	
	set search_path to "Analisi_dev";

	select max(id) into versione_corrente from versioni;



	open curs_gisa_controlli_ufficiali;
	loop
		fetch curs_gisa_controlli_ufficiali into rec;
		EXIT WHEN NOT FOUND;
		if rec.count <2 then
			if rec.max = 'm' then
				update ra.h_gisa_controlli_ufficiali m set rng = int8range(lower(rng), versione_corrente)
				where m.ctid = rec.rowid;
			end if;
			if rec.min = 'v' then
				rec_gisa_controlli_ufficiali = rec.r;
				insert into ra.h_gisa_controlli_ufficiali values (rec_gisa_controlli_ufficiali.*);
			end if;
		end if;
	end loop;

	return 1;
	
end;
$$;


ALTER FUNCTION ra.update_h_gisa_controlli_ufficiali() OWNER TO postgres;

--
-- Name: check_esiste_cf(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.check_esiste_cf(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
	BEGIN
	declare 
		proc_name varchar;
		ret rbac_types.result_type; 
		n integer;
		rt json;
		idstabilimento bigint;
		_cf varchar;
		
		begin 
			proc_name:='rbac.check_esiste_cf';
			ret.esito:=false;
			_cf=v->>'cod_fis';
	
			select count(*) into n from rbac.utenti u where u.cf=_cf;
			if n>0 then
			    ret:=rbac_ui.build_ret(ret,proc_name, 'codice_fiscale_esistente');
    	   		ret.esito:=false;
    	   		return ret;
			end if;
			if not cu_anag.check_cf(_cf) then
			    ret:=rbac_ui.build_ret(ret,proc_name, 'codice_fiscale_non_valido');
    	   		ret.esito:=false;
    	   		return ret;			
			end if;
		
			ret.esito:=true;
			ret.info:='0';

	 		return ret;
		end;
	END;
$$;


ALTER FUNCTION rbac.check_esiste_cf(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_dati(character varying, character varying, bigint, json); Type: PROCEDURE; Schema: rbac; Owner: postgres
--

CREATE PROCEDURE rbac.get_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json)
    LANGUAGE plpgsql
    AS $$

declare 	
	idtransazione bigint;
	proc_name varchar;
	id_op bigint;  
	id_risorsa bigint;
	ret ag_types.result_type;
	ret_2 ag_types.result_type;
	ret_3 ag_types.result_type;

	ret_eventi ag_types.result_type;
	ret_calendari ag_types.result_type;
	retj json;
	text_msg1 varchar;	
	text_msg2 varchar;	
	text_msg3 varchar;	
	text_msg4 varchar;
	str_conf varchar;

		idstruttura bigint;
		responsabile bool;
		--idutente bigint;
	ts timestamp;
	id bigint;
	fallito bool;
	j_user_info json;
	n integer;
	v_j json;
	skipUi bool;
begin 
	ts:=CLOCK_TIMESTAMP();
	proc_name:='rbac.get_dati';
	idtransazione:= rbac_log.get_id_transazione(idutente,proc_name);
	id_op:=rbac_log.op(proc_name,idtransazione,v,null,ts,-1,operazione);

	--idutente è rbac.id_utente_struttura_ruolo
	select row_to_json(a.*) into j_user_info from
	(	
		select *,id_struttura as id_struttura_root from public.get_utente_info_3(idutente)
	) a;

	if j_user_info is not null then
		if v is null or v='' or v='{}' then
			v:= '{"user_info":'||j_user_info||'}';
		else
			v:= substring(v,1,length(v)-1)||',"user_info":'||j_user_info||'}';
		end if;
	end if;

raise notice 'USER_DATA %', v;
	id_op:=ag_log.op(proc_name,idtransazione,v,null,ts,-1,operazione);
   	--COMMIT;
 
	begin 
	fallito:=false;
	skipUi := false;


	case operazione

		when 'get_user_info' then
			if v is not null then
				ret.esito = true;
				ret.info := v;
			end if;
		when 'get_menu' then
			ret:=rbac_ui.get_menu(v::json, idtransazione);
		when 'get_ruoli' then
			ret:=rbac.get_ruoli(v::json, idtransazione);
		when 'get_ruoli_permessi' then
			ret:=rbac.get_ruoli_permessi(v::json, idtransazione);
		when 'get_ruolo_ruoli' then
			ret:=rbac.get_ruolo_ruoli(v::json, idtransazione);
		when 'get_utenti' then
			ret:=rbac.get_utenti(v::json, idtransazione);
		when 'get_utenti_for_struttura' then
			ret:=rbac.get_utenti_for_struttura(v::json, idtransazione);
		when 'get_utente_singolo' then
			ret:=rbac.get_utente_singolo(v::json, idtransazione);
		when 'get_utente_ruoli' then
			ret:=rbac.get_utente_ruoli(v::json, idtransazione);
		when 'get_ruoli_utente' then
			ret:=rbac.get_ruoli_utente(v::json, idtransazione);
		when 'get_ruolo_singolo' then
			ret:=rbac.get_ruolo_singolo(v::json, idtransazione);
		when 'get_sezioni' then
			ret:=rbac_ui.get_sezioni(v::json, idtransazione);
		when 'get_modalita' then
			ret:=rbac_types.get_modalita(v::json, idtransazione);
		when 'get_ruolo_ruoli_for_add' then
			ret:=rbac.get_ruolo_ruoli_for_add(v::json, idtransazione);
		when 'get_permessi' then
			ret:=rbac.get_permessi(v::json, idtransazione);
		when 'get_tipi_operazioni' then
			ret:=rbac.get_tipi_operazioni(v::json, idtransazione);
		when 'get_operazioni_by_sel' then
			ret:="log".get_operazioni_by_sel(v::json, idtransazione);
		when 'get_riepilogo_cu' then
			ret:=cu_his.get_riepilogo_cu(v::json, idtransazione);
		when 'get_operazione_singolo' then
			ret:=log.get_operazione_singolo(v::json, idtransazione);
		when 'get_dettaglio_operazione' then
			skipUi = true;
			ret:=log.get_dettaglio_operazione(v::json, idtransazione);
		when 'get_strutture_asl' then
			ret:=cu_anag.get_strutture_asl(v::json, idtransazione);
		when 'check_esiste_cf' then
			ret:=rbac.check_esiste_cf(v::json, idtransazione);
		when 'get_cu_soggetti_fisici_by_sel' then
			ret:=cu_anag.get_soggetti_fisici_by_sel(v::json, idtransazione);
		when 'get_qualifiche' then
			ret:=rbac_conf.get_qualifiche(v::json, idtransazione);
		when 'get_utenti_by_sel' then
			ret:=rbac.get_utenti_by_sel(v::json, idtransazione);
		when 'get_strutture_by_asl' then
			ret:=agenda.get_strutture_by_asl(v::json, idtransazione);
		when 'get_utente_strutture' then
			ret:=rbac.get_utente_strutture(v::json, idtransazione);
		when 'get_utente_strutture_singolo' then
			ret:=rbac.get_utente_strutture_singolo(v::json, idtransazione);
		when 'get_strutture_utente' then
			ret:=rbac.get_strutture_utente(v::json, idtransazione);
 	else
 			ret.esito := false;
 			ret.info  := 'CASO NON PREVISTO';
 			raise notice 'ELSE CASE';
	end case;

	RAISE notice 'rbac.get_dati ret.esito: %', ret.esito;
	raise notice 'skipUi %', skipUi;
	if ret.esito=false then 
		RAISE notice 'rbac.get_dati if su ret.esito=false';
		fallito=true;
		RAISE notice 'rbac.get_dati ROLLBACK a seguito di ret.esito=false';
	end if;
	if  skipUi = false then
		str_conf:= rbac_ui.get_ui_definition(''::varchar,'rbac.'||operazione,((j_user_info->'id_struttura_root')::varchar)::int8,idtransazione);
		raise notice 'OPERAZIONE % STR_CONF=%',operazione,str_conf;
		raise notice 'j_user_info=%',j_user_info;
		if str_conf is not null and str_conf != '' then
		 	 ret.info:='{'||str_conf||','||right(ret.info,length(ret.info)-1);
		end if;
	end if;

	exception when others then
		fallito:=true;
		RAISE notice 'agenda.get_dati ROLLBACK a seguito di exception';
		GET STACKED DIAGNOSTICS text_msg1 = MESSAGE_TEXT,
		                  			text_msg2 = PG_EXCEPTION_DETAIL,
		                  			text_msg3 = PG_EXCEPTION_HINT,
		                 			text_msg4 = PG_EXCEPTION_CONTEXT;
		ret.esito:=false;
		ret.valore:= null;
	if replace(upper(j_user_info->>'ambiente'),'"','') ='local' then
		ret.err_msg:=coalesce(ret.err_msg,'')||coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');
	else
		ret.err_msg:=coalesce(ret.err_msg,'')||coalesce(text_msg1,'');
	end if;
   end;

	joutput:=row_to_json(ret);
	id_op:=ag_log.op(proc_name,idtransazione,v,null,ts,-1,operazione);
end;
$$;


ALTER PROCEDURE rbac.get_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json) OWNER TO postgres;

--
-- Name: get_permessi(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_permessi(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;
	idruolo bigint;
	proc_name varchar;
	rt json;
	
	begin
		proc_name:='rbac.get_ruoli_permessi';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		idruolo:=v->'id_ruolo';

		select json_agg(row_to_json(a.*)) into rt   
			from (select vp.*
				  from rbac.vw_permessi vp 
				  left join rbac.vw_ruolo_permessi vrp ON vrp.id_sezione = vp.id_sezione AND vrp.id_modalita = vp.id_modalita AND vrp.id_ruolo = idruolo
				  where vrp.id_sezione is null or vrp.id_modalita is null
			order by cod_risorsa) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_permessi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ruoli(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_ruoli(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;

	begin
		proc_name:='rbac.get_ruoli';
		ret.esito:=false;
		id_op:=rbac_log.start_op(proc_name,idtransazione ,'');

		select json_agg(row_to_json(a.*)) into rt from (select * from rbac.vw_ruoli order by livello, cod) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_ruoli(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ruoli_permessi(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_ruoli_permessi(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	idruolo bigint;

	begin
		proc_name:='rbac.get_ruoli_permessi';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		idruolo:=v->'id_ruolo';

		select json_agg(row_to_json(a.*)) into rt   
			from (select * from rbac.vw_ruolo_permessi where id_ruolo = idruolo 
			order by descr_ruolo, descr_portale, descr_sezione, descr_modalita) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_ruoli_permessi(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ruoli_utente(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_ruoli_utente(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;   
	idutentestruttura bigint;
	proc_name varchar;
	rt json;

	begin
		proc_name:='rbac.get_ruoli';
		ret.esito:=false;
		id_op:=rbac_log.start_op(proc_name,idtransazione ,'');
		idutentestruttura:=v->>'id_utente_struttura';
	
		/*select json_agg(row_to_json(a.*)) into rt from (select * from rbac.vw_ruoli r
			where id_ruolo not in(
						select vur.id_ruolo 
						from rbac.vw_utenti vu 
						join rbac.vw_utente_ruoli vur on vur.id_utente = vu.id_utente 
						where vu.id_utente = idutente
						)
			order by sigla) a; */
	
		select json_agg(row_to_json(a.*)) into rt from (
				select true selezionabile, usr.id_utente_struttura_ruolo is not null as selezionato,
				r.id_ruolo as ruolo_id,
				r.descr as ruolo_descr,
				r.cod as ruolo_cod,
				r.sigla as ruolo_sigla,
				usr.id_utente_struttura_ruolo
				from rbac.vw_ruoli r
				left join ( select * from rbac.vw_utente_strutture_ruoli 
							where id_utente_struttura = idutentestruttura ) usr on r.id_ruolo = usr.id_ruolo
				order by r.sigla
		) a;
		

		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_ruoli_utente(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ruolo_ruoli(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_ruolo_ruoli(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;   
	v_cf varchar;
	proc_name varchar;
	rt json;
	idruolo bigint;

	begin
		proc_name:='rbac.get_ruolo_ruoli';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		idruolo:=v->>'id_ruolo';

		select json_agg(row_to_json(a.*)) into rt   from (select * from rbac.vw_ruolo_ruoli where id_ruolo_cte=idruolo order by descr_cto) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_ruolo_ruoli(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ruolo_ruoli_for_add(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_ruolo_ruoli_for_add(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;   
	idruolocte bigint;
	proc_name varchar;
	rt json;

	begin
		proc_name:='rbac.get_ruolo_ruoli_for_add';
		ret.esito:=false;
		id_op:=rbac_log.start_op(proc_name,idtransazione ,'');
		idruolocte:=v->>'id_ruolo_cte';
	
		select json_agg(row_to_json(a.*)) into rt from (
		
			select vr.*,
				   (ri.id_ruolo is null and rr.id is null and rd.id_ruolo is null) selectable,
				   (ri.id_ruolo is null and rr.id is null and rd.id_ruolo is null) selezionabile, 
				case when rd.id_ruolo is not null then 'PRESENTE'
					 when ri.id_ruolo is not null then 'INCLUDE'
					 when rr.id       is not null then 'PRESENTE'
					 end motivo
				from rbac.vw_ruoli vr
				left join rbac.vw_ruoli_inclusi_down_tree ri on ri.id_ruolo=idruolocte and ri.id_ruolo_cto=vr.id_ruolo
				left join rbac.ruolo_ruoli rr on rr.id_ruolo_cte = idruolocte and rr.id_ruolo_cto =vr.id_ruolo
				left join rbac.vw_ruoli_inclusi_up_tree rd on rd.id_ruolo=idruolocte and rd.id_ruolo_cto=vr.id_ruolo
				where rd.id_ruolo is null or rd.id_ruolo != idruolocte or ri.id_ruolo is null or ri.id_ruolo!= idruolocte --is  null 	and rr.id is null					and rd.id_ruolo is null					
				order by vr.sigla
		
		
		
		/*
			select vr.*,
				   (ri.id_ruolo is null and rr.id is null and rd.id_ruolo is null) selectable,
				   (ri.id_ruolo is null and rr.id is null and rd.id_ruolo is null) selezionabile, 
				case when rd.id_ruolo is not null then 'INCLUDE'
					 when ri.id_ruolo is not null then 'INCLUSO'
					 when rr.id       is not null then 'PRESENTE'
					 end motivo
				from rbac.vw_ruoli vr
				left join rbac.vw_ruoli_inclusi_down_tree ri on ri.id_ruolo=idruolocte and ri.id_ruolo_cto=vr.id_ruolo
				left join rbac.ruolo_ruoli rr on rr.id_ruolo_cte = idruolocte and rr.id_ruolo_cto =vr.id_ruolo
				left join rbac.vw_ruoli_inclusi_up_tree rd on rd.id_ruolo=idruolocte and rd.id_ruolo_cto=vr.id_ruolo
				--where ri.id_ruolo is  null 	and rr.id is null					and rd.id_ruolo is null					
				order by vr.sigla*/
	) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_ruolo_ruoli_for_add(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ruolo_singolo(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_ruolo_singolo(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;  
	idruolo bigint;
	proc_name varchar;
	rt json;

	begin
		proc_name:='rbac.get_ruolo_singolo';
		ret.esito:=false;
		id_op:=rbac_log.start_op(proc_name,idtransazione ,'');
		idruolo:= v->'id_ruolo';

		select json_agg(row_to_json(a.*)) into rt from (select * from rbac.vw_ruoli where id_ruolo = idruolo order by sigla) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_ruolo_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_strutture_utente(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_strutture_utente(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	v_id_struttura bigint;
	begin
		proc_name:='rbac.get_strutture_utente';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		v_id_struttura:=v->>'id_struttura';

		select json_agg(row_to_json(a.*)) into rt from (
			select * from rbac.vw_utente_strutture 
			where id_struttura = v_id_struttura
			and validita @> localtimestamp
		) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_strutture_utente(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tipi_operazioni(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_tipi_operazioni(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;
	idruolo bigint;
	proc_name varchar;
	rt json;
	
	begin
		proc_name:='rbac.get_tipi_operazioni';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');

		select json_agg(row_to_json(a.*)) into rt   
			from (select * from "log".vw_funzioni where (cod_area = 'AN' or cod_area = 'CU' or cod_area = 'TRF' or cod_area = 'AG') order by descr) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_tipi_operazioni(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_utente_ruoli(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_utente_ruoli(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;   
	v_cf varchar;
	proc_name varchar;
	rt json;

	begin
		proc_name:='rbac.get_utente_ruoli';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		v_cf:=v->>'cf';

		select json_agg(row_to_json(a.*)) into rt   from (select * from rbac.vw_utente_ruoli where cf=v_cf order by descr_ruolo) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_utente_ruoli(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_utente_singolo(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_utente_singolo(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;
	v_id_utente bigint;
	proc_name varchar;
	rt json;

	begin
		proc_name:='rbac.get_utente_singolo';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		v_id_utente:=v->>'id_utente';

		select json_agg(row_to_json(a.*)) into rt from (
			select * from rbac.vw_utenti 
			where id_utente=v_id_utente 
			order by cf
		) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_utente_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_utente_strutture(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_utente_strutture(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	v_id_utente bigint;
	begin
		proc_name:='rbac.get_utente_strutture';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		v_id_utente:=v->>'id_utente';

		select json_agg(row_to_json(a.*)) into rt   from (select * from rbac.vw_utente_strutture where id_utente = v_id_utente) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_utente_strutture(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_utente_strutture_singolo(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_utente_strutture_singolo(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	v_id_utente_struttura bigint;
	begin
		proc_name:='rbac.get_utente_strutture_singolo';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		v_id_utente_struttura:=v->>'id_utente_struttura';

		select json_agg(row_to_json(a.*)) into rt   from (
				select * from rbac.vw_utente_strutture 
				where id_utente_struttura = v_id_utente_struttura
			) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_utente_strutture_singolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_utenti(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_utenti(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;

	begin
		proc_name:='rbac.get_utenti';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');

		select json_agg(row_to_json(a.*)) into rt   from (select * from rbac.vw_utenti order by cf) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_utenti(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_utenti_by_sel(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_utenti_by_sel(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;

	v_limite int;
	v_id_asl int;
	v_nome varchar;
	v_cognome varchar;
	v_cf varchar;
	
	begin
		proc_name:='rbac.get_utenti_by_sel';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
	
		v_cf = '%'||cu_anag.string_normalize(v->>'cf')||'%';
		v_nome = '%'||cu_anag.string_normalize(v->>'nome')||'%';
		v_cognome = '%'||cu_anag.string_normalize(v->>'cognome')||'%';
	
		if v->>'id_asl' is not null then
		v_id_asl:=v->>'id_asl';
		end if;
	
		if v->>'limite' is not null then
		v_limite:=v->>'limite';
		end if;

		select json_agg(row_to_json(a.*)) into rt   from (
			select * from rbac.vw_utenti 
			where (nome ilike v_nome or (nome is null and v_nome = '%%')) 
			and (cognome ilike v_cognome or( cognome is null and v_cognome = '%%'))
			and (cf ilike v_cf or (cf is null and v_cf = '%%'))
			and (id_asl::int = v_id_asl or (v_id_asl is null))
			order by cf limit v_limite
		) a;
	
	 	if json_array_length(rt) is null then
			ret.esito=false;
    	    ret:=rbac_ui.build_ret(ret,proc_name, 'utenti_non_trovati');
    	else
    		ret.esito:=true;
		 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';
		end if;

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_utenti_by_sel(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_utenti_for_struttura(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.get_utenti_for_struttura(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;
	v_id_struttura bigint;
	v_id_asl bigint;

	begin
		proc_name:='rbac.get_utenti_for_struttura';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		v_id_struttura:=v->'id_struttura';
		v_id_asl:=v->'id_asl';
		

		select json_agg(row_to_json(a.*)) into rt   from (
			select u.id_utente, u.cf, u.nome, u.cognome, u.descr_qualifica, u.asl_descr from rbac.vw_utenti u 
			left join rbac.vw_utente_strutture vus on vus.id_utente = u.id_utente and vus.id_struttura = v_id_struttura
			where (vus.id_struttura is null or vus.fine_validita is not null) and u.id_asl::bigint = v_id_asl
			and u.dpat
			order by u.cf) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac.get_utenti_for_struttura(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_add_ruolo(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_add_ruolo(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- start
	    R_R rbac.ruoli;
		n bigint;
        proc_name varchar; -- end
	begin
		proc_name:='rbac.upd_add_ruolo';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		
		raise notice 'V_J=%', v_j;

		R_R.sigla:= v_j->>'sigla';
		R_R.descr:= v_j->>'descr';

		R_R.sigla:= upper(trim(R_R.sigla));
		R_R.descr:= trim(R_R.descr);

		select count(*) into n from rbac.ruoli r
		where r.sigla = R_R.sigla;

		if n > 0 then
		ret:=rbac_ui.build_ret(ret,proc_name,'sigla_ruolo_gia_inserito');
			return ret;
		end if;			

		select count(*) into n from rbac.ruoli r
		where r.descr = R_R.descr;

		if n > 0 then
		ret:=rbac_ui.build_ret(ret,proc_name,'descr_ruolo_gia_inserito');
			return ret;
		end if;

		R_R.id:= nextval('rbac.ruolo_id_seq');
		R_R.cod:= R_R.id;
		R_R.responsabile:= false;
		R_R.livello:= 4;
	
		insert into rbac.ruoli	values(R_R.*);
		
	
		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_add_ruolo(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_add_struttura_utente(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_add_struttura_utente(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- start
	    R_US rbac.utente_strutture;
		R_U rbac.vw_utenti;
		inizio timestamp;
		fine timestamp;
		n int;
        proc_name varchar; -- end
	begin
		proc_name:='rbac.upd_add_struttura_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		
		raise notice 'V_J=%', v_j;
		
		inizio:=v_j->>'inizio';
		fine:=v_j->>'fine';
		R_U.id_utente:=v_j->>'id_utente';

		select * into R_U from rbac.vw_utenti
		where id_utente = R_U.id_utente;

		if R_U.id is null then
			ret.esito:=false;	
    		ret:=rbac_ui.build_ret(ret,proc_name,'utente_non_trovato');
			ret.info='0';
			return ret;
		end if;

		if R_U.inizio_validita > inizio then
			ret.esito:=false;	
    		ret:=rbac_ui.build_ret(ret,proc_name,'validita_utente_validita_struttura_non_compatibili');
			ret.info='0';
			return ret;
		end if;

		if inizio >= fine then
			ret.esito:=false;	
    		ret:=rbac_ui.build_ret(ret,proc_name,'inizio_e_fine_validita_non_compatibili');
			ret.info='0';
			return ret;
		end if;

		R_US.id:= nextval('rbac.utente_strutture_id_seq');
		R_US.id_utente:=v_j->>'id_utente';
		R_US.id_struttura:=v_j->>'id_struttura';
		R_US.validita:= tsrange(inizio,fine,'[)');
		R_US.id_nominativo:= R_US.id;

		select count(*) into n from rbac.utente_strutture
		where id_utente = R_US.id_utente 
		and id_struttura = R_US.id_struttura
		and validita && R_US.validita;
	
		if n = 0 then
			insert into rbac.utente_strutture values(R_US.*);
		else
			ret.esito:=false;	
    		ret:=rbac_ui.build_ret(ret,proc_name,'struttura_gia_presente_per_validita');
			ret.info='0';
			return ret;
		end if;
	
		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_add_struttura_utente(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_add_utente(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_add_utente(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- start
	    R_U rbac.utenti;
        proc_name varchar; -- end
        inizio timestamp;
        fine timestamp;
		n bigint;
	begin
		proc_name:='rbac.upd_add_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		
		raise notice 'V_J=%', v_j;
		
		inizio:=v_j->>'inizio';
		fine:=v_j->>'fine';

		R_U.id:= nextval('rbac.utenti_id_seq');
		R_U.cf:= v_j->>'cf';
		R_U.id_qualifica:= v_j->>'id_qualifica';
		R_U.id_asl:= v_j->>'id_asl';
		R_U.mail:= v_j->>'mail';
		R_U.tel:= v_j->>'tel';
		R_U.dpat:= true;	--	R_U.dpat:= case when R_U.id_asl = -1 then false else true end;
		R_U.validita:= tsrange(inizio,fine,'[)');


/*		select count(*) into n from rbac.vw_utenti
		where cf = R_U.cf and id_asl = R_U.id_asl and validita @> localtimestamp;

		if n>0 then
			ret.esito:=false;	
    		ret:=rbac_ui.build_ret(ret,proc_name,'utente_asl_gia_presente');
			ret.info='0';
			return ret;
		end if;
*/
	
		insert into rbac.utenti	values(R_U.*);
		
	
		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '{"id_utente":'|| R_U.id ||'}';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_add_utente(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_dati(character varying, character varying, bigint, json); Type: PROCEDURE; Schema: rbac; Owner: postgres
--

CREATE PROCEDURE rbac.upd_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json)
    LANGUAGE plpgsql
    AS $$
declare 
	idtransazione bigint;
	proc_name varchar;
	id_op bigint;  
	ret ag_types.result_type;
	text_msg1 varchar;	
	text_msg2 varchar;	
	text_msg3 varchar;	
	text_msg4 varchar;
	ts timestamp;
	fallito bool;
	j_user_info json;
	n integer;
begin
	ts:=CLOCK_TIMESTAMP();
	proc_name:='rbac.upd_dati';
	idtransazione:= ag_log.get_id_transazione(idutente,proc_name);
	id_op:=ag_log.start_op(proc_name,idtransazione ,v);
	--idutente è rbac.id_utente_struttura_ruolo
	select row_to_json(a.*) into j_user_info from
	(	
		select *,id_struttura as id_struttura_root from public.get_utente_info_3(idutente)
	) a;
   	begin
	   	fallito:=false;
	   	case operazione
	   		when 'upd_ins_ruoli_utente' then
	   			ret:=rbac.upd_ins_ruoli_utente(v::json, idtransazione);
	   		when 'upd_del_ruoli_utente' then
	   			ret:=rbac.upd_del_ruoli_utente(v::json, idtransazione);
	   		when 'upd_ins_ruolo_permesso' then
	   			ret:=rbac.upd_ins_ruolo_permesso(v::json, idtransazione);
	   		when 'upd_del_ruolo_permesso' then
	   			ret:=rbac.upd_del_ruolo_permesso(v::json, idtransazione);
	   		when 'upd_ins_ruolo_ruoli' then
	   			ret:=rbac.upd_ins_ruolo_ruoli(v::json, idtransazione);
	   		when 'upd_del_ruolo_ruoli' then
	   			ret:=rbac.upd_del_ruolo_ruoli(v::json, idtransazione);
	   		when 'upd_modalita_sezione' then
	   			ret:=rbac.upd_modalita_sezione(v::json, idtransazione);
	   		when 'upd_add_utente' then
	   			ret:=rbac.upd_add_utente(v::json, idtransazione);
	   		when 'upd_upd_utente' then
	   			ret:=rbac.upd_upd_utente(v::json, idtransazione);
	   		when 'upd_add_struttura_utente' then
	   			ret:=rbac.upd_add_struttura_utente(v::json, idtransazione);
	   		when 'upd_upd_struttura_utente' then
	   			ret:=rbac.upd_upd_struttura_utente(v::json, idtransazione);
	   		when 'upd_utente_struttura_ruolo' then
	   			ret:=rbac.upd_utente_struttura_ruolo(v::json, idtransazione);
	   		when 'upd_add_ruolo' then
	   			ret:=rbac.upd_add_ruolo(v::json, idtransazione);
	   		when 'upd_upd_ruolo' then
	   			ret:=rbac.upd_upd_ruolo(v::json, idtransazione);
			else
 			ret.esito := false;
 			ret.info  := 'CASO NON PREVISTO';
	   	end case;
		
	    RAISE notice 'rbac.upd_evento ret.esito: %', ret.esito;
	   
   		if ret.esito=false then 
   			RAISE notice 'rbac.upd_evento if su ret.esito=false';
   			fallito=true;
	   		RAISE notice 'rbac.upd_evento ROLLBACK a seguito di ret.esito=false';
   		end if;
		

	--end;
	
	if fallito=true then 
		rollback;
	end if;


	exception when others then
		fallito:=true;
		RAISE notice 'gds.upd_dati ROLLBACK a seguito di exception';
		GET STACKED DIAGNOSTICS text_msg1 = MESSAGE_TEXT,
                          			text_msg2 = PG_EXCEPTION_DETAIL,
                          			text_msg3 = PG_EXCEPTION_HINT,
                         			text_msg4 = PG_EXCEPTION_CONTEXT;
			ret.esito:=false;
			ret.valore:= null;
		
			if replace(upper(j_user_info->>'ambiente'),'"','') = 'local' or replace(upper(j_user_info->>'ambiente'),'"','') = 'dev'  then
				ret.err_msg:=coalesce(ret.err_msg,'')||coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');
			else
				--ret.err_msg:=coalesce(text_msg1,'');
				ret.err_msg:=coalesce(ret.err_msg,'')||coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');

			end if;
			--ret.msg:=coalesce(text_msg1,'')|| chr(10) ||coalesce(text_msg2,'')|| chr(10)  ||coalesce(text_msg3,'')|| chr(10)  ||coalesce(text_msg4,'');
			RAISE notice '%', ret;
		rollback;
	end;
	--if ret.info is null then ret.valore = 0; end if;
	joutput:=row_to_json(ret);
	id_op:=rbac_log.op(proc_name,idtransazione,v,joutput,ts,-1,operazione);
commit;

end;
$$;


ALTER PROCEDURE rbac.upd_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json) OWNER TO postgres;

--
-- Name: upd_del_ruoli_utente(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_del_ruoli_utente(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- START
        idutente bigint;  
       	idruolo bigint;
       	idsroot bigint;
       	u json;
       	R_UI rbac.utente_ruoli;
        proc_name varchar; -- END
	begin
		proc_name:='rbac.upd_ins_ruoli_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idutente:=v_j->'id_utente';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';
		idruolo:=v_j->'id_ruolo';

		delete from rbac.utente_ruoli where id_utente = idutente and id_ruolo = idruolo;
		
		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_del_ruoli_utente(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_del_ruolo_permesso(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_del_ruolo_permesso(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- START
        idruolopermesso bigint;
        idpermesso bigint;
       	idsroot bigint;
       	u json;
        proc_name varchar; -- END
	begin
		proc_name:='rbac.upd_del_ruolo_permesso';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idruolopermesso:=v_j->>'id_ruolo_permesso';
		idpermesso:=v_j->>'id_permesso';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';

		delete from rbac.ruolo_permessi where id = idruolopermesso;
	
	    --delete from rbac.permessi  where id = idpermesso;
		
		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_del_ruolo_permesso(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_del_ruolo_ruoli(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_del_ruolo_ruoli(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- START
        idruoloruoli bigint;
       	idsroot bigint;
       	u json;
        proc_name varchar; -- END
	begin
		proc_name:='rbac.upd_del_ruolo_ruoli';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idruoloruoli:=v_j->>'id_ruolo_ruoli';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';

		delete from rbac.ruolo_ruoli where id = idruoloruoli;
		
		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_del_ruolo_ruoli(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ins_ruoli_utente(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_ins_ruoli_utente(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- START
        idutente bigint;  
       	idruoli bigint;
       	idsroot bigint;
       	u json;
       	R_UI rbac.utente_ruoli;
        proc_name varchar; -- END
	begin
		proc_name:='rbac.upd_ins_ruoli_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idutente:=v_j->'id_utente';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';

		insert into rbac.utente_ruoli
		select nextval('rbac.utente_ruoli_id_seq'),idutente,(value::varchar)::bigint from
		json_array_elements(v_j->'id_ruoli') returning * into R_UI;
	
		raise notice 'R_UI%',R_UI;

		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_ins_ruoli_utente(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ins_ruolo_permesso(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_ins_ruolo_permesso(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- START
        idmodalita bigint;  
	    peso_modalita_risorsa bigint;
       	idruolo bigint;
       --	idrisorsa bigint;
        idpermesso bigint;
       	idsroot bigint;
       	i bigint;
       	u json;
        proc_name varchar; -- END
	begin
		proc_name:='rbac.upd_ins_ruolo_permesso';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idruolo:=v_j->>'id_ruolo';
		--idpermesso:=v_j->'id_permesso';
		idmodalita:=v_j->>'id_modalita';
		--idrisorsa:=v_j->>'id_risorsa';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';

		--insert into rbac.permessi (id_risorsa,id_modalita) values (idrisorsa,idmodalita) returning id into idpermesso;
	
		--insert into rbac.ruolo_permessi (id_ruolo,id_permesso) values (idruolo,idpermesso);
	
		/*insert into rbac.ruolo_permessi
		select nextval('rbac.ruolo_permessi_id_seq'),idruolo,(value::varchar)::bigint from
		json_array_elements(v_j->'id_permessi'); */
	
		--select min(peso) into peso_modalita_risorsa from rbac_types.modalita;
		
		for i in
			select * from json_array_elements(v_j->'id_sezione')
		loop
			RAISE NOTICE 'output array %', i;
			select vp.id_permesso into idpermesso from rbac.vw_permessi vp 
			where vp.id_sezione = i and vp.id_modalita = idmodalita;
			insert into rbac.ruolo_permessi (id_ruolo,id_permesso) values (idruolo,idpermesso);
		end loop;
		
	
		/*insert into rbac.permessi 
		select nextval('rbac.permessi_id_seq'),peso_modalita_risorsa,(value::varchar)::bigint from
		json_array_elements(v_j->'id_risorse'); */	
	
		delete from rbac.ruolo_permessi where id in
			(select id_ruolo_permesso from (
			select id_sezione,id_ruolo_permesso ,peso,lead(peso) over (partition by id_sezione order by id_sezione,peso) l
			from rbac.vw_ruolo_permessi
			where id_ruolo=idruolo
			order by id_sezione, peso) a
			where l is not null);

		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_ins_ruolo_permesso(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ins_ruolo_ruoli(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_ins_ruolo_ruoli(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- START
       	idruolo bigint;
       	idsroot bigint;
       	u json;
       	R_RR rbac.ruolo_ruoli;
        proc_name varchar; -- END
	begin
		proc_name:='rbac.upd_ins_ruoli_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idruolo:=v_j->'id_ruolo';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';

		for R_RR in
			select nextval('rbac.ruoloruoli_id_seq'),idruolo,(value::varchar)::bigint from
			json_array_elements(v_j->'id_ruoli_cti') loop
				insert into rbac.ruolo_ruoli values(R_RR.*)
				returning * into R_RR;
		end loop;
		raise notice 'R_RR%',R_RR;

		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_ins_ruolo_ruoli(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_modalita_risorsa(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_modalita_risorsa(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- START
        idmodalita bigint;
        idrisorsa bigint;
       	idpermesso_pre_modifica bigint;
       	idpermesso bigint;
       	idsroot bigint;
       	u json;
        proc_name varchar; -- END
	begin
		proc_name:='rbac.upd_modalita_risorsa';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		idmodalita:=v_j->>'id_modalita';
		idrisorsa:=v_j->>'id_risorsa';
       	u:= v_j->'user_info';
		idsroot:= u->'id_struttura_root';
	
	
		raise notice 'idmodalita%',idmodalita;
		
		if idmodalita = 1 
		then 
			select vp.id_permesso into idpermesso_pre_modifica from rbac.vw_permessi vp where id_risorsa = idrisorsa order by peso desc limit 1;
		elsif idmodalita = 2 
		then
			select vp.id_permesso into idpermesso_pre_modifica from rbac.vw_permessi vp where id_risorsa = idrisorsa order by peso limit 1;
		end if; 
	
		select vp.id_permesso into idpermesso from rbac.vw_permessi vp where id_risorsa = idrisorsa and id_modalita = idmodalita;
		
		
		update rbac.ruolo_permessi 
		set id_permesso = idpermesso
		where id_permesso = idpermesso_pre_modifica;
		
		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_modalita_risorsa(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_modalita_sezione(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_modalita_sezione(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- START
        _id_modalita bigint;
        _id_ruolo_permesso bigint;
		R_RP rbac.vw_ruolo_permessi;
		R_P rbac.vw_permessi;
       	u json;
        proc_name varchar; -- END
	begin
		proc_name:='rbac.upd_modalita_sezione';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V_J=%', v_j;

		_id_modalita:=v_j->>'id_modalita';
		_id_ruolo_permesso:=v_j->>'id_ruolo_permesso';
		
		select * into R_RP from rbac.vw_ruolo_permessi
		where id_ruolo_permesso = _id_ruolo_permesso;
				
		select * into R_P from rbac.vw_permessi
		where id_sezione = R_RP.id_sezione
		and id_modalita = _id_modalita;

		update rbac.ruolo_permessi 
		set id_permesso = R_P.id_permesso
		where id = _id_ruolo_permesso;
		
		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_modalita_sezione(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_upd_ruolo(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_upd_ruolo(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- start
	    R_R rbac.ruoli;
		n bigint;
        proc_name varchar; -- end
	begin
		proc_name:='rbac.upd_upd_ruolo';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		
		raise notice 'V_J=%', v_j;

		R_R.id:= v_j->>'id';
		R_R.sigla:= v_j->>'sigla';
		R_R.descr:= v_j->>'descr';

		R_R.sigla:= upper(trim(R_R.sigla));
		R_R.descr:= trim(R_R.descr);

		select count(*) into n from rbac.ruoli r
		where r.sigla = R_R.sigla and r.id != R_R.id;

		if n > 0 then
		ret:=rbac_ui.build_ret(ret,proc_name,'sigla_ruolo_gia_inserito');
			return ret;
		end if;			

		select count(*) into n from rbac.ruoli r
		where r.descr = R_R.descr and r.id != R_R.id;

		if n > 0 then
		ret:=rbac_ui.build_ret(ret,proc_name,'descr_ruolo_gia_inserito');
			return ret;
		end if;
	
		update rbac.ruoli
		set sigla = R_R.sigla,
			descr = R_R.descr
		where id = R_R.id;
		
	
		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_upd_ruolo(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_upd_struttura_utente(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_upd_struttura_utente(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- start
		inizio timestamp;
		fine timestamp;
		v_id_utente_struttura bigint;
        proc_name varchar; -- end
	begin
		proc_name:='rbac.upd_upd_struttura_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		
		raise notice 'V_J=%', v_j;
		
		inizio:=v_j->>'inizio';
		fine:=v_j->>'fine';

		if inizio >= fine then
			ret.esito:=false;	
    		ret:=rbac_ui.build_ret(ret,proc_name,'inizio_e_fine_validita_non_compatibili');
			ret.info='0';
			return ret;
		end if;
		--tsrange(inizio,fine,'[)');
		v_id_utente_struttura=v_j->>'id_struttura';

		update rbac.utente_strutture
		set validita = tsrange(inizio,fine,'[)')
		where id = v_id_utente_struttura;
	
		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_upd_struttura_utente(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_upd_utente(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_upd_utente(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- start
	    v_id_utente bigint;
		v_id_qualifica bigint;
		v_mail varchar;
		v_tel varchar;
        inizio timestamp;
        fine timestamp;
        proc_name varchar; -- end
	begin
		proc_name:='rbac.upd_upd_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		
		raise notice 'V_J=%', v_j;
		
		v_id_utente:=v_j->>'id_utente';
		v_id_qualifica:= v_j->>'id_qualifica';
		v_mail:= v_j->>'mail';
		v_tel:= v_j->>'tel';
		inizio:=v_j->>'inizio';
		fine:=v_j->>'fine';
		--tsrange(inizio,fine,'[)');

		if inizio >= fine then
			ret.esito:=false;	
    		ret:=rbac_ui.build_ret(ret,proc_name,'inizio_e_fine_validita_non_compatibili');
			ret.info='0';
			return ret;
		end if;
	
		update rbac.utenti u
		set id_qualifica = v_id_qualifica,
			mail = v_mail,
			tel = v_tel,
			validita =  tsrange(inizio,fine,'[)')
		where id = v_id_utente;
	
		ret.esito:=true;
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_upd_utente(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_utente_struttura_ruolo(json, bigint); Type: FUNCTION; Schema: rbac; Owner: postgres
--

CREATE FUNCTION rbac.upd_utente_struttura_ruolo(v_j json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret rbac_types.result_type; -- start
	    R_US rbac.utente_strutture;
        proc_name varchar; -- end
        idruolo bigint;
       	idutentestruttura bigint;
       
	begin
		proc_name:='rbac.upd_utente_struttura_ruolo';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		
		raise notice 'V_J=%', v_j;
	
		idruolo:=v_j->>'id_ruolo';
		idutentestruttura:=v_j->>'id_utente_struttura';
	
		insert into rbac.utente_strutture_ruoli 
		values (nextval('rbac.utente_strutture_ruoli_id_seq'),idutentestruttura,idruolo)
		on conflict(id_utente_struttura) do update set id_ruolo = idruolo;
	
		ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idnominativostruttura);
	    ret:=rbac_ui.build_ret(ret,proc_name, 'salvataggio_effettuato_con_successo');
	   	ret.info = '0';
 		return ret;
	end;
END
$$;


ALTER FUNCTION rbac.upd_utente_struttura_ruolo(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_qualifiche(json, bigint); Type: FUNCTION; Schema: rbac_conf; Owner: postgres
--

CREATE FUNCTION rbac_conf.get_qualifiche(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;

	begin
		proc_name:='rbac_conf.get_titoli';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');

		select json_agg(row_to_json(a.*)) into rt   from (select * from rbac_conf.vw_qualifiche order by sigla) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac_conf.get_qualifiche(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_risorse(json, bigint); Type: FUNCTION; Schema: rbac_conf; Owner: postgres
--

CREATE FUNCTION rbac_conf.get_risorse(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint; 
	idruolo bigint;   
	proc_name varchar;
	rt json;

	begin
		proc_name:='rbac_conf.get_risorse';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		idruolo:=v->'id_ruolo';
		

		/*select json_agg(row_to_json(a.*)) into rt   from (select * from rbac_conf.vw_risorse vr 
		where id_risorsa not in(
			select vrp.id_risorsa 
			from rbac.vw_ruolo_permessi vrp  
			where vrp.id_ruolo = idruolo
		) 
		order by cod) a; */
	
		select json_agg(row_to_json(a.*)) into rt   from (select vr.*
				from rbac_conf.vw_risorse vr 
				left join rbac.vw_ruolo_permessi vrp on vr.id_risorsa = vrp.id_risorsa and vrp.id_ruolo = idruolo
				where vrp.id_ruolo is null
				order by cod) a;
			
		
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac_conf.get_risorse(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: end_op(character varying, bigint, character varying); Type: FUNCTION; Schema: rbac_log; Owner: postgres
--

CREATE FUNCTION rbac_log.end_op(pname character varying, idtransazione bigint, v character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	begin
		insert into rbac_log.call_logs   values (nextval('rbac_log.call_logs_id_seq'),idtransazione,pname,'END',CLOCK_TIMESTAMP(),v);
		/*if length(v)>0 then
			update rbac_log.operazioni set ret=v,ts_end=CLOCK_TIMESTAMP()
			where id_transazione=idtransazione and ret is null and procedura=pname;
		else
			update rbac_log.operazioni set ret=v,ts_end=CLOCK_TIMESTAMP()
			where id_transazione=idtransazione and ret is null and procedura=pname;
		end if;*/
		return(currval('rbac_log.call_logs_id_seq'));
	end;
END
$$;


ALTER FUNCTION rbac_log.end_op(pname character varying, idtransazione bigint, v character varying) OWNER TO postgres;

--
-- Name: get_id_transazione(bigint, character varying); Type: FUNCTION; Schema: rbac_log; Owner: postgres
--

CREATE FUNCTION rbac_log.get_id_transazione(iduser bigint, titolo character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare R_T rbac_log.transazioni%ROWTYPE;
	begin
		R_T.id=nextval('rbac_log.transazioni_id_seq');
		R_T.id_user=iduser;
		R_T.ts:=current_timestamp;
		R_T.descr:=titolo;
		insert into rbac_log.transazioni values (R_T.*);
		return R_T.id;
	end;
END
$$;


ALTER FUNCTION rbac_log.get_id_transazione(iduser bigint, titolo character varying) OWNER TO postgres;

--
-- Name: op(character varying, bigint, character varying, json, timestamp without time zone, bigint, character varying); Type: FUNCTION; Schema: rbac_log; Owner: postgres
--

CREATE FUNCTION rbac_log.op(pname character varying, idtransazione bigint, param character varying, v json, tsstart timestamp without time zone, idtrattato bigint DEFAULT '-1'::integer, tipooperazione character varying DEFAULT ''::character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	stmt varchar;
	begin
		insert into rbac_log.operazioni  
			(id,id_transazione,procedura,fase,ts_start,ts_end,ts_transazione,val,id_trattato,ret) 
		values 
			(nextval('rbac_log.operazioni_id_seq'),idtransazione,pname,tipooperazione,tsstart,CLOCK_TIMESTAMP(),current_timestamp,param,
			idtrattato,    						 '"esito":' ||coalesce(v->>'esito','')  ||
				',"valore":'||coalesce(v->>'valore','') ||
				',"msg":'   ||coalesce(v->>'msg'  ,''));

    	return(currval('rbac_log.operazioni_id_seq'));
	end;
END
$$;


ALTER FUNCTION rbac_log.op(pname character varying, idtransazione bigint, param character varying, v json, tsstart timestamp without time zone, idtrattato bigint, tipooperazione character varying) OWNER TO postgres;

--
-- Name: start_op(character varying, bigint, character varying, bigint); Type: FUNCTION; Schema: rbac_log; Owner: postgres
--

CREATE FUNCTION rbac_log.start_op(pname character varying, idtransazione bigint, param character varying, idtrattato bigint DEFAULT '-1'::integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	begin
		insert into rbac_log.call_logs   values (nextval('rbac_log.call_logs_id_seq'),idtransazione,pname,'START',CLOCK_TIMESTAMP(),param);
		--insert into rbac_log.operazioni  (id,id_transazione,procedura,fase,ts_start,ts_transazione,val,id_trattato) values 
	--(nextval('rbac_log.operazioni_id_seq'),idtransazione,pname,'START',CLOCK_TIMESTAMP(),current_timestamp,param,idtrattato);
		return(currval('rbac_log.call_logs_id_seq'));
	end;
END
$$;


ALTER FUNCTION rbac_log.start_op(pname character varying, idtransazione bigint, param character varying, idtrattato bigint) OWNER TO postgres;

--
-- Name: upd_record(character varying, bigint, record, character varying); Type: FUNCTION; Schema: rbac_log; Owner: postgres
--

CREATE FUNCTION rbac_log.upd_record(tbl character varying, idtransazione bigint, r record, act character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	r_new record;
	begin
		act = upper(act);
		raise notice 'TBL=% ACT=%',tbl,act;
		if act = 'D' or act = 'U' then
			raise notice 'D U TBL %',tbl;
			case   tbl 
				when 'rbac.ruoli'      then
					update rbac_his.ruoli             					set his_validita=tsrange(lower(his_validita),current_timestamp::timestamp,'[)')
						where id=R.id and upper_inf(his_validita);
			else
				return -1;
			end case;
		end if;
		if act = 'U' or act = 'I' then
			raise notice 'I U TBL %',tbl;
					raise notice 'D U TBL %',tbl;
			case   tbl 
				when 'rbac.ruoli'      then 
					insert into rbac_his.ruoli
						select nextval('rbac_log.his_id_seq'),tsrange(current_timestamp::timestamp,null,'[)'),idtransazione,clock_timestamp(),current_timestamp, e.*        
							from rbac.ruoli e where id=r.id;				

			else
				return -1;
			end case;
		end if;
		return 0;
	end;
END
$$;


ALTER FUNCTION rbac_log.upd_record(tbl character varying, idtransazione bigint, r record, act character varying) OWNER TO postgres;

--
-- Name: get_dati(character varying, character varying, bigint, json); Type: PROCEDURE; Schema: rbac_srv; Owner: postgres
--

CREATE PROCEDURE rbac_srv.get_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json)
    LANGUAGE plpgsql
    AS $$
begin
	declare
		proc_name varchar;
	begin
		proc_name:='rbac_srv.get_dati';
		call rbac.get_dati(operazione,v,idutente,joutput);
	end;
END
$$;


ALTER PROCEDURE rbac_srv.get_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json) OWNER TO postgres;

--
-- Name: upd_dati(character varying, character varying, bigint, json); Type: PROCEDURE; Schema: rbac_srv; Owner: postgres
--

CREATE PROCEDURE rbac_srv.upd_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json)
    LANGUAGE plpgsql
    AS $$

	declare
		proc_name varchar;
	begin
		proc_name:='rbac_srv.upd_dati';
		call rbac.upd_dati(operazione,v,idutente,joutput);

	end;

$$;


ALTER PROCEDURE rbac_srv.upd_dati(IN operazione character varying, IN v character varying, IN idutente bigint, INOUT joutput json) OWNER TO postgres;

--
-- Name: get_modalita(json, bigint); Type: FUNCTION; Schema: rbac_types; Owner: postgres
--

CREATE FUNCTION rbac_types.get_modalita(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;

	begin
		proc_name:='rbac_types.get_modalita';
		ret.esito:=false;
		id_op:=rbac_log.start_op(proc_name,idtransazione ,'');

		select json_agg(row_to_json(a.*)) into rt from (select * from rbac_types.vw_modalita vm order by sigla) a;
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||coalesce(rt,'[]')||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac_types.get_modalita(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: build_ret(ag_types.result_type, character varying, character varying); Type: FUNCTION; Schema: rbac_ui; Owner: postgres
--

CREATE FUNCTION rbac_ui.build_ret(r ag_types.result_type, pname character varying, val character varying) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	begin
		--r.valore:= val;
		--if not r.esito then
			--r.msg:=coalesce(r.msg,'') || ' ('|| coalesce(r.valore,-1)||')' ;
			r.msg:=/*coalesce(r.msg,'')||' '||CHR(13)||*/rbac_ui.get_proc_msg(pname,val);
			if r.msg is null then 
				r.msg:='Messaggio non presente in tabella '||val;
				r.err_msg :=' ['||coalesce(pname,'PROC UNDEFINED')||' ('||val||') ] ';
			end if;
		--end if;
		return r;
	end;
END
$$;


ALTER FUNCTION rbac_ui.build_ret(r ag_types.result_type, pname character varying, val character varying) OWNER TO postgres;

--
-- Name: build_ret(rbac_types.result_type, character varying, character varying); Type: FUNCTION; Schema: rbac_ui; Owner: postgres
--

CREATE FUNCTION rbac_ui.build_ret(r rbac_types.result_type, pname character varying, val character varying) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	begin
		--r.valore:= val;
		--if not r.esito then
			--r.msg:=coalesce(r.msg,'') || ' ('|| coalesce(r.valore,-1)||')' ;
			r.msg:=/*coalesce(r.msg,'')||' '||CHR(13)||*/ag_ui.get_proc_msg(pname,val);
			if r.msg is null then 
				r.msg:='Messaggio non presente in tabella '||val;
				r.err_msg :=' ['||coalesce(pname,'PROC UNDEFINED')||' ('||val||') ] ';
			end if;
		--end if;
		return r;
	end;
END
$$;


ALTER FUNCTION rbac_ui.build_ret(r rbac_types.result_type, pname character varying, val character varying) OWNER TO postgres;

--
-- Name: get_menu(json, bigint); Type: FUNCTION; Schema: rbac_ui; Owner: postgres
--

CREATE FUNCTION rbac_ui.get_menu(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	v_mn varchar;
	rt json;
	id_usr bigint;
	begin
		proc_name:='rbac.get_menu';
		raise notice 'rbac.get_menu';
		raise notice 'v=%',v;
		v_mn:=replace((v->'menu')::varchar,'"','');
		id_usr:=v->'user_info'->'id_utente_struttura_ruolo';

		raise notice 'v_menu=%', v_mn;
		raise notice 'id_usr=%', id_usr;
		if v_mn is null then
			ret.esito:=false;
			--ret.msg:='parametro menu non specificato';
		    ret:=rbac_ui.build_ret(ret,proc_name, 'parametro_menu_non_specificato');
			ret.info:=rt;
			return ret;
		end if;
				
		select json_agg(row_to_json(a.*)) into rt from (
			/*
			select distinct on (s.cod) s.cod, s.icon, usr.livello lev, s.ord, s.descr, lower(r.descr_modalita) modality
			from rbac.vw_utente_strutture_ruoli usr
			join rbac.vw_ruoli_inclusi_up_tree rr on usr.id_ruolo =rr.id_ruolo
			join rbac.vw_ruolo_permessi r on r.id_ruolo = usr.id_ruolo and r.cod_portale = v_mn
			join rbac_ui.vw_sezioni s on s.cod = r.cod_sezione and s.cod_portale = v_mn
			where usr.id_utente_struttura_ruolo = id_usr
			order by s.cod, peso desc, s.id_portale, s.ord
			*/
			select * from (
				select distinct on (s.cod) s.cod, s.icon, usr.livello lev, s.ord, s.descr, lower(r.descr_modalita) modality, s.visibile
				from rbac.vw_utente_strutture_ruoli usr
				join rbac.vw_ruoli_inclusi_up_tree rr on usr.id_ruolo = rr.id_ruolo
				join rbac.vw_ruolo_permessi r on r.id_ruolo = rr.id_ruolo_cto  and r.cod_portale = v_mn
				join rbac_ui.vw_sezioni s on s.cod = r.cod_sezione and s.cod_portale = v_mn
				where usr.id_utente_struttura_ruolo = id_usr
				order by s.cod, peso desc
			) s order by s.ord --subquery per il corretto ordinamentos
			
		) a;

		if v_mn = 'check' then
			select json_agg(row_to_json(a.*)) into rt from ( 
				select * from rbac_ui.vw_sezioni
			)a;
		end if;
		
		raise notice '%',json_array_length(rt);

    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=rt;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac_ui.get_menu(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_portali(json, bigint); Type: FUNCTION; Schema: rbac_ui; Owner: postgres
--

CREATE FUNCTION rbac_ui.get_portali(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret rbac_types.result_type; 
	proc_name varchar;
	user_info json;
	id_usr bigint;
	rt json;
	begin
		proc_name:='rbac_ui.get_portali';
		raise notice 'rbac_ui.get_portali';
		raise notice 'v=%',v;

		user_info:=v->'user_info';
		raise notice 'user_info=%',user_info;
		id_usr:=user_info->>'id_utente_struttura_ruolo';
		raise notice 'id_usr=%', id_usr;

		if v->'dev' then 
			select json_agg(row_to_json(a.*)) into rt from (
				select * from rbac_ui.portali
				where tipo_portale
			) a;
		else
			select json_agg(row_to_json(a.*)) into rt from (
				/*
				select distinct on (p.id_portale) p.* 
				from rbac.vw_utente_strutture_ruoli usr
				join rbac.vw_ruoli_inclusi_up_tree rr on usr.id_ruolo = rr.id_ruolo
				join rbac.vw_ruolo_permessi rp on rp.id_ruolo = usr.id_ruolo
				join rbac_ui.vw_sezioni s on s.cod = rp.cod_sezione and s.visibile
				join rbac_ui.vw_portali p on p.id = s.id_portale 
				where usr.id_utente_struttura_ruolo = id_usr and p.tipo_portale
				*/
				select distinct on (p.id_portale) p.* 
				from rbac.vw_utente_strutture_ruoli usr
				join rbac.vw_ruoli_inclusi_up_tree rr on usr.id_ruolo = rr.id_ruolo
				join rbac.vw_ruolo_permessi rp on rp.id_ruolo = rr.id_ruolo_cto 
				join rbac_ui.vw_sezioni s on s.cod = rp.cod_sezione and s.visibile
				join rbac_ui.vw_portali p on p.id = s.id_portale 
				where usr.id_utente_struttura_ruolo = id_usr and p.tipo_portale

			) a;
		end if;
		
		raise notice '%',json_array_length(rt);

    	ret.esito:=true;
 		ret.msg:=null;
		ret.info:='{"dati":'||coalesce(rt,'[]')||'}';
				  --',"user_info":'||coalesce(user_info,'{}')||'}';
	 	--ret.info:=rt;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac_ui.get_portali(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_sezioni(json, bigint); Type: FUNCTION; Schema: rbac_ui; Owner: postgres
--

CREATE FUNCTION rbac_ui.get_sezioni(v json, idtransazione bigint) RETURNS rbac_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret cu_types.result_type; 
	id_op bigint; 
	idruolo bigint;   
	proc_name varchar;
	rt json;

	begin
		proc_name:='rbac_ui.get_sezioni';
		ret.esito:=false;
		id_op:=cu_log.start_op(proc_name,idtransazione ,'');
		idruolo:=v->'id_ruolo';
		

		/*select json_agg(row_to_json(a.*)) into rt   from (select * from rbac_conf.vw_risorse vr 
		where id_risorsa not in(
			select vrp.id_risorsa 
			from rbac.vw_ruolo_permessi vrp  
			where vrp.id_ruolo = idruolo
		) 
		order by cod) a; */
	
		select json_agg(row_to_json(a.*)) into rt   from (select s.*
				from rbac_ui.vw_sezioni s 
				left join rbac.vw_ruolo_permessi vrp on s.id_sezione = vrp.id_sezione and vrp.id_ruolo = idruolo
				where vrp.id_ruolo is null and s.visibile
				order by s.id_portale,s.ord) a;
			
		
	
		ret.esito:=true;
	 	ret.info:='{"dati":'||rt||'}';

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION rbac_ui.get_sezioni(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ui_definition(character varying, character varying, bigint, bigint); Type: FUNCTION; Schema: rbac_ui; Owner: postgres
--

CREATE FUNCTION rbac_ui.get_ui_definition(type_info character varying, fnct character varying, id_ns bigint, idtransazione bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare
	R_NS matrix.vw_nominativi_struttura;
	R_GD rbac_ui.grid_definition;
	proc_name varchar;
	begin
		proc_name:='rbac_ui.get_ui_definition';
		raise notice 'type_info % fcnt % id_ns %',type_info,fnct,id_ns;

		case type_info
			when  'grid' then
			
				select * into R_GD from rbac_ui.grid_definition gd join matrix.vw_tree_nodes_down t on t.id_node_ref=gd.id_user
					where t.id_node=id_ns and funct=fnct order by dist_node limit 1;
				/*select * into R_GD from ag_ui.grid_definition gd where gd.id_user =id_ns  and funct=fnct;
				if R_GD.id_user is null then
					select * into R_NS from matrix.vw_nominativi_struttura ns where id=id_ns;
	
					select * into R_GD from ag_ui.grid_definition gd join matrix.vw_tree_nodes_down t on t.id_node_ref=gd.id_user
					where t.id_node=R_NS.id_node_struttura and funct=fnct order by dist_node limit 1;
				end if;*/
			else
				select * into R_GD from rbac_ui.grid_definition gd --join matrix.vw_tree_nodes_down t on t.id_node_ref=gd.id_user
					where /*t.id_node=id_ns and */ funct=fnct /*order by dist_node*/ limit 1;
		end case;
		return R_GD.str_conf;
	end;
end;
$$;


ALTER FUNCTION rbac_ui.get_ui_definition(type_info character varying, fnct character varying, id_ns bigint, idtransazione bigint) OWNER TO postgres;

--
-- Name: build_att_forfet(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.build_att_forfet(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idasl bigint;
        idns bigint;
        R trf.trf_attivita_forfet%ROWTYPE;
        n integer;
        proc_name varchar; -- end
        _anno text;
        begin
		proc_name:='trf.build_att_forfet';
		idasl:=v_j->'user_info'->'id_asl';
		raise notice 'idasl=%',idasl;
		idns:=v_j->'user_info'->'id_utente';
		raise notice 'idns=%',idns;
		_anno:=v_j->>'anno';
		raise notice 'anno=%',_anno;

		insert into trf.servizi 
		select nextval('agenda.agenda_id_seq'),descr,id_tml,'forfettario' from (
		select  distinct descr, id_tml from trf.vw_trf_forfettarie
		where (idasl =-1 or id_struttura=idasl) and descr not in (select descr from trf.servizi where type='forfettario')) a;

		insert into trf.clienti
		select nextval('agenda.agenda_id_seq'),null,id_linea,'linea', null from (
		select distinct id_linea from trf.vw_trf_forfettarie
		where (idasl =-1 or id_struttura=idasl) and id_linea not in (select id_ref from trf.clienti where type='linea')) a;

n:=0;
		for R in select 0 id,c.id c_id,s.id s_id, date_trunc('year', (_anno||'-01-01')::timestamp) ,
			 date_trunc('year', (_anno||'-01-01')::timestamp) + interval '1 year' -interval '1 day' data_da ,
			idns,null note,t.valore,t.id_tariffa, t.id_asl,id_tml,'forfettario' id_type_attivita,false closed,null,null, 1
			from trf.vw_trf_forfettarie t
				join trf.servizi s on s."type" ='forfettario' and t.descr=s.descr 
				join trf.clienti c on c.id_ref=t.id_linea and c."type" ='linea'
			where (idasl =-1 or id_struttura=idasl) and (c.id,s.id, date_trunc('year', (_anno||'-01-01')::timestamp)) not in 
													(select id_cliente,id_servizio,data_da from trf.trf_attivita_forfet) loop
			R.id:=nextval('agenda.agenda_id_seq');
			insert into trf.trf_attivita_forfet values (R.*);	
			insert into trf.trf_attivita_dettagli_forfet values (nextval('agenda.agenda_id_seq'),R.id,R.id_tariffa,R.imponibile,R.imponibile::numeric);
		n:=n+1;
		end loop;
													
		--GET DIAGNOSTICS n = ROW_COUNT;
        
    	ret.esito:= true;
    	ret.msg := 'Generati '||n||' elementi';
		--ret:=ag_ui.build_ret(ret,proc_name,);
		return ret;
	end;
END
$$;


ALTER FUNCTION trf.build_att_forfet(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: calcola_costo(bigint, numeric); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.calcola_costo(idtrf bigint, q numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
begin
	declare
		prezzo numeric;
	begin
		select GREATEST (sum (case 
					when c.tipo=0 then c.valore          -- MINIMO
					else 0 end)   ,
				sum (case 
					when c.tipo=0 then 0
					when c.tipo=1 then c.valore          -- FISSO
					when c.tipo=2 then valore *(q- lower(scaglione)) -- SCAGLIONE
					when c.tipo=3 then valore *q else 0 end)) -- CUMULATIVO
		--prezzo_fisso+prezzo_base+prezzo_cumulativo*q+prezzo_scaglione * (q- lower(scaglione))
		into prezzo	from tariffa_voci vt
		join tariffa_voci_calcolo c on C.id_tariffa_voce =vt.id
		join tariffa_strutture ts on ts.id=vt.id_tariffa_struttura
		where ts.id_tariffa=idtrf and  scaglione @> q;
	raise notice 'PREZZO %', prezzo;
	return prezzo;
	end;
end;
$$;


ALTER FUNCTION trf.calcola_costo(idtrf bigint, q numeric) OWNER TO postgres;

--
-- Name: calcola_costo(bigint, numeric, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.calcola_costo(idtrf bigint, q numeric, idtrfstruttura bigint) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
begin
	declare
		prezzo numeric;
	begin
		raise notice 'idtrfstruttura %', idtrfstruttura;
		select GREATEST (sum (case 
					when c.tipo=0 then c.valore          -- MINIMO
					else 0 end)   ,
				sum (case 
					when c.tipo=0 then 0
					when c.tipo=1 then c.valore          -- FISSO
					when c.tipo=2 then valore *(q- lower(scaglione)) -- SCAGLIONE
					when c.tipo=3 then valore *q else 0 end)) -- CUMULATIVO
		--prezzo_fisso+prezzo_base+prezzo_cumulativo*q+prezzo_scaglione * (q- lower(scaglione))
		into prezzo	from tariffa_voci vt
		join tariffa_voci_calcolo c on C.id_tariffa_voce =vt.id
		join tariffa_strutture ts on ts.id=vt.id_tariffa_struttura
		where ts.id_tariffa=idtrf and  scaglione @> q and ts.id = idtrfstruttura;
	raise notice 'PREZZO %', prezzo;
	return prezzo;
	end;
end;
$$;


ALTER FUNCTION trf.calcola_costo(idtrf bigint, q numeric, idtrfstruttura bigint) OWNER TO postgres;

--
-- Name: calcola_costo(bigint, numeric, timestamp without time zone, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.calcola_costo(idtrf bigint, q numeric, dt timestamp without time zone, idasl bigint) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
begin
	declare
		prezzo numeric;
	begin
		select sum (case 
					when c.tipo=0 or c.tipo=1 then c.valore          -- FISSO o BASE
					when c.tipo=2 then valore *t.fact_equiv *(q- lower(scaglione)) -- SCAGLIONE
					when c.tipo=3 then valore *t.fact_equiv *q end)                -- CUMULATIVO
		--prezzo_fisso+prezzo_base+prezzo_cumulativo*q+prezzo_scaglione * (q- lower(scaglione))
		into prezzo	from tariffa_strutture ts join tariffa_voci vt on vt.id_tariffa_struttura=ts.id
		join vw_tariffe t on t.id_tariffa=ts.id_tariffa
		join tariffa_voci_calcolo c 
		on C.id_tariffa_voce =vt.id where ts.id_tariffa=idtrf and  scaglione @> q
				and ts.validita @>dt and (ts.id_asl=idasl or ts.id_asl is null);
	raise notice 'PREZZO %', prezzo;
	return prezzo;
	end;
end;
$$;


ALTER FUNCTION trf.calcola_costo(idtrf bigint, q numeric, dt timestamp without time zone, idasl bigint) OWNER TO postgres;

--
-- Name: del_tariffa(character varying, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.del_tariffa(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;   
        proc_name varchar; -- END
        idtariffa bigint;
        v_j json;
        n integer;
        idasl bigint;
       	R_T trf.tariffe;
       	R_T2 trf.tariffe;
       	R_TT matrix.tree_nodes;
       	v_validita tsrange;
       	R_STRUCT matrix.vw_tree_nodes_up_asl;
		idstrutturaasl bigint;
        begin
		proc_name:='trf.del_tariffa';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'V=%',v;
		v_j:=v::json;
		idtariffa:=replace((v_j->'id_tariffa')::text,'"','')::int8;
		--idasl:=v_j->'user_info'->'id_tariffa';
		idasl:=v_j->'user_info'->'id_asl';
		raise notice 'idasl%',idasl;
		idstrutturaasl=v_j->'user_info'->'id_struttura';
		select * into R_STRUCT from matrix.vw_tree_nodes_up_asl vtnua where id_node=idstrutturaasl;
		select * into R_T from trf.tariffe where id = idtariffa;
		select count(*) into n from matrix.tree_nodes where id_parent =idtariffa;
		if  n > 0 then
			ret.esito:=false;
			ret.valore:= null;
			--ret.msg:=proc_name || ': id '||(v_j->'id')::varchar|| ' ha dei nodi sottostanti';
			ret:=ag_ui.build_ret(ret,proc_name,'tariffa_con_nodi_sottostanti');
			RAISE notice '%', ret;
			return ret;
		end if;
		if idasl=-1 or R_STRUCT.n_livello = 0 then
			select validita into v_validita from trf.tariffa_strutture where id_tariffa=idtariffa;
			raise notice 'data oggi%',current_timestamp::timestamp without time zone;
			raise notice 'validita%',v_validita;
			if lower(v_validita) < current_timestamp::timestamp without time zone
			then 
				raise notice 'entrato minore asl -1';
				update trf.tariffa_strutture 
				set validita = tsrange(lower(validita),current_timestamp::timestamp without time zone, '[)')
				where id_tariffa=idtariffa;
				--delete from trf.tariffa_strutture  where id_tariffa=idtariffa;
				update trf.tariffe 
				set validita = tsrange(lower(validita),current_timestamp::timestamp without time zone, '[)')
				where id = idtariffa returning * into R_T;
				raise notice 'R_T%',R_T;
				--delete from trf.tariffe where id=idtariffa;	
				n:=ag_log.upd_record('trf.tariffe',idtransazione,R_T,'D');
			elsif lower(v_validita) > current_timestamp::timestamp without time zone
			then
				raise notice 'entrato maggiore asl -1';
				raise notice 'intervallo 1 giorno%',lower(v_validita) + interval '1 day';
				update trf.tariffa_strutture 
				set validita = tsrange(lower(validita),lower(validita) + interval '1 day', '[)')
				where id_tariffa=idtariffa;
				--delete from trf.tariffa_strutture  where id_tariffa=idtariffa;
				update trf.tariffe 
				set validita = tsrange(lower(validita),lower(validita) + interval '1 day', '[)')
				where id = idtariffa returning * into R_T;
				raise notice 'R_T%',R_T;
				--delete from trf.tariffe where id=idtariffa;	
				n:=ag_log.upd_record('trf.tariffe',idtransazione,R_T,'D');
			end if;
			
		else
			if lower(v_validita) < current_timestamp::timestamp without time zone
			then 
				raise notice 'entrato minore';
				update trf.tariffa_strutture 
				set validita = tsrange(lower(validita),current_timestamp::timestamp without time zone, '[)')
				where id_tariffa=idtariffa and id_asl =idasl;
				--delete from trf.tariffa_strutture  where id_tariffa=idtariffa and id_asl =idasl;
				select count(*) into n from trf.tariffa_strutture  where id_tariffa=idtariffa;
				if n = 0 then
					update trf.tariffe 
					set validita = tsrange(lower(validita),current_timestamp::timestamp without time zone, '[)')
					where id = idtariffa returning * into R_T2;
					raise notice 'R_T2%',R_T2;
					--delete from trf.tariffe where id=idtariffa;
					n:=ag_log.upd_record('trf.tariffe',idtransazione,R_T2,'D');
				end if;
			elsif lower(v_validita) > current_timestamp::timestamp without time zone
			then
				raise notice 'entrato maggiore';
				update trf.tariffa_strutture 
				set validita = tsrange(lower(validita),lower(validita) + interval '1 day', '[)')
				where id_tariffa=idtariffa and id_asl =idasl;
				--delete from trf.tariffa_strutture  where id_tariffa=idtariffa and id_asl =idasl;
				select count(*) into n from trf.tariffa_strutture  where id_tariffa=idtariffa;
				if n = 0 then
					update trf.tariffe 
					set validita = tsrange(lower(validita),lower(validita) + interval '1 day', '[)')
					where id = idtariffa returning * into R_T2;
					raise notice 'R_T2%',R_T2;
					--delete from trf.tariffe where id=idtariffa;
					n:=ag_log.upd_record('trf.tariffe',idtransazione,R_T2,'D');
				end if;
			end if;
			
		end if;

		GET DIAGNOSTICS n = ROW_COUNT;
		if  n <=0 then
			ret.esito:=false;
			ret.valore:= null;
			ret.msg:=proc_name || ': id '||idtariffa|| ' inesistente';
			RAISE notice '%', ret;
			return ret;
		end if;

		--delete from matrix.tree_nodes where id=idtariffa;
		update matrix.tree_nodes 
		set validita = tsrange(lower(validita),current_timestamp::timestamp without time zone, '[)')
		where id = idtariffa returning * into R_TT;
		n:=ag_log.upd_record('agenda.tree_nodes',idtransazione,R_TT,'D');
    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
        ret:=ag_ui.build_ret(ret,proc_name,'tariffa_eliminata_correttamente');
		ret.info='0';
 
		return ret;
	end;
END
$$;


ALTER FUNCTION trf.del_tariffa(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: del_tariffa_ml(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.del_tariffa_ml(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
       	idml bigint;
        R record;
        idtariffa bigint;
        proc_name varchar; -- end
        str varchar;

        begin
		proc_name:='trf.del_tariffa_ml';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--v_j:=v::json;
		idtariffa:=v_j->'id_tariffa_ml';
		if idtariffa is null then
				idtariffa:=v_j->'id';
		end if;
		raise notice 'ID_TARIFFA_ML=%',idtariffa;

		raise notice 'STR=%',str;
		if idtariffa = null then
			    ret.esito:=false;	
			   ret.msg:='ID non selezionato';
			    return ret;
		end if;
		select * into R from trf.tariffa_ml where id=idtariffa;
		delete from trf.tariffa_ml_livello where id_tariffa_ml=idtariffa;
	    delete from trf.tariffa_ml where id =idtariffa;
	    select id into idml from trf.tariffa_ml 
	     where id_linea_attivita =R.id_linea_attivita order by validita desc limit 1;
	    if idml is not null then
	    	update trf.tariffa_ml set validita=tsrange(lower(validita),null,'[)')
	    	where id=idml;
	    end if;
    	ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
        ret:=ag_ui.build_ret(ret,proc_name,'eliminazione_avvenuta_con_successo');
        ret.info='0';
		return ret;
	end;
END
$$;


ALTER FUNCTION trf.del_tariffa_ml(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: del_tariffa_struttura(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.del_tariffa_struttura(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idtariffa bigint;
        idtariffastruttura bigint;
        proc_name varchar; -- end
        str varchar;
       r record;

        begin
		proc_name:='trf.del_tariffa_struttura';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--v_j:=v::json;
		idtariffastruttura:=v_j->'id_tariffa_struttura';
		if idtariffastruttura is null then
			idtariffastruttura:=v_j->'id';
		end if;
	
		raise notice 'ID_TARIFFA_STRUTTURA=%',idtariffastruttura;

		raise notice 'STR=%',str;
		if idtariffastruttura = null then
			ret.esito:=false;
			ret.msg:='ID non selezionato';
			return ret;
		end if;
	
		select * into R from trf.tariffa_strutture ts where id=idtariffastruttura;
	
		if R.id is not null then
			select id into idtariffa from trf.tariffe where id=R.id_tariffa
			order by validita desc limit 1;
		end if;
		
		if idtariffa is not null then
			update trf.tariffa_strutture set validita = tsrange(lower(validita),null,'[)') where id=idtariffa;
		end if;
		
		delete from trf.tariffa_voci where id_tariffa_struttura=idtariffastruttura;
	   -- delete from trf.tariffa_strutture where id =idtariffastruttura;
    	ret.esito:=true;
    	
		ret:=ag_ui.build_ret(ret,proc_name,'tariffa_cancellata');
	    ret.info:='0';
		return ret;
	end;
END
$$;


ALTER FUNCTION trf.del_tariffa_struttura(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_att_dati_da_inviare(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_att_dati_da_inviare(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint; 
	proc_name varchar;
	rt json;
	begin
		proc_name:='trf.get_att_dati_da_inviare';
		--id_trf_attivita al posto di id nella select
		select json_agg(row_to_json(a.*)) into rt from (
			select id , str_j from trf.trf_att_inviate tai 
			where id in (select (value::varchar)::bigint from json_array_elements(v_j->'id_trf_att_inviate') ))a;
	
		if json_array_length(rt) <= 0 then
			ret.esito:=true;	
			ret:=ag_ui.build_ret(ret,proc_name,'attività_da_inviare_non_trovate');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_att_dati_da_inviare(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_att_forf_riep(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_att_forf_riep(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;

	begin
		proc_name:='trf.get_att_forf_riep';
		raise notice 'v=%',v;

		select json_agg(row_to_json(g.*)) into rt from (
			select * from trf.vw_trf_att_forf_riep
		) g;

		raise notice '%',json_array_length(rt);
		ret.esito:=true;	
		ret.info:=rt;
		if json_array_length(rt) is null then
    		--ret.msg:='linee per calendario non trovate per le impostazioni attuali';
    	    --ret:=ag_ui.build_ret(ret,proc_name, 'nessun_riepilogo');
    		--ret.info:=null; 
		ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'nessun_riepilogo');
	  ret.info = null;
    	else
 			ret.msg:=null;
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_att_forf_riep(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_attivita(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_attivita(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idrisorsa bigint;
	proc_name varchar;
	R_ASL matrix.struttura_asl;
	R_EV agenda.vw_calendari%ROWTYPE;
	idstrutturaroot bigint;
	responsabile bool;
	rt json;

	begin
		proc_name:='trf.get_attivita';
		idrisorsa:=((v_j->>'user_info')::json)->'id_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		idstrutturaroot:=((v_j->>'user_info')::json)->'id_struttura_root';
		responsabile:=v_j->'user_info'->'responsabile';
		raise notice 'id risorsa: %', idrisorsa;
		select * into R_ASL from matrix.struttura_asl sa where id=idstrutturaroot;
		if responsabile then
			select json_agg(row_to_json(a.*)) into rt from (
				select *, not closed selezionabile,not closed selezionabile_cliente
				from trf.vw_trf_attivita a
				where per_conto_di =R_ASL.id_asl
				order by closed, data_da
			) a;
		else
			select json_agg(row_to_json(a.*)) into rt from (
				select *, not closed selezionabile, not closed selezionabile_cliente
				from trf.vw_trf_attivita a
				where id_trf_operatore = idrisorsa
				order by closed, data_da
			) a;
		end if;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=true;	
    		--ret.msg:='attivita non trovate';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'attività_non_trovate');
    		ret.info:=null; 
    	
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_attivita(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_attivita_by_sel(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_attivita_by_sel(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idrisorsa bigint;
	proc_name varchar;
	R_ASL matrix.struttura_asl;
	R_EV agenda.vw_calendari%ROWTYPE;
	idstrutturaroot bigint;
	responsabile bool;
	rt json;
	v_cliente varchar;
	v_servizio varchar;
	v_data_inizio timestamp;
	v_data_fine timestamp;
	v_periodo json;
	v_operatore varchar;
	v_indirizzo varchar;
	v_tariffa varchar;
	v_stato varchar;
	v_limite int;
	--idutente bigint;
	begin
		proc_name:='trf.get_attivita_by_sel';
		idrisorsa:=((v->>'user_info')::json)->'id_utente';
		--select id_anagrafica into idanagrafica from rbac.vw_utente_strutture where id_nominativo=idrisorsa;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		idstrutturaroot:=((v->>'user_info')::json)->'id_struttura_root';
		responsabile:=v->'user_info'->'responsabile';
		raise notice 'id risorsa: %', idrisorsa;
		if v->>'periodo' != '' then
			v_periodo:=v->>'periodo';
			raise notice 'fine v_periodo%', v_periodo->>'end';
			if v_periodo->>'start' != '' then
				v_data_inizio:=to_timestamp(v_periodo->>'start'::varchar, 'YYYY-MM-DD');
			end if;
			if v_periodo->>'end' != '' then
				v_data_fine:=to_timestamp(v_periodo->>'end'::varchar, 'YYYY-MM-DD');
					if length(v_periodo->>'end')<=10 then
						v_data_fine:= v_data_fine + interval '1 day';
					end if;
			end if;

		end if;
	
		raise notice 'start %',v_data_inizio;
		raise notice 'end %', v_data_fine;

		if v->>'limite' is not null then
			v_limite:=v->>'limite';
		end if;
		if v->>'cliente' is not null then
			v_cliente:=replace('%'||cu_anag.string_normalize(v->>'cliente')||'%',' ','%');
		end if;
		if v->>'servizio' is not null then
			v_servizio:=replace('%'||cu_anag.string_normalize(v->>'servizio')||'%',' ','%');
		end if;
		if v->>'operatore' is not null then
			v_operatore:=replace('%'||cu_anag.string_normalize(v->>'operatore')||'%',' ','%');
		end if;
		if v->>'indirizzo' is not null then
			v_indirizzo:=replace('%'||cu_anag.string_normalize(v->>'indirizzo')||'%',' ','%');
			--v_indirizzo:=v->>'indirizzo';
		end if;
		if v->>'tariffa' is not null then
			v_tariffa:=replace('%'||cu_anag.string_normalize(v->>'tariffa')||'%',' ','%');
		end if;
		if v->>'stato' is not null then
			v_stato:=v->>'stato';
		end if;
		
		raise notice 'v%',v;	
	
		select * into R_ASL from matrix.struttura_asl sa where id=idstrutturaroot;
		if responsabile then
			select json_agg(row_to_json(a.*)) into rt from (
				select *, not closed selezionabile,not closed selezionabile_cliente
				from trf.vw_trf_attivita a
				--per_conto_di =R_ASL.id_asl or
				--and v_indirizzo = '%%'
				where 
				per_conto_di =R_ASL.id_asl and ((coalesce(descr_cliente, '') ilike '%'||v_cliente||'%' or (v_cliente is null))
			and (coalesce(descr_servizio,'') ilike '%'||v_servizio||'%' or (v_servizio is null))
			and (v_data_inizio is null or data_da >= v_data_inizio)
			and (data_a <= v_data_fine or v_data_fine is null ) 
			and (coalesce(sigla_tariffa,'') ilike '%'||v_tariffa||'%' or (v_tariffa is null))
			and (coalesce(descr_trf_operatore,'') ilike '%'||v_operatore||'%' or (v_operatore is null))
			and (coalesce(indirizzo_completo,'') ilike '%'||v_indirizzo||'%' or (v_indirizzo is null ))
			and (coalesce(closed_str,'') ilike '%'||v_stato||'%' or (v_stato is null))
			)
				order by closed, data_da limit v_limite
			) a;
		else
			select json_agg(row_to_json(a.*)) into rt from (
				select *, not closed selezionabile, not closed selezionabile_cliente
				from trf.vw_trf_attivita a
				--id_trf_operatore = idrisorsa or
				where id_trf_operatore = idrisorsa and ((coalesce(descr_cliente, '') ilike '%'||v_cliente||'%' or (v_cliente is null))
			and (coalesce(descr_servizio,'') ilike '%'||v_servizio||'%' or (v_servizio is null))
			and (v_data_inizio is null or data_da >= v_data_inizio)
			and (data_a <= v_data_fine or v_data_fine is null ) 
			and (coalesce(sigla_tariffa,'') ilike '%'||v_tariffa||'%' or (v_tariffa is null))
			and (coalesce(descr_trf_operatore,'') ilike '%'||v_operatore||'%' or (v_operatore is null))
			and (coalesce(indirizzo_completo,'') ilike '%'||v_indirizzo||'%' or (v_indirizzo is null))
			and (coalesce(closed_str,'') ilike '%'||v_stato||'%' or (v_stato is null))
			)
				order by closed, data_da limit v_limite
			) a;
		end if;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=true;	
    		--ret.msg:='attivita non trovate';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'attività_non_trovate');
    		ret.info:=null; 
    	
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:='{"dati":'||coalesce(rt,'[]')||'}';
		end if;
	
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_attivita_by_sel(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_attivita_fatturabili(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_attivita_fatturabili(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idstrutturaroot bigint;
	proc_name varchar;
	R_EV agenda.vw_calendari%ROWTYPE;
	R_ASL record;
	rt json;

	begin
		proc_name:='trf.get_attivita_fatturabili';
		idstrutturaroot:=((v_j->>'user_info')::json)->'id_struttura_root';
		select *into R_ASL from matrix.struttura_asl sa where id=idstrutturaroot;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from 
		(select *, id_fattura is null selezionabile,numero_fattura fattura from trf.vw_trf_attivita a
		where per_conto_di =R_ASL.id_asl and closed) a;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=true;	
    		--ret.msg:='attivita fatturabili non trovate';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'attivita_fatturabili_non_trovate');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_attivita_fatturabili(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_attivita_forfet(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_attivita_forfet(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idrisorsa bigint;
	proc_name varchar;
	R_EV agenda.vw_calendari%ROWTYPE;
	rt json;
	v_anno integer;

	begin
		proc_name:='trf.get_attivita_forfet';
		idrisorsa:=((v_j->>'user_info')::json)->'id_utente';
		v_anno:=v_j->'anno';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'id risorsa: %', idrisorsa;
		select json_agg(row_to_json(a.*)) into rt from (
			select *,not finale selezionabile from trf.vw_trf_attivita_forfet a
		where id_trf_operatore =idrisorsa and extract( year from data_da)=v_anno order by data_da) a;
	
		raise notice 'NUMERO RECORD %',json_array_length(rt);
		--raise notice 'RET %',coalesce(rt,'');
		if json_array_length(rt) is null then
				raise notice '0 record';
    		--ret.msg:='attivita non trovate';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'attività_non_trovate');
    	   ret.esito:=true;
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_attivita_forfet(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_costo_simulato(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_costo_simulato(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idtariffa bigint;
	rt json;
	c numeric;
	str varchar;

	begin
		SET search_path TO tmp,public,trf;
		delete from tmp.tariffa_strutture ;
		delete from tmp.tariffa_voci ;
		delete from tmp.tariffa_voci_calcolo ;
		
		ret:=trf.upd_tariffa_voci((v)::varchar, idtransazione );
		if (ret.esito = false) then
			raise notice 'ERRORE SALVATAGGIO PARAMETRI TMP';
		else
			c:=trf.calcola_costo((v->'parametri'->'id_tariffa')::varchar::bigint, (v->'quantita')::varchar::numeric);
			ret.info:= '{"valore":'||c||'}';
			raise notice 'VALORE trf.calcola_costo % % % %', ret.valore , (v->'parametri'->'id_tariffa')::varchar::bigint, (v->'quantita')::varchar::numeric, (v->'parametri'->'dati'->0->'id_tariffa_struttura')::varchar::bigint;
			ret.esito:=true;
		end if;
		SET search_path TO trf,agenda,public;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_costo_simulato(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_fatt_forf_riep(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_fatt_forf_riep(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	rt json;

	begin
		proc_name:='trf.get_fatt_forf_riep';
		raise notice 'v=%',v;

		select json_agg(row_to_json(g.*)) into rt from (
			select * from trf.vw_trf_fatt_forf_riep
		) g;

		raise notice '%',json_array_length(rt);
		ret.esito:=true;	
		ret.info:=rt;
		if json_array_length(rt) is null then
    		--ret.msg:='linee per calendario non trovate per le impostazioni attuali';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'nessun_riepilogo');
    		--ret.info:=null; 
    	else
 			ret.msg:=null;
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_fatt_forf_riep(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_fattura(character varying, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_fattura(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	idtrffattura bigint;   
	proc_name varchar;
	R_FATT RECORD;
	rt json;
	v_j json;
	j_dett json;

	begin
		proc_name:='trf.get_fattura';
		v_j:= v::json;
		idtrffattura:=v_j->'id_trf_fattura';
		raise notice 'idtrffattura %',idtrffattura;
		--id_op:=gds_log.stavrt_op(proc_name,idtransazione ,'');
		select  f.id,f.id_cliente,f.data_creazione, f.descr,f.descr_tariffa, f.comune_fatturazione ,
		f.indirizzo_fatturazione , 
		  f.piva ,f.codfis  into R_FATT
	    from trf.vw_trf_fatture f where id_trf_fattura=idtrffattura;

	    select trf.get_fattura_dettagli(idtrffattura) into j_dett;
		ret.esito:=true;	
    	ret.msg:='';
	   	ret.info:='{"trfattivita":'||row_to_json(R_FATT)::varchar || ',"dettagli":'||j_dett::varchar||'}';
	   	--ret.info:=j_dett;
		return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_fattura(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_fattura_dettagli(bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_fattura_dettagli(idtrffattura bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
begin
	declare
	id_op bigint;
	R_FATT trf.trf_fatture%ROWTYPE;
idtariffa bigint;
	rt json;
	j_tree json;
    max_lev integer;
    struttura varchar;
   ui_default varchar;
	begin  

	ui_default:='{"colonne":[{"campo":"descrizione","intestazione":"Descrizione","tipo":"text","editabile": false},{"campo":"valore","intestazione":"Valore","tipo":"text","editabile": true}]}';

	select * into R_FATT from trf.trf_fatture where id=idtrffattura;
idtariffa:= R_FATT.id_tariffa;

WITH RECURSIVE c AS (
    SELECT id_node,id_node_parent ,sigla_tariffa ,descr_tariffa , 0 as livello 
    FROM matrix.vw_tree_nodes_tariffario_descr t 
    -- use parameters here, to select the root first
    WHERE id_node=idtariffa and visibile_fatt --2174 --AND id_parent IS NULL
  UNION ALL
    SELECT t.id_node,t.id_node_parent,t.sigla_tariffa,t.descr_tariffa, c.livello + 1 as livello
    FROM matrix.vw_tree_nodes_tariffario_descr t
    JOIN c ON t.id_node_parent = c.id_node and visibile_fatt
) select max(livello) into max_lev from c;
	struttura:= CASE WHEN MAX_LEV=3 THEN '[{"nome":"RADICE"},{"nome":"SEZIONI"},{"nome":"RIGHE"},{"nome":"COLONNE"}]' 
			         WHEN MAX_LEV=2 THEN '[{"nome":"RADICE"},{"nome":"SEZIONI"},{"nome":"RIGHE"}]'
			         WHEN MAX_LEV=1 THEN '[{"nome":"RADICE"},{"nome":"RIGHE"}]'
			         WHEN MAX_LEV=0 THEN '[{"nome":"RADICE"}]'end;
-- calculate node levels select array_to_json('{"prova","1"}'::varchar[])
WITH RECURSIVE c AS (
    SELECT path_ord,id_node,id_node_parent ,sigla_tariffa sigla,descr_tariffa descrizione, 0 as livello,d.costo valore,coalesce(u.ui_info_fatt,ui_default) ui_info
        ,array_to_json(
        	array_append(
        	    	array_append(
    					array_append(
    						array_append(null,t.descr_tariffa::varchar),
    						coalesce(d.valore::varchar,'')::varchar),
    						coalesce(uf.descr_in_fatt ,'')),
    						coalesce(d.costo::varchar ,'')))::varchar lista_valori
    FROM matrix.vw_tree_nodes_tariffario_descr t left join trf.trf_fattura_dettagli d on d.id_tariffa= t.id_node and d.id_trf_fattura=idtrffattura
    	left join trf_ui.trf_ui u on u.id_tariffa=t.id_node and visibile_fatt left join trf_ui.trf_ui_righe_fatt uf on uf.id_tariffa =t.id_node 
    WHERE id_node=idtariffa --2174 --AND id_parent IS NULL
  UNION ALL
    SELECT t.path_ord,t.id_node,t.id_node_parent,t.sigla_tariffa sigla ,t.descr_tariffa descrizione, c.livello + 1 as livello,d.costo valore,coalesce(u.ui_info_fatt,ui_default) ui_info
    ,array_to_json(
        	array_append(
        	    	array_append(
    					array_append(
    						array_append(null,t.descr_tariffa::varchar),
    						coalesce(d.valore::varchar,'')::varchar),
    						coalesce(uf.descr_in_fatt ,'')),
    						coalesce(d.costo::varchar ,'')))::varchar lista_valori
    FROM matrix.vw_tree_nodes_tariffario_descr t left join trf.trf_fattura_dettagli d on d.id_tariffa= t.id_node and d.id_trf_fattura=idtrffattura
    left join trf_ui.trf_ui u on u.id_tariffa=t.id_node  left join trf_ui.trf_ui_righe_fatt uf on uf.id_tariffa =t.id_node 
    JOIN c ON t.id_node_parent = c.id_node
    where visibile_fatt
),

-- select max level
max_livello AS (
  SELECT max(livello) max_livello FROM c
),
-- accumulate children
j AS (
    SELECT c.*, json '[]' sezioni -- at max level, there are only leaves
    FROM c, max_livello
    WHERE livello = max_livello
  UNION ALL
    -- a little hack, because PostgreSQL doesn't like aggregated recursive terms
    SELECT (c).*, array_to_json(array_agg(j  order by path_ord)) sezioni
    FROM (
      SELECT c, j,j.path_ord
      FROM j
      JOIN c ON j.id_node_parent = c.id_node order by j.path_ord
    ) v
    GROUP BY v.c
)
-- select only root
SELECT row_to_json(j) json_tree into j_tree
FROM j
WHERE livello = 0;

	struttura:= '{"struttura":'||struttura||',"dati":'||j_tree||'}';
raise notice 'STRUTTURA %',struttura;
	rt:= struttura::json;

	return rt;
	end;
end;
$$;


ALTER FUNCTION trf.get_fattura_dettagli(idtrffattura bigint) OWNER TO postgres;

--
-- Name: get_fatture(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_fatture(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV agenda.vw_calendari%ROWTYPE;
	rt json;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='trf.get_fatture';
		idstrutturaasl=v->'user_info'->'id_struttura_root';
		raise notice 'idstrutturaasl: %', idstrutturaasl;
		select * into R_ASL from matrix.struttura_asl where id=idstrutturaasl;
		--raise notice 'idasl: %', R_ASL.id_asl;
	
		select json_agg(row_to_json(a.*)) into rt from 
			(select a.*,s.ts::date as data_agg,s.descr_stato,p.n_ft_periodica,p.n_ft_periodica is null selezionabile  from trf.vw_trf_fatture a 
		join trf.vw_trf_fatture_ultimo_stato s on a.id_trf_fattura=s.id_trf_fattura
		left join trf.vw_trf_ft_periodiche_dett p on p.id_trf_fattura =a.id_trf_fattura
		where a.id_asl=R_ASL.id_asl order by a.data_creazione desc,a.numero_fattura desc) a;
	
		raise notice '%',json_array_length(rt);
	
		ret.esito:=true;
		if json_array_length(rt) is null then
            
			ret:=ag_ui.build_ret(ret,proc_name,'fatture_non_trovate');
    		--ret.msg:='fatture non trovate';
    		--ret.info:=null; 
    	else
    		--ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_fatture(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_fatture_da_eliminare(bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_fatture_da_eliminare(idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV agenda.vw_calendari%ROWTYPE;
	rt json;

	begin
		proc_name:='agenda.get_fatture';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from trf.vw_trf_fatture a;
	
		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='fatture non trovate';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'fatture_non_trovate');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_fatture_da_eliminare(idtransazione bigint) OWNER TO postgres;

--
-- Name: get_fatture_periodiche(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_fatture_periodiche(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV agenda.vw_calendari%ROWTYPE;
	rt json;
	idstrutturaasl bigint;
	R_ASL record;

	begin
		proc_name:='trf.get_fatture_periodiche';
		idstrutturaasl=v->'user_info'->'id_struttura_root';
		raise notice 'idstrutturaasl: %', idstrutturaasl;
		select * into R_ASL from matrix.struttura_asl where id=idstrutturaasl;
		--raise notice 'idasl: %', R_ASL.id_asl;
	
		select json_agg(row_to_json(a.*)) into rt from 
			(select * from trf.vw_trf_ft_periodiche vtfp) a;
		raise notice 'rt: %', rt;
		raise notice '%',json_array_length(rt);
	
		ret.esito:=true;
		if json_array_length(rt) is null then
            raise notice 'null';
			ret:=ag_ui.build_ret(ret,proc_name,'fatture_non_trovate');
    		--ret.msg:='fatture non trovate';
    		--ret.info:=null; 
    	else
    		--ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_fatture_periodiche(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_query_fattura_xml(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_query_fattura_xml(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $_$
begin
	declare
		ret ag_types.result_type;
		R record;
		R_REPLACE record;
		idtrffattura bigint;
      	--j json;
      	txt_xml varchar;
        stringa varchar;
      	testo_modificato varchar;
	begin
	idtrffattura:=v->'id_trf_fattura';
    raise notice 'FATTURA %',idtrffattura;
   if idtrffattura is null then
   	idtrffattura:=v->'id_fattura';
   end if;
      raise notice 'FATTURA %',idtrffattura;
	select json_agg(row_to_json(b.*)) into stringa from (
	select tf.testo as xmlstring from trf_conf.template_fatturazione tf where descr = 'GEFF_QUERY') b;
	raise notice 'txt_xml %',stringa;

/*
	testo_modificato:= stringa;
	for R in select row_to_json(c.*) j from trf.vw_dati_per_query_contabilita c where c.id_trf_fattura = idtrffattura 
	union all select row_to_json(p.*) from trf_conf.vw_ws_parameters p where application='GEFF' loop
		raise notice 'R.J %',R.j;
		for R_REPLACE in select key,coalesce(value,'') value from json_each_text(R.j) loop
			raise notice 'R_PLACE %',R_REPLACE;
			testo_modificato:=replace(testo_modificato,'$'||R_REPLACE.key||'$',replace(R_REPLACE.value,'&','e'));	
			raise notice 'TESTO_MODIFICATO %', testo_modificato;
		end loop;
		--update trf.trf_fattura_dettagli set stringa_xml=testo_modificato where id =R.id_fattura_dettaglio;
	end loop;
	*/


	testo_modificato:= stringa;


		for R_REPLACE in select a.key, a.val from trf_conf.vw_ws_parameters a where application='GEFF' loop
			raise notice 'R_REPLACE %',R_REPLACE;
			testo_modificato:=replace(testo_modificato,'$'||R_REPLACE.key||'$',replace(R_REPLACE.val,'&','e'));	
			raise notice 'TESTO_MODIFICATO %', testo_modificato;
		end loop;
	
	
	
	raise notice 'SELECT PER DATI FATTURA %',idtrffattura;
		for R in select c.id_fattura_dettaglio ,row_to_json(c.*) j from trf.vw_dati_per_contabilita c
					where c.id_trf_fattura = idtrffattura loop
		--testo_modificato:= txt_xml;
						raise notice 'R %',R;
			for R_REPLACE in select key,coalesce(value,'') value from json_each_text(R.j) loop
				raise notice 'R_PLACE 2%',R_REPLACE;
				testo_modificato:=replace(testo_modificato,'$'||R_REPLACE.key||'$',replace(R_REPLACE.value,'&','e'));	
				raise notice 'TESTO_MODIFICATO %', testo_modificato;
			end loop;
		--update trf.trf_fattura_dettagli set stringa_xml=testo_modificato where id =R.id_fattura_dettaglio;
		end loop;

	
	--testo_modificato:= '{"id_fattura":'||(v->>'id_fattura')::bigint::text||',"testo_xml":"'||testo_modificato||'"}';
	testo_modificato:= '{"id_fattura":'||(v->>'id_fattura')::bigint::text||',"testo_xml":'||testo_modificato||'}';
    ret.esito:=true;
   	ret.info:=testo_modificato;
 	ret.msg:=null;
	return ret;
	end;
end;
$_$;


ALTER FUNCTION trf.get_query_fattura_xml(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_rilevazione_attivita(character varying); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_rilevazione_attivita(v character varying) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	idtrfattivita bigint;   
	proc_name varchar;
	R_ATT RECORD;
	rt json;
	v_j json;
	j_dett json;
	f boolean;
	id_op bigint;

	begin
		proc_name:='trf.get_rilevazione_attivita';
		v_j:= v::json;
		idtrfattivita:=v_j->'id_trf_attivita';
		--id_op:=gds_log.stavrt_op(proc_name,idtransazione ,'');
		id_op:=ag_log.start_op(proc_name,idtransazione ,'');
		select  a.id,a.id_trf_attivita,a.id_cliente,a.id_tariffa,a.sigla_tariffa,a.descr_tariffa  tariffa_applicata,
			data_da attivita_da,data_a attivita_a,descr_servizio servizio,descr_trf_operatore operatore, /*descr_cliente*/ descr_cliente_con_indirizzo cliente,
			per_conto_di,descrizione_breve_asl sigla_ente,valido_da tariffa_da, valido_a tariffa_a,a.note,a.tipo_giorno, a.closed  into R_ATT
	    from trf.vw_trf_attivita a where id_trf_attivita=idtrfattivita;
	    select agenda.get_rilevazione_quantita(idtrfattivita) into j_dett;
	    select count(*) > 0 into f from trf.trf_attivita_dettagli where id_trf_attivita =idtrfattivita and valore is not null;
	    ret.esito:=true;
	   	ret.valore:=null;
	   	ret.info:='{"trfattivita":'|| row_to_json(R_ATT)::varchar || ', "dettagli": '|| 
	   			j_dett::varchar ||',"fatturabile":'||f||'}';
	   	--ret.info:=j_dett;
		return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_rilevazione_attivita(v character varying) OWNER TO postgres;

--
-- Name: get_rilevazione_attivita(character varying, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_rilevazione_attivita(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	idtrfattivita bigint;   
	proc_name varchar;
	R_ATT RECORD;
	rt json;
	v_j json;
	j_dett json;
	f boolean;
	id_op bigint;

	begin
		proc_name:='trf.get_rilevazione_attivita';
		v_j:= v::json;
		idtrfattivita:=v_j->'id_trf_attivita';
		--id_op:=gds_log.stavrt_op(proc_name,idtransazione ,'');
		id_op:=ag_log.start_op(proc_name,idtransazione ,'');
		select  a.id,a.id_trf_attivita,a.id_cliente,a.id_tariffa,a.sigla_tariffa,a.descr_tariffa  tariffa_applicata,
			data_da attivita_da,data_a attivita_a,descr_servizio servizio,descr_trf_operatore operatore, /*descr_cliente*/ descr_cliente_con_indirizzo cliente,
			per_conto_di,descrizione_breve_asl sigla_ente,valido_da tariffa_da, valido_a tariffa_a,a.note,a.tipo_giorno, a.closed  into R_ATT
	    from trf.vw_trf_attivita a where id_trf_attivita=idtrfattivita;
	    select agenda.get_rilevazione_quantita(idtrfattivita) into j_dett;
	    select count(*) > 0 into f from trf.trf_attivita_dettagli where id_trf_attivita =idtrfattivita and valore is not null;
	    ret.esito:=true;
	   	ret.valore:=null;
	   	ret.info:='{"trfattivita":'|| row_to_json(R_ATT)::varchar || ', "dettagli": '|| 
	   			j_dett::varchar ||',"fatturabile":'||f||'}';
	   	--ret.info:=j_dett;
		return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_rilevazione_attivita(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_scontrino_xml(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_scontrino_xml(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $_$
begin
	declare
		ret ag_types.result_type;
		R_REPLACE record;
		stringa json;
		testo_modificato varchar;
	begin
		
		select json_agg(row_to_json(b.*)) into stringa from (
			select (
				select testo
				from trf_conf.template_fatturazione tf
				where descR = 'GEFF_START') || string_agg(a.stringa_xml, '') || (
					select testo
					from trf_conf.template_fatturazione tf
					where descR = 'GEFF_END'
				) as xmlString
			from (
				select tfd.stringa_xml 
				from trf.trf_fattura_dettagli tfd
				where tfd.id_trf_fattura = (v->>'id_fattura')::bigint
				and stringa_xml is not null
				order by tfd.ordine
			) a
		) b;
		
		testo_modificato:= stringa;
	
		for R_REPLACE in select a.key, a.val from trf_conf.vw_ws_parameters a where application='GEFF' loop
			raise notice 'R_REPLACE %',R_REPLACE;
			testo_modificato:=replace(testo_modificato,'$'||R_REPLACE.key||'$',replace(R_REPLACE.val,'&','e'));	
			raise notice 'TESTO_MODIFICATO %', testo_modificato;
		end loop;
	
		raise notice 'R_REPLACE stringa=% testo=%',stringa,testo_modificato;
		stringa:=testo_modificato;--'{"id_fattura":'||(v->>'id_fattura')::bigint::text||',"testo_xml":"'||testo_modificato||'"}';
		testo_modificato:= '{"id_fattura":'||(v->>'id_fattura')::bigint::text||',"testo_xml":'||testo_modificato||'}';
		raise notice 'TESTO MODIFICATO %',testo_modificato;
		stringa:=testo_modificato;
		ret.info:=stringa;
		raise notice 'STRINGA FINALE %',stringa;
	    ret.esito:=true;
	 	ret.msg:=null;
		return ret;
	end;
end;
$_$;


ALTER FUNCTION trf.get_scontrino_xml(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_stati_forfet(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_stati_forfet(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	idrisorsa bigint;
	proc_name varchar;
	rt json;
	begin
		proc_name:='agenda.get_stati_forfet';
		idrisorsa:=((v_j->>'user_info')::json)->'id_utente';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		raise notice 'id risorsa: %', idrisorsa;
		select json_agg(row_to_json(a.*)) into rt from (
			select * from trf_types.vw_trf_attivita_forfet_stati a
			order by id) a;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='attivita non trovate';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'stati_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:='{"dati":'||rt||'}';
		end if;
	
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_stati_forfet(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tariffa(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_tariffa(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idtariffa bigint;
	rt json;
	str varchar;
str_f varchar;

	begin
		proc_name:='trf.get_tariffa';
		str=v->'id_tariffa';
	    idtariffa:=replace(str,'"','')::bigint;
	  	id_op:=ag_log.start_op(proc_name,idtransazione ,'');
		select row_to_json(vt.*) into str from trf.vw_tariffe vt where id=idtariffa;
		str_f:='{';
		if str is not null then
			str_f:=str_f||'"tariffa":'||str||',';
		end if;
		raise notice 'STR=%',str;
		raise notice 'STR_F=%',str_f;
	
		select json_agg(row_to_json(u.*)) into str from trf.vw_tariffe_u_mis u;
		str_f:= str_f ||'"unita_misura":'||str;
		raise notice 'STR=%',str;
		raise notice 'STR_F=%',str_f;
	
		select json_agg(row_to_json(i.*)) into str from trf.vw_trf_cod_iva i;
		str_f:= str_f ||',"codici_iva":'||str||'}';
		raise notice 'STR=%',str;
		raise notice 'STR_F=%',str_f;

    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=str_f;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_tariffa(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tariffa_ml(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_tariffa_ml(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idstrutturaasl bigint;
	idlineaattivita bigint;
	rt json;
	str varchar;
str1 varchar;
	begin
		proc_name:='agenda.get_tariffa_ml';	
		idstrutturaasl=v->'user_info'->'id_struttura_root';
		idlineaattivita:=v->'id';
		raise notice 'idstrutturaasl: %', idstrutturaasl;
	    		select json_agg(descr_livello_rischio) into str from 
			(select descr_livello_rischio from public.vw_livelli_rischio order by ord_livello_rischio) a;
	
		/*select json_agg(row_to_json(x.*)) into rt from (
			select id_linea_attivita,id_tariffa_ml,validita,valida_da,valida_a,aperta,
				json_agg(json_build_object('livello',livello,'liv',liv,'valore',valore)) tariffe
			from trf.vw_tariffa_ml_livello
			where id_linea_attivita=idlineaattivita
			group by 1,2,3,4,5,6
		) x;*/
	
			select json_agg(row_to_json(y.*)) into rt from ( 
		select id_linea_attivita,id_tariffa_ml,validita,valida_da,valida_a,aperta,tariffe,
			n=1 and upper_inf(validita) and valida_da > current_timestamp cancellabile
			from
		(
			select id_linea_attivita,id_tariffa_ml,validita,valida_da,valida_a,aperta,
			row_number () over (order by valida_da desc) n,
				json_agg(json_build_object('livello',livello,'liv',liv,'valore',valore)) tariffe
			from trf.vw_tariffa_ml_livello
			where id_linea_attivita=idlineaattivita
			group by 1,2,3,4,5,6
		) x)y;
	
	    ret.esito:=true;
 		ret.msg:=null;
		if json_array_length(rt) is null then	
    		--ret.msg:='tariffa_master_list non trovata';
    	    --ret:=ag_ui.build_ret(ret,proc_name, 'tariffa_master_list_non_trovata');
    		str1:='{"livelli":'||str||'}';
    	else
			ret.msg := null;
			str1:='{"livelli":'||str||',"dati":'||rt||'}';
		end if;
		raise notice 'STR1 %', str1;
		ret.info:= str1;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_tariffa_ml(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tariffa_voci(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_tariffa_voci(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idtariffa bigint;
	rt json;
	str varchar;
	idasl bigint;
	R_T trf.tariffe%ROWTYPE;

	begin
		proc_name:='trf.get_tariffa_voci';
		idtariffa=v->'id_tariffa';
		--str:='{"tariffa_voci":{"descr":["FISSO","BASE","CUMULATIVO","SCAGLIONE"]},"id_tariffa":'||idtariffa||'"dati":';	
		idasl:= v->'user_info'->'id_asl';
		id_op:=ag_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*))
		into rt
		from (select * from trf_types.trf_tipi_calcolo order by n) a;
	
		select * into R_T from trf.tariffe where id=idtariffa;
		raise notice 'R_T = %',RT;
		str:='{"tariffa_voci":'||rt||',"id_tariffa":'||idtariffa||',"modificabile":'||
			case when (R_T.livello_asl and idasl != -1) or (not R_T.livello_asl and idasl = -1) then 'true' else 'false' end 
		    ;	
	
		select json_agg(row_to_json(c.*) ) into rt from (
			select ts.id id_tariffa_struttura,ts.id_asl ,a.descrizione_breve as asl, lower(ts.validita) da,upper(ts.validita) a,upper_inf(ts.validita) attiva,
			coalesce(upper_inf(ts.validita) and (idasl=ts.id_asl or (idasl=-1 and ts.id_asl is null)),false) cancellabile, dati
			from trf.tariffa_strutture ts 
			join matrix.vw_asl a on a.id_asl=ts.id_asl or (a.id_asl=-1 and ts.id_asl is null) 
			join (
				select id_tariffa_struttura,json_agg(row_to_json(a.*)) dati
				from (select ts.id as id_tariffa_struttura,v.id,coalesce(ordine,0) ordine,
				    coalesce(lower(scaglione),0) inf,upper(scaglione) upp,case when scaglione is null then true else lower_inc(scaglione) end  inf_inc,
					upper_inc(scaglione) upp_inc,jsonb_build_array( vcf.valore ,vcb.valore ,vcs.valore ,vcc.valore ) valori 
					from trf.tariffe t join trf.tariffa_strutture ts on t.id= ts.id_tariffa 
					join trf.tariffa_voci v on v.id_tariffa_struttura =ts.id
					join trf.tariffa_voci_calcolo vcf on v.id=vcf.id_tariffa_voce and vcf.tipo=0
					join trf.tariffa_voci_calcolo vcb on v.id=vcb.id_tariffa_voce and vcb.tipo=1
					join trf.tariffa_voci_calcolo vcs on v.id=vcs.id_tariffa_voce and vcs.tipo=2
					join trf.tariffa_voci_calcolo vcc on v.id=vcc.id_tariffa_voce and vcc.tipo=3
					where t.id=idtariffa order by ordine) a group by 1) b on b.id_tariffa_struttura=ts.id
				   where (ts.id_asl=idasl or ts.id_asl is null or idasl=-1) order by ts.validita desc) c;
		
	/*	select json_agg(row_to_json(a.*))
		into rt
		from (
							select v.id,coalesce(ordine,0) ordine,coalesce(lower(scaglione),0) inf,upper(scaglione) upp,case when scaglione is null then true else lower_inc(scaglione) end  inf_inc,
			upper_inc(scaglione) upp_inc,jsonb_build_array( vcf.valore ,vcb.valore ,vcs.valore ,vcc.valore ) valori 
			from trf.tariffe t join trf.tariffa_strutture ts on t.id= ts.id_tariffa 
			left join trf.tariffa_voci v on v.id_tariffa_struttura =ts.id
			left join trf.tariffa_voci_calcolo vcf on v.id=vcf.id_tariffa_voce and vcf.tipo=0
			left join trf.tariffa_voci_calcolo vcb on v.id=vcb.id_tariffa_voce and vcb.tipo=1
			left join trf.tariffa_voci_calcolo vcs on v.id=vcs.id_tariffa_voce and vcs.tipo=2
			left join trf.tariffa_voci_calcolo vcc on v.id=vcc.id_tariffa_voce and vcc.tipo=3
		where t.id=idtariffa order by ordine) a;*/
		if rt is not null then
			str:=str||',"lista":'||rt::varchar;
		end if;	
		str := str ||'}';
		raise notice 'STR=%',str;
		raise notice '%',json_array_length(rt);

    	
	    ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=str;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_tariffa_voci(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tariffario(bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_tariffario(idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	rt json;
	R_T trf.vw_tariffari%ROWTYPE;

	begin
		proc_name:='trf.get_triffario';

		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(a.id_node,a.id_node_parent,a.id_node as id,sigla_tariffa as descrizione_breve, descr_tariffa as descrizione,false selezionato,false selezionabile)) into rt from (select * /*, descr_tariffa as name, id_node as idNode, sigla_tariffa as sigla, path_ord as pathOrd */ from matrix.vw_tree_nodes_up_tariffario a 
		--where id_tariffario=1 order by path_ord) a;
		select json_agg(row_to_json(c.*)) into rt  from (select * 
			from (select a.id_node id,a.id_node,a.id_node_parent, descr_tariffa  as descrizione_breve, a.sigla_tariffa|| ' - ' ||a.descr_tariffa as descrizione,false selezionato--,false selezionabile
				from matrix.vw_tree_nodes_up_tariffario a
				where id_tariffario=trf.get_tariffario_per_data(null) order by path_ord) b
			) c;
	
	
		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='tariffaio non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'tariffario_non_trovato');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_tariffario(idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tariffario(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_tariffario(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	rt json;
	R_T trf.vw_tariffari%ROWTYPE;
	idtariffario bigint;
	idasl bigint;
	idstrutturaasl bigint;
	R_STRUCT matrix.vw_tree_nodes_up_asl;

	begin
		proc_name:='trf.get_tariffario';

		id_op:=ag_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(a.id_node,a.id_node_parent,a.id_node as id,sigla_tariffa as descrizione_breve, descr_tariffa as descrizione,false selezionato,false selezionabile)) into rt from (select * /*, descr_tariffa as name, id_node as idNode, sigla_tariffa as sigla, path_ord as pathOrd */ from matrix.vw_tree_nodes_up_tariffario a 
		--where id_tariffario=1 order by path_ord) a;
		idtariffario:=trf.get_tariffario_per_data(null);
		idasl:=v->'user_info'->'id_asl';


		idstrutturaasl=v->'user_info'->'id_struttura_root';
		select * into R_STRUCT from matrix.vw_tree_nodes_up_asl vtnua where id_node=idstrutturaasl;
		
		if idasl = -1 or R_STRUCT.n_livello = 0 then 
			raise notice 'IDASL -1';
			select json_agg(row_to_json(c.*)) into rt  from (
				select a.ordinamento,a.id_node id,a.id_node,a.id_node_parent,
				f.descr     as descrizione_breve, 		
				case when f.sigla  = f.descr  then f.sigla 
				else f.sigla|| ' - ' ||f.descr end as descrizione,false selezionato,--,false selezionabile
					validita_tariffa,valido_da_tariffa,valido_a_tariffa,livello_asl,upper_inf(f.validita_tariffa) attiva,
					f.valida,a.path_ord,z.id is null and f.valida cancellabile 
					from matrix.vw_tree_nodes_up a
					join trf.vw_tariffe f on f.id=a.id_node
					left join (select distinct id_node_parent id from matrix.vw_tree_nodes_tariffario vtnt) z on z.id=a.id_node 
					where f.id_tariffario=idtariffario order by path_ord		
				) c;
		else
			raise notice 'IDASL %',idasl;
			select json_agg(row_to_json(c.*)) into rt  from (

					select a.ordinamento,a.id_node id,a.id_node,a.id_node_parent,
					f.descr     as descrizione_breve, 		
					case when f.sigla  = f.descr  then f.sigla 
					else f.sigla|| ' - ' ||f.descr end as descrizione,false selezionato,
						validita_tariffa,valido_da_tariffa,valido_a_tariffa,livello_asl,upper_inf(f.validita_tariffa) attiva,
						f.valida,a.path_ord , false cancellabile
						from matrix.vw_tree_nodes_up a
						join trf.vw_tariffe f on f.id=a.id_node
						where f.id_tariffario=idtariffario and not livello_asl 
					union
					select a.ordinamento,a.id_node id,a.id_node,a.id_node_parent,
					f.descr     as descrizione_breve, 		
					case when f.sigla  = f.descr  then f.sigla 
					else f.sigla|| ' - ' ||f.descr end as descrizione,false selezionato,
						validita_tariffa,valido_da_tariffa,valido_a_tariffa,livello_asl,upper_inf(f.validita_tariffa) attiva,
						f.valida,a.path_ord ,false /*z.id is null*/ cancellabile 
						from matrix.vw_tree_nodes_up a
						join trf.vw_tariffe f on f.id=a.id_node
						join trf.tariffa_strutture ts on ts.id_tariffa =f.id_tariffa 
						left join (select distinct id_node_parent id from matrix.vw_tree_nodes_tariffario vtnt) z on z.id=a.id_node
						where f.id_tariffario=idtariffario 	and  livello_asl 
						and id_asl is not null and id_asl=idasl									
						order by path_ord
			) c;
		end if;

		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='tariffario non trovato';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'tariffario_non_trovato');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_tariffario(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tariffario_export(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_tariffario_export(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	rt json;
	R_T trf.vw_tariffari%ROWTYPE;

	begin
		proc_name:='trf.get_tariffario_export';

		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(a.id_node,a.id_node_parent,a.id_node as id,sigla_tariffa as descrizione_breve, descr_tariffa as descrizione,false selezionato,false selezionabile)) into rt from (select * /*, descr_tariffa as name, id_node as idNode, sigla_tariffa as sigla, path_ord as pathOrd */ from matrix.vw_tree_nodes_up_tariffario a 
		--where id_tariffario=1 order by path_ord) a;
		select json_agg(row_to_json(c.*)) into rt 
		from (
			select sigla,descr,da,a,minimo,base,scaglione,cumulativo
			from trf.vw_tariffe_export 
		) c;

		raise notice '%', json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		ret.msg:='tariffe non trovate';
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
 			select val into ret.info
 			from trf_ui.vw_trf_intestazioni
 			where cod = 'tariffe_export';
 		raise notice 'RETINFO %',ret.info;
 			ret.info := '{'||ret.info||',"dati":' || coalesce(rt,'[]') ||'}';
	 		--ret.info:=rt;
		end if;

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_tariffario_export(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tariffario_per_attivita(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_tariffario_per_attivita(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	rt json;
	R_T trf.vw_tariffari%ROWTYPE;

	begin
		proc_name:='trf.get_tariffario_per_attivita';

		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		--select json_agg(row_to_json(a.id_node,a.id_node_parent,a.id_node as id,sigla_tariffa as descrizione_breve, descr_tariffa as descrizione,false selezionato,false selezionabile)) into rt from (select * /*, descr_tariffa as name, id_node as idNode, sigla_tariffa as sigla, path_ord as pathOrd */ from matrix.vw_tree_nodes_up_tariffario a 
		--where id_tariffario=1 order by path_ord) a;
		select json_agg(row_to_json(c.*)) into rt  from (select * 
		from (	select tu.id_node id, 
				tu.descr_tariffa  as descrizione_breve, 
				tu.sigla_tariffa|| ' - ' ||tu.descr_tariffa as descrizione,false selezionato,tu.*
			--	, pt.id is not null selezionato 
				from	(select distinct td.id_node_ref id from trf.tariffe t 
		join matrix.vw_tree_nodes_down td on td.id_node =t.id where visibile_piani ) a 
		join matrix.vw_tree_nodes_up_tariffario  tu on tu.id_node =a.id
		--left join trf.trf_piano_tariffa pt on pt.id_tariffa =tu.id_node --and id_piano=idpiano 
				where id_tariffario=trf.get_tariffario_per_data(null) 
				and tu.valido_a_tariffa is null 	order by path_ord
			
			
			
			/*
			select a.id_node id,a.id_node,a.id_node_parent,
			a.descr_tariffa  as descrizione_breve, 
			
			case when a.sigla_tariffa = a.descr_tariffa then a.sigla_tariffa
			else a.sigla_tariffa|| ' - ' ||a.descr_tariffa end as descrizione
,false selezionato,--,false selezionabile
				validita_tariffa,valido_da_tariffa,valido_a_tariffa,livello_asl,upper_inf(f.validita_tariffa) attiva,
				f.valida,
				a.visibile_piani
				from matrix.vw_tree_nodes_up_tariffario a
				join trf.vw_tariffe f on f.id=a.id_node
				where a.id_tariffario=trf.get_tariffario_per_data(null) 
				--
				and a.visibile_piani is true or a.descr_tariffa = 'TARIFFARIO COMPLETO'
				order by path_ord	*/
				
				) b
			) c;

		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		ret.msg:='tariffario non trovato';
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;

	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_tariffario_per_attivita(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tariffario_per_data(timestamp without time zone); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_tariffario_per_data(t timestamp without time zone) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
begin
	declare
	declare
	n bigint;

	begin
		select id into n from trf.tariffari where validita @> coalesce(t,current_timestamp::timestamp);
		return n;
	end;
end;
$$;


ALTER FUNCTION trf.get_tariffario_per_data(t timestamp without time zone) OWNER TO postgres;

--
-- Name: get_tariffario_per_piani(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_tariffario_per_piani(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	idpiano bigint;
	rt json;

	begin
		proc_name:='trf.get_tariffario_per_piani';
		idpiano:=v_j->'id_piano';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		id_op:=ag_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (
		/*
				select t.*,pt.id is not null selezionato from matrix.vw_tree_nodes_up_tariffario t 
				left join trf.trf_piano_tariffa pt on pt.id_tariffa =t.id_node and id_piano=idpiano 
				where id_tariffario=1 order by path_ord*/
		--select tu.id_node id, tu.descr_tariffa descrizione,tu.sigla_tariffa descrizione_breve,tu.*, pt.id is not null selezionato from 
		select tu.id_node id, 
					tu.descr_tariffa  as descrizione_breve, 
			tu.sigla_tariffa|| ' - ' ||tu.descr_tariffa as descrizione,false selezionato,tu.*, pt.id is not null selezionato from 
		(select distinct td.id_node_ref id from trf.tariffe t join matrix.vw_tree_nodes_down td on td.id_node =t.id where visibile_piani ) a 
		join matrix.vw_tree_nodes_up_tariffario  tu on tu.id_node =a.id
		left join trf.trf_piano_tariffa pt on pt.id_tariffa =tu.id_node and id_piano=idpiano 
				where id_tariffario=trf.get_tariffario_per_data(null) order by path_ord
				
				) a;
	
		--ret.valore:= id_record;
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='tariffaio non trovati';
		    ret:=ag_ui.build_ret(ret,proc_name, 'tariffario_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_tariffario_per_piani(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tariffario_per_regole(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_tariffario_per_regole(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	R_EV matrix.vw_tree_nodes_up_tariffario%ROWTYPE;
	--idpiano bigint;
	rt json;

	begin
		proc_name:='trf.get_tariffario_per_regole';
		--idpiano:=v_j->'id_piano';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		select json_agg(row_to_json(a.*)) into rt from (
		/*
				select t.*,pt.id is not null selezionato from matrix.vw_tree_nodes_up_tariffario t 
				left join trf.trf_piano_tariffa pt on pt.id_tariffa =t.id_node and id_piano=idpiano 
				where id_tariffario=1 order by path_ord*/
		select tu.id_node id, tu.descr_tariffa descrizione,/*tu.sigla_tariffa*/tu.descr_tariffa descrizione_breve,tu.* from 
		(select distinct td.id_node_ref id from trf.tariffe t join matrix.vw_tree_nodes_down td on td.id_node =t.id where visibile_piani ) a 
		join matrix.vw_tree_nodes_up_tariffario  tu on tu.id_node =a.id
				where id_tariffario=trf.get_tariffario_per_data(null) order by path_ord
				
				) a;
	
		--ret.valore:= id_record;
			/*
						select a.ordinamento,a.id_node id,a.id_node,a.id_node_parent,
			f.descr     as descrizione_breve, 		
			case when f.sigla  = f.descr  then f.sigla 
			else f.sigla|| ' - ' ||f.descr end as descrizione
,false selezionato,--,false selezionabile
				validita_tariffa,valido_da_tariffa,valido_a_tariffa,livello_asl,upper_inf(f.validita_tariffa) attiva,
				f.valida
				from matrix.vw_tree_nodes_up a
				join trf.vw_tariffe f on f.id=a.id_node
				where f.id_tariffario=trf.get_tariffario_per_data(null) order by path_ord
			*/
			
			
	
		raise notice '%',json_array_length(rt);
	
		if json_array_length(rt) is null then
			ret.esito:=false;	
    		--ret.msg:='tariffaio non trovati';
    	    ret:=ag_ui.build_ret(ret,proc_name, 'tariffario_non_trovati');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_tariffario_per_regole(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_tipo_per_sicer(character varying, character varying, character varying); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_tipo_per_sicer(cod_tipo_impresa character varying, cf character varying, piva character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare
		tipo varchar;
	begin
		tipo:=
			case when cod_tipo_impresa is not null then cod_tipo_impresa
				 when cod_tipo_impresa is null and length(cf)=16 and length(coalesce(piva,'')) != 11 then 'P' 
	             when cod_tipo_impresa is null and length(cf)=16 and length(coalesce(piva,''))  = 11 then 'D' 
		         else 'S' end;
	raise notice 'TIPO %', tipo;
	return tipo;
	end;
end;
$$;


ALTER FUNCTION trf.get_tipo_per_sicer(cod_tipo_impresa character varying, cf character varying, piva character varying) OWNER TO postgres;

--
-- Name: get_trf_att_inviate(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_trf_att_inviate(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
declare
	ret ag_types.result_type;    
	proc_name varchar;
	rt json;

	BEGIN
		proc_name:='agenda.get_trf_att_inviate';
		select json_agg(row_to_json(a.*)) into rt
		from (
			select i.* from trf.vw_trf_att_inviate i
			join trf.vw_trf_attivita a on a.id_trf_attivita  = i.id_trf_attivita
			where a.per_conto_di = (select id_asl from matrix.struttura_asl sa where id::text=((v->>'user_info')::json)->>'id_struttura_root')
		) a;
		raise notice 'RT=%',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	END;
end;
$$;


ALTER FUNCTION trf.get_trf_att_inviate(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_trf_att_inviate_by_sel(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_trf_att_inviate_by_sel(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
declare
	ret ag_types.result_type;    
	proc_name varchar;
	rt json;
	v_cliente varchar;
	v_servizio varchar;
	v_data_inizio_attivita timestamp;
	v_data_fine_attivita timestamp;
	v_data_inizio_invio_attivita timestamp;
	v_data_fine_invio_attivita timestamp;
	v_periodo_attivita json;
	v_periodo_attivita_inviate json;
	v_stato varchar;
	v_limite int;
	BEGIN
		proc_name:='agenda.get_trf_att_inviate_by_sel';
		if v->>'periodo_attivita' != '' then
			v_periodo_attivita:=v->>'periodo_attivita';
			raise notice 'fine v_periodo%', v_periodo_attivita->>'end';
			if v_periodo_attivita->>'start' != '' then
				v_data_inizio_attivita:=to_timestamp(v_periodo_attivita->>'start'::varchar, 'YYYY-MM-DD');
			end if;
			if v_periodo_attivita->>'end' != '' then
				v_data_fine_attivita:=to_timestamp(v_periodo_attivita->>'end'::varchar, 'YYYY-MM-DD');
					if length(v_periodo_attivita->>'end')<=10 then
						v_data_fine_attivita:= v_data_fine_attivita + interval '1 day';
					end if;
			end if;

		end if;
	
		if v->>'periodo_attivita_invio' != '' then
			v_periodo_attivita_inviate:=v->>'periodo_attivita_invio';
			raise notice 'fine v_periodo%', v_periodo_attivita_inviate->>'end';
			if v_periodo_attivita_inviate->>'start' != '' then
				v_data_inizio_invio_attivita:=to_timestamp(v_periodo_attivita_inviate->>'start'::varchar, 'YYYY-MM-DD');
			end if;
			if v_periodo_attivita_inviate->>'end' != '' then
				v_data_fine_invio_attivita:=to_timestamp(v_periodo_attivita_inviate->>'end'::varchar, 'YYYY-MM-DD');
					if length(v_periodo_attivita_inviate->>'end')<=10 then
						v_data_fine_invio_attivita:= v_data_fine_invio_attivita + interval '1 day';
					end if;
			end if;

		end if;
	
		raise notice 'start %',v_data_inizio_attivita;
		raise notice 'end %', v_data_fine_attivita;

		if v->>'limite' is not null then
			v_limite:=v->>'limite';
		end if;
		if v->>'cliente' is not null then
			v_cliente:=replace('%'||cu_anag.string_normalize(v->>'cliente')||'%',' ','%');
		end if;
		if v->>'servizio' is not null then
			v_servizio:=replace('%'||cu_anag.string_normalize(v->>'servizio')||'%',' ','%');
		end if;
		if v->>'stato' is not null then
			v_stato:=v->>'stato';
		end if;
		select json_agg(row_to_json(a.*)) into rt
		from (
			select i.* from trf.vw_trf_att_inviate i
			join trf.vw_trf_attivita a on a.id_trf_attivita  = i.id_trf_attivita
			where a.per_conto_di = (select id_asl from matrix.struttura_asl sa where id::text=((v->>'user_info')::json)->>'id_struttura_root')
			and ((coalesce(i.descr_cliente, '') ilike '%'||v_cliente||'%' or (v_cliente is null))
			and (coalesce(i.descr_servizio, '') ilike '%'||v_servizio||'%' or (v_servizio is null))
			and (coalesce(i.descr_stato, '') ilike '%'||v_stato||'%' or (v_stato is null))
			and (v_data_inizio_attivita is null or i.data_da >= v_data_inizio_attivita)
			and (i.data_da <= v_data_fine_attivita or v_data_fine_attivita is null ) 
			and (v_data_inizio_invio_attivita is null or i.tm_ultimo_invio >= v_data_inizio_invio_attivita)
			and (i.tm_ultimo_invio <= v_data_fine_invio_attivita or v_data_fine_invio_attivita is null ) 
			)
		) a;
		raise notice 'RT=%',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	END;
end;
$$;


ALTER FUNCTION trf.get_trf_att_inviate_by_sel(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_trf_att_inviate_stati(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_trf_att_inviate_stati(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
declare
	ret ag_types.result_type;    
	proc_name varchar;
	rt json;
	idattinviata bigint;

	BEGIN
		proc_name:='trf.get_trf_att_inviate_stati';
		raise notice 'v=%', v;
		idattinviata:=v->'id_att_inviata';
		select json_agg(row_to_json(a.*)) into rt
		from (select *,
		case 
			when vtaius.ret like '%"result":{"esito":"OK"%' then 'OK'
			when vtaius.ret like '%"result":{"code":%'     then translate(substring(vtaius.ret,strpos(vtaius.ret,'"result":{"code":')),'[{}];','     ')
			when vtaius.ret like '%"esito":%"errore"%'     then translate(substring(vtaius.ret,strpos(vtaius.ret,'"errore"')),'[{}];','     ')
			else right(vtaius.ret,28) end "left" from trf.vw_trf_att_inviate_stati vtaius
			  where vtaius.id_att_inviata = idattinviata  order by vtaius.ts desc) a;
		raise notice 'RT=%',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	END;
end;
$$;


ALTER FUNCTION trf.get_trf_att_inviate_stati(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_trf_att_inviate_ultimo_stato(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_trf_att_inviate_ultimo_stato(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
declare
	ret ag_types.result_type;    
	proc_name varchar;
	rt json;
	idattinviata bigint;

	BEGIN
		proc_name:='agenda.get_trf_att_inviate_ultimo_stato';
		raise notice 'v=%', v;
		idattinviata:=v->'id_att_inviata';
		select json_agg(row_to_json(a.*)) into rt
		from (select * from trf.vw_trf_att_inviate_ultimo_stato vtaius
			  where vtaius.id_att_inviata = idattinviata) a;
		raise notice 'RT=%',rt;
	
		ret.esito:=true;
	 	--ret.info:=rt;
	 	ret.info:='{"dati":'||coalesce(rt::varchar,'[]')||'}';
		raise notice 'ret.info %',ret.info;
	 	return ret;
	END;
end;
$$;


ALTER FUNCTION trf.get_trf_att_inviate_ultimo_stato(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_trf_per_regole(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_trf_per_regole(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idtariffa bigint;
	rt json;
	rt_op json;
rt_tipi_oper json;
	str varchar;

	begin
		proc_name:='agenda.get_trf_per_regole';
		idtariffa=v->'id_tariffa';

		select json_agg(row_to_json(a.*)) into rt
		from (select id_child id,sigla,descr,calcolabile, id id_tariffa
	               from trf.vw_trf_per_regole vtpr where id=idtariffa) a;

		
		/*select json_agg(row_to_json(c.*)) into rt_op from (
			select b.id_regola_fatt,t.id,t.sigla,t.descr,row_to_json(b.*) as operazione from
				(select id_regola_fatt,trf.op,trf.ord_exec,trf.id_tariffa,t.sigla,t.descr,json_agg( row_to_json(a.* )) operandi from 

					(select d.id_regola_fatt,d.id_tariffa,t.sigla ,t.descr from trf.trf_regole_fatt_dett d join trf.tariffe t on d.id_tariffa =t.id) a
					join trf.trf_regole_fatt trf on trf.id=a.id_regola_fatt join trf.tariffe t on t.id=trf.id_tariffa 
				group by 1,2,3,4,5,6) b join trf.tariffe t on b.id_tariffa=t.id) c
			where id in (select id_node as id from matrix.vw_tree_nodes_down where id_node_ref=idtariffa);*/

		select json_agg(row_to_json(c.*)) into rt_op from (			
			select d.id_regola_fatt,trf.op,trf.ord_exec,trf.id_tariffa,tl.sigla,tl.descr,
					json_agg(json_build_object('id',d.id_tariffa,'sigla',tr.sigla,'descr',tr.descr,'calcolabile',
					false,'id_tariffa',idtariffa ) ) operandi
			from trf.trf_regole_fatt_dett d join trf.tariffe tr on d.id_tariffa =tr.id	
			join trf.trf_regole_fatt trf on trf.id=d.id_regola_fatt join trf.tariffe tl on tl.id=trf.id_tariffa 		
			group by 1,2,3,4,5,6		) c
		where id_tariffa in (select id_node as id from matrix.vw_tree_nodes_down where id_node_ref=idtariffa);
		
		
		select json_agg( row_to_json(a.* )) operandi into rt_tipi_oper from trf_types.trf_tipi_regole a;
		str:='{"elementi":'||rt||',"operazioni":'||coalesce(rt_op,'[]')||',"tipi_op":'||rt_tipi_oper||'}';
		raise notice 'RT=%',rt;
		raise notice 'RT_OP=%',rt_op;
		raise notice 'STR=%',str;
	
    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:=str;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_trf_per_regole(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: get_ws_call(character varying, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.get_ws_call(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	idtrffattura bigint;   
	proc_name varchar;
	R_FATT RECORD;
	rt json;
	v_j json;
	j_dett json;
	idtrfstato bigint;
	act varchar;
	
	begin
		proc_name:='trf.get_ws_call';
		v_j:= v::json;
		idtrffattura:=v_j->'id_trf_fattura';
		raise notice 'idtrffattura %', idtrffattura;
	
		ret.esito=true;

		if idtrffattura is null then	
			select id_trf_fattura,id_trf_stato+1  into idtrffattura,idtrfstato  from trf.vw_trf_fatture_ultimo_stato
			where act_required='START' and dt_new_invio is not null and dt_new_invio <= current_timestamp
			order by ord,ts limit 1;
			act:='WRITE';
			if idtrffattura is null then
				select id_trf_fattura,act_required,id_trf_stato into idtrffattura, act,idtrfstato  from trf.vw_trf_fatture_ultimo_stato
				where act_required!='STOP' and ts < current_timestamp - interval '2 minutes'  and dt_new_invio is not null and dt_new_invio >= current_timestamp
				order by ord,ts limit 1;
			end if;
		else
			-- Recupera lo stato attuale
			select act_required,id_trf_stato into act, idtrfstato
			from trf.vw_trf_fatture_ultimo_stato
			where act_required!='STOP' and id_trf_fattura=idtrffattura  and dt_new_invio is not null and dt_new_invio <= current_timestamp;

			if act = 'START' then
				idtrfstato:=idtrfstato+1;
				act:='WRITE';
			end if;
		end if;
		raise notice 'ACT=%',act;
	
		if act is null then
			ret.info:=null;
			return ret;
		end if;
	
		-- Ritorna ws di lettura o scrittura
		if act='WRITE' then
			ret:=trf.get_scontrino_xml(('{"id_fattura":'||idtrffattura||'}')::json,idtransazione);
			raise notice 'RET SCONTRINO XML %',ret;
		end if;
		if act='READ' then
			ret:=trf.get_query_fattura_xml(('{"id_fattura":'||idtrffattura||'}')::json,idtransazione);
			raise notice 'RET FATTURA %',ret;
		end if;
		ret.info:=left(ret.info,length(ret.info)-1)||',"act":"'||act||'"}';
		raise notice 'RET FINALE %',ret;
		-- Aggiorna lo stato
		insert into trf.trf_fattura_stati values (nextval('trf.trf_fattura_stati_id_seq'),idtrffattura,null,idtrfstato,current_timestamp);
		
		return ret;
	end;
end;
$$;


ALTER FUNCTION trf.get_ws_call(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: ins_tariffa(character varying, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.ins_tariffa(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;   
        proc_name varchar; -- END
       	R_T trf.vw_tariffe%ROWTYPE; 
        R_TT trf.tariffe%ROWTYPE; 
        idtariffa bigint;
        v_j json;
        n integer;
       	da timestamp;
        a timestamp;
       idasl bigint;
      	R_A record;
       	R_STRUCT matrix.vw_tree_nodes_up_asl;
		idstrutturaasl bigint;
	begin
		proc_name:='trf.ins_tariffa';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		if v_j->>'valido_a_tariffa' is not null then
			a:= (v_j->'valido_a_tariffa')::text::timestamp;
		end if;
		idasl:=v_j->'user_info'->'id_asl';
	    da:=(v_j->'valido_da_tariffa')::text::timestamp;
	    R_T:=  json_populate_record(null::trf.vw_tariffe,v_j);
	    R_TT.id=nextval('agenda.agenda_id_seq');
	   	R_TT.livello_asl:= R_T.livello_asl;
	    R_TT.id_tariffario :=  R_T.id_tariffario;
		R_TT.sigla         :=  R_T.sigla;
		R_TT.descr         :=  R_T.descr;
		R_T.ordinamento=LPAD(R_T.ordinamento::varchar,4,'0');
		if R_TT.descr is null or R_TT.descr = '' then 
			R_TT.descr         :=  R_TT.sigla;
		end if;
		R_TT.cod_iva              :=  R_T.cod_iva;
		R_TT.limiti               := numrange(R_T.limite_inf, R_T.limite_sup, '[]');
		R_TT.nota                 :=  R_T.nota;
		R_TT.visibile_trf         :=  R_T.visibile_trf;
		R_TT.visibile_fatt        :=  R_T.visibile_fatt;
		R_TT.visibile_piani       :=  R_T.visibile_piani;
		R_TT.visibile_contabilita :=  R_T.visibile_contabilita;
		if idasl != -1::bigint and R_STRUCT.n_livello != 0 then
			R_TT.livello_asl      :=  true; --R_T.livello_asl;
		else
			R_TT.livello_asl      :=  false;
		end if;
		--R_TT.livello_asl      	  :=  R_T.livello_asl;
		R_TT.id_u_mis	          :=  R_T.id_u_mis;
		R_TT.validita             := tsrange(da,a,'[)');
		if R_TT.id = R_T.id_parent then
			ret.esito:=false;
			ret.valore:= null;
			ret.msg:=proc_name || ': valori che generano LOOP nell tree_nodes';
			RAISE notice '%', ret;
			return ret;
		end if;
	    insert into trf.tariffe values (R_TT.*);
	   	n:=ag_log.upd_record('trf.tariffe',idtransazione,R_TT,'I');
	   	idasl:=v_j->'user_info'->'id_asl';

		idstrutturaasl=v_j->'user_info'->'id_struttura';
		select * into R_STRUCT from matrix.vw_tree_nodes_up_asl vtnua where id_node=idstrutturaasl;
	
	    if R_TT.livello_asl and (idasl=-1 or R_STRUCT.n_livello = 0) then
	    	for R_A in select distinct id_asl as id_asl from matrix.vw_tree_nodes_up_asl where n_livello=1 loop
	    		insert into trf.tariffa_strutture values(nextval('agenda.agenda_id_seq'),R_TT.id,R_A.id_asl,R_TT.validita);
	    		n:=ag_log.upd_record('trf.tariffa_strutture',idtransazione,R_TT,'I');
	    	end loop;
	    else
	    	insert into trf.tariffa_strutture values(nextval('agenda.agenda_id_seq'),R_TT.id,case when idasl=-1 then null else idasl end,R_TT.validita);
	    	n:=ag_log.upd_record('trf.tariffa_strutture',idtransazione,R_TT,'I');
	    end if;
	    insert into matrix.tree_nodes values(R_TT.id,
	   (select t.id from matrix.trees t where t.name='Tariffario'),R_T.id_parent,LPAD(R_T.ordinamento::varchar,4,'0'),R_TT.descr);

		GET DIAGNOSTICS n = ROW_COUNT;
		if  n <=0 then
			ret.esito:=false;
			ret.valore:= null;
			ret.msg:=proc_name || ': valori non inseriti';
			RAISE notice '%', ret;
			return ret;
		end if;
	
	ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info = '0';
    	--ret.esito:=true;	
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
		return ret;
	end;
END
$$;


ALTER FUNCTION trf.ins_tariffa(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: or_by_str(character varying); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.or_by_str(str character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
	declare 
		n integer;

        begin
	    n:=0;
	    str:=upper(str);
	    for i in 1 .. length(str) loop
	    	n:=n*26;
	    	n = n+ascii(substring(str,i,1))-64;
	    end loop;
		return n;
	end;
END
$$;


ALTER FUNCTION trf.or_by_str(str character varying) OWNER TO postgres;

--
-- Name: translitterato_per_sicer(character varying); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.translitterato_per_sicer(t character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	declare
	str varchar;
	begin
		return t;
		str:= replace(replace(replace(replace(replace(replace(replace(replace
		(t,'à','a''')
	      ,'è','e''')
	      ,'ì','i''')
	      ,'ò','o''')
	      ,'ù','u''')
	      ,'é','e''')
	      ,'’','''') 
	     ,'#','');
	 	return str;
	end;
end;
$$;


ALTER FUNCTION trf.translitterato_per_sicer(t character varying) OWNER TO postgres;

--
-- Name: upd_att_close(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_att_close(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idlinea bigint;
        proc_name varchar; -- END
        idevento bigint;
      	R record;
      	R_A trf.trf_attivita;
      	n integer;
	begin
		proc_name:='trf.upd_att_close';
		id_op:=ag_log.start_op(proc_name,idtransazione ,'');

		raise notice 'V_J %',v_j;
		update trf.trf_attivita set closed = true, data_closed = current_timestamp
		where (closed is null or not closed and id_cliente is not null and id_tariffa is not null)
		and id in (
			select (value::varchar)::bigint
			from json_array_elements(v_j->'id_attivita')
		)
		returning * into R_A;
		n:=ag_log.upd_record('trf.trf_attivita',idtransazione,R_A,'U');
		raise notice 'CLOSE EFFETTUATA %',v_j->'id_attivita';
		for R in
			select (value::varchar)::bigint id from json_array_elements(v_j->'id_attivita') loop
	 		ret:= trf.upd_att_da_inviare(('{"id_trf_attivita":['||R.id||']}')::json,idtransazione);
	 		raise notice 'SICER EFFETTUATA %',v_j->'id_attivita';
	 		if ret.esito = false then
	 			ret:=ag_ui.build_ret(ret,proc_name,'errore_creazione_attività_sicer');
				return ret;
	 		end if;
	 	end loop;

			
			
    	ret.esito:=true;	
		ret:=ag_ui.build_ret(ret,proc_name,idlinea);
	    --ret:=ag_ui.build_ret(ret,proc_name,'chiusura_attività_avvenuta_con_successo');
		--ret.info='0';
		return ret;
	end;
END
$$;


ALTER FUNCTION trf.upd_att_close(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_att_da_inviare(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_att_da_inviare(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret         ag_types.result_type; 
	ret_calcolo ag_types.result_type; 
	ret_xml ag_types.result_type; 
	id_op bigint; 
	proc_name varchar;
	rt json;
	n integer;
	nf integer;
	j_prestazioni  json;
	j_sedefiscale  json;
	j_sedelegale   json;
	j_proprietario json;
	j_detentore    json;
	j_stabilimento json;
	idimpresa bigint;
	str_stabilimento varchar;
	tipocliente varchar;
	is_organization text;
	strj json;
	F Record;
	R_AI trf.trf_att_inviate;
	R_S trf_types.trf_fattura_stati;
	R_FP trf.trf_ft_periodiche;
	R_IMP cu_anag.vw_imprese;
	idazsede bigint;
	idlinea bigint;
	psf varchar; -- eventuale codice fiscale della persona fisica
	fnt varchar;
	begin
		proc_name:='trf.upd_att_da_inviare';
	
		id_op:=ag_log.start_op(proc_name,idtransazione ,'');
		n:=0; 
		select * into R_S from trf_types.trf_fattura_stati where cod = 'generata';

		for F in select * from trf.trf_attivita vta 
			where id in (
				select (value::varchar)::bigint from json_array_elements(v_j->'id_trf_attivita') )
				/*and id not in (select id_trf_attivita  from trf.trf_att_inviate)*/
				order by id_cliente ,per_conto_di loop
					raise notice 'Attivita LETTA';
			select json_agg(row_to_json(a.*)) into j_prestazioni   from (
				select t.id "IdPrestazione",t.sigla "CodicePrestazione",t.descr "DescrizionePrestazione",
				to_char(a.data_da,'dd/mm/yyyy') "DataPrestazione",d.valore "Quantita",'G'||a.per_conto_di "AslFatt",
				an.codice_fiscale "DatoFiscaleOp",d.id "IdGisa",0 "Importo",'N' "FuoriFascia",'' Protocollo,
				case when sa.descrizione_breve is not null and sa.descrizione_breve ilike '%SIAN%' then 'SI' else 'SV' end "CodServizio"
				from trf.trf_attivita_dettagli d
				join trf.trf_attivita a on a.id=d.id_trf_attivita
				left join matrix.struttura_asl sa on sa.id=a.per_conto_di_struttura
				join trf.tariffe t on t.id=d.id_tariffa 
				join matrix.anagrafica an on an.id_anagrafica=a.id_trf_operatore 
				where id_trf_attivita=F.id
			) a;
		 	raise notice 'j_prestazioni %',j_prestazioni;
		
		 	select id_impresa,id_az_sede,id_linea,fonte,UPPER(tipo_cliente),coalesce(piva,codfis) piva into idimpresa,idazsede,idlinea,fnt,tipocliente,psf
		 	from trf.vw_clienti c where c.id=F.id_cliente;
		 raise notice 'CCLIENTE % %',psf,tipocliente;
		 
		 	select * into R_IMP from cu_anag.vw_imprese where id=idimpresa;
			/*select riferimento_id_nome_tab into is_organization 	
			from trf.clienti c
			join agenda.vw_linee l on c.id_ref =l.id 
			where c.id=F.id_cliente; */
		  	raise notice 'idazsede % id_linea % fonte %',idazsede,idlinea,fnt;
		
			if fnt ilike 'BDN%' then 
			  raise notice 'FONTE BDN';
	/* BDN */
			/* PROPRIETARIO */
				select row_to_json(a.* ) into j_proprietario from ( 
					select
						trf.get_tipo_per_sicer(sf.cod_tipo_impresa,sf.cf_impresa,sf.piva_impresa) "Tipo",
						coalesce(coalesce(sf.cognome,sf.ragsoc),'') "CognomeRagSoc",coalesce(sf.nome) "Nome",
						case when sf.cf_impresa is not null and length(sf.cf_impresa)=16 and length(coalesce(sf.piva_impresa,'')) != 11 and length(coalesce(sf.piva_impresa,'')) != 13 
						then '' else regexp_replace(sf.piva_impresa,'^IT','') end "PartIva",
						coalesce(sf.cf,'') "CodFiscale",coalesce(sf.toponimo ||' ','')||coalesce(sf.indirizzo_nome ||' ','') "Indirizzo",coalesce(sf.cap,'') "Cap",
						coalesce(sf.istat_comune,'') "ComuneResidenza",
						coalesce(to_char(sf.data_nascita,'dd/mm/yyyy'),'') "DataNascita",
						coalesce(sf.istat_nascita,'') "ComuneNascita"					
					from cu_anag.vw_stabilimento_figure sf
					where sf.id_stabilimento=idazsede and upper(sigla_tipo_figura)='PROPRIETARIO') a;	
			/* SEDE FISCALE <- PROPRIETARIO */
				j_sedefiscale:=j_proprietario;										
				raise notice 'j_proprietario %',j_proprietario;
				if tipocliente='LINEA' then
				/* STABILIMENTO */
					select row_to_json(a.* ) into j_stabilimento from (		
						select 'AL' "CodTipologiaStruttura",
							case when l.cod_tipo_linea like '% - % - %' then lpad(substring(l.cod_tipo_linea, 1,strpos(l.cod_tipo_linea,' - ') -1 ), 4, '0')
					 					else '' end "CodSpecie", 
					 		l.denominazione_sede_operativa  "Insegna", 'G'||l.id_struttura "CodAsl",
					 		l.indirizzo "Indirizzo", l.provincia_istat||l.comune_istat "Comune", 
					 		coalesce(l.cod_nazionale,'') "CodAziendale",coalesce(l.id_esterno,'') "IdBDN"
					 		from  agenda.vw_linee l 
								left join cu_anag.vw_soggetti_fisici sf on sf.codice_fiscale = l.piva
								left join conf_ext.vw_comuni_vigenti_attivi ac_n on
										(ac_n.denominazione_it=sf.comune_nascita or ac_n.denominazione_composta =sf.comune_nascita)
								where l.id_linea=idlinea
						) a;
					raise notice 'j_stabilimento %',j_stabilimento;
				else
				/* STABILIMENTO */
					select row_to_json(a.* ) into j_stabilimento from (
						select 'AL' "CodTipologiaStruttura",coalesce(l.id_esterno,'') "IdBDN"
					 		from  CU_ANAG.vw_linee l 
								where l.id_stabilimento=idazsede limit 1
						) a;
					raise notice 'j_stabilimento da stabilimento %',j_stabilimento;
				end if;
	
			else /* NO BDN*/
			
			/* STABILIMENTO  */
				select row_to_json(a.* ) into j_stabilimento from (
					select s.cod_tipologia_struttura "CodTipologiaStruttura",''  "CodSpecie",
						coalesce(s.nome,'') "Insegna",coalesce(s.az_cod_aziendale,'')  "CodAziendale",
						coalesce(coalesce(s.cod_regionale,s.cod_nazionale),'') "NumRegistrazione",
						coalesce(coalesce(s.cod_nazionale,s.cod_regionale),'') "NumRiconoscimento",
						coalesce(s.toponimo ||' ','')||coalesce(s.indirizzo ||' ','') "Indirizzo",
						s.istat "Comune",'G'||/*F.per_conto_di*/s.id_asl "CodAsl",coalesce(s.cap,'') "Cap"
						from cu_anag.vw_stabilimenti s 
						where s.id=idazsede ) a;
				
				raise notice 'j_proprietario 1';
 			/* PROPRIETARIO */
				select row_to_json(a.* ) into j_proprietario from (
					select
						trf.get_tipo_per_sicer(sf.cod_tipo_impresa,sf.cf_impresa,sf.piva_impresa) "Tipo",									
						coalesce(coalesce(sf.cognome,sf.ragsoc),'') "CognomeRagSoc",coalesce(sf.nome) "Nome",
						case when sf.cf_impresa is not null and length(sf.cf_impresa)=16 and length(coalesce(sf.piva_impresa,'')) != 11 and length(coalesce(sf.piva_impresa,'')) != 13 then ''
						else regexp_replace(sf.piva_impresa,'^IT','') end "PartIva",
						coalesce(sf.cf,'') "CodFiscale",coalesce(sf.toponimo ||' ','')||coalesce(sf.indirizzo_nome ||' ','') "Indirizzo",coalesce(sf.cap,'') "Cap",
						coalesce(sf.istat_comune,'') "ComuneResidenza",coalesce(to_char(sf.data_nascita,'dd/mm/yyyy'),'') "DataNascita",
						coalesce(sf.istat_nascita,'') "ComuneNascita"
						from cu_anag.vw_stabilimento_figure sf
						where sf.id_stabilimento=idazsede and upper(sigla_tipo_figura)='PROPRIETARIO') a;
				
				if j_proprietario is null then
			/* PROPRIETARIO  <- TITOLARE */
					raise notice 'j_proprietario 2';
					select row_to_json(a.* ) into j_proprietario from ( 
						select  
						trf.get_tipo_per_sicer(sf.cod_tipo_impresa,sf.cf_impresa,sf.piva_impresa) "Tipo",
						coalesce(coalesce(sf.cognome,sf.ragsoc),'') "CognomeRagSoc",coalesce(sf.nome) "Nome",
						case when sf.cf_impresa is not null and length(sf.cf_impresa)=16 and length(coalesce(sf.piva_impresa,'')) != 11 and length(coalesce(sf.piva_impresa,'')) != 13 then ''
						else regexp_replace(sf.piva_impresa,'^IT','') end "PartIva",
							sf.cf "CodFiscale",coalesce(sf.toponimo ||' ','')||coalesce(sf.indirizzo_nome ||' ','') "Indirizzo",coalesce(sf.cap,'') "Cap",
							coalesce(sf.istat_comune,'') "ComuneResidenza",coalesce(to_char(sf.data_nascita,'dd/mm/yyyy'),'') "DataNascita",
							coalesce(sf.istat_nascita,'') "ComuneNascita"
							from cu_anag.vw_stabilimento_figure sf
							where sf.id_stabilimento=idazsede and upper(sigla_tipo_figura)='TITOLARE') a;
				end if;
			
		
				if j_proprietario is null then
			/* PROPRIETARIO  <- LEGALE RAPPRESENTANTE */
					raise notice 'j_proprietario 3';
					select row_to_json(a.* ) into j_proprietario from (
						select 
							trf.get_tipo_per_sicer(sf.cod_tipo_impresa,sf.cf_impresa,sf.piva_impresa) "Tipo",
							coalesce(coalesce(sf.cognome,sf.ragsoc),'') "CognomeRagSoc",coalesce(sf.nome) "Nome",
						case when sf.cf_impresa is not null and length(sf.cf_impresa)=16 and length(coalesce(sf.piva_impresa,'')) != 11 and length(coalesce(sf.piva_impresa,'')) != 13 then '' 
						else regexp_replace(sf.piva_impresa,'^IT','') end "PartIva",
							sf.cf "CodFiscale",coalesce(sf.toponimo ||' ','')||coalesce(sf.indirizzo_nome ||' ','') "Indirizzo",coalesce(sf.cap,'') "Cap",
							sf.istat_comune "ComuneResidenza",coalesce(to_char(sf.data_nascita,'dd/mm/yyyy'),'') "DataNascita",
							coalesce(sf.istat_nascita,'') "ComuneNascita"
							from cu_anag.vw_stabilimento_figure sf
							where sf.id_stabilimento=idazsede and upper(sigla_tipo_figura)='LEGALE RAPPRESENTANTE') a;
				end if;
 /* SEDE LEGALE */
			 /* SEDE LEGALE STABILIMENTO SEDI*/
				select row_to_json(a.* ) into j_sedelegale from (	
					select
						trf.get_tipo_per_sicer(ss.cod_tipo_impresa,ss.cf_impresa,ss.piva_impresa) "Tipo",
						ss.ragsoc "CognomeRagSoc",'' "nome",
						case when ss.cf_impresa is not null and length(ss.cf_impresa)=16 and length(coalesce(ss.piva_impresa,'')) != 11 and length(coalesce(ss.piva_impresa,'')) != 13 then ''
						else regexp_replace(ss.piva_impresa,'^IT','') end "PartIva",
						ss.cf "CodFiscale",coalesce(ss.toponimo ||' ','')||coalesce(ss.indirizzo ||' ','') "Indirizzo",coalesce(ss.cap,'') "Cap",
						coalesce(ss.istat_comune,'') "ComuneResidenza"
						from cu_anag.vw_stabilimento_sedi ss  where ss.id_stabilimento=idazsede and sigla_tipo_sede='SL') a;
			/* SEDE LEGALE IMPRESA SEDI*/
				if j_sedelegale is null then
					select row_to_json(a.* ) into j_sedelegale from (	
						select  
							trf.get_tipo_per_sicer(ss.cod_tipo_impresa,ss.cf,ss.piva) "Tipo",
						    ss.ragsoc "CognomeRagSoc",'' "nome",
							case when ss.cf is not null and length(ss.cf)=16 and length(coalesce(ss.piva,'')) != 11 and length(coalesce(ss.piva,'')) != 13 then ''
								 else regexp_replace(ss.piva,'^IT','') end "PartIva",
							ss.cf "CodFiscale",coalesce(ss.toponimo ||' ','')||coalesce(ss.indirizzo ||' ','') "Indirizzo",coalesce(ss.cap,'') "Cap",
							coalesce(ss.istat_comune,'') "ComuneResidenza"
							from cu_anag.vw_impresa_sedi ss  where ss.id_impresa=idimpresa and upper(sigla_tipo_sede)='SL'
						) a;
				end if;
				if j_sedelegale is null then
			/* SEDE LEGALE STABILIMENTO */					
					select row_to_json(a.* ) into j_sedelegale from (						
						select  						
							trf.get_tipo_per_sicer(ss.cod_tipo_impresa,ss.cf_impresa,ss.piva_impresa) "Tipo",
							ss.ragsoc "CognomeRagSoc",'' "nome",
							case when ss.cf_impresa is not null and length(ss.cf_impresa)=16 and length(coalesce(ss.piva_impresa,'')) != 11 and length(coalesce(ss.piva_impresa,'')) != 13 then ''
							else regexp_replace(ss.piva_impresa,'^IT','') end "PartIva",
							ss.cf_impresa "CodFiscale",coalesce(ss.toponimo ||' ','')||coalesce(ss.indirizzo ||' ','') "Indirizzo",
							coalesce(ss.cap,'') "Cap",
							coalesce(ss.istat_comune,'') "ComuneResidenza",coalesce(sdi,'') "CodSdi"
						from cu_anag.vw_stabilimenti ss where ss.id_stabilimento=idazsede) a;
				end if;
raise notice 'tipoclienet %',tipocliente;
/* SEDE FISCALE */
				if upper(tipocliente)='SOGGETTO_FISICO' then
				raise notice 'tipoclienet %          %',tipocliente,psf;
					select row_to_json(a.* ) into j_sedefiscale from (
					select  'P' "Tipo",sf.cognome "CognomeRagSoc",sf.nome "Nome",
					'' "PartIva",
						sf.codice_fiscale "CodFiscale",
						sf.indirizzo_completo "Indirizzo",trim(coalesce(sf.cap,'')) "Cap",
						coalesce(sf.istat_indirizzo,'') "ComuneResidenza",istat_nascita "ComuneNascita",
						coalesce(to_char(data_nascita,'dd/mm/yyyy'),'') "DataNascita"
						from cu_anag.vw_soggetti_fisici sf 
	
						
						where sf.codice_fiscale=psf) a;
					raise notice 'j_sedefiscale %',j_sedefiscale;
				else
			/* SEDE FISCALE DA STABILIMENTO SEDI */
					select row_to_json(a.* ) into j_sedefiscale from (
						select  						
							trf.get_tipo_per_sicer(ss.cod_tipo_impresa,ss.cf_impresa,ss.piva_impresa) "Tipo",
						    ss.ragsoc "CognomeRagSoc",'' "nome",
							case when ss.cf_impresa is not null and length(ss.cf_impresa)=16 and length(coalesce(ss.piva_impresa,'')) != 11 and length(coalesce(ss.piva_impresa,'')) != 13 then ''
							else regexp_replace(ss.piva_impresa,'^IT','') end "PartIva",
							ss.cf "CodFiscale",coalesce(ss.toponimo ||' ','')||coalesce(ss.indirizzo ||' ','') "Indirizzo",
							coalesce(ss.cap,'') "Cap",
							coalesce(ss.istat_comune,'') "ComuneResidenza",coalesce(sdi,'') "CodSdi"
						from cu_anag.vw_stabilimento_sedi ss where ss.id_stabilimento=idazsede and cod_tipo_sede ilike 'SF') a;
					raise notice 'SEDE FISCALE DA STABILIMENTO SEDI';
					if j_sedefiscale is null then
			/* SEDE FISCALE DA IMPRESA SEDI */
						select row_to_json(a.* ) into j_sedefiscale from (
						select  
							trf.get_tipo_per_sicer(ss.cod_tipo_impresa,ss.cf,ss.piva) "Tipo",
							ss.ragsoc "CognomeRagSoc",'' "nome",
							case when ss.cf is not null and length(ss.cf)=16 and length(coalesce(ss.piva,'')) != 11 and length(coalesce(ss.piva,'')) != 13 then ''
							else regexp_replace(ss.piva,'^IT','') end "PartIva",
							ss.cf "CodFiscale",coalesce(ss.toponimo ||' ','')||coalesce(ss.indirizzo ||' ','') "Indirizzo",
							coalesce(ss.cap,'') "Cap",
							ss.istat_comune "ComuneResidenza",coalesce(sdi,'') "CodSdi"
						from cu_anag.vw_impresa_sedi ss where ss.id_impresa=idimpresa and cod_tipo_sede ilike 'SF') a;
					raise notice 'SEDE FISCALE DA IMPRESA SEDI';
					end if;
				
					if j_sedelegale is not null then
						j_sedefiscale=j_sedelegale;
					end if;

					if j_sedefiscale is null then
			/* SEDE FISCALE DA STABILIMENTO */					
						select row_to_json(a.* ) into j_sedefiscale from (						
							select 
								trf.get_tipo_per_sicer(ss.cod_tipo_impresa,ss.cf_impresa,ss.piva_impresa) "Tipo",
								ss.ragsoc "CognomeRagSoc",'' "nome",
								case when ss.cf_impresa is not null and length(ss.cf_impresa)=16 and length(coalesce(ss.piva_impresa,'')) != 11 and length(coalesce(ss.piva_impresa,'')) != 13 then ''
								else regexp_replace(ss.piva_impresa,'^IT','') end "PartIva",
								ss.cf_impresa "CodFiscale",coalesce(ss.toponimo ||' ','')||coalesce(ss.indirizzo ||' ','') "Indirizzo",
								coalesce(ss.cap,'') "Cap",
								coalesce(ss.istat_comune,'') "ComuneResidenza",coalesce(sdi,'') "CodSdi"
							from cu_anag.vw_stabilimenti ss where ss.id_stabilimento=idazsede) a;
						raise notice 'SEDE FISCALE  DA STABILIMENTO';
					end if;
				end if;
				raise notice 'j_sedefiscale %',j_sedefiscale;
			end if;
			if upper(tipocliente)='SOGGETTO_FISICO' then
			select row_to_json(a.*) into j_stabilimento from (
				select nome || ' ' ||cognome "Insegna",'T52' "CodTipologiaStruttura",indirizzo_luogo "Indirizzo",
				istat_indirizzo "Comune",'G'||c.id_asl "CodAsl"
				from cu_anag.vw_soggetti_fisici vsf join agenda.vw_comuni c on vsf.istat_indirizzo=c.istat_comune
			where codice_fiscale=psf) a ;
				--j_stabilimento:='{"CodTipologiaStruttura":"T52"}';
			end if;
			raise notice 'JSON ARRAY %',rt;
			raise notice 'j_stabilimento%',j_stabilimento;
			raise notice 'j_prestazioni%',j_prestazioni;
			raise notice 'j_sedefiscale%',j_sedefiscale;
			raise notice 'j_proprietario%',j_proprietario;
			raise notice 'j_sedelegale%',j_sedelegale;
			str_stabilimento:=substring(j_stabilimento::varchar,2, length(j_stabilimento::varchar)-2);
			raise notice 'str_stabilimento%',str_stabilimento;
			strj:=trf.translitterato_per_sicer('{"Prestazioni":'||j_prestazioni||coalesce(',"SedeFiscale":'||j_sedefiscale,'')||
					coalesce(',"Proprietario":'||j_proprietario,'')||
					coalesce(',"SedeLegale":'||j_sedelegale,'')||coalesce(','||str_stabilimento,'')||'}');
			raise notice 'strj %',strj;
			select * into R_AI from trf.trf_att_inviate where id_trf_attivita=F.id;
			if R_AI.id is null then
				R_AI.id:=nextval('agenda.agenda_id_seq');
				insert into trf.trf_att_inviate values(R_AI.id,F.id,current_timestamp,strj);
				n:=ag_log.upd_record('trf.trf_att_inviate',idtransazione,R_AI,'I');
				raise notice 'INSERT';
			else
				update trf.trf_att_inviate set str_j=strj where id=R_AI.id;
				n:=ag_log.upd_record('trf.trf_att_inviate',idtransazione,R_AI,'U');
				raise notice 'UPDATE';
			end if;
			--delete from trf.trf_att_inviate where id_trf_attivita=F.id;
			--insert into trf.trf_att_inviate values(nextval('agenda.agenda_id_seq'),F.id,current_timestamp,strj);
			insert into trf.trf_att_inviate_stati values(nextval('trf.trf_att_inviate_stati_id_seq'),R_AI.id,
				case when strj is null then 'ERRORE GISA GENERAZIONE JSON :'|| 
				case when j_stabilimento is null then ' Stabilimento' else '' end ||
				case when j_prestazioni is null then ' prestazioni ' else '' end ||
				case when j_sedefiscale is null then ' sedefiscale' else '' end ||
				case when j_proprietario is null then ' proprietario' else '' end ||
				case when j_sedelegale is null then ' sedelegale' else '' end
				else null end,
				R_S.id,current_timestamp);
			n:=n+1;
		end loop;

		if n <= 0 then
			ret.esito:=true;	
			ret:=ag_ui.build_ret(ret,proc_name,'attività_non_trovate');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.upd_att_da_inviare(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_att_da_inviare_2024_01_12(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_att_da_inviare_2024_01_12(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret         ag_types.result_type; 
	ret_calcolo ag_types.result_type; 
	ret_xml ag_types.result_type; 
	id_op bigint; 
	proc_name varchar;
	rt json;
	n integer;
	nf integer;
	j_prestazioni  json;
	j_sedefiscale  json;
	j_sedelegale   json;
	j_proprietario json;
	j_detentore    json;
	j_stabilimento json;
	str_stabilimento varchar;
	is_organization text;
	strj json;
	F Record;
	R_AI trf.trf_att_inviate;
	R_S trf_types.trf_fattura_stati;
	R_FP trf.trf_ft_periodiche;
	begin
		proc_name:='trf.upd_att_da_inviare';
	
		id_op:=ag_log.start_op(proc_name,idtransazione ,'');
		n:=0; 
		select * into R_S from trf_types.trf_fattura_stati where cod = 'generata';

		for F in select * from trf.trf_attivita vta 
			where id in (
				select (value::varchar)::bigint from json_array_elements(v_j->'id_trf_attivita') )
				/*and id not in (select id_trf_attivita  from trf.trf_att_inviate)*/
				order by id_cliente ,per_conto_di loop
					raise notice 'Attivita LETTA';
			select json_agg(row_to_json(a.*)) into j_prestazioni   from (
				select t.id "IdPrestazione",t.sigla "CodicePrestazione",t.descr "DescrizionePrestazione",
				to_char(a.data_da,'dd/mm/yyyy') "DataPrestazione",d.valore "Quantita",'G'||a.per_conto_di "AslFatt",
				an.codice_fiscale "DatoFiscaleOp",d.id "IdGisa",0 "Importo",'N' "FuoriFascia",'' Protocollo,
				case when sa.descrizione_breve is not null and sa.descrizione_breve ilike '%SIAN%' then 'SI' else 'SV' end "CodServizio"
				from trf.trf_attivita_dettagli d
				join trf.trf_attivita a on a.id=d.id_trf_attivita
				left join matrix.struttura_asl sa on sa.id=a.per_conto_di_struttura
				join trf.tariffe t on t.id=d.id_tariffa 
				join matrix.anagrafica an on an.id_anagrafica=a.id_trf_operatore 
				where id_trf_attivita=F.id
			) a;
		 	raise notice 'j_prestazioni %',j_prestazioni;
		
			select riferimento_id_nome_tab into is_organization 	
			from trf.clienti c
			join agenda.vw_linee l on c.id_ref =l.id 
			where c.id=F.id_cliente; 
		
			if is_organization = 'organization' then 
			
				select row_to_json(a.* ) into j_proprietario from (
						select case when sf.codice_fiscale is not null then 'P' else 'S' end "Tipo",
					l.piva "CognomeRagSoc", sf.nome "Nome", 
					case when sf.codice_fiscale is not null then '' else l.piva end "PartIva", 
					sf.codice_fiscale "CodFiscale",
					l.indirizzo "Indirizzo", l.provincia_istat||l.comune_istat "ComuneResidenza", l.cap "Cap", 
					lpad(ac_n.codistat::varchar,6,'0') "ComuneNascita",
					coalesce(to_char(sf.data_nascita,'dd/mm/yyyy'),'') "DataNascita"
						from trf.clienti c
					join agenda.vw_linee l on c.id_ref =l.id 
					join matrix.vw_stabilimenti_linee sl on sl.id = l.id
					left join cu_anag.vw_soggetti_fisici sf on sf.codice_fiscale = l.piva
					left join conf_ext.vw_comuni_vigenti_attivi ac_n on
								(ac_n.denominazione_it=sf.comune_nascita or ac_n.denominazione_composta =sf.comune_nascita)
					where c.id=F.id_cliente 
				) a;	
			
			select row_to_json(a.* ) into j_stabilimento from (
				select 'AL' "CodTipologiaStruttura",
					case when l.cod_tipo_linea like '% - % - %' then lpad(substring(l.cod_tipo_linea, 1,strpos(l.cod_tipo_linea,' - ') -1 ), 4, '0')
			 					else '' end "CodSpecie", 
			 		--sl.num_riconoscimento "IdBdn",
			 		l.rag_soc "Insegna", 'G'||l.id_struttura "CodAsl",
			 		l.indirizzo "Indirizzo", l.provincia_istat||l.comune_istat "Comune", 
			 		sl.num_riconoscimento "CodAziendale"
					from trf.clienti c
						join agenda.vw_linee l on c.id_ref =l.id 
						join matrix.vw_stabilimenti_linee sl on sl.id = l.id
						left join cu_anag.vw_soggetti_fisici sf on sf.codice_fiscale = l.piva
						left join conf_ext.vw_comuni_vigenti_attivi ac_n on
								(ac_n.denominazione_it=sf.comune_nascita or ac_n.denominazione_composta =sf.comune_nascita)
			
						where c.id=F.id_cliente 
				) a;
			
			select row_to_json(a.* ) into j_sedefiscale from (
				select case when sf.codice_fiscale is not null then 'P' else 'S' end "Tipo",
					l.piva "CognomeRagSoc", sf.nome "Nome", 
					case when sf.codice_fiscale is not null then '' else l.piva end "PartIva", 
					sf.codice_fiscale "CodFiscale",
					l.indirizzo "Indirizzo", l.provincia_istat||l.comune_istat "ComuneResidenza", l.cap "Cap", 
					lpad(ac_n.codistat::varchar,6,'0') "ComuneNascita",
					coalesce(to_char(sf.data_nascita,'dd/mm/yyyy'),'') "DataNascita"
					from trf.clienti c
					join agenda.vw_linee l on c.id_ref =l.id 
					join matrix.vw_stabilimenti_linee sl on sl.id = l.id
					left join cu_anag.vw_soggetti_fisici sf on sf.codice_fiscale = l.piva
					left join conf_ext.vw_comuni_vigenti_attivi ac_n on
								(ac_n.denominazione_it=sf.comune_nascita or ac_n.denominazione_composta =sf.comune_nascita)
					where c.id=F.id_cliente 
				) a;
				raise notice 'j_sedefiscale %',j_sedefiscale;
			
			else 
			
			select row_to_json(a.* ) into j_stabilimento from (
			 select ss.sd_cod_tipologia_struttura "CodTipologiaStruttura",
			 		case when l.cod_tipo_linea like '% - % - %' then lpad(substring(l.cod_tipo_linea, 1,strpos(l.cod_tipo_linea,' - ') -1 ), 4, '0')
			 					else '' end "CodSpecie", 	
			 		--case when imp.az_cod_aziendale  ~ '[0-9]{3}[A-Z]{2}[0-9]{3}' then imp.az_cod_aziendale else '' end "IdBDN",
					ss.nome "Insegna", coalesce(imp.az_cod_aziendale,'') "CodAziendale",/*imp.az_cod_aziendale*/
					coalesce(ss.sd_cod_regionale,imp.az_cod_aziendale) "NumRegistrazione",'' "NumRiconoscimento",
					--coalesce(i.toponimo ||' ','')||coalesce(i.indirizzo ||' ','')||coalesce(i.cap||' ','') "Indirizzo",
					coalesce(ss.toponimo ||' ','')||coalesce(ss.indirizzo ||' ','') "Indirizzo",
					lpad(ss.istat::varchar,6,'0') "Comune",'G'||/*F.per_conto_di*/ac.id_asl "CodAsl",ac.cap_default "Cap"
					from trf.clienti c
					join agenda.vw_linee l on c.id_ref =l.id 
					join cu_anag.imprese imp on l.piva=imp.piva or l.piva=imp.cf
					join cu_anag.stabilimenti ss on imp.id=ss.id_impresa and ss.comune=l.comune
					left join agenda.comuni ac on ac.comune =ss.comune --=i.comune
					where c.id=F.id_cliente order by l.id limit 1 --and sss.id_tipo_sede =1
				) a;
			
		
				select row_to_json(a.* ) into j_proprietario from (
					select imp.cod_tipo_impresa /*'P'*/ "Tipo",sf.cognome "CognomeRagSoc",sf.nome "Nome",sf.codice_fiscale "CodFiscale", sf.indirizzo_nome "Indirizzo" ,
						lpad(ac.codistat::varchar,6,'0') "ComuneResidenza",sf.cap "Cap",'' "Pec",
						coalesce(sf.email,'') "Mail",coalesce(sf.telefono,'') "Telefono",coalesce(to_char(sf.data_nascita,'dd/mm/yyyy'),'') "DataNascita",
						lpad(ac_n.codistat::varchar,6,'0') "ComuneNascita"
							from trf.clienti c
						join agenda.vw_linee l on c.id_ref =l.id 
						join cu_anag.imprese imp on l.piva=imp.piva or l.piva=imp.cf
						join cu_anag.stabilimenti ss on imp.id=ss.id_impresa and ss.comune=l.comune
						join cu_anag.vw_stabilimento_figure sf on sf.id_stabilimento=ss.id
						left join conf_ext.vw_comuni_vigenti_attivi ac on
								(ac.denominazione_it=sf.comune_residenza or ac.denominazione_composta =sf.comune_residenza)
						left join conf_ext.vw_comuni_vigenti_attivi ac_n on
								(ac_n.denominazione_it=sf.comune_nascita or ac_n.denominazione_composta =sf.comune_nascita)
						where c.id=F.id_cliente and sf.id_tipo_figura=6
				) a;	
			
				select row_to_json(a.* ) into j_sedelegale from (
					select imp.cod_tipo_impresa  "Tipo",
					--case when sss.cf is not null and length(sss.cf)=16 and length(coalesce(sss.piva,'')) != 11 then 'P' else 'S' end "Tipo",
					imp.nome "CognomeRagSoc",'' "nome",
					       case when sss.cf is not null and length(sss.cf)=16 and length(coalesce(sss.piva,'')) != 11 then '' else sss.piva end "PartIva",
					sss.cf "CodFiscale",coalesce(i.toponimo ||' ','')||coalesce(i.indirizzo ||' ','') "Indirizzo",coalesce(i.cap,'') "Cap",
					lpad(ac.codistat::varchar,6,'0') "ComuneResidenza",i.cap /*ac.cap_default*/ "Cap"
					from trf.clienti c
					join agenda.vw_linee l on c.id_ref =l.id 
					join cu_anag.imprese imp on l.piva=imp.piva  or l.piva=imp.cf
					join cu_anag.stabilimenti ss on imp.id=ss.id_impresa and ss.comune=l.comune
					join cu_anag.stabilimento_sedi sss on sss.id_stabilimento =ss.id
					join cu_anag.indirizzi i on sss.id_indirizzo =i.id
					--left join agenda.comuni ac on ac.comune =i.comune 
					left join conf_ext.vw_comuni_vigenti_attivi ac on ac.denominazione_it=i.comune  or ac.denominazione_composta =i.comune
					where c.id=F.id_cliente and sss.id_tipo_sede =1  order by l.id limit 1
				) a;	
			
				select row_to_json(a.* ) into j_sedefiscale from (
				select --case when sss.cf is not null and length(sss.cf)=16 and length(coalesce(sss.piva,'')) != 11 then 'P' else 'S' end
					imp.cod_tipo_impresa "Tipo",
					imp.nome "CognomeRagSoc",'' "nome",
					   case when sss.cf is not null and length(sss.cf)=16 and length(coalesce(sss.piva,'')) != 11 then '' else sss.piva end "PartIva",
					sss.cf "CodFiscale",coalesce(i.toponimo ||' ','')||coalesce(i.indirizzo ||' ','') "Indirizzo",coalesce(i.cap,'') "Cap",
					lpad(ac.codistat::varchar,6,'0') "ComuneResidenza",/*ac.cap_default*/ i.cap "Cap"
					from trf.clienti c
					join agenda.vw_linee l on c.id_ref =l.id 
					join cu_anag.imprese imp on l.piva=imp.piva or l.piva=imp.cf
					join cu_anag.stabilimenti ss on imp.id=ss.id_impresa and ss.comune=l.comune
					join cu_anag.stabilimento_sedi sss on sss.id_stabilimento =ss.id
					join cu_anag.indirizzi i on sss.id_indirizzo =i.id
					--left join agenda.comuni ac on ac.comune =i.comune 
					left join conf_ext.vw_comuni_vigenti_attivi ac on ac.denominazione_it=i.comune  or ac.denominazione_composta =i.comune
					where c.id=F.id_cliente and sss.id_tipo_sede =2  order by l.id limit 1
				) a;
				raise notice 'j_sedefiscale %',j_sedefiscale;
			end if;
				
			raise notice 'JSON ARRAY %',rt;
			raise notice 'j_stabilimento%',j_stabilimento;
			raise notice 'j_prestazioni%',j_prestazioni;
			raise notice 'j_sedefiscale%',j_sedefiscale;
			raise notice 'j_proprietario%',j_proprietario;
			raise notice 'j_sedelegale%',j_sedelegale;
			str_stabilimento:=substring(j_stabilimento::varchar,2, length(j_stabilimento::varchar)-2);
			strj:=trf.translitterato_per_sicer('{"Prestazioni":'||j_prestazioni||coalesce(',"SedeFiscale":'||j_sedefiscale,'')||
					coalesce(',"Proprietario":'||j_proprietario,'')||
					coalesce(',"SedeLegale":'||j_sedelegale,'')||','||str_stabilimento||'}');
			select * into R_AI from trf.trf_att_inviate where id_trf_attivita=F.id;
			if R_AI.id is null then
				R_AI.id:=nextval('agenda.agenda_id_seq');
				insert into trf.trf_att_inviate values(R_AI.id,F.id,current_timestamp,strj);
				raise notice 'INSERT';
			else
				update trf.trf_att_inviate set str_j=strj where id=R_AI.id;
				raise notice 'UPDATE';
			end if;
			--delete from trf.trf_att_inviate where id_trf_attivita=F.id;
			--insert into trf.trf_att_inviate values(nextval('agenda.agenda_id_seq'),F.id,current_timestamp,strj);
			insert into trf.trf_att_inviate_stati values(nextval('trf.trf_att_inviate_stati_id_seq'),R_AI.id,
				case when strj is null then 'ERRORE GISA GENERAZIONE JSON :'|| 
				case when j_stabilimento is null then ' Stabilimento' else '' end ||
				case when j_prestazioni is null then ' prestazioni ' else '' end ||
				case when j_sedefiscale is null then ' sedefiscale' else '' end ||
				case when j_proprietario is null then ' proprietario' else '' end ||
				case when j_sedelegale is null then ' sedelegale' else '' end
				else null end,
				R_S.id,current_timestamp);
			n:=n+1;
		end loop;

		if n <= 0 then
			ret.esito:=true;	
			ret:=ag_ui.build_ret(ret,proc_name,'attività_non_trovate');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.upd_att_da_inviare_2024_01_12(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_att_forfet_stato(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_att_forfet_stato(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idstato bigint;
        proc_name varchar; -- END
       	R_AT trf.trf_attivita_forfet%ROWTYPE; 
        n bigint;
        begin
		proc_name:='trf.upd_att_forfet_stato';
		idstato:=v_j->'id_stato';
		if idstato is null then
		    ret.esito:=false;	
			ret:=ag_ui.build_ret(ret,proc_name,'stato_non_specificato');
			return ret;
		end if;
			
		for R_AT in update trf.trf_attivita_forfet  set id_stato =idstato where id in (
			select  (value::varchar)::bigint from 
			json_array_elements(v_j->'attivita') ) returning * loop 
			--n:=ag_log.upd_record('trf.trf_attivita_forfet',idtransazione,R_AT,'U');
				n:=0;
		end loop;
			
    	ret.esito:=true;	
		ret:=ag_ui.build_ret(ret,proc_name,null);
		return ret;
	end;
END
$$;


ALTER FUNCTION trf.upd_att_forfet_stato(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_att_id_cliente(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_att_id_cliente(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idlinea bigint;
        proc_name varchar; -- END
        idstabilimento bigint;
       	cf varchar;
        R_C trf.clienti;
       	R_T trf.trf_attivita;
       	R_SF cu_anag.soggetti_fisici;
       	R_SS cu_anag.vw_stabilimenti_all;
       	n integer;
        begin
		proc_name:='trf.upd_att_id_cliente';

		raise notice 'V_J %',v_j;
		idstabilimento:= (v_j->>'id_stabilimento')::bigint;
		cf:= v_j->>'codice_fiscale';
		if cf is not null then
			select * into R_C from trf.clienti where piva=cf; 
			if R_C.id is null then
				select * into R_SF from cu_anag.soggetti_fisici sf  where codice_fiscale=cf; 
				R_C.id:= nextval('agenda.agenda_id_seq');
				R_C.id_ref:=R_SF.id; --R_EV.id_linea;
				R_C.piva:=cf; --R_EV.id_linea;
				R_C.descr:=cf;
				R_C."type" :='soggetto_fisico';
				insert into trf.clienti values (R_C.*);
				n:=ag_log.upd_record('trf.clienti',idtransazione,R_C,'I');
			end if;
		else
			if idstabilimento is not null then
				select c.* into R_C from trf.clienti c where id_ref=idstabilimento and c."type" ='az_sede';
				if R_C.id is null then
				select * into R_SS from cu_anag.vw_stabilimenti_all s where id = idstabilimento;
					R_C.id:= nextval('agenda.agenda_id_seq');
					R_C.id_ref:=idstabilimento; --R_EV.id_linea;
					R_C."type" :='az_sede';
					R_C.descr:=R_SS.nome;
					R_C.piva:=coalesce(R_SS.piva_impresa,R_SS.cf_impresa);
					insert into trf.clienti values (R_C.*);
					n:=ag_log.upd_record('trf.clienti',idtransazione,R_C,'I');
				end if;
			else
				ret.esito:=false;
	    		ret:=cu_ui.build_ret(ret,proc_name, 'cliente_non_specificato');
	    		ret.info = null;
	    		return ret;
			end if;
		end if;
		update trf.trf_attivita set id_cliente=R_C.id where id=(v_j->>'id_attivita')::bigint returning * into R_T;
		n:=ag_log.upd_record('trf.trf_attivita',idtransazione,R_T,'U');	
	
    	ret.esito:=true;	
		ret:=ag_ui.build_ret(ret,proc_name,idlinea);
		return ret;
	end;
END
$$;


ALTER FUNCTION trf.upd_att_id_cliente(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_att_id_tariffa(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_att_id_tariffa(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idlinea bigint;
        proc_name varchar; -- END
        idtariffa bigint;
       	R_T trf.trf_attivita;
       	n integer;
        begin
		proc_name:='trf.upd_att_id_tariffa';

		raise notice 'V_J %',v_j;
		idtariffa:= (v_j->>'id_tariffa')::bigint;
		update trf.trf_attivita set id_tariffa=idtariffa where id=(v_j->>'id_attivita')::bigint returning * into R_T;
		n:=ag_log.upd_record('trf.trf_attivita',idtransazione,R_T,'U');
			
    	ret.esito:=true;	
		ret:=ag_ui.build_ret(ret,proc_name,idlinea);
		return ret;
	end;
END
$$;


ALTER FUNCTION trf.upd_att_id_tariffa(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_att_inviata_sicer(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_att_inviata_sicer(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret         ag_types.result_type; 
	id_op bigint; 
	proc_name varchar;
	R_AS trf.trf_att_inviate_stati;
	rt json;
	esito varchar;
	n integer;

	begin
		proc_name:='trf.upd_att_inviata_sicer';
		raise notice 'v_j= %', v_j;
		R_AS.id:=nextval('trf.trf_att_inviate_stati_id_seq');
		R_AS.id_att_inviata:=v_j->'id_att_inviata';
		R_AS.ret:=v_j->>'ret';
		R_AS.ts:=current_timestamp;
		raise notice 'R_AS%', R_AS;
		esito:=R_AS.ret::json->'result'->'esito';
		if R_AS.ret like'%"result":{"esito":"OK"%' then
			select id into R_AS.id_trf_att_inviate_tipo_stati from trf_types.trf_att_inviate_tipo_stati where cod='f';
		else
			select id into R_AS.id_trf_att_inviate_tipo_stati from trf_types.trf_att_inviate_tipo_stati where cod='i';
		end if;
		raise notice 'esito %', esito;
		insert into trf.trf_att_inviate_stati values (R_AS.*);
		n:=ag_log.upd_record('trf.trf_att_inviate_stati',idtransazione,R_AS,'I');		
	
		ret.esito:=true;
		ret.msg:=null;
 		ret.info:='';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.upd_att_inviata_sicer(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_fatture(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_fatture(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
		ret ag_types.result_type;
		R record;
	begin

	delete from trf.trf_fattura_dettagli;
	delete from trf.trf_fatture;
	insert into trf.trf_fatture select
		nextval('agenda.agenda_id_seq'),id_cliente, current_timestamp,id_tariffa from 
		(select distinct id_cliente,id_tariffa  from trf.trf_attivita) a;
	insert into trf.trf_fattura_dettagli select nextval('agenda.agenda_id_seq'), x.* from
		
	(select f.id id_trf_fattura, d.id_tariffa,sum(valore::numeric),sum(costo::numeric) from trf.trf_attivita_dettagli d
			join trf.trf_attivita a on a.id=d.id_trf_attivita 
			
			join trf.trf_fatture f on f.id_cliente=a.id_cliente and f.id_tariffa =a.id_tariffa
			
			 group by 1,2) x;
	for R in select id from trf.trf_fatture tf loop
		ret:=trf.upd_fatture_calcolo(('{"id_trf_fattura":'||R.id||'}')::json,1)	;
	end loop;
	
    ret.esito:=true;
 	ret.msg:=null;
	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.upd_fatture(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_fatture_calcolo(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_fatture_calcolo(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
		ret ag_types.result_type;
		R record;
		idtrffattura bigint;
	    n integer;
        k integer;
       cnt integer;
       magg decimal;
	begin
	idtrffattura:=v->'id_trf_fattura';
    raise notice 'FATTURA %',idtrffattura;
	n:=0;
    k:=1;
    cnt:=1;
   	--select value::decimal into magg from ag_cof.
   	magg :=  ag_conf.get_value('trf_param_magg',current_timestamp::timestamp)::decimal;
    --magg:=5.0/1000;
	while k>0 and cnt <= 20 loop
		insert into trf.trf_fattura_dettagli 
			select nextval('agenda.agenda_id_seq'), d.*,row_number () over () +n from (
				select idtrffattura,rf.id_tariffa,
					case when op='+' or upper(trim(op))='SOMMA' then sum(coalesce(valore,0)) when upper(trim(op))='MIN' then min(valore) when upper(trim(op))='MAGG' then sum(valore*magg) end,
					case when op='+' or upper(trim(op))='SOMMA' then sum(coalesce(costo,0))  when upper(trim(op))='MIN' then min(costo)  when upper(trim(op))='MAGG' then sum(costo *magg) end
					from trf.trf_fattura_dettagli fd
					join trf.trf_regole_fatt_dett rd on fd.id_tariffa = rd.id_tariffa
					join trf.trf_regole_fatt rf on rd.id_regola_fatt =rf.id  and ord_exec=cnt
					where fd.id_trf_fattura =idtrffattura group by 1,2,op) d;
		get diagnostics k = row_count; 
		raise notice 'CICLO % GENERATE % RIGHE' ,cnt,k;
		n:=n+k;
		cnt := cnt +1;
	end loop;

	
    ret.esito:=true;
 	ret.msg:=null;
	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.upd_fatture_calcolo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_fatture_xml(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_fatture_xml(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $_$
begin
	declare
		ret ag_types.result_type;
		R record;
		R_REPLACE record;
		idtrffattura bigint;
      	--j json;
      	txt_xml varchar;
      	testo_modificato varchar;
	begin
	idtrffattura:=v->'id_trf_fattura';
    raise notice 'FATTURA %',idtrffattura;

	select tf.testo into txt_xml from trf_conf.template_fatturazione tf where descr = 'GEFF';
	raise notice 'txt_xml %',txt_xml;
   /*	for R in select d.* from trf.trf_fattura_dettagli d join trf.tariffe t on d.id_tariffa =t.id and t.visibile_contabilita
   		where d.id_trf_fattura = idtrffattura loop
	   	testo_modificato:= txt_xml;
	    raise notice 'R.id  %',R.id;
	   	select row_to_json( c.*) into j from trf.vw_dati_per_contabilita c
			where c.id_fattura_dettaglio =R.id;
	   	for R_REPLACE in select key,coalesce(value,'') value from json_each_text(j) loop
			raise notice 'R_PLACE %',R_REPLACE;
			testo_modificato:=replace(testo_modificato,'$'||R_REPLACE.key||'$',R_REPLACE.value);	
			raise notice 'TESTO_MODIFICATO %', testo_modificato;
		end loop;
		update trf.trf_fattura_dettagli set stringa_xml=testo_modificato where id =R.id;	
   	end loop;*/

	for R in select c.id_fattura_dettaglio ,row_to_json(c.*) j from trf.vw_dati_per_contabilita c where c.id_trf_fattura = idtrffattura loop
		testo_modificato:= txt_xml;
		for R_REPLACE in select key,coalesce(value,'') value from json_each_text(R.j) loop
			raise notice 'R_PLACE %',R_REPLACE;
			testo_modificato:=replace(testo_modificato,'$'||R_REPLACE.key||'$',replace(R_REPLACE.value,'&','e'));	
			raise notice 'TESTO_MODIFICATO %', testo_modificato;
		end loop;
		update trf.trf_fattura_dettagli set stringa_xml=testo_modificato where id =R.id_fattura_dettaglio;
	end loop;
    ret.esito:=true;
 	ret.msg:=null;
	return ret;
	end;
end;
$_$;


ALTER FUNCTION trf.upd_fatture_xml(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_genera_fatture(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_genera_fatture(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret         ag_types.result_type; 
	ret_calcolo ag_types.result_type; 
	ret_xml ag_types.result_type; 
	id_op bigint; 
--idstrutturaroot bigint;
	proc_name varchar;
	rt json;
	n integer;
	nf integer;
	R_F Record;
	L_F record;
	R_S record;
	begin
		SET search_path TO trf,agenda,public;
		proc_name:='trf.upd_genera_fatture';
		--idstrutturaroot:=((v_j->>'user_info')::json)->'id_struttura_root';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		n:=0; 
		select * into R_S from trf_types.trf_fattura_stati where cod = 'generata';
		for L_F in select id_cliente ,id_tariffa,per_conto_di,DATE_TRUNC('month', data_da) dt
		from trf.trf_attivita where id_fattura is null and id in (
		select  (value::varchar)::bigint from json_array_elements(v_j->'id_attivita') )
		group by 1,2,3,4  loop
			insert into trf.trf_fatture values (nextval('agenda.agenda_id_seq'),L_F.id_cliente,current_timestamp,
			L_F.id_tariffa,L_F.per_conto_di,nextval('trf.trf_fatture_id_seq'::regclass),null,L_F.dt);
			--get diagnostics n = row_count;
			insert into trf.trf_fattura_stati values(nextval('trf.trf_fattura_stati_id_seq'),
				currval('agenda.agenda_id_seq'),null,R_S.id,current_timestamp);
			raise notice 'FATTURA GENERATA % % % %',L_F.id_cliente ,L_F.id_tariffa,L_F.per_conto_di,L_F.dt;
			n := n+1;
		end loop;
		nf:=n;
		raise notice 'FATTURE %',n;

		update trf.trf_attivita a set id_fattura = (
			select id from trf.trf_fatture f
			where a.id_cliente=f.id_cliente and (a.id_tariffa=f.id_tariffa or (a.id_tariffa is null and f.id_tariffa is null))
			and a.per_conto_di= f.id_asl and data_creazione=current_timestamp and dt=DATE_TRUNC('month', a.data_da))
		where a.id_fattura is null and id in (select  (value::varchar)::bigint from json_array_elements(v_j->'id_attivita'));
	    get diagnostics n = row_count;
		raise notice 'ATTIVITA %',n;	
	
		insert into trf.trf_fattura_dettagli select nextval('agenda.agenda_id_seq'), a.* from
		(select id_fattura,d.id_tariffa ,sum(d.valore::numeric) valore,/*sum(d.costo)*/ 0 costo 
			from trf.trf_attivita a join trf.trf_attivita_dettagli d on d.id_trf_attivita =a.id
												  join trf.trf_fatture f on a.id_fattura =f.id
		where a.id in (select  (value::varchar)::bigint from json_array_elements(v_j->'id_attivita')) group by 1,2)a;
	
	
		update trf.trf_fattura_dettagli fd set costo=trf.calcola_costo(id_tariffa,valore,f.dt,f.id_asl) from
			(select f.id,f.dt,f.id_asl,tfd.id  id_fattura_dettaglio
				from trf.trf_attivita a  join trf.trf_fatture f on a.id_fattura =f.id
				join trf.trf_fattura_dettagli tfd on tfd.id_trf_fattura=f.id
			where a.id in (select  (value::varchar)::bigint from json_array_elements(v_j->'id_attivita')) ) as f
		where fd.id=f.id_fattura_dettaglio;
	
	
		
	
	
    	get diagnostics n = row_count;
			raise notice 'DETTAGLI %',n;
	
	
    	for R_F in select * from trf.trf_fatture where data_creazione=current_timestamp loop
	    	raise notice 'CALCOLO FATTURA';
	    	ret_calcolo:= trf.upd_fatture_calcolo(('{"id_trf_fattura":'||R_F.id||'}')::json,idtransazione);
	    	raise notice 'CALCOLO XML';
	    	ret_xml:= trf.upd_fatture_xml(('{"id_trf_fattura":'||R_F.id||'}')::json,idtransazione);
		end loop;

		ret.esito:=true;
	
		if nf <= 0 then
			ret.esito:=true;	
			ret:=ag_ui.build_ret(ret,proc_name,'attivita_fatture_non_trovate');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.upd_genera_fatture(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_genera_ft_periodiche(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_genera_ft_periodiche(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret         ag_types.result_type; 
	ret_calcolo ag_types.result_type; 
	ret_xml ag_types.result_type; 
	id_op bigint; 
--idstrutturaroot bigint;
	proc_name varchar;
	rt json;
	n integer;
	nf integer;
	F Record;
	R_S trf_types.trf_fattura_stati;
	R_FP trf.trf_ft_periodiche;
	begin
		proc_name:='trf.upd_genera_ft_periodiche';

		id_op:=ag_log.start_op(proc_name,idtransazione ,'');
		n:=0; 
		select * into R_S from trf_types.trf_fattura_stati where cod = 'generata';

		for F in select DATE_TRUNC('quarter', dt) q,*,row_number ()  over 
			(partition by id_cliente ,id_asl, DATE_TRUNC('quarter', dt) 
			 order by descr_tariffa) ordine,descr_tariffa,costo from trf.vw_trf_fatture vtf
			where id in (
				select (value::varchar)::bigint from json_array_elements(v_j->'id_fatture') )
				and id not in (select tfpd.id_trf_fattura id from trf.trf_ft_periodiche_dett tfpd)
				order by id_cliente ,id_asl, DATE_TRUNC('quarter', dt) loop
					raise notice 'FATTURA LETTA';
			if F.ordine = 1 then
				/*if (R_FP.id is not null ) then 
					ret_xml:=trf.upd_ft_periodica_xml(('{"id_trf_ft_periodica":'||R_FP.id||'}')::json,idtransazione);
				end if;*/
				R_FP.id:=nextval('agenda.agenda_id_seq');
				R_FP.id_cliente:=F.id_cliente;
				R_FP.data_creazione:=current_timestamp;
				R_FP.id_asl:=F.id_asl;
				R_FP.n_ft_periodica:=nextval('trf.trf_ft_periodiche_id_seq'::regclass);
				R_FP.dt:=F.q;
				insert into trf.trf_ft_periodiche values (R_FP.*);
				raise notice 'CREAZIONE trf_ft_periodiche';

				insert into trf.trf_ft_periodiche_stati values(nextval('trf.trf_ft_periodiche_stati_id_seq'),
				currval('agenda.agenda_id_seq'),null,R_S.id,current_timestamp);
				raise notice 'INSERT  trf_ft_periodiche_stati';
				raise notice 'FATTURA PERIODICA GENERATA % % %',F.id_cliente ,F.id_asl,F.dt;
				n := n+1;
			end if;
					
			insert into trf.trf_ft_periodiche_dett values(nextval('agenda.agenda_id_seq'),R_FP.id,
				F.dt,F.descr_tariffa,F.costo,F.ordine,null,F.id_trf_fattura);
				raise notice 'INSERT  trf_ft_periodiche_dettagli';
					
		end loop;
	
	/*	if (R_FP.id is not null ) then 
			ret_xml:=trf.upd_ft_periodica_xml(('{"id_trf_ft_periodica":'||R_FP.id||'}')::json,idtransazione);
		end if;*/
				
		if n <= 0 then
			ret.esito:=true;	
			ret:=ag_ui.build_ret(ret,proc_name,'prestazioni_non_trovate');
    		ret.info:=null; 
    	else
    		ret.esito:=true;
 			ret.msg:=null;
	 		ret.info:=rt;
		end if;
	
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.upd_genera_ft_periodiche(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_piano_periodo(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_piano_periodo(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	id_op bigint;   
	proc_name varchar;
	idpiano bigint;
	periodoTime tsrange;

	begin
		proc_name:='trf.upd_piano_periodo';
		
		idpiano=v->'id_piano';
		raise notice 'id_piano: %', idpiano;
	
		raise notice 'periodo from JSON: %', v->>'periodo';
	
		periodoTime=v->>'periodo';
		raise notice 'periodo: %', periodoTime;
		
		delete from agenda.piano_periodo where id_piano = idpiano;
	
		insert into agenda.piano_periodo (id_piano, periodo) values (idpiano, periodoTime);
	
    	ret.esito:=true;
        ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato');
		ret.info='0';
 		--ret.msg:=null;
 		--ret.info:=true;
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.upd_piano_periodo(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_rilevazione_attivita(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_rilevazione_attivita(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
		ret ag_types.result_type;
		R record;
		R_A trf.trf_attivita%ROWTYPE;
		R_AD trf.trf_attivita_dettagli;
		n integer;
		idtrfattivita int8;
	   proc_name varchar;
	begin
     proc_name:='trf.upd_rilevazione_attivita';
    SET search_path TO trf,agenda,public;
	idtrfattivita =v->'id_trf_attivita';
	proc_name:='trf.upd_rilevazione_attivita';
	select * into R_A from trf.trf_attivita where id=idtrfattivita;
	if (R_A.closed) then
	    ret.esito:=false;	
    	ret:=ag_ui.build_ret(ret,proc_name,'attivita_gia_chiusa');
        ret.info = null;
	   -- ret.esito:=false;
 		--ret.msg:=ag_ui.build_ret(ret,proc_name, 'attivita_gia_chiusa');
	return ret;
	end if;
	delete from trf.trf_attivita_dettagli where id_trf_attivita =idtrfattivita;
	for R in select *  from json_to_recordset(v->'valori') as x(id_tariffa bigint,valore varchar) loop
			insert into trf.trf_attivita_dettagli values(nextval('agenda.agenda_id_seq'),
			idtrfattivita,R.id_tariffa,trim(R.valore),0 
		/*trf.calcola_costo(R.id_tariffa,R.valore::numeric,R_A.data_da,R_A.per_conto_di)*/)
			returning * into R_AD;
			n:=ag_log.upd_record('trf.trf_attivita_dettagli',idtransazione,R_AD,'I');
			raise notice 'ID_TARIFFA %',R.id_tariffa;
	end loop;

    ret.esito:=true;
 	ret.msg:=null;
	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.upd_rilevazione_attivita(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_scontrino_pdf(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_scontrino_pdf(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
		ret ag_types.result_type;
		R record;
	begin

	insert into trf.trf_scontrino_pdf (filename, base64_pdf, id_trf_fattura)
	values (v->>'filename', (v->>'bytearray')::bytea, (v->>'id_fattura')::bigint)
	on conflict (id_trf_fattura)
	do update set filename = v->>'filename', base64_pdf = (v->>'bytearray')::bytea;
	
    ret.esito:=true;
 	ret.msg:=null;
	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.upd_scontrino_pdf(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_tariffa(character varying, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_tariffa(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
		ret ag_types.result_type; -- START
        id_op bigint;   
        proc_name varchar; -- END
       	R_T trf.vw_tariffe%ROWTYPE;
       	R_T2 trf.tariffe;
        idtariffa bigint;
        da timestamp;
        a timestamp;
        v_j json;
       	n integer;
       	li numeric;
      	ls numeric;
	begin
		proc_name:='trf.upd_tariffa';
		-- raise notice 'UPDTARIFFA V=%',v;
		-- id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j := v::json;
		raise notice 'v_j: %', v_j;
	
	    R_T := json_populate_record(null::trf.vw_tariffe, v_j);
	    raise notice 'R_T: %', R_T;
	   	raise notice 'id_tariffa_j  %', v_j->'id';
	   	
	   	if v_j->>'valido_a_tariffa' is null then
	   		a := null;
	   	else
	   		a:= (v_j->'valido_a_tariffa')::text::timestamp;
	   	end if;
	   
	  	da:=(v_j->'valido_da_tariffa')::text::timestamp;
	  	
	    if v_j->>'limite_inf' is null then
	   		li:=null;
	   	else
	   		li:= (v_j->'limite_inf')::text::numeric;
	   	end if;
	   	if v_j->>'limite_sup' is null then
	   		ls:=null;
	   	else
	   		ls:= (v_j->'limite_sup')::text::numeric;
	   	end if;
	  
	  	if R_T.id = R_T.id_parent then
			ret.esito:=false;
			ret.valore:= null;
			ret.msg:=proc_name || ': valori che generano LOOP nell tree_nodes';
			RAISE notice '%', ret;
			return ret;
		end if;
		R_T.limiti:=numrange(R_T.limite_inf,R_T.limite_sup,'[)');

		raise notice 'id_tariffa %', R_T.id;
	    update trf.tariffe set (
	    	sigla, descr, cod_iva, nota, visibile_trf, visibile_fatt, visibile_piani, visibile_contabilita, id_u_mis, validita,
	    	livello_asl, limiti
	    ) = (
	    	R_T.sigla, R_T.descr, R_T.cod_iva, R_T.nota, R_T.visibile_trf, R_T.visibile_fatt, R_T.visibile_piani, R_T.visibile_contabilita, 
	    	R_T.id_u_mis, tsrange(da,a,'[)'),R_T.livello_asl,numrange(li,ls,'[)')
	    )
		where id = R_T.id
		returning * into R_T2;
		n:=ag_log.upd_record('trf.tariffe',idtransazione,R_T2,'U');
		
		update matrix.tree_nodes set id_parent=R_T.id_parent,node_descr=R_T.descr,ordinamento=LPAD(R_T.ordinamento::varchar,4,'0') where id=R_T.id;

		insert into trf_ui.trf_ui_righe_fatt (id_tariffa, descr_in_fatt) 
		values (R_T.id ,R_T.descr_in_fatt)
		on conflict (id_tariffa)
		do update set descr_in_fatt = R_T.descr_in_fatt;
	
		GET DIAGNOSTICS n = ROW_COUNT;
		if  n <=0 then
			ret.esito:=false;
			ret.valore:= null;
			ret.msg:=proc_name || ': id '||(v_j->'id')::varchar|| ' inesistente';
			RAISE notice '%', ret;
			return ret;
		end if;
		ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
		ret.info ='0';
    	--ret.esito:=true;
		--ret:=ag_ui.build_ret(ret,proc_name,idtariffa);
 
		return ret;
	end;
END
$$;


ALTER FUNCTION trf.upd_tariffa(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_tariffa_ml(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_tariffa_ml(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idlineaattivita bigint;
        proc_name varchar; -- end
        R_ML  		trf.tariffa_ml%ROWTYPE; 
       	R_LIVELLO   trf.tariffa_ml_livello%ROWTYPE; 
       	validada timestamp;
        validaa timestamp;
        R json;
        idevento bigint;
       v_dati json;
        begin
		proc_name:='trf.upd_tariffa_ml';
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		-- idlineaattivita:=v_j->'id_linea_attivita';
		idlineaattivita:=v_j->'id';
		raise notice 'id_linea_attivita=%',idlineaattivita;
	
		-- validada:= v_j->'valida_da';
		-- validaa := v_j->'valida_a';
	
		v_dati:=v_j->'dati';	
		validada:= v_dati->'data_inizio';
		--validaa := v_dati->'data_fine';
		raise notice 'validada=%',validada;
		raise notice 'validaa=%',validaa;
		update trf.tariffa_ml set validita=tsrange(lower(validita),validada,'[)')
		where upper_inf(validita) and id_linea_attivita=idlineaattivita;
		R_ML.id:=nextval('agenda.agenda_id_seq');
		R_ML.id_linea_attivita:=idlineaattivita;
		R_ML.validita:=tsrange(validada,null,'[)');
	
		insert into trf.tariffa_ml values (R_ML.*);
		
		for R in select * from json_array_elements(v_dati->'tariffe') loop
			raise notice 'R %', R;
			R_LIVELLO.id:=nextval('agenda.agenda_id_seq');
			R_LIVELLO.id_tariffa_ml:=R_ML.id;
			R_LIVELLO.livello:=R->'livello';
			R_LIVELLO.valore:=R->'valore';
			insert into trf.tariffa_ml_livello values(R_LIVELLO.*);
		end loop;
	    ret.esito:=true;	
    	ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_avvenuto_con_successo');
		ret.info ='0';
    	--ret.esito:=true;
    	--ret.info := 'Salvataggio avvenuto con successo';
		--ret:=ag_ui.build_ret(ret,proc_name,idlineaattivita);
		return ret;
	end;
END
$$;


ALTER FUNCTION trf.upd_tariffa_ml(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_tariffa_piano(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_tariffa_piano(v_j json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idtariffa bigint;
        idpiano bigint;
        proc_name varchar; -- END
        idevento bigint;
        n integer;
       	rt json;

        begin
		proc_name:='trf.upd_tariffa_piano';
	
		idpiano:=v_j->'id_piano';
		idtariffa:=v_j->'id_tariffa';
		
		if idtariffa is null then
			delete from trf.trf_piano_tariffa tpt where id_piano = idpiano;
			n := 1;
		else
			update trf.trf_piano_tariffa set id_tariffa =idtariffa where id_piano=idpiano;
			get diagnostics n:=ROW_COUNT;
			if n= 0 then
				insert into trf.trf_piano_tariffa values(nextval('agenda.agenda_id_seq'),idtariffa,idpiano);
				n:=1;
			end if;
		end if;
		if n= 1 then
 			ret.msg:=null;
	 		ret.info:=rt;
    		ret.esito:=true;
    		-- select * into rt from trf.vw_trf_piano_tariffa where id_piano=idpiano;
			-- ret:=ag_ui.build_ret(ret,proc_name,rt);
		else
		 	ret.msg:='Errore '|| proc_name || ' n='||n;
	 		ret.info:=null;
    		ret.esito:=false;
			-- ret:=ag_ui.build_ret(ret,proc_name,rt);
    	
		end if;
	     ret:=ag_ui.build_ret(ret,proc_name,'salvataggio_effettuato_con_successo');
	      ret.info='0';
		return ret;
	end;
END
$$;


ALTER FUNCTION trf.upd_tariffa_piano(v_j json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_tariffa_voci(character varying, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_tariffa_voci(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare 
	    ret ag_types.result_type; -- START
        id_op bigint;  
        idtariffa bigint;
        idtariffastruttura bigint;
        proc_name varchar; -- end
        R_T trf.tariffe%ROWTYPE; 
        R_TS  trf.tariffa_strutture%ROWTYPE; 
       	R_TV  trf.tariffa_voci%ROWTYPE; 
        R_TVC trf.tariffa_voci_calcolo%ROWTYPE; 
       	data_da timestamp;
        R record;
        idevento bigint;
       str varchar;
        v_j json;
        idasl bigint;
        begin
		proc_name:='trf.upd_tariffa_voci';
	raise notice 'V varchar %',v;
		--id_op:=gds_log.start_op(proc_name,idtransazione ,'');
		v_j:=v::json;
		raise notice 'V_J  %',v_j;
		idasl=v_j->'user_info'->'id_asl';

		if v_j->'parametri' is not null then
				v_j:=v_j->'parametri';
		end if;
	
		idtariffa:=v_j->'id_tariffa';
		raise notice 'idtariffa %',idtariffa;
		if idasl = -1 then idasl := null; end if;
	
		raise notice 'ID_TARIFFA=%',idtariffa;
		--v_j = v_j->'parametri';
		select * into R_T from trf.tariffe where id=idtariffa;
		if R_T.livello_asl and  idasl is null then 
			ret.esito:=false;
		 	ret:=ag_ui.build_ret(ret,proc_name,'tariffa_gestibile_a_livello_asl');
	      	ret.info= null;
	     	return ret;
		end if;

		--select * into R_TV from trf.tariffa_strutture ts where id_tariffa=idtariffa and upper_inf(validita)
		str:=v_j->'id_tariffa_struttura';

		if str is null or str = 'null' then
			/*select * into R_TS from tariffa_strutture
			where id_tariffa=idtariffa and (id_asl is not null and id_asl=idasl) or (idasl=-1 and id_asl is null);*/
			raise notice 'NO id_trf_dt';
		else
			idtariffastruttura:=str::bigint;
			select * into R_TS from tariffa_strutture
			where id=idtariffastruttura;
		end if;

		raise notice 'STR=%',str;
		/*if str = 'null' then
			idtariffastruttura:=null;
		else
			idtariffastruttura:=v_j->'id_tariffa_struttura';
			raise notice 'ID_TARIFFA_STRUTTURA=%',idtariffastruttura;
		end if;*/
		data_da:= v_j->'data_da';
		raise notice 'DATA_DA=%',data_da;
		idasl:=v_j->'user_info'->'id_asl';

	 
		--select * into R_TS from tariffa_strutture where id=idtariffastruttura and ;
		if R_TS.id is null then
			R_TS.id_tariffa:=idtariffa;
			R_TS.id_asl:=idasl;
		end if;
		if R_TS.id_tariffa is null then
			R_TS.id_tariffa:=idtariffa;
		end if;
		if R_TS.id_asl is null then
			R_TS.id_asl:=idasl;
		end if;

		R_TS.validita:=tsrange(data_da,null,'[)');

		--delete from tariffa_voci where id_tariffa=idtariffa;
		if R_TS.id is not null then
			update tariffa_strutture set validita = tsrange(lower(validita),data_da,'[)')
			where id=idtariffastruttura;
		end if; /* AF 2023 09 22 */
		R_TS.id:=nextval('agenda.agenda_id_seq');
		raise notice 'R_TS %',R_TS;
		insert into tariffa_strutture values(R_TS.*);
	
		for R in select * from json_array_elements(v_j->'dati') loop
			raise notice 'R %', R;
			R_TV.id:=nextval('tariffa_voci_id_seq');
			R_TV.id_tariffa_struttura:=R_TS.id;
			R_TV.scaglione:=numrange((R.value->'inf')::varchar::numeric,
				case when (R.value->'upp') is null or (R.value->'upp')::varchar = 'null' or (R.value->'upp')::varchar = '""' or (R.value->'upp')::varchar ='' then null::numeric else (R.value->'upp')::varchar::numeric end ,
			   /* case when (R.value->'inf_incl')::varchar = 'true' then '[' else '(' end ||
			    case when (R.value->'upp_incl')::varchar = 'true' then ']' else ')' end */
				case when (R.value->'inf')::varchar::numeric = 0 then '[' else'(' end||
				case when (R.value->'upp') is null or (R.value->'upp')::varchar = 'null' or (R.value->'upp')::varchar = '""' or (R.value->'upp')::varchar ='' then ')' else']' end);
			R_TV.ordine:=(R.value->'ordine')::varchar::integer;
			insert into "tariffa_voci" values (R_TV.*);
			R_TVC.id_tariffa_voce=R_TV.id;
			for j in 0..3 loop
				raise notice 'J=%',j;
				raise notice 'valore %',(R.value->'valori'->>j)::varchar;
				if (R.value->'valori'->>j)::varchar != 'null' and (R.value->'valori'->>j)::varchar != '' then
					R_TVC.tipo=j;
					R_TVC.valore=R.value->'valori'->>j;
					raise notice '-----valore %',(R.value->'valori'->>j)::varchar;
					insert into tariffa_voci_calcolo values (R_TVC.*);
				end if;
			end loop;	
		end loop;
    	ret.esito:=true;
    	--ret:=ag_ui.build_ret(ret,proc_name,idtariffa::text);
	
		return ret;
	end;
END
$$;


ALTER FUNCTION trf.upd_tariffa_voci(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_trf_per_regole(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_trf_per_regole(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type;   
	proc_name varchar;
	idtariffa bigint;
	r_opz json;
	r_opd json;
	R_TRF trf.trf_regole_fatt%ROWTYPE;
	R_TRFD trf.trf_regole_fatt_dett%ROWTYPE;

	begin
		proc_name:='agenda.upd_trf_per_regole';
		idtariffa=v->'id_tariffa';
	
	
		delete from trf.trf_regole_fatt_dett where id_regola_fatt in (select id from trf.trf_regole_fatt
			where id_tariffa in (select id_node as id from matrix.vw_tree_nodes_down where id_node_ref=idtariffa));
		delete from trf.trf_regole_fatt
			where id_tariffa in (select id_node as id from matrix.vw_tree_nodes_down where id_node_ref=idtariffa);
	
		for R_OPZ in select * from json_array_elements(v->'operazioni') loop
			raise notice 'R_OPZ %',R_OPZ;
			R_TRF.id:=nextval('trf.trf_regole_fatt_id_seq');
			R_TRF.op:=replace(upper(trim((R_OPZ->'op')::varchar)),'"','');
			R_TRF.val:=null;
			R_TRF.id_tariffa:=R_OPZ->'id_tariffa';
			R_TRF.ord_exec:=R_OPZ->'ord_exec';
			insert into trf.trf_regole_fatt values (R_TRF.*);
			for R_OPD in select * from json_array_elements(R_OPZ->'operandi') loop
				raise notice 'R_OPD %',R_OPD;
				R_TRFD.id:=nextval('trf.trf_regole_fatt_dett_id_seq');
				R_TRFD.id_regola_fatt:=R_TRF.id;
				R_TRFD.id_tariffa:=R_OPD->'id_tariffa';
				insert into trf.trf_regole_fatt_dett values (R_TRFD.*);
			end loop;
		
		end loop;
	
    	ret.esito:=true;
 		ret.msg:=null;
	 	ret.info:='{}';
	 	return ret;
	end;
end;
$$;


ALTER FUNCTION trf.upd_trf_per_regole(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ws_call(json, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_ws_call(v json, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	idtrffattura bigint;   
	proc_name varchar;
	R_FATT trf.vw_trf_fatture_ultimo_stato%rowtype;
	rt json;
	j_dett json;
	idtrfstato bigint;
	esito_call boolean;
	esito varchar;
	esitomsg varchar;
	tot integer;

	begin
		proc_name:='trf.upd_ws_call';

		ret.esito:=true;
		idtrffattura:=v->'id_trf_fattura';
		esito_call:=v->'jsonRes'->'esito'->'esito';
		if not esito_call then
			ret.esito:=false;
			ret.msg:='Errore nella chiamata WS';
			return ret;
		end if;
	
		-- Recupera informazioni della fattura
		select * into R_FATT from trf.vw_trf_fatture_ultimo_stato where id_trf_fattura =idtrffattura;
		
		esito:=v->'jsonRes'->'info'->>'FIN_Esito';
		raise notice 'ESITO >%<',esito;
		if esito is not null then
			esitomsg:=coalesce(v->'jsonRes'->'info'->>'FIN_ErrorDescription','')|| ' '||coalesce(v->'jsonRes'->'info'->>'FIN_ErrorCode','');
		end if;
	
		if esito is null then
			esito:=v->'jsonRes'->'info'->>'faultcode';
			if esito is not null then
				esitomsg:=coalesce(v->'jsonRes'->'info'->>'faultstring','');
			end if;
		end if;
		if esito is null then
			esito:=v->'jsonRes'->'info'->>'Success';
		end if;
		
	
		if esito is null or (esito !='OK' and esito != 'true') then
			ret.esito:=false;
			ret.msg:='Errore esito WS '||esito||' ';
			return ret;
		end if;		
		if esito is not null and  esito = 'OK' then
			if R_FATT.act_required = 'WRITE' then
				R_FATT.id_trf_stato:=R_FATT.id_trf_stato+1;
			end if;
			tot:= v->'jsonRes'->'info'->'OpenAmt';
			if tot is not null and tot= 0 then
				R_FATT.id_trf_stato:=R_FATT.id_trf_stato+1;
				raise notice 'NUOVO STATO OK %',R_FATT.id_trf_stato;
			end if;
			update trf.trf_fatture set open_amt=tot where id=idtrffattura;
		end if;

		-- Aggiorna lo stato in base alle condizioni precedenti
		insert into trf.trf_fattura_stati values (nextval('trf.trf_fattura_stati_id_seq'),idtrffattura,null,
		R_FATT.id_trf_stato,current_timestamp);
		return ret;
	end;
end;
$$;


ALTER FUNCTION trf.upd_ws_call(v json, idtransazione bigint) OWNER TO postgres;

--
-- Name: upd_ws_call(character varying, bigint); Type: FUNCTION; Schema: trf; Owner: postgres
--

CREATE FUNCTION trf.upd_ws_call(v character varying, idtransazione bigint) RETURNS ag_types.result_type
    LANGUAGE plpgsql
    AS $$
begin
	declare
	ret ag_types.result_type; 
	idtrffattura bigint;   
	proc_name varchar;
	R_FATT trf.vw_trf_fatture_ultimo_stato%rowtype;
	rt json;
	v_j json;
	j_dett json;
	idtrfstato bigint;
	esito varchar;

	begin
		proc_name:='trf.upd_ws_call';
		v_j:= v::json;
		ret.esito:=true;
		idtrffattura:=v_j->'id_trf_fattura';
	
		-- Recupera informazioni della fattura
		select * into R_FATT from trf.vw_trf_fatture_ultimo_stato where id_trf_fattura =idtrffattura;
		
		esito:=v_j->'info'->>'FIN_Esito';
		raise notice 'ESITO >%<',esito;
		
		if esito is not null and  esito = 'OK' then
			-- Decrementa lo stato
		--	R_FATT.id_trf_stato:=R_FATT.id_trf_stato - 1;
		--	raise notice 'NUOVO STATO KO %',R_FATT.id_trf_stato;
		--else
			-- Incrementa lo stato
		--	R_FATT.id_trf_stato:=R_FATT.id_trf_stato + 1;
			raise notice 'NUOVO STATO OK %',R_FATT.id_trf_stato;
		end if;

		-- Aggiorna lo stato in base alle condizioni precedenti
		insert into trf.trf_fattura_stati values (nextval('trf.trf_fattura_stati_id_seq'),idtrffattura,null,
		R_FATT.id_trf_stato,current_timestamp);
		return ret;
	end;
end;
$$;


ALTER FUNCTION trf.upd_ws_call(v character varying, idtransazione bigint) OWNER TO postgres;

--
-- Name: postgres_fdw_handler; Type: FOREIGN DATA WRAPPER; Schema: -; Owner: postgres
--

CREATE FOREIGN DATA WRAPPER postgres_fdw_handler;


ALTER FOREIGN DATA WRAPPER postgres_fdw_handler OWNER TO postgres;

--
-- Name: bdn_fvg; Type: SERVER; Schema: -; Owner: postgres
--

CREATE SERVER bdn_fvg FOREIGN DATA WRAPPER dblink_fdw OPTIONS (
    dbname 'bdn_fvg'
);


ALTER SERVER bdn_fvg OWNER TO postgres;

--
-- Name: USER MAPPING gisa_fvg SERVER bdn_fvg; Type: USER MAPPING; Schema: -; Owner: postgres
--

CREATE USER MAPPING FOR gisa_fvg SERVER bdn_fvg OPTIONS (
    "user" 'postgres'
);


--
-- Name: cu_dblink; Type: SERVER; Schema: -; Owner: postgres
--

CREATE SERVER cu_dblink FOREIGN DATA WRAPPER dblink_fdw OPTIONS (
    dbname 'cu_fvg'
);


ALTER SERVER cu_dblink OWNER TO postgres;

--
-- Name: USER MAPPING postgres SERVER cu_dblink; Type: USER MAPPING; Schema: -; Owner: postgres
--

CREATE USER MAPPING FOR postgres SERVER cu_dblink;


--
-- Name: gisa_fvg_dblink; Type: SERVER; Schema: -; Owner: postgres
--

CREATE SERVER gisa_fvg_dblink FOREIGN DATA WRAPPER dblink_fdw OPTIONS (
    dbname 'gisa_fvg'
);


ALTER SERVER gisa_fvg_dblink OWNER TO postgres;

--
-- Name: local_dblink; Type: SERVER; Schema: -; Owner: postgres
--

CREATE SERVER local_dblink FOREIGN DATA WRAPPER dblink_fdw OPTIONS (
    dbname 'mdgm_fvg'
);


ALTER SERVER local_dblink OWNER TO postgres;

--
-- Name: USER MAPPING postgres SERVER local_dblink; Type: USER MAPPING; Schema: -; Owner: postgres
--

CREATE USER MAPPING FOR postgres SERVER local_dblink OPTIONS (
    password '',
    "user" 'postgres'
);


--
-- Name: allevamenti_avicoli; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".allevamenti_avicoli (
    regione character varying,
    ruolo_descrizione character varying,
    ruolo_dettaglio character varying,
    comune character varying,
    codice_azienda character varying,
    denominazione_allevamento character varying,
    specie_allevata character varying,
    proprietario character varying,
    allev_id_fiscale character varying,
    detentore character varying,
    deten_id_fiscale character varying,
    telefono character varying,
    tipo_produzione character varying,
    orientamento_produttivo character varying,
    tipo_attivita character varying,
    data_inizio_attivita character varying,
    data_fine_attivita character varying,
    delegato character varying,
    filiera_avicola character varying,
    cicli_anno character varying,
    capacita character varying,
    superficie character varying,
    num_capannoni character varying,
    gruppi integer
);


ALTER TABLE "Analisi_dev".allevamenti_avicoli OWNER TO postgres;

--
-- Name: allevamenti_bovini_bufalini; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".allevamenti_bovini_bufalini (
    regione character varying,
    ruolo_descrizione character varying,
    ruolo_dettaglio character varying,
    azienda_codice character varying,
    allev_id_fiscale character varying,
    spe_descrizione character varying,
    allev_denominazione character varying,
    indirizzo_allev character varying,
    detentore character varying,
    proprietario character varying,
    delegato character varying,
    inizio_fine_attivita character varying,
    tipologia_struttura character varying,
    allev_flag_carne_latte character varying,
    tipologia_produttiva character varying,
    indirizzo_azienda character varying,
    modalita_allev character varying,
    flag_ripr character varying
);


ALTER TABLE "Analisi_dev".allevamenti_bovini_bufalini OWNER TO postgres;

--
-- Name: allevamenti_equidi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".allevamenti_equidi (
    rownum integer,
    regione character varying(50),
    ruolo_descrizione character varying(128),
    ruolo_dettaglio character varying(128),
    azienda_codice character varying(50),
    allev_denominazione character varying(50),
    allev_id_fiscale character varying(50),
    spe_descrizione character varying(50),
    titolare character varying(50),
    titolare_id_fisc character varying(50),
    titolare_email character varying(50),
    detentore character varying(50),
    detentore_id_fisc character varying(50),
    detentore_email character varying(50),
    allev_telefono character varying(50),
    tipologia_struttura character varying(50),
    orientamento_produttivo character varying(50),
    modalita character varying(50),
    allev_dt_inizio_attivita character varying(50),
    allev_dt_fine_attivita character varying(50),
    latitudine character varying(50),
    longitudine character varying(50),
    azienda_indirizzo character varying(50),
    azienda_cap integer,
    azienda_com_descrizione character varying(50),
    azienda_pro_sigla character varying(50),
    allev_indirizzo character varying(50),
    allev_cap integer,
    allev_comune character varying(50),
    delegato character varying(50),
    flag_riproduzione character varying(50)
);


ALTER TABLE "Analisi_dev".allevamenti_equidi OWNER TO postgres;

--
-- Name: allevamenti_ovini_caprini; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".allevamenti_ovini_caprini (
    regione character varying,
    ruolo_descrizione character varying,
    ruolo_dettaglio character varying,
    codice_azienda character varying,
    allev_denominazione character varying,
    codice_fiscale character varying,
    specie_prevalente character varying,
    capi_allevati_ovini character varying,
    capi_allevati_caprini character varying,
    proprietario character varying,
    proprietario_codice_fiscale character varying,
    email_proprietario character varying,
    detentore character varying,
    detentore_codice_fiscale character varying,
    email_detentore character varying,
    telefono character varying,
    tipologia_struttura character varying,
    orientamento_produttivo character varying,
    modalita character varying,
    data_inizio_attivita character varying,
    data_fine_attivita character varying,
    latitudine character varying,
    longitudine character varying,
    azienda_indirizzo character varying,
    azienda_cap integer,
    azienda_comune character varying,
    azienda_prov character varying,
    allev_indirizzo character varying,
    allev_cap integer,
    allev_comune character varying,
    delegato character varying,
    flag_riproduzione character varying
);


ALTER TABLE "Analisi_dev".allevamenti_ovini_caprini OWNER TO postgres;

--
-- Name: allevamenti_suidi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".allevamenti_suidi (
    rownum integer,
    regione character varying,
    ruolo_descrizione character varying,
    ruolo_dettaglio character varying,
    azienda_codice character varying,
    allev_denominazione character varying,
    allev_id_fiscale character varying,
    spe_descrizione character varying,
    flag_suini character varying,
    flag_cinghiali character varying,
    titolare character varying,
    titolare_id_fisc character varying,
    titolare_email character varying,
    detentore character varying,
    detentore_id_fisc character varying,
    detentore_email character varying,
    allev_telefono character varying,
    tipologia_struttura character varying,
    orientamento_produttivo character varying,
    modalita character varying,
    allev_dt_inizio_attivita character varying,
    allev_dt_fine_attivita character varying,
    latitudine character varying,
    longitudine character varying,
    azienda_indirizzo character varying,
    azienda_cap integer,
    azienda_com_descrizione character varying,
    azienda_pro_sigla character varying,
    allev_indirizzo character varying,
    allev_cap integer,
    allev_comune character varying,
    delegato character varying,
    flag_riproduzione character varying
);


ALTER TABLE "Analisi_dev".allevamenti_suidi OWNER TO postgres;

--
-- Name: campioni; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".campioni (
    id_asl integer,
    asl character varying,
    ragione_sociale character varying,
    partita_iva character varying,
    tipo_operatore character varying,
    tipologia_impianto character varying,
    motivazione_campione character varying,
    tipo_piano_monitoraggio_old text,
    id_piano integer,
    id_attivita integer,
    piano_attivita text,
    id_campione integer,
    data_prelievo timestamp without time zone,
    identificativo_campione character varying,
    prelevatore_1_a4 text,
    prelevatore_2_a4 text,
    prelevatore_3_a4 text,
    strategia_campionamento_a1 text,
    capitoli_piani_a3 text,
    specie_alimento_b6 character varying,
    metodo_produzione_b7 text,
    anno_campione text,
    data_chiusura_campione timestamp without time zone,
    id_controllo_ufficiale character varying,
    esito text,
    punteggio_campione integer,
    responsabilita_positiva character varying,
    data_esito_analita timestamp without time zone,
    esito_motivazione_respingimento text,
    note_esito_campione text,
    codice_accettazione text,
    num_verbale character varying,
    barcode character varying,
    analita_lev_1 text,
    analita_lev_2 text,
    analita_lev_3 text,
    analita_lev_4 text,
    matrice_lev_1 text,
    matrice_lev_2 text,
    matrice_lev_3 text,
    note_campione text,
    anno_controllo text,
    codice_interno_piano text
);


ALTER TABLE "Analisi_dev".campioni OWNER TO postgres;

--
-- Name: check_columns_log; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".check_columns_log (
    tname text,
    descr text,
    id_versione bigint
);


ALTER TABLE "Analisi_dev".check_columns_log OWNER TO postgres;

--
-- Name: check_duplicati; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".check_duplicati (
    dbi character varying,
    cnt integer,
    date timestamp without time zone
);


ALTER TABLE "Analisi_dev".check_duplicati OWNER TO postgres;

--
-- Name: seq_schema; Type: SEQUENCE; Schema: Analisi_dev; Owner: postgres
--

CREATE SEQUENCE "Analisi_dev".seq_schema
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "Analisi_dev".seq_schema OWNER TO postgres;

--
-- Name: config; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".config (
    id bigint DEFAULT nextval('"Analisi_dev".seq_schema'::regclass) NOT NULL,
    descr character varying NOT NULL,
    value character varying NOT NULL
);


ALTER TABLE "Analisi_dev".config OWNER TO postgres;

--
-- Name: config_iuv; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".config_iuv (
    id integer NOT NULL,
    cod_raggruppamento bigint NOT NULL,
    motivo boolean,
    query character varying,
    enabled boolean,
    alias character varying,
    descr character varying
);


ALTER TABLE "Analisi_dev".config_iuv OWNER TO postgres;

--
-- Name: dizionario_aziende; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".dizionario_aziende (
    azienda_fittizia text,
    azienda_originale text,
    id integer NOT NULL,
    riferimento_id bigint,
    riferimento_nome_tab text
);


ALTER TABLE "Analisi_dev".dizionario_aziende OWNER TO postgres;

--
-- Name: dizionario_aziende_new; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".dizionario_aziende_new (
    azienda_fittizia text,
    azienda_originale text,
    id integer,
    riferimento_id bigint,
    riferimento_nome_tab text
);


ALTER TABLE "Analisi_dev".dizionario_aziende_new OWNER TO postgres;

--
-- Name: dizionario_aziende_random; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".dizionario_aziende_random (
    row_number bigint,
    azienda_fittizia text,
    azienda_originale text,
    id integer,
    riferimento_id bigint,
    riferimento_nome_tab text
);


ALTER TABLE "Analisi_dev".dizionario_aziende_random OWNER TO postgres;

--
-- Name: dizionario_nomi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".dizionario_nomi (
    nome text,
    cognome text,
    nome_originale text,
    id integer NOT NULL,
    id_originale bigint
);


ALTER TABLE "Analisi_dev".dizionario_nomi OWNER TO postgres;

--
-- Name: dizionario_nomi_id_seq; Type: SEQUENCE; Schema: Analisi_dev; Owner: postgres
--

CREATE SEQUENCE "Analisi_dev".dizionario_nomi_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "Analisi_dev".dizionario_nomi_id_seq OWNER TO postgres;

--
-- Name: dizionario_nomi_id_seq; Type: SEQUENCE OWNED BY; Schema: Analisi_dev; Owner: postgres
--

ALTER SEQUENCE "Analisi_dev".dizionario_nomi_id_seq OWNED BY "Analisi_dev".dizionario_nomi.id;


--
-- Name: dizionario_nomi_random; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".dizionario_nomi_random (
    row_number bigint,
    nome text,
    cognome text,
    nome_originale text,
    id integer,
    id_originale bigint
);


ALTER TABLE "Analisi_dev".dizionario_nomi_random OWNER TO postgres;

--
-- Name: dpat_indicatore_new; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".dpat_indicatore_new (
    id bigint,
    cod_raggruppamento bigint,
    id_piano_attivita integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_esame text,
    tipo_attivita text,
    codice_interno_indicatore integer,
    alias_indicatore text,
    codice_interno_piani_gestione_cu integer,
    codice_interno_attivita_gestione_cu text,
    codice_interno_univoco_tipo_attivita_gestione_cu text,
    codice_alias_indicatore text,
    extra_gisa boolean
);


ALTER TABLE "Analisi_dev".dpat_indicatore_new OWNER TO postgres;

--
-- Name: dpat_indicatore_new_20200227; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".dpat_indicatore_new_20200227 (
    id bigint,
    cod_raggruppamento bigint,
    id_piano_attivita integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_esame text,
    tipo_attivita text,
    codice_interno_indicatore integer,
    alias_indicatore text,
    codice_interno_piani_gestione_cu integer,
    codice_interno_attivita_gestione_cu text,
    codice_interno_univoco_tipo_attivita_gestione_cu text,
    codice_alias_indicatore text,
    extra_gisa boolean
);


ALTER TABLE "Analisi_dev".dpat_indicatore_new_20200227 OWNER TO postgres;

--
-- Name: dpat_piano_attivita_new; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".dpat_piano_attivita_new (
    id bigint,
    cod_raggruppamento bigint,
    id_sezione integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_esame text,
    tipo_attivita text,
    codice_interno_piano integer,
    codice_interno_attivita integer,
    alias_piano text,
    alias_attivita text,
    codice_alias_attivita text
);


ALTER TABLE "Analisi_dev".dpat_piano_attivita_new OWNER TO postgres;

--
-- Name: dpat_sez_new; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".dpat_sez_new (
    id bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100)
);


ALTER TABLE "Analisi_dev".dpat_sez_new OWNER TO postgres;

--
-- Name: get_controlli_ispezioni_semplici_percontodi_raggruppamento; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".get_controlli_ispezioni_semplici_percontodi_raggruppamento (
    rng int8range,
    id_controllo integer,
    id_motivo_ispezione integer,
    id_piano_ispezione integer,
    struttura_complessa character varying,
    struttura_semplice character varying,
    per_conto_di_completo character varying,
    id_unita_operativa integer,
    id_asl_struttura integer,
    codice_interno_univoco_uo integer
);


ALTER TABLE "Analisi_dev".get_controlli_ispezioni_semplici_percontodi_raggruppamento OWNER TO postgres;

--
-- Name: gisa_controlli_ufficiali; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".gisa_controlli_ufficiali (
    id_controllo bigint,
    id_asl integer,
    asl text,
    data_inizio_controllo timestamp without time zone,
    data_fine_controllo timestamp without time zone,
    data_chiusura_controllo timestamp without time zone,
    id_dbi_gisa bigint
);


ALTER TABLE "Analisi_dev".gisa_controlli_ufficiali OWNER TO postgres;

--
-- Name: gisadbi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".gisadbi (
    id bigint DEFAULT nextval('"Analisi_dev".seq_schema'::regclass) NOT NULL,
    tname character varying NOT NULL,
    enabled boolean,
    status character(1),
    is_controllo boolean,
    is_function boolean,
    schema character varying,
    params character varying,
    giornaliero boolean,
    istantaneo boolean,
    id_config_db bigint,
    is_userdatatype boolean
);


ALTER TABLE "Analisi_dev".gisadbi OWNER TO postgres;

--
-- Name: gisadbi_20201001; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".gisadbi_20201001 (
    id bigint,
    tname character varying,
    enabled boolean,
    status character(1),
    is_controllo boolean,
    is_function boolean,
    schema character varying,
    params character varying,
    giornaliero boolean,
    istantaneo boolean
);


ALTER TABLE "Analisi_dev".gisadbi_20201001 OWNER TO postgres;

--
-- Name: gisadbi_backup; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".gisadbi_backup (
    id bigint,
    tname character varying,
    enabled boolean,
    status character(1),
    is_controllo boolean,
    is_function boolean,
    schema character varying,
    params character varying,
    giornaliero boolean,
    istantaneo boolean
);


ALTER TABLE "Analisi_dev".gisadbi_backup OWNER TO postgres;

--
-- Name: gisadbi_coll; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".gisadbi_coll (
    id bigint NOT NULL,
    tname character varying NOT NULL,
    enabled boolean,
    status character(1),
    is_controllo boolean,
    is_function boolean,
    schema character varying,
    params character varying,
    giornaliero boolean,
    istantaneo boolean,
    id_config_db integer,
    is_userdatatype boolean
);


ALTER TABLE "Analisi_dev".gisadbi_coll OWNER TO postgres;

--
-- Name: h_comuni1; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_comuni1 (
    rng int8range,
    id integer,
    cod_comune character varying,
    cod_regione character varying,
    cod_provincia character varying,
    nome character varying,
    istat character varying,
    codiceistatasl character varying,
    codice character varying,
    codice_old character varying,
    codiceistatasl_old character varying,
    cap text,
    notused boolean,
    cod_nazione integer,
    codiceasl_bdn text,
    codice_nuovo text,
    codice_nuovo_ text,
    istat_comune_provincia character varying,
    cap_ character varying,
    istat_pre character varying,
    note_hd text,
    reverse_cap text,
    codice_catastale character varying,
    denominazione_it character varying
);


ALTER TABLE "Analisi_dev".h_comuni1 OWNER TO postgres;

--
-- Name: h_controlli_gestori_acque_rete; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_controlli_gestori_acque_rete (
    rng int8range,
    id_controllo integer,
    data_inserimento timestamp without time zone,
    data_inizio_controllo timestamp without time zone,
    data_chiusura_controllo timestamp without time zone,
    data_fine_controllo timestamp without time zone,
    id_stato_controllo integer,
    stato_controllo text,
    id_asl integer,
    asl character varying,
    nome_punto_prelievo text,
    temperatura text,
    cloro text,
    ore text,
    prot_routine boolean,
    prot_verifica boolean,
    prot_replica_micro boolean,
    prot_replica_chim boolean,
    prot_radioattivita boolean,
    prot_ricerca_fitosanitari boolean,
    alfa text,
    beta text,
    radon text,
    dose text,
    trizio text,
    tipo_decreto character varying,
    id_punto_prelievo integer
);


ALTER TABLE "Analisi_dev".h_controlli_gestori_acque_rete OWNER TO postgres;

--
-- Name: h_dbi_bdu_animali; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_bdu_animali (
    rng int8range,
    data_inserimento timestamp without time zone,
    data_registrazione timestamp without time zone,
    microchip text,
    tatuaggio text,
    inserito_da text,
    ruolo_inserito_da text,
    id_animale integer,
    commerciale text,
    stato_animale text,
    id_asl_animale integer,
    descrizione_asl_animale text,
    specie text,
    razza text,
    taglia text,
    data_nascita timestamp without time zone,
    sesso text,
    veterinario_chippatore text,
    data_microchip timestamp without time zone,
    proprietario text,
    comune_proprietario text,
    tipo_proprietario text,
    stato_decesso text,
    data_decesso timestamp without time zone,
    detentore text,
    tipo_detentore text,
    id_asl_detentore integer,
    asl_detentore text,
    comune_cattura text,
    flag_sterilizzato boolean,
    data_sterilizzazione timestamp without time zone,
    flag_contributo_sterilizzazione boolean,
    flag_contributo_canili boolean,
    ente_sterilizzazione text,
    valore_ente_sterilizzazione text,
    flag_sterilizzazione_pregressa boolean,
    id_asl_sterilizzazione integer,
    asl_evento_sterilizzazione text,
    id_proprietario integer,
    id_detentore integer,
    flag_randagio boolean,
    flag_sterilizzazione boolean,
    detentore_corrente_flag_canile boolean
);


ALTER TABLE "Analisi_dev".h_dbi_bdu_animali OWNER TO postgres;

--
-- Name: h_dbi_bdu_animali_anagrafati; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_bdu_animali_anagrafati (
    rng int8range,
    data_inserimento timestamp without time zone,
    data_registrazione timestamp without time zone,
    microchip text,
    tatuaggio text,
    inserito_da text,
    ruolo_inserito_da text,
    id_animale integer,
    flag_attivita_itinerante boolean,
    comune_attivita_itinerante text,
    luogo_attivita_itinerante text,
    data_attivita_itinerante timestamp without time zone,
    commerciale text,
    stato_originale text,
    asl_originale text,
    id_asl integer,
    specie text,
    razza text,
    veterinario_chippatore text,
    data_microchip timestamp without time zone,
    stato_decesso text,
    proprietario text,
    comune_proprietario text,
    tipo_proprietario text,
    tipo_vet integer,
    data_nascita timestamp without time zone,
    flag_stampata_richiesta_prima_iscrizione boolean,
    sesso text
);


ALTER TABLE "Analisi_dev".h_dbi_bdu_animali_anagrafati OWNER TO postgres;

--
-- Name: h_dbi_bdu_animali_vivi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_bdu_animali_vivi (
    rng int8range,
    data_inserimento timestamp without time zone,
    data_registrazione timestamp without time zone,
    microchip text,
    tatuaggio text,
    inserito_da text,
    ruolo_inserito_da text,
    id_animale integer,
    specie text,
    razza text,
    data_nascita timestamp without time zone,
    sesso text,
    stato_animale text,
    cognome_proprietario text,
    nome_proprietario text,
    codice_fiscale text,
    indirizzo_proprietario text,
    cap text,
    comune_proprietario text,
    id_asl integer,
    asl text
);


ALTER TABLE "Analisi_dev".h_dbi_bdu_animali_vivi OWNER TO postgres;

--
-- Name: h_dbi_bdu_caricamenti_mc; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_bdu_caricamenti_mc (
    rng int8range,
    microchip text,
    asl text,
    codice_fiscale text,
    assegnato boolean,
    abilitato boolean,
    data_caricamento timestamp without time zone,
    data_registrazione_animale timestamp without time zone,
    data_inserimento_animale timestamp without time zone,
    anno integer,
    tipovet integer,
    id_asl integer,
    attribuito_a text
);


ALTER TABLE "Analisi_dev".h_dbi_bdu_caricamenti_mc OWNER TO postgres;

--
-- Name: h_dbi_bdu_caricamenti_mc_lp; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_bdu_caricamenti_mc_lp (
    rng int8range,
    login_utente_caricamento text,
    nominativo_utente_caricamento text,
    microchip text,
    assegnato boolean,
    abilitato boolean,
    data_caricamento timestamp without time zone,
    data_registrazione timestamp without time zone,
    data_inserimento timestamp without time zone
);


ALTER TABLE "Analisi_dev".h_dbi_bdu_caricamenti_mc_lp OWNER TO postgres;

--
-- Name: h_dbi_bdu_colonie; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_bdu_colonie (
    rng int8range,
    tutore text,
    nr_protocollo text,
    asl text,
    id_asl integer,
    data_inserimento timestamp without time zone,
    data_registrazione_colonia timestamp without time zone,
    data_censimento_totale timestamp without time zone,
    comune text,
    nr_totale_gatti integer,
    totale_presunto boolean,
    microchip text,
    flag_sterilizzazione boolean,
    data_sterilizzazione timestamp without time zone
);


ALTER TABLE "Analisi_dev".h_dbi_bdu_colonie OWNER TO postgres;

--
-- Name: h_dbi_bdu_registrazioni_data_evento; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_bdu_registrazioni_data_evento (
    rng int8range,
    id_animale integer,
    data_furto timestamp without time zone,
    luogo_furto text,
    dati_denuncia_furto text,
    importo_smarrimento double precision,
    luogo_smarrimento text,
    data_smarrimento timestamp without time zone,
    data_decesso timestamp without time zone,
    tipo_decesso text,
    luogo_decesso text,
    data_ritrovamento timestamp without time zone,
    ritrovamento_non_denunciato text,
    luogo_ritrovamento text,
    comune_ritrovamento text,
    nuovo_proprietario_ritrovamento text,
    asl_proprietario_sterilizzazione text,
    comune_cattura text,
    data_sterilizzazione timestamp without time zone,
    sterilizzazione_con_contributo text,
    sterilizzazione_progetto_canili text,
    ente_sterilizzazione text,
    veterinario_1_sterilizzazione text,
    veterinario_2_sterilizzazione text,
    evento_pregresso text,
    data_cattura timestamp without time zone,
    verbale_cattura text,
    data_rilascio_passaporto timestamp without time zone,
    data_scadenza_passaporto timestamp without time zone,
    numero_passaporto text,
    rinnovo_passaporto text,
    data_trasferimento timestamp without time zone,
    nuovo_proprietario_trasferimento text,
    vecchio_proprietario_trasferimento text,
    vecchio_detentore_trasferimento text,
    data_trasferimento_fuoriregione timestamp without time zone,
    regione_destinazione_fuoriregione text,
    data_cessione timestamp without time zone,
    vecchio_proprietario_cessione text,
    asl_vecchio_proprietario_cessione text,
    asl_nuovo_proprietario_cessione text,
    data_adozione_colonia timestamp without time zone,
    vecchio_proprietario_adozione_colonia text,
    vecchio_detentore_adozione_colonia text,
    nuovo_proprietario_adozione_colonia text,
    data_adozione_canile timestamp without time zone,
    vecchio_proprietario_adozione_canile text,
    vecchio_detentore_adozione_canile text,
    tipo_adozione text,
    nuovo_proprietario_adozione_canile text,
    data_presa_in_carico timestamp without time zone,
    nuovo_proprietario_presa_in_carico text,
    data_reimmissione timestamp without time zone,
    comune_reimmissione text,
    data_rientro_fuoriregione timestamp without time zone,
    regione_rientro_fuori_regione text,
    luogo_rientro_fuori_regione text,
    data_prelievo_leishmania timestamp without time zone,
    veterinario_prelievo_leishmania text,
    asl_evento text,
    id_asl integer,
    inserita_da text,
    ruolo_inserita_da text,
    specie text,
    microchip text,
    tatuaggio text,
    id_tipologia_registrazione integer,
    descrizione_tipologia_registrazione text,
    id_evento integer,
    data_operazione_sistema timestamp without time zone,
    data_evento timestamp without time zone,
    proprietario_pre_evento text,
    detentore_pre_evento text,
    tipologia_proprietario_pre_evento text,
    tipologia_detentore_pre_evento text,
    nuovo_proprietario_cessione text,
    nuovo_proprietario_presa_cessione text,
    nuovo_proprietario_presa_in_carico_adozione_fa text,
    vecchio_proprietario_trasferimento_fuori_regione text,
    nuovo_proprietario_trasferimento_fuori_regione text,
    nuovo_proprietario_trasferimento_canile text,
    vecchio_detentore_trasferimento_canile text,
    nuovo_proprietario_trasf_sindaco text,
    vecchio_proprietario_trasferimento_fuori_stato text,
    nuovo_proprietario_trasferimento_fuori_stato text,
    data_allontanamento timestamp without time zone,
    medico_esecutore_allontanamento text,
    veterinario_allontanamento text,
    causale_allontanamento text,
    data_mutilazione timestamp without time zone,
    medico_esecutore_mutilazione text,
    veterinario_mutilazione text,
    intervento_eseguito_mutilazione text,
    causale_mutilazione text,
    data_adozione_fuori_asl timestamp without time zone,
    vecchio_detentore_adozione_fuori_asl text,
    nuovo_proprietario_adozione_fuori_asl text
);


ALTER TABLE "Analisi_dev".h_dbi_bdu_registrazioni_data_evento OWNER TO postgres;

--
-- Name: h_dbi_bdu_ritrovamenti; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_bdu_ritrovamenti (
    rng int8range,
    specie text,
    microchip text,
    tatuaggio text,
    stato text,
    stato_decesso text,
    data_ritrovamento timestamp without time zone,
    data_restituzione timestamp without time zone,
    asl_evento text,
    id_asl integer,
    inserita_da text,
    ruolo_inserita_da text,
    tipo_evento text,
    ritrovato_restituito_a_proprietario boolean,
    ritrovato_affidato_a_canile_restituito_a_proprietario boolean,
    ritrovato_affidato_a_canile boolean,
    id_canile_affidamento integer,
    ragione_sociale_canile_affidamento text,
    canile_municipale boolean
);


ALTER TABLE "Analisi_dev".h_dbi_bdu_ritrovamenti OWNER TO postgres;

--
-- Name: h_dbi_bdu_veterinari_liberi_professionisti; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_bdu_veterinari_liberi_professionisti (
    rng int8range,
    asl character varying,
    cognome character varying,
    nome character varying,
    codice_fiscale text,
    n_accreditamento character varying
);


ALTER TABLE "Analisi_dev".h_dbi_bdu_veterinari_liberi_professionisti OWNER TO postgres;

--
-- Name: h_dbi_get_all_imprese_; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_all_imprese_ (
    rng int8range,
    riferimento_id_impresa integer,
    riferimento_nome_tab_impresa text,
    ragione_sociale text,
    codice_fiscale text,
    codice_fiscale_rappresentante text,
    partita_iva text,
    nominativo_rappresentante text,
    comune_leg text,
    provincia_leg text,
    indirizzo_leg text,
    cap_leg text,
    fatturazione_elettronica boolean,
    split_payment boolean,
    codice_sdi text,
    id_indirizzo_fatturazione integer,
    comune_fatturazione text,
    provincia_fatturazione text,
    indirizzo_fatturazione text,
    cap_fatturazione text
);


ALTER TABLE "Analisi_dev".h_dbi_get_all_imprese_ OWNER TO postgres;

--
-- Name: h_dbi_get_all_linee; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_all_linee (
    rng int8range,
    id_attivita integer,
    id_linea integer,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    num_riconoscimento character varying,
    n_linea character varying,
    data_inizio_attivita timestamp without time zone,
    data_fine_attivita timestamp without time zone,
    macroarea text,
    aggregazione text,
    attivita text,
    path_attivita_completo text,
    norma text,
    id_norma integer,
    codice_macroarea text,
    codice_aggregazione text,
    codice_attivita text,
    stato text,
    id_stato integer,
    miscela boolean,
    tipo_attivita_descrizione character varying,
    tipo_attivita integer,
    sintesis boolean
);


ALTER TABLE "Analisi_dev".h_dbi_get_all_linee OWNER TO postgres;

--
-- Name: h_dbi_get_all_linee_back; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_all_linee_back (
    rng int8range,
    id_linea integer,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    n_linea character varying,
    data_inizio_attivita timestamp without time zone,
    data_fine_attivita timestamp without time zone,
    macroarea text,
    aggregazione text,
    attivita text,
    path_attivita_completo text,
    norma text,
    id_norma integer,
    codice_macroarea text,
    codice_aggregazione text,
    codice_attivita text,
    stato text,
    id_stato integer,
    miscela boolean,
    tipo_attivita_descrizione character varying,
    tipo_attivita integer
);


ALTER TABLE "Analisi_dev".h_dbi_get_all_linee_back OWNER TO postgres;

--
-- Name: h_dbi_get_all_partite; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_all_partite (
    rng int8range,
    descrizione_macello character varying,
    codice_macello character varying,
    id_asl integer,
    asl character varying,
    partita character varying,
    num_seduta character varying,
    codice_azienda_provenienza character varying,
    specie character varying,
    data_macellazione timestamp without time zone,
    num_capi_ovini_cinghiali integer,
    num_capi_caprini_suini integer,
    num_capi_ovini_cinghiali_macellati integer,
    num_capi_caprini_suini_macellati integer,
    partita_sottoposta_a_test_tse text,
    num_capi_caprini_da_testare_tse integer,
    num_capi_ovini_da_testare_tse integer
);


ALTER TABLE "Analisi_dev".h_dbi_get_all_partite OWNER TO postgres;

--
-- Name: h_dbi_get_all_stabilimenti; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_all_stabilimenti (
    rng int8range,
    id_record_anagrafica text,
    riferimento_id integer,
    riferimento_id_nome text,
    riferimento_id_nome_col text,
    riferimento_id_nome_tab text,
    data_inserimento timestamp without time zone,
    ragione_sociale character varying,
    asl_rif integer,
    asl character varying,
    codice_fiscale character varying,
    codice_fiscale_rappresentante character varying,
    partita_iva character varying,
    categoria_rischio integer,
    prossimo_controllo timestamp without time zone,
    num_riconoscimento character varying,
    n_reg character varying,
    n_linea character varying,
    nominativo_rappresentante text,
    tipo_attivita_descrizione character varying,
    tipo_attivita integer,
    data_inizio_attivita timestamp without time zone,
    data_fine_attivita timestamp without time zone,
    stato text,
    id_stato integer,
    comune character varying,
    provincia_stab character varying,
    indirizzo character varying,
    cap_stab character varying,
    comune_leg character varying,
    provincia_leg character varying,
    indirizzo_leg character varying,
    cap_leg character varying,
    macroarea text,
    aggregazione text,
    attivita text,
    path_attivita_completo text,
    gestione_masterlist text,
    norma text,
    id_norma integer,
    tipologia_operatore integer,
    targa character varying,
    id_controllo_ultima_categorizzazione integer,
    id_tipo_ricerca integer,
    descrizione_tipo_ricerca text,
    latitudine_stab double precision,
    longitudine_stab double precision,
    codice_macroarea text,
    codice_aggregazione text,
    codice_attivita text,
    miscela boolean,
    data_controllo_ultima_categorizzazione timestamp without time zone,
    tipo_categorizzazione text
);


ALTER TABLE "Analisi_dev".h_dbi_get_all_stabilimenti OWNER TO postgres;

--
-- Name: h_dbi_get_all_stabilimenti_; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_all_stabilimenti_ (
    rng int8range,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    riferimento_id_impresa integer,
    riferimento_nome_tab_impresa text,
    ragione_sociale text,
    asl_rif integer,
    asl text,
    codice_fiscale text,
    codice_fiscale_rappresentante text,
    partita_iva text,
    n_reg text,
    nominativo_rappresentante text,
    comune text,
    provincia_stab text,
    indirizzo text,
    cap_stab text,
    comune_leg text,
    provincia_leg text,
    indirizzo_leg text,
    cap_leg text,
    latitudine_stab double precision,
    longitudine_stab double precision,
    categoria_rischio integer,
    prossimo_controllo timestamp without time zone,
    id_controllo_ultima_categorizzazione integer,
    data_controllo_ultima_categorizzazione timestamp without time zone,
    tipo_categorizzazione text,
    data_inserimento timestamp without time zone,
    livello_rischio text,
    tipologia integer,
    categoria_rischio_qualitativa text,
    approval_number text,
    impresa_id_opu integer,
    stabilimento_id_opu integer,
    impresa_id_organization integer,
    stabilimento_id_organization integer
);


ALTER TABLE "Analisi_dev".h_dbi_get_all_stabilimenti_ OWNER TO postgres;

--
-- Name: h_dbi_get_all_stabilimenti__backup20201013; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_all_stabilimenti__backup20201013 (
    rng int8range,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    ragione_sociale character varying,
    asl_rif integer,
    asl character varying,
    codice_fiscale character varying,
    codice_fiscale_rappresentante character varying,
    partita_iva character varying,
    n_reg character varying,
    nominativo_rappresentante text,
    comune character varying,
    provincia_stab character varying,
    indirizzo character varying,
    cap_stab character varying,
    comune_leg character varying,
    provincia_leg character varying,
    indirizzo_leg character varying,
    cap_leg character varying,
    latitudine_stab double precision,
    longitudine_stab double precision,
    categoria_rischio integer,
    prossimo_controllo timestamp without time zone,
    id_controllo_ultima_categorizzazione integer,
    data_controllo_ultima_categorizzazione timestamp without time zone,
    tipo_categorizzazione text,
    data_inserimento timestamp without time zone
);


ALTER TABLE "Analisi_dev".h_dbi_get_all_stabilimenti__backup20201013 OWNER TO postgres;

--
-- Name: h_dbi_get_all_stabilimenti__backup20201013_back; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_all_stabilimenti__backup20201013_back (
    rng int8range,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    ragione_sociale character varying,
    asl_rif integer,
    asl character varying,
    codice_fiscale character varying,
    codice_fiscale_rappresentante character varying,
    partita_iva character varying,
    n_reg character varying,
    nominativo_rappresentante text,
    comune character varying,
    provincia_stab character varying,
    indirizzo character varying,
    cap_stab character varying,
    comune_leg character varying,
    provincia_leg character varying,
    indirizzo_leg character varying,
    cap_leg character varying,
    latitudine_stab double precision,
    longitudine_stab double precision,
    categoria_rischio integer,
    prossimo_controllo timestamp without time zone,
    id_controllo_ultima_categorizzazione integer,
    data_controllo_ultima_categorizzazione timestamp without time zone,
    tipo_categorizzazione text,
    data_inserimento timestamp without time zone
);


ALTER TABLE "Analisi_dev".h_dbi_get_all_stabilimenti__backup20201013_back OWNER TO postgres;

--
-- Name: h_dbi_get_allcapi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_allcapi (
    rng int8range,
    descrizione_macello character varying,
    codice_macello character varying,
    id_asl integer,
    asl character varying,
    matricola character varying,
    codice_azienda_provenienza character varying,
    specie character varying,
    data_macellazione timestamp without time zone,
    cd_veterinario_1 character varying,
    cd_veterinario_2 character varying,
    cd_veterinario_3 character varying,
    cd_data_nascita timestamp without time zone,
    categoria text
);


ALTER TABLE "Analisi_dev".h_dbi_get_allcapi OWNER TO postgres;

--
-- Name: h_dbi_get_allegati_b2; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_allegati_b2 (
    rng int8range,
    id_controllo integer,
    data_controllo timestamp without time zone,
    motivo_ispezione text,
    stato_controllo text,
    id_asl_controllo integer,
    asl_controllo text,
    file_nome text,
    file_data_inserimento timestamp without time zone,
    file_codice text,
    operatore_tipo text,
    operatore_norma text,
    operatore_ragione_sociale text,
    presente text
);


ALTER TABLE "Analisi_dev".h_dbi_get_allegati_b2 OWNER TO postgres;

--
-- Name: h_dbi_get_allerte; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_allerte (
    rng int8range,
    id_allerta character varying,
    tipo_operazione text,
    id_asl integer,
    asl character varying,
    data_apertura_o_chiusura timestamp without time zone,
    stato text,
    data_invio_allegatof text,
    data_inserimento_allerta timestamp without time zone,
    matrici text,
    azione_non_conforme_per text,
    descrizione_breve text,
    origine text
);


ALTER TABLE "Analisi_dev".h_dbi_get_allerte OWNER TO postgres;

--
-- Name: h_dbi_get_analiti; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_analiti (
    rng int8range,
    progressivo bigint,
    descrizione_analita_livello_uno character varying,
    descrizione_analita_livello_due character varying,
    descrizione_analita_livello_tre character varying,
    codice_analita_livello_uno text,
    codice_analita_livello_due text,
    codice_analita_livello_tre text,
    id_analita_livello_uno integer,
    id_analita_livello_due integer,
    id_analita_livello_tre integer
);


ALTER TABLE "Analisi_dev".h_dbi_get_analiti OWNER TO postgres;

--
-- Name: h_dbi_get_apicoltura_censimenti; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_apicoltura_censimenti (
    rng int8range,
    codice_azienda text,
    codice_apiario text,
    data_censimento timestamp without time zone,
    progressivo integer,
    numero_sciami integer,
    numero_alveari integer,
    data_cessazione_apiario timestamp without time zone
);


ALTER TABLE "Analisi_dev".h_dbi_get_apicoltura_censimenti OWNER TO postgres;

--
-- Name: h_dbi_get_apicoltura_lista_apiari; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_apicoltura_lista_apiari (
    rng int8range,
    id_apicoltore integer,
    asl_apicoltore text,
    ragione_sociale text,
    codice_azienda text,
    codice_fiscale_impresa text,
    id_apiario integer,
    codice_fiscale_proprietario text,
    nome_proprietario text,
    cognome_proprietario text,
    flag_laboratorio_annesso boolean,
    tipo_attivita_apicoltura text,
    comune_sede_legale text,
    via_sede_legale text,
    stato_apicoltore text,
    apicoltore_inviato_bdn text,
    apicoltore_data_registrazione_bdn timestamp without time zone,
    apicoltore_data_registrazione_bdar timestamp without time zone,
    data_inizio_attivita timestamp without time zone,
    codice_fiscale_detentore text,
    nome_detentore text,
    cognome_detentore text,
    asl_apiario text,
    progressivo integer,
    ubicazione_comune text,
    ubicazione_via text,
    latitudine double precision,
    longitudine double precision,
    specie text,
    modalita_allevamento text,
    classificazione text,
    data_inizio_attivita_apiario timestamp without time zone,
    num_alveari integer,
    num_sciami integer,
    stato_apiario text,
    apiario_inviato_bdn text,
    apiario_data_registrazione_bdn timestamp without time zone,
    data_inserimento_apiario timestamp without time zone,
    data_cessazione_apiario timestamp without time zone,
    id_asl integer,
    id_utente_access_ext_delegato integer,
    codice_fiscale_delegato text,
    utente_insert_impresa text,
    ruolo_utente_insert_impresa text,
    utente_insert_apicoltore text,
    ruolo_utente_insert_apicoltore text
);


ALTER TABLE "Analisi_dev".h_dbi_get_apicoltura_lista_apiari OWNER TO postgres;

--
-- Name: h_dbi_get_campi_aggiuntivi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_campi_aggiuntivi (
    rng int8range,
    id_controllo integer,
    tipo_sospetto text,
    codice_buffer text,
    descrizione_breve text,
    stato_buffer text,
    data_stato timestamp without time zone,
    data_evento timestamp without time zone,
    comune_coinvolto_buffer text
);


ALTER TABLE "Analisi_dev".h_dbi_get_campi_aggiuntivi OWNER TO postgres;

--
-- Name: h_dbi_get_campi_estesi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_campi_estesi (
    rng int8range,
    org_id integer,
    specie_macelli character varying,
    codifica_specie_sintesi character varying,
    data_ricezione_autorizzazione_ingrosso timestamp without time zone,
    numero_autorizzazione_ingrosso text,
    data_ricezione_autorizzazione_dettaglio timestamp without time zone,
    numero_autorizzazione_dettaglio text,
    tipo_trasporto character varying,
    animale_trasportato character varying,
    targa text,
    descrizione text,
    classe character varying,
    tipologia_acque integer,
    codice_classe integer,
    dataprovvedimento timestamp without time zone,
    provvedimento text,
    data_classificazione timestamp without time zone,
    data_fine_classificazione timestamp without time zone,
    tipo_produzione text,
    numero_decreto text,
    ente_gestore character varying,
    codice_punto_prelievo character varying,
    tipologia_punto_prelievo character varying,
    tipo_struttura character varying,
    codice_l30 character varying,
    razza character varying,
    provvedimento_autorizzazione character varying,
    scadenza_autorizzazione character varying,
    sede character varying
);


ALTER TABLE "Analisi_dev".h_dbi_get_campi_estesi OWNER TO postgres;

--
-- Name: h_dbi_get_campioni_eseguiti_macelli; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_campioni_eseguiti_macelli (
    rng int8range,
    id_asl integer,
    asl character varying,
    id_capo integer,
    cd_matricola character varying,
    id_macello integer,
    ragione_sociale_macello character varying,
    codice_azienda_provenienza character varying,
    matrice character varying,
    tipo_analisi character varying,
    esito character varying,
    data_ricezione_esito timestamp without time zone,
    molecole text,
    motivo character varying,
    data_inserimento timestamp without time zone,
    data_macellazione timestamp without time zone
);


ALTER TABLE "Analisi_dev".h_dbi_get_campioni_eseguiti_macelli OWNER TO postgres;

--
-- Name: h_dbi_get_capi_libero_consumo_sequestro_organi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_capi_libero_consumo_sequestro_organi (
    rng int8range,
    id_macello integer,
    descrizione_macello character varying,
    codice_macello character varying,
    id_asl integer,
    asl character varying,
    matricola character varying,
    codice_azienda_provenienza character varying,
    specie character varying,
    data_macellazione timestamp without time zone,
    organo character varying,
    lesione_anatomopatologica character varying
);


ALTER TABLE "Analisi_dev".h_dbi_get_capi_libero_consumo_sequestro_organi OWNER TO postgres;

--
-- Name: h_dbi_get_controlli_acque_rete; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_controlli_acque_rete (
    rng int8range,
    id_controllo integer,
    data_inizio_controllo timestamp without time zone,
    temperatura text,
    cloro text,
    ore text,
    prot_routine boolean,
    prot_verifica boolean,
    prot_replica_micro boolean,
    prot_replica_chim boolean,
    prot_radioattivita boolean,
    prot_ricerca_fitosanitari boolean,
    alfa text,
    beta text,
    radon text,
    dose text,
    trizio text,
    tipo_decreto text,
    desc_asl text,
    id_punto_prelievo integer,
    campione_finalita_misura text,
    campione_nota_finalita_misura text,
    campione_motivo_prelievo text,
    campione_nota_motivo_prelievo text,
    fornitura_denominazione_zona text,
    fornitura_denominazione_gestore text,
    punto_tipo_acqua text,
    punto_note text,
    campionamento_numero_prelievi text,
    campionamento_chi text,
    di_alfa_totale_mar text,
    di_alfa_totale_misura text,
    di_alfa_totale_incertezza text,
    di_alfa_totale_data_misura text,
    di_alfa_totale_laboratorio text,
    di_alfa_totale_metodo_prova text,
    di_beta_totale_mar text,
    di_beta_totale_misura text,
    di_beta_totale_incertezza text,
    di_beta_totale_data_misura text,
    di_beta_totale_laboratorio text,
    di_beta_totale_metodo_prova text,
    di_beta_residua_mar text,
    di_beta_residua_misura text,
    di_beta_residua_incertezza text,
    di_beta_residua_data_misura text,
    di_beta_residua_laboratorio text,
    di_beta_residua_metodo_prova text,
    radon_concentrazione_mar text,
    radon_concentrazione_misura text,
    radon_concentrazione_incertezza text,
    radon_concentrazione_data_misura text,
    radon_concentrazione_laboratorio text,
    radon_concentrazione_metodo_prova text,
    trizio_concentrazione_mar text,
    trizio_concentrazione_misura text,
    trizio_concentrazione_incertezza text,
    trizio_concentrazione_data_misura text,
    trizio_concentrazione_laboratorio text,
    trizio_concentrazione_metodo_prova text
);


ALTER TABLE "Analisi_dev".h_dbi_get_controlli_acque_rete OWNER TO postgres;

--
-- Name: h_dbi_get_controlli_benessere_dati_aggiuntivi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_controlli_benessere_dati_aggiuntivi (
    rng int8range,
    id_controllo_ufficiale integer,
    data_controllo timestamp without time zone,
    codice_piano text,
    num_bovini integer,
    num_suini integer,
    num_equidi integer,
    num_altre_specie integer,
    num_bufali integer,
    num_pesci_acqua_dolce integer,
    num_pesci_ornamentali integer,
    num_oche integer,
    num_conigli integer,
    num_ovaiole integer,
    num_broiler integer,
    num_vitelli integer,
    num_struzzi integer,
    num_cani integer,
    num_ovicaprini integer,
    num_pollame integer,
    num_pesci integer,
    num_uccelli integer,
    num_rettili integer,
    num_altro integer
);


ALTER TABLE "Analisi_dev".h_dbi_get_controlli_benessere_dati_aggiuntivi OWNER TO postgres;

--
-- Name: h_dbi_get_controlli_mvs; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_controlli_mvs (
    rng int8range,
    idcontrollo integer,
    asl character varying,
    data_inserimento_controllo timestamp without time zone,
    controllo_documentale_effettuato text,
    num_capi_macellati text,
    num_capi text,
    data_acquisto_1 text,
    allev_origine_1 text,
    data_acquisto_2 text,
    allev_origine_2 text,
    data_acquisto_3 text,
    allev_origine_3 text
);


ALTER TABLE "Analisi_dev".h_dbi_get_controlli_mvs OWNER TO postgres;

--
-- Name: h_dbi_get_controlli_ufficiali_eseguitinew; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_controlli_ufficiali_eseguitinew (
    rng int8range,
    id_controllo_ufficiale integer,
    riferimento_id integer,
    riferimento_id_nome text,
    riferimento_id_nome_col text,
    riferimento_id_nome_tab text,
    id_asl integer,
    asl character varying,
    tipo_controllo character varying,
    tipo_ispezione_o_audit text,
    tipo_piano_monitoraggio text,
    id_piano integer,
    id_attivita integer,
    tipo_controllo_bpi text,
    tipo_controllo_haccp text,
    oggetto_del_controllo text,
    punteggio text,
    data_inizio_controllo date,
    anno_controllo text,
    data_chiusura_controllo date,
    aggiornata_cat_controllo text,
    categoria_rischio integer,
    prossimo_controllo timestamp with time zone,
    tipo_checklist text,
    linea_attivita_sottoposta_a_controllo text,
    unita_operativa text,
    id_struttura_uo integer,
    supervisionato_in_data timestamp without time zone,
    supervisionato_da character varying,
    supervisione_note text,
    congruo_supervisione text,
    note text,
    tipo_piano_monitoraggio_old text,
    codice_interno_univoco_uo integer,
    codice_interno_piano text,
    area_appartenenza_uo text,
    id_record_anagrafica text,
    codice_macroarea text,
    codice_aggregazione text,
    codice_attivita text
);


ALTER TABLE "Analisi_dev".h_dbi_get_controlli_ufficiali_eseguitinew OWNER TO postgres;

--
-- Name: h_dbi_get_controlli_ufficiali_lista_identificativi_animali; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_controlli_ufficiali_lista_identificativi_animali (
    rng int8range,
    idcontrollo integer,
    asl character varying,
    data_controllo timestamp without time zone,
    lista_identificativi text
);


ALTER TABLE "Analisi_dev".h_dbi_get_controlli_ufficiali_lista_identificativi_animali OWNER TO postgres;

--
-- Name: h_dbi_get_dati_acque_di_rete; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_dati_acque_di_rete (
    rng int8range,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    tipologia text,
    ente_gestore character varying,
    stato text
);


ALTER TABLE "Analisi_dev".h_dbi_get_dati_acque_di_rete OWNER TO postgres;

--
-- Name: h_dbi_get_matrici; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_matrici (
    rng int8range,
    progressivo bigint,
    descrizione_matrice_livello_uno character varying,
    descrizione_matrice_livello_due character varying,
    descrizione_matrice_livello_tre character varying,
    codice_matrice_livello_uno text,
    codice_matrice_livello_due text,
    codice_matrice_livello_tre text,
    id_matrice_livello_uno integer,
    id_matrice_livello_due integer,
    id_matrice_livello_tre integer
);


ALTER TABLE "Analisi_dev".h_dbi_get_matrici OWNER TO postgres;

--
-- Name: h_dbi_get_non_conformita; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_non_conformita (
    rng int8range,
    id_controllo_ufficiale integer,
    id_singola_nc integer,
    id_non_conformita integer,
    riferimento_id integer,
    riferimento_nome_tab text,
    riferimento_id_nome_tab_impresa_sazionata text,
    riferimento_id_impresa_sazionata integer,
    identificativo character varying,
    tipologia integer,
    tipo_nc_int integer,
    tipo_non_conformita text,
    punteggio integer,
    puntiformali text,
    nc_formali_valutazione text,
    puntisignificativi text,
    nc_significative_valutazione text,
    puntigravi text,
    entered timestamp without time zone,
    descrizione_non_conformita text,
    id_linea integer,
    provvedimenti_benessere text,
    id_operatore_mercato integer,
    num_sanzioni_intraprese integer,
    num_sequestri_intrapresi integer,
    num_reati_intrapresi integer,
    num_diffide_intraprese integer,
    num_followup_per_nc_formali integer,
    num_followup_per_nc_significative integer,
    num_followup_per_nc_gravi integer,
    oggetto_non_conformita text
);


ALTER TABLE "Analisi_dev".h_dbi_get_non_conformita OWNER TO postgres;

--
-- Name: h_dbi_get_norme; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_norme (
    rng int8range,
    code integer,
    description text,
    default_item boolean,
    level integer,
    enabled boolean,
    tipo_iter integer,
    entered timestamp without time zone,
    modified timestamp without time zone,
    flag_vecchia_gestione boolean,
    id_tipologia_organization integer,
    codice_norma text
);


ALTER TABLE "Analisi_dev".h_dbi_get_norme OWNER TO postgres;

--
-- Name: h_dbi_get_operatori_mercato; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_operatori_mercato (
    rng int8range,
    riferimento_id_operatore integer,
    riferimento_id_nome_tab_operatore text,
    ragione_sociale_operatore_mercato character varying,
    num_box integer,
    identificativo text,
    data_cessazone timestamp without time zone,
    id_linea_mercato integer,
    riferimento_id_linea_nome_tab text
);


ALTER TABLE "Analisi_dev".h_dbi_get_operatori_mercato OWNER TO postgres;

--
-- Name: h_dbi_get_partite_libero_consumo_sequestro_organi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_partite_libero_consumo_sequestro_organi (
    rng int8range,
    descrizione_macello character varying,
    codice_macello character varying,
    id_asl integer,
    asl character varying,
    partita character varying,
    num_seduta character varying,
    codice_azienda_provenienza character varying,
    specie character varying,
    data_macellazione timestamp without time zone,
    num_capi_ovini integer,
    num_capi_caprini integer,
    numero_capi_ovini_libero_consumo_sequestro_organi integer,
    numero_capi_caprini_libero_consumo_sequestro_organi integer,
    organo character varying,
    lesione_anatomopatologica character varying
);


ALTER TABLE "Analisi_dev".h_dbi_get_partite_libero_consumo_sequestro_organi OWNER TO postgres;

--
-- Name: h_dbi_get_punti_prelievo; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_punti_prelievo (
    rng int8range,
    id integer,
    denominazione text,
    id_asl integer,
    code_tipologia integer,
    codice text,
    id_gestore integer,
    data_inserimento timestamp without time zone,
    stato text,
    codice_gisa text,
    nome_gestore text,
    indirizzo_via text,
    latitudine double precision,
    longitudine double precision,
    descrizione_tipologia text,
    id_comune integer,
    descrizione_comune text,
    descrizione_asl text
);


ALTER TABLE "Analisi_dev".h_dbi_get_punti_prelievo OWNER TO postgres;

--
-- Name: h_dbi_get_registro_trasgressori; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_registro_trasgressori (
    rng int8range,
    "n. prog" text,
    "Id controllo" text,
    "ASL di competenza" text,
    "Ente accertatore 1" text,
    "Ente accertatore 2" text,
    "Ente accertatore 3" text,
    "PV n." text,
    "Num. sequestro eventualmente effettuato" text,
    "Data accertamento" text,
    "Data prot. in entrata in regione" text,
    trasgressore text,
    "Obbligato in solido" text,
    "Importo sanzione ridotta" text,
    "Importo sanzione ridotta del 30%" text,
    "Illecito di competenza della U.O.D. 01" text,
    "Data ultima notifica" text,
    "PV oblato in misura ridotta" text,
    "Importo effettivamente introitato (1)" text,
    "Data pagamento" text,
    "Funzionario assegnatario" text,
    "Presentati scritti difensivi" text,
    "Presentata richiesta riduzione sanzione e/o rateizzazione" text,
    "Presentata richiesta audizione" text,
    "Ordinanza emessa" text,
    "Num. Ordinanza" text,
    "Data di emissione dell'Ordinanza" text,
    "Giorni di lavorazione pratica" text,
    "Importo sanzione ingiunta" text,
    "Data Ultima Notifica Ordinanza" text,
    "Data Pagamento Ordinanza" text,
    "Pagamento Ordinanza Effettuato nei Termini" text,
    "Concessa rateizzazione dell'ordinanza-ingiunzione" text,
    "Rate pagate" text,
    "Ordinanza ingiunzione oblata" text,
    "Importo effettivamente introitato (2)" text,
    "Presentata opposizione all'ordinanza-ingiunzione" text,
    "Sentenza favorevole al ricorrente" text,
    "Importo stabilito dalla A.G." text,
    "Ordinanza-ingiunzione oblata secondo sentenza" text,
    "Importo effettivamente introitato (3)" text,
    "Avviata per esecuzione forzata" text,
    "Importo effettivamente introitato (4)" text,
    "Note Gruppo 1" text,
    "Note Gruppo 2" text,
    "Pratica chiusa" text
);


ALTER TABLE "Analisi_dev".h_dbi_get_registro_trasgressori OWNER TO postgres;

--
-- Name: h_dbi_get_report_b11_allevamenti; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_report_b11_allevamenti (
    rng int8range,
    id_bdn integer,
    id_bdn_b11 integer,
    id_controllo integer,
    id_fiscale_allevamento text,
    occodice text,
    stato text,
    id_fiscale_detentore text,
    tipo_produzione text,
    codice_orientamento text,
    data_estrazione timestamp without time zone,
    data_import timestamp without time zone,
    esito_import text,
    descrizione_errore text,
    data_estrazione_b11 timestamp without time zone,
    data_import_b11 timestamp without time zone,
    esito_import_b11 text,
    descrizione_errore_b11 text,
    operazione text,
    esito_controllo text,
    specie_allev character varying,
    specie_allevamento text,
    tipo_allevamento_codice text,
    flag_preavviso text,
    data_preavviso timestamp without time zone,
    flag_copia_checklist text,
    flag_esito_sa text,
    id_alleg integer,
    pianomonitoraggio integer
);


ALTER TABLE "Analisi_dev".h_dbi_get_report_b11_allevamenti OWNER TO postgres;

--
-- Name: h_dbi_get_report_ba_allevamenti; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_report_ba_allevamenti (
    rng int8range,
    punteggio integer,
    id_alleg integer,
    nome_lista_riscontro text,
    id_controllo integer,
    flag_cee boolean,
    stato text,
    flag_extra_piano text,
    id_fiscale_detentore text,
    tipo_produzione text,
    codice_orientamento text,
    num_capannoni_suini text,
    num_capannoni_attivi_suini text,
    num_box_suini text,
    num_box_attivi_suini text,
    num_vitelli_max text,
    num_vitelli_presenti text,
    data_estrazione timestamp without time zone,
    data_import timestamp without time zone,
    esito_import text,
    descrizione_errore text,
    operazione text,
    esito_controllo text,
    specie_allev text,
    tipo_allegato text,
    flag_vitelli text,
    tipo_allevamento_codice text,
    flag_preavviso text,
    data_preavviso timestamp without time zone,
    pianomonitoraggio integer
);


ALTER TABLE "Analisi_dev".h_dbi_get_report_ba_allevamenti OWNER TO postgres;

--
-- Name: h_dbi_get_report_ba_sa_allevamenti; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_report_ba_sa_allevamenti (
    rng int8range,
    id_bdn integer,
    ragione_sociale character varying,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    id_controllo integer,
    data_controllo timestamp without time zone,
    stato_controllo text,
    codice_asl text,
    codice_azienda character varying,
    id_fiscale_proprietario text,
    id_fiscale_detentore text,
    specie_allevata text,
    id_alleg integer,
    nome_checklist character varying,
    data_invio timestamp without time zone,
    esito_import_bdn text,
    descrizione_errore_bdn text,
    flag_preavviso text,
    data_preavviso text,
    flag_rilascio_copia_checklist text,
    id_chk_bns_mod_ist integer,
    stato_checklist text,
    alias_indicatore text,
    descrizione_indicatore text
);


ALTER TABLE "Analisi_dev".h_dbi_get_report_ba_sa_allevamenti OWNER TO postgres;

--
-- Name: h_dbi_get_sanzioni; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_sanzioni (
    rng int8range,
    idcontrollo integer,
    idsanzione integer,
    id_nonconformita integer,
    trasgressore text,
    obbligato text
);


ALTER TABLE "Analisi_dev".h_dbi_get_sanzioni OWNER TO postgres;

--
-- Name: h_dbi_get_stabilimenti_sintesis; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_stabilimenti_sintesis (
    rng int8range,
    riferimento_id integer,
    tipo_impresa text,
    tipo_societa text,
    ragione_sociale text,
    partita_iva text,
    codice_fiscale_impresa text,
    cf_rapp_sede_legale text,
    nome_rapp_sede_legale text,
    cognome_rapp_sede_legale text,
    indirizzo_sede_legale text,
    comune_sede_legale text,
    cap_sede_legale text,
    prov_sede_legale text,
    comune_stab text,
    indirizzo_stab text,
    cap_stab text,
    prov_stab text,
    stab_descrizione_carattere text,
    stab_descrizione_attivita text,
    stab_asl text,
    lat_stab text,
    long_stab text,
    approval_number text,
    norma text,
    codice_norma text,
    macroarea text,
    codice_macroarea text,
    aggregazione text,
    codice_aggregazione text,
    attivita text,
    codice_attivita text,
    stato_linea text,
    data_inizio_attivita timestamp without time zone,
    data_fine_attivita timestamp without time zone,
    categoria_rischio integer,
    data_prossimo_controllo timestamp without time zone,
    id_controllo_ultima_categorizzazione integer,
    data_controllo_ultima_categorizzazione timestamp without time zone,
    tipo_categorizzazione text,
    livello_rischio text
);


ALTER TABLE "Analisi_dev".h_dbi_get_stabilimenti_sintesis OWNER TO postgres;

--
-- Name: h_dbi_get_tamponi_macelli; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_tamponi_macelli (
    rng int8range,
    id_asl integer,
    descr_asl text,
    nome_macello character varying,
    matricola_capo character varying,
    matrice text,
    piano character varying,
    distruttivo text,
    data_macellazione timestamp without time zone
);


ALTER TABLE "Analisi_dev".h_dbi_get_tamponi_macelli OWNER TO postgres;

--
-- Name: h_dbi_get_targhe_matricole; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dbi_get_targhe_matricole (
    rng int8range,
    id_linea integer,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    targa text,
    matricola text
);


ALTER TABLE "Analisi_dev".h_dbi_get_targhe_matricole OWNER TO postgres;

--
-- Name: h_dpat_get_nominativi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dpat_get_nominativi (
    rng int8range,
    id_nominativo integer,
    id_anagrafica_nominativo integer,
    nominativo text,
    codice_fiscale text,
    qualifica text,
    data_scadenza_nominativo timestamp without time zone,
    id_struttura_semplice integer,
    desc_strutt_semplice text,
    stato_strutt_semplice integer,
    data_scadenza_strutt_semplice timestamp without time zone,
    id_strutt_complessa integer,
    desc_strutt_complessa text,
    data_scadenza_strutt_complessa timestamp without time zone,
    stato_strutt_complessa integer,
    id_asl integer,
    anno integer
);


ALTER TABLE "Analisi_dev".h_dpat_get_nominativi OWNER TO postgres;

--
-- Name: h_dpat_indicatore_new; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dpat_indicatore_new (
    rng int8range,
    id integer,
    cod_raggruppamento integer,
    id_piano_attivita integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_esame text,
    codice_interno_indicatore integer,
    alias_indicatore text,
    codice_interno_piani_gestione_cu integer,
    codice_interno_attivita_gestione_cu text,
    codice_interno_univoco_tipo_attivita_gestione_cu text,
    codice_alias_indicatore text,
    flag_benessere boolean,
    entered timestamp without time zone,
    modified timestamp without time zone,
    entered_by integer,
    modified_by integer,
    note_hd text,
    tipo_item_dpat integer,
    rendic_per_campioni boolean
);


ALTER TABLE "Analisi_dev".h_dpat_indicatore_new OWNER TO postgres;

--
-- Name: h_dpat_indicatore_new_12112019; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dpat_indicatore_new_12112019 (
    rng int8range,
    id integer,
    cod_raggruppamento integer,
    id_piano_attivita integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_esame text,
    tipo_attivita text,
    codice_interno_indicatore integer,
    alias_indicatore text,
    codice_interno_piani_gestione_cu integer,
    codice_interno_attivita_gestione_cu text,
    codice_interno_univoco_tipo_attivita_gestione_cu text,
    codice_alias_indicatore text,
    extra_gisa boolean,
    flag_benessere boolean
);


ALTER TABLE "Analisi_dev".h_dpat_indicatore_new_12112019 OWNER TO postgres;

--
-- Name: h_dpat_indicatore_new_14lugl_err; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dpat_indicatore_new_14lugl_err (
    rng int8range,
    id integer,
    cod_raggruppamento integer,
    id_piano_attivita integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_esame text,
    codice_interno_indicatore integer,
    alias_indicatore text,
    codice_interno_piani_gestione_cu integer,
    codice_interno_attivita_gestione_cu text,
    codice_interno_univoco_tipo_attivita_gestione_cu text,
    codice_alias_indicatore text,
    flag_benessere boolean,
    entered timestamp without time zone,
    modified timestamp without time zone,
    entered_by integer,
    modified_by integer,
    note_hd text,
    tipo_item_dpat integer
);


ALTER TABLE "Analisi_dev".h_dpat_indicatore_new_14lugl_err OWNER TO postgres;

--
-- Name: h_dpat_indicatore_new_20200227; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dpat_indicatore_new_20200227 (
    rng int8range,
    id integer,
    cod_raggruppamento integer,
    id_piano_attivita integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_esame text,
    codice_interno_indicatore integer,
    alias_indicatore text,
    codice_interno_piani_gestione_cu integer,
    codice_interno_attivita_gestione_cu text,
    codice_interno_univoco_tipo_attivita_gestione_cu text,
    codice_alias_indicatore text,
    extra_gisa boolean,
    flag_benessere boolean,
    entered timestamp without time zone,
    modified timestamp without time zone,
    entered_by integer,
    modified_by integer,
    note_hd text,
    extra_rendicontazioni boolean
);


ALTER TABLE "Analisi_dev".h_dpat_indicatore_new_20200227 OWNER TO postgres;

--
-- Name: h_dpat_indicatore_new_20200702; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dpat_indicatore_new_20200702 (
    rng int8range,
    id integer,
    cod_raggruppamento integer,
    id_piano_attivita integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp(6) without time zone,
    stato integer,
    codice_esame text,
    codice_interno_indicatore integer,
    alias_indicatore text,
    codice_interno_piani_gestione_cu integer,
    codice_interno_attivita_gestione_cu text,
    codice_interno_univoco_tipo_attivita_gestione_cu text,
    codice_alias_indicatore text,
    flag_benessere boolean,
    entered timestamp(6) without time zone,
    modified timestamp(6) without time zone,
    entered_by integer,
    modified_by integer,
    note_hd text,
    tipo_item_dpat integer
);


ALTER TABLE "Analisi_dev".h_dpat_indicatore_new_20200702 OWNER TO postgres;

--
-- Name: h_dpat_indicatore_new_20200713; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dpat_indicatore_new_20200713 (
    rng int8range,
    id integer,
    cod_raggruppamento integer,
    id_piano_attivita integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_esame text,
    codice_interno_indicatore integer,
    alias_indicatore text,
    codice_interno_piani_gestione_cu integer,
    codice_interno_attivita_gestione_cu text,
    codice_interno_univoco_tipo_attivita_gestione_cu text,
    codice_alias_indicatore text,
    flag_benessere boolean,
    entered timestamp without time zone,
    modified timestamp without time zone,
    entered_by integer,
    modified_by integer,
    note_hd text,
    tipo_item_dpat integer
);


ALTER TABLE "Analisi_dev".h_dpat_indicatore_new_20200713 OWNER TO postgres;

--
-- Name: h_dpat_indicatore_new_28092020; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dpat_indicatore_new_28092020 (
    rng int8range,
    id integer,
    cod_raggruppamento integer,
    id_piano_attivita integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_esame text,
    codice_interno_indicatore integer,
    alias_indicatore text,
    codice_interno_piani_gestione_cu integer,
    codice_interno_attivita_gestione_cu text,
    codice_interno_univoco_tipo_attivita_gestione_cu text,
    codice_alias_indicatore text,
    flag_benessere boolean,
    entered timestamp without time zone,
    modified timestamp without time zone,
    entered_by integer,
    modified_by integer,
    note_hd text,
    tipo_item_dpat integer,
    rendic_per_campioni boolean
);


ALTER TABLE "Analisi_dev".h_dpat_indicatore_new_28092020 OWNER TO postgres;

--
-- Name: h_dpat_indicatore_new_2lug; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dpat_indicatore_new_2lug (
    rng int8range,
    id integer,
    cod_raggruppamento integer,
    id_piano_attivita integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp(6) without time zone,
    stato integer,
    codice_esame text,
    codice_interno_indicatore integer,
    alias_indicatore text,
    codice_interno_piani_gestione_cu integer,
    codice_interno_attivita_gestione_cu text,
    codice_interno_univoco_tipo_attivita_gestione_cu text,
    codice_alias_indicatore text,
    flag_benessere boolean,
    entered timestamp(6) without time zone,
    modified timestamp(6) without time zone,
    entered_by integer,
    modified_by integer,
    note_hd text,
    tipo_item_dpat integer
);


ALTER TABLE "Analisi_dev".h_dpat_indicatore_new_2lug OWNER TO postgres;

--
-- Name: h_dpat_piano_attivita_new; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dpat_piano_attivita_new (
    rng int8range,
    id integer,
    cod_raggruppamento integer,
    id_sezione integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_esame text,
    tipo_attivita text,
    codice_interno_piano integer,
    codice_interno_attivita integer,
    alias_piano text,
    alias_attivita text,
    codice_alias_attivita text,
    entered timestamp without time zone,
    modified timestamp without time zone,
    entered_by integer,
    modified_by integer,
    note_hd text
);


ALTER TABLE "Analisi_dev".h_dpat_piano_attivita_new OWNER TO postgres;

--
-- Name: h_dpat_sez_new; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_dpat_sez_new (
    rng int8range,
    id integer,
    cod_raggruppamento integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying,
    entered timestamp without time zone,
    modified timestamp without time zone,
    entered_by integer,
    modified_by integer
);


ALTER TABLE "Analisi_dev".h_dpat_sez_new OWNER TO postgres;

--
-- Name: h_estrazione_campioni_pnaa; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_estrazione_campioni_pnaa (
    rng int8range,
    "id campione" integer,
    "id controllo" integer,
    "numero scheda" text,
    "Data campione" timestamp without time zone,
    "Verbale campione" text,
    "Codice preaccettazione campione" text,
    "Asl campione" text,
    "CU Per conto di" text,
    "Verbale Anno" text,
    "Verbale Mese" text,
    "Verbale giorno" text,
    "Verbale ore" text,
    "Verbale Presente al prelievo" text,
    "Verbale sottoscritti" text,
    "Verbale Numero campioni prelevati" text,
    "Verbale DPA" text,
    "A1. Strategia di campionamento" text,
    "A2. Metodo di campionamento" text,
    "A3. Programma di Controllo" text,
    "A3. specifica principi farmacologicamente attivi" text,
    "A3. specifica additivi nutrizionali" text,
    "A3. specifica cocciodiostatici/istomonostatici" text,
    "A3. specifica additivi tecnologici" text,
    "A3. specifica Principi additivi organolettici" text,
    "A3. specifica additivi zootecnici" text,
    "A3. specifica principi farm. attivi carry over" text,
    "A3. specifica coccidiostatici/istomonastici carry over" text,
    "A3. specifica contamin. inorganici e composti azotati" text,
    "A3. specifica radionuclidi" text,
    "A3. specifica pesticidi" text,
    "A3. specifica micotossine" text,
    "A3. specifica altro" text,
    "A3. Principi farmacologicamente attivi" text,
    "A3. Principi farmacologicamente attivi carry over" text,
    "A3. Quantità di P.A/Cocc." text,
    "A3. Contaminanti inorganici e composti az, pe, ra" text,
    "A4. Prelevatore" text,
    "A5. Luogo di prelievo" text,
    "A6. Codice luogo di prelievo" text,
    "A7. Targa mezzo di trasporto" text,
    "A8. Indirizzo del luogo di prelievo" text,
    "A9. Comune" text,
    "A10. Provincia" text,
    "A11. Latitudine luogo" text,
    "A11. Longitudine luogo" text,
    "A12. Ragione sociale" text,
    "A13. Rappresentante legale" text,
    "A14. Codice fiscale" text,
    "A15. Detentore" text,
    "A16. Telefono" text,
    "B1. Matrice del campione" text,
    "B1. Specie vegetale dichiarata" text,
    "B1. Specifica materia prima/mangime semplice" text,
    "B1. Mangime composto" text,
    "B1. Premiscela additivi" text,
    "B1. Categoria Sottoprodotti" text,
    "B2. Trattamento mangime" text,
    "B3. Confezionamento" text,
    "B4. Ragione sociale ditta produttrice" text,
    "B5. Indrizzo ditta produttrice" text,
    "B6. Specie e categoria animale per alimento" text,
    "B7. Metodo di produzione" text,
    "B8. Nome commerciale mangime" text,
    "B9. Stato prodotto" text,
    "B10. Ragione sociale responsabile etichettatura" text,
    "B11. Indirizzo responsabile etichettatura" text,
    "B12. Paese di produzione" text,
    "B13. Data di produzione" text,
    "B14. Data di scadenza" text,
    "B15. Numero di lotto" text,
    "B16. Dimensione del lotto" text,
    "B17. Ingredienti" text,
    "B18. Commenti ulteriori sul mangime" text,
    "C1. Laboratorio destinazione" text,
    "D. Informazioni cartellino" text,
    "D. Descrizione attrezzature" text,
    "D. Num punti" text,
    "D. Num CE" text,
    "D. Peso Volume" text,
    "D. Operazioni" text,
    "D. Kg/lt" text,
    "D. Operazioni campione globale" text,
    "D. CF" text,
    "D. g/ml" text,
    "D. Dichiarazione" text,
    "D. Conservazione campione" text,
    "D. Numero copia/e" text,
    "D. Numero campioni finali" text,
    "D. Custode campione" text,
    "D. Per conto di" text,
    "D. Rinuncia per controversia/controperizia" text,
    "D. Volume finale" text,
    "D. Numero campioni finali inviati" text,
    "D. Numero copie inviate" text,
    "D. Destinazione invio" text,
    "D. Data invio" text,
    "D. CG ridotto" text,
    "D. CG/CR" text,
    "D. Sequestro partita" text,
    "Codice SINVSA" text
);


ALTER TABLE "Analisi_dev".h_estrazione_campioni_pnaa OWNER TO postgres;

--
-- Name: h_estrazione_controlli_apicoltura_tipoab; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_estrazione_controlli_apicoltura_tipoab (
    rng int8range,
    id_controllo_ufficiale text,
    data_inizio_controllo text,
    alias_indicatore text,
    piano_monitoraggio text,
    ragione_sociale text,
    asl_apiario text,
    cun text,
    comune_apiario text,
    provincia_apiario text,
    indirizzo_apiario text,
    cap_apiario text,
    num_alveari_presenti text,
    modalita_selezione_apiario text,
    classificazione text,
    motivo_controllo_apiario text,
    specifica_altro_motivo_controllo text,
    numero_alveari_controllati text,
    esito text,
    note_esito text
);


ALTER TABLE "Analisi_dev".h_estrazione_controlli_apicoltura_tipoab OWNER TO postgres;

--
-- Name: h_get_accettazioni; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_accettazioni (
    rng int8range,
    numero text,
    data date,
    asl_id integer,
    asl text,
    clinica text,
    microchip text,
    deceduto_non_anagrafe boolean,
    asl_animale_id integer,
    asl_animale text,
    proprietario text,
    specie_description text,
    specie_id integer,
    username_utente text,
    utente text,
    motivazione_id integer,
    motivazione text,
    attivita_esterna_id integer,
    attivita_esterna text,
    note text,
    numero_cc text
);


ALTER TABLE "Analisi_dev".h_get_accettazioni OWNER TO postgres;

--
-- Name: h_get_campioni; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_campioni (
    rng int8range,
    id_asl integer,
    asl character varying,
    motivazione_campione character varying,
    id_piano integer,
    id_attivita integer,
    id_campione integer,
    data_prelievo timestamp without time zone,
    identificativo_campione character varying,
    prelevatore_1_a4 text,
    prelevatore_2_a4 text,
    prelevatore_3_a4 text,
    strategia_campionamento_a1 text,
    capitoli_piani_a3 text,
    specie_alimento_b6 character varying,
    metodo_produzione_b7 text,
    anno_campione text,
    data_chiusura_campione timestamp without time zone,
    id_controllo_ufficiale character varying,
    esito text,
    punteggio_campione integer,
    responsabilita_positiva character varying,
    data_esito_analita timestamp without time zone,
    esito_motivazione_respingimento text,
    note_esito_campione text,
    codice_accettazione text,
    num_verbale character varying,
    barcode character varying,
    analita_lev_1 text,
    analita_lev_2 text,
    analita_lev_3 text,
    analita_lev_4 text,
    matrice_lev_1 text,
    matrice_lev_2 text,
    matrice_lev_3 text,
    note_campione text,
    anno_controllo text,
    codice_interno_piano text,
    descrizione_esito_esame text,
    motivazione_non_conformita text,
    rendicontabile boolean,
    codice_preaccettazione text
);


ALTER TABLE "Analisi_dev".h_get_campioni OWNER TO postgres;

--
-- Name: h_get_campioni_20200722; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_campioni_20200722 (
    rng int8range,
    id_asl integer,
    asl character varying,
    ragione_sociale character varying,
    partita_iva character varying,
    tipo_operatore character varying,
    tipologia_impianto character varying,
    motivazione_campione character varying,
    tipo_piano_monitoraggio_old text,
    id_piano integer,
    id_attivita integer,
    piano_attivita text,
    id_campione integer,
    data_prelievo timestamp without time zone,
    identificativo_campione character varying,
    prelevatore_1_a4 text,
    prelevatore_2_a4 text,
    prelevatore_3_a4 text,
    strategia_campionamento_a1 text,
    capitoli_piani_a3 text,
    specie_alimento_b6 character varying,
    metodo_produzione_b7 text,
    anno_campione text,
    data_chiusura_campione timestamp without time zone,
    id_controllo_ufficiale character varying,
    esito text,
    punteggio_campione integer,
    responsabilita_positiva character varying,
    data_esito_analita timestamp without time zone,
    esito_motivazione_respingimento text,
    note_esito_campione text,
    codice_accettazione text,
    num_verbale character varying,
    barcode character varying,
    analita_lev_1 text,
    analita_lev_2 text,
    analita_lev_3 text,
    analita_lev_4 text,
    matrice_lev_1 text,
    matrice_lev_2 text,
    matrice_lev_3 text,
    note_campione text,
    anno_controllo text,
    codice_interno_piano text,
    descrizione_esito_esame text
);


ALTER TABLE "Analisi_dev".h_get_campioni_20200722 OWNER TO postgres;

--
-- Name: h_get_campioni_20201014; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_campioni_20201014 (
    rng int8range,
    id_asl integer,
    asl character varying,
    motivazione_campione character varying,
    id_piano integer,
    id_attivita integer,
    id_campione integer,
    data_prelievo timestamp without time zone,
    identificativo_campione character varying,
    prelevatore_1_a4 text,
    prelevatore_2_a4 text,
    prelevatore_3_a4 text,
    strategia_campionamento_a1 text,
    capitoli_piani_a3 text,
    specie_alimento_b6 character varying,
    metodo_produzione_b7 text,
    anno_campione text,
    data_chiusura_campione timestamp without time zone,
    id_controllo_ufficiale character varying,
    esito text,
    punteggio_campione integer,
    responsabilita_positiva character varying,
    data_esito_analita timestamp without time zone,
    esito_motivazione_respingimento text,
    note_esito_campione text,
    codice_accettazione text,
    num_verbale character varying,
    barcode character varying,
    analita_lev_1 text,
    analita_lev_2 text,
    analita_lev_3 text,
    analita_lev_4 text,
    matrice_lev_1 text,
    matrice_lev_2 text,
    matrice_lev_3 text,
    note_campione text,
    anno_controllo text,
    codice_interno_piano text,
    descrizione_esito_esame text,
    motivazione_non_conformita text,
    rendicontabile boolean
);


ALTER TABLE "Analisi_dev".h_get_campioni_20201014 OWNER TO postgres;

--
-- Name: h_get_campioni_20201014_2; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_campioni_20201014_2 (
    rng int8range,
    id_asl integer,
    asl character varying,
    motivazione_campione character varying,
    id_piano integer,
    id_attivita integer,
    id_campione integer,
    data_prelievo timestamp without time zone,
    identificativo_campione character varying,
    prelevatore_1_a4 text,
    prelevatore_2_a4 text,
    prelevatore_3_a4 text,
    strategia_campionamento_a1 text,
    capitoli_piani_a3 text,
    specie_alimento_b6 character varying,
    metodo_produzione_b7 text,
    anno_campione text,
    data_chiusura_campione timestamp without time zone,
    id_controllo_ufficiale character varying,
    esito text,
    punteggio_campione integer,
    responsabilita_positiva character varying,
    data_esito_analita timestamp without time zone,
    esito_motivazione_respingimento text,
    note_esito_campione text,
    codice_accettazione text,
    num_verbale character varying,
    barcode character varying,
    analita_lev_1 text,
    analita_lev_2 text,
    analita_lev_3 text,
    analita_lev_4 text,
    matrice_lev_1 text,
    matrice_lev_2 text,
    matrice_lev_3 text,
    note_campione text,
    anno_controllo text,
    codice_interno_piano text,
    descrizione_esito_esame text,
    motivazione_non_conformita text,
    rendicontabile boolean
);


ALTER TABLE "Analisi_dev".h_get_campioni_20201014_2 OWNER TO postgres;

--
-- Name: h_get_categorie_rischio; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_categorie_rischio (
    rng int8range,
    code integer,
    description text,
    tipologia integer,
    desc_tipologia character varying
);


ALTER TABLE "Analisi_dev".h_get_categorie_rischio OWNER TO postgres;

--
-- Name: h_get_cc; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_cc (
    rng int8range,
    numero text,
    data_apertura date,
    data_chiusura date,
    destinazione_animale text,
    username_utente_dimissioni text,
    utente_dimissioni text,
    tipo_cc text,
    necroscopica boolean,
    day_hospital boolean,
    motivo_ricovero text,
    clinica text,
    asl text,
    asl_id integer,
    microchip text,
    deceduto_non_anagrafe boolean,
    asl_animale text,
    asl_animale_id integer,
    username_utente text,
    utente text,
    specie text,
    specie_id integer,
    razza text,
    numero_accettazione text,
    num_reg_sterilizzazione integer,
    data_reinvenimento_sinantropo timestamp without time zone,
    comune_reinvenimento_sinantropo text,
    luogo_reinvenimento_sinantropo text,
    data_rilascio_sinantropo timestamp without time zone,
    comune_rilascio_sinantropo text,
    luogo_rilascio_sinantropo text,
    numero_riferimento_mittente_necroscopia text,
    tipologia_riferimento_mittente_necroscopia text
);


ALTER TABLE "Analisi_dev".h_get_cc OWNER TO postgres;

--
-- Name: h_get_checklist_sorveglianza; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_checklist_sorveglianza (
    rng int8range,
    id integer,
    id_controllo integer,
    is_principale boolean,
    stato text,
    livello_rischio integer,
    tipo_check integer,
    num_chk integer
);


ALTER TABLE "Analisi_dev".h_get_checklist_sorveglianza OWNER TO postgres;

--
-- Name: h_get_comuni; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_comuni (
    rng int8range,
    id integer,
    cod_comune character varying,
    cod_regione character varying,
    cod_provincia integer,
    nome character varying,
    istat character varying,
    cap character varying,
    cod_nazione integer,
    id_asl integer
);


ALTER TABLE "Analisi_dev".h_get_comuni OWNER TO postgres;

--
-- Name: h_get_controlli_altri_congiunti; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_altri_congiunti (
    rng int8range,
    id_controllo_ufficiale integer,
    id_tecnica_cu integer,
    nome_componente_nucleo text,
    ruolo_componente_nucleo character varying,
    gruppo_ruolo_componente_nucleo text
);


ALTER TABLE "Analisi_dev".h_get_controlli_altri_congiunti OWNER TO postgres;

--
-- Name: h_get_controlli_audit; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_audit (
    rng int8range,
    id_controllo integer,
    data_inserimento timestamp without time zone,
    data_inizio_controllo timestamp without time zone,
    data_chiusura_controllo timestamp without time zone,
    data_fine_controllo timestamp without time zone,
    id_stato_controllo integer,
    stato_controllo text,
    asl character varying,
    riferimento_id integer,
    riferimento_nome_tab text,
    id_asl integer,
    congruo_supervisione text,
    supervisionato_in_data timestamp without time zone,
    supervisionato_da integer,
    supervisione_note text,
    note text,
    id_tecnica_cu integer,
    punteggio integer,
    utente_inserimento text
);


ALTER TABLE "Analisi_dev".h_get_controlli_audit OWNER TO postgres;

--
-- Name: h_get_controlli_audit_autorita_competenti; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_audit_autorita_competenti (
    rng int8range,
    id_controllo integer,
    data_inserimento timestamp without time zone,
    data_inizio_controllo timestamp without time zone,
    data_chiusura_controllo timestamp without time zone,
    data_fine_controllo timestamp without time zone,
    id_stato_controllo integer,
    stato_controllo text,
    tipo_controllo text,
    asl character varying,
    id_asl integer,
    id_struttura_controllata integer,
    struttura_controllata text,
    path_completo_struttura text,
    congruo_supervisione text,
    supervisionato_in_data timestamp without time zone,
    supervisionato_da integer,
    supervisione_note text,
    note text,
    id_tecnica_cu integer,
    punteggio integer
);


ALTER TABLE "Analisi_dev".h_get_controlli_audit_autorita_competenti OWNER TO postgres;

--
-- Name: h_get_controlli_audit_autorita_competenti_oggetto_audit; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_audit_autorita_competenti_oggetto_audit (
    rng int8range,
    id_oggetto integer,
    oggetto_audit text,
    id_controllo integer,
    audit_di_followup boolean,
    tipo_audit text
);


ALTER TABLE "Analisi_dev".h_get_controlli_audit_autorita_competenti_oggetto_audit OWNER TO postgres;

--
-- Name: h_get_controlli_audit_motivi_2020; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_audit_motivi_2020 (
    rng int8range,
    id_controllo integer,
    id_motivo_audit integer,
    id_piano integer,
    descrizione_motivo_padre character varying,
    descrizione_motivo_figlio text,
    codice_interno_piano_attivita text,
    alias_padre text,
    alias_indicatore text
);


ALTER TABLE "Analisi_dev".h_get_controlli_audit_motivi_2020 OWNER TO postgres;

--
-- Name: h_get_controlli_audit_oggetto_del_controllo_2020; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_audit_oggetto_del_controllo_2020 (
    rng int8range,
    id_controllo integer,
    id_oggetto_del_controllo integer,
    oggetto_del_controllo text,
    id_macrocategoria integer,
    descrizione_macrocategoria text
);


ALTER TABLE "Analisi_dev".h_get_controlli_audit_oggetto_del_controllo_2020 OWNER TO postgres;

--
-- Name: h_get_controlli_audit_oggettodelcontrollo; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_audit_oggettodelcontrollo (
    rng int8range,
    id_controllo integer,
    id_motivo integer,
    motivo_audit text,
    id_tipo_audit integer,
    tipo_audit text,
    id_oggetto_bpi integer,
    oggetto_bpi text,
    id_oggetto_haccp integer,
    oggetto_haccp text
);


ALTER TABLE "Analisi_dev".h_get_controlli_audit_oggettodelcontrollo OWNER TO postgres;

--
-- Name: h_get_controlli_audit_percontodi_2020; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_audit_percontodi_2020 (
    rng int8range,
    id_controllo integer,
    struttura_complessa text,
    struttura_semplice text,
    per_conto_di_completo text,
    id_unita_operativa integer,
    id_asl_struttura integer,
    codice_interno_univoco_uo integer,
    area_appartenenza_uo character varying,
    id_motivo_audit integer,
    id_piano_audit integer
);


ALTER TABLE "Analisi_dev".h_get_controlli_audit_percontodi_2020 OWNER TO postgres;

--
-- Name: h_get_controlli_audit_sorv_percontodi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_audit_sorv_percontodi (
    rng int8range,
    id_controllo integer,
    struttura_complessa text,
    struttura_semplice text,
    per_conto_di_completo text,
    id_unita_operativa integer,
    id_asl_struttura integer,
    codice_interno_univoco_uo integer,
    area_appartenenza_uo character varying
);


ALTER TABLE "Analisi_dev".h_get_controlli_audit_sorv_percontodi OWNER TO postgres;

--
-- Name: h_get_controlli_congiunti_asl_crr; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_congiunti_asl_crr (
    rng int8range,
    id_controllo_ufficiale integer,
    id_tecnica_cu integer,
    nome_componente_nucleo text,
    ruolo_componente_nucleo character varying,
    gruppo_ruolo_componente_nucleo text
);


ALTER TABLE "Analisi_dev".h_get_controlli_congiunti_asl_crr OWNER TO postgres;

--
-- Name: h_get_controlli_congiunti_asl_extra_asl; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_congiunti_asl_extra_asl (
    rng int8range,
    id_controllo_ufficiale integer,
    id_tecnica_cu integer,
    nome_componente_nucleo text,
    ruolo_componente_nucleo character varying,
    gruppo_ruolo_componente_nucleo text
);


ALTER TABLE "Analisi_dev".h_get_controlli_congiunti_asl_extra_asl OWNER TO postgres;

--
-- Name: h_get_controlli_congiunti_asl_extra_asl_fdo; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_congiunti_asl_extra_asl_fdo (
    rng int8range,
    id_controllo_ufficiale integer,
    id_tecnica_cu integer,
    nome_componente_nucleo text,
    ruolo_componente_nucleo character varying,
    gruppo_ruolo_componente_nucleo text
);


ALTER TABLE "Analisi_dev".h_get_controlli_congiunti_asl_extra_asl_fdo OWNER TO postgres;

--
-- Name: h_get_controlli_crr; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_crr (
    rng int8range,
    id_controllo_ufficiale integer,
    id_tecnica_cu integer,
    nome_componente_nucleo text,
    ruolo_componente_nucleo character varying,
    gruppo_ruolo_componente_nucleo text
);


ALTER TABLE "Analisi_dev".h_get_controlli_crr OWNER TO postgres;

--
-- Name: h_get_controlli_extra_asl_fdo; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_extra_asl_fdo (
    rng int8range,
    id_controllo_ufficiale integer,
    id_tecnica_cu integer,
    nome_componente_nucleo text,
    ruolo_componente_nucleo character varying,
    gruppo_ruolo_componente_nucleo text
);


ALTER TABLE "Analisi_dev".h_get_controlli_extra_asl_fdo OWNER TO postgres;

--
-- Name: h_get_controlli_ispezioni_carni; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_ispezioni_carni (
    rng int8range,
    id_controllo integer,
    data_inserimento timestamp without time zone,
    data_inizio_controllo timestamp without time zone,
    data_chiusura_controllo timestamp without time zone,
    data_fine_controllo timestamp without time zone,
    id_stato_controllo integer,
    stato_controllo text,
    asl character varying,
    riferimento_id integer,
    riferimento_nome_tab text,
    id_asl integer,
    congruo_supervisione text,
    supervisionato_in_data timestamp without time zone,
    supervisionato_da integer,
    supervisione_note text,
    note text,
    id_tecnica_cu integer,
    punteggio integer,
    utente_inserimento text
);


ALTER TABLE "Analisi_dev".h_get_controlli_ispezioni_carni OWNER TO postgres;

--
-- Name: h_get_controlli_ispezioni_semplici; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_ispezioni_semplici (
    rng int8range,
    id_controllo integer,
    data_inserimento timestamp without time zone,
    data_inizio_controllo timestamp without time zone,
    data_chiusura_controllo timestamp without time zone,
    data_fine_controllo timestamp without time zone,
    id_stato_controllo integer,
    stato_controllo text,
    id_asl integer,
    asl character varying,
    riferimento_id integer,
    riferimento_nome_tab text,
    congruo_supervisione text,
    supervisionato_in_data timestamp without time zone,
    supervisionato_da integer,
    supervisione_note text,
    note text,
    id_tecnica_cu integer,
    targa_matricola text,
    punteggio integer,
    utente_inserimento text
);


ALTER TABLE "Analisi_dev".h_get_controlli_ispezioni_semplici OWNER TO postgres;

--
-- Name: h_get_controlli_ispezioni_semplici_motivi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_ispezioni_semplici_motivi (
    rng int8range,
    id_controllo integer,
    id_motivo_ispezione integer,
    id_piano integer,
    descrizione_motivo_padre character varying,
    descrizione_motivo_figlio text,
    codice_interno_piano_attivita text,
    alias_padre text,
    alias_indicatore text
);


ALTER TABLE "Analisi_dev".h_get_controlli_ispezioni_semplici_motivi OWNER TO postgres;

--
-- Name: h_get_controlli_ispezioni_semplici_oggetto_del_controllo; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_ispezioni_semplici_oggetto_del_controllo (
    rng int8range,
    id_controllo integer,
    id_oggetto_del_controllo integer,
    oggetto_del_controllo text,
    id_macrocategoria integer,
    descrizione_macrocategoria text
);


ALTER TABLE "Analisi_dev".h_get_controlli_ispezioni_semplici_oggetto_del_controllo OWNER TO postgres;

--
-- Name: h_get_controlli_ispezioni_semplici_percontodi; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_ispezioni_semplici_percontodi (
    rng int8range,
    id_controllo integer,
    id_motivo_ispezione integer,
    id_piano_ispezione integer,
    struttura_complessa character varying,
    struttura_semplice character varying,
    per_conto_di_completo character varying,
    id_unita_operativa integer,
    id_asl_struttura integer,
    codice_interno_univoco_uo integer
);


ALTER TABLE "Analisi_dev".h_get_controlli_ispezioni_semplici_percontodi OWNER TO postgres;

--
-- Name: h_get_controlli_non_eseguito; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_non_eseguito (
    rng int8range,
    id_controllo integer,
    data_inserimento timestamp without time zone,
    data_inizio_controllo timestamp without time zone,
    data_chiusura_controllo timestamp without time zone,
    data_fine_controllo timestamp without time zone,
    id_stato_controllo integer,
    stato_controllo text,
    asl character varying,
    riferimento_id integer,
    riferimento_nome_tab text,
    tipo_controllo text,
    id_asl integer,
    congruo_supervisione text,
    supervisionato_in_data timestamp without time zone,
    supervisionato_da integer,
    supervisione_note text,
    note text,
    id_tecnica_cu integer,
    punteggio integer
);


ALTER TABLE "Analisi_dev".h_get_controlli_non_eseguito OWNER TO postgres;

--
-- Name: h_get_controlli_nucleoispettivo; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_nucleoispettivo (
    rng int8range,
    id_controllo integer,
    ruolo text,
    cognome text,
    nome text,
    id_componente integer
);


ALTER TABLE "Analisi_dev".h_get_controlli_nucleoispettivo OWNER TO postgres;

--
-- Name: h_get_controlli_sorveglianze; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_sorveglianze (
    rng int8range,
    id_controllo integer,
    data_inserimento timestamp without time zone,
    data_inizio_controllo timestamp without time zone,
    data_chiusura_controllo timestamp without time zone,
    data_fine_controllo timestamp without time zone,
    stato_controllo text,
    id_stato_controllo integer,
    asl character varying,
    riferimento_id integer,
    riferimento_nome_tab text,
    id_asl integer,
    aggiornata_categoria boolean,
    categoria_rischio integer,
    data_prossimo_controllo timestamp without time zone,
    congruo_supervisione text,
    supervisionato_in_data timestamp without time zone,
    supervisionato_da integer,
    supervisione_note text,
    note text,
    id_tecnica_cu integer,
    punteggio integer,
    utente_inserimento text
);


ALTER TABLE "Analisi_dev".h_get_controlli_sorveglianze OWNER TO postgres;

--
-- Name: h_get_controlli_sorveglianze_backup; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_controlli_sorveglianze_backup (
    rng int8range,
    id_controllo integer,
    data_inserimento timestamp without time zone,
    data_inizio_controllo timestamp without time zone,
    data_chiusura_controllo timestamp without time zone,
    data_fine_controllo timestamp without time zone,
    stato_controllo text,
    id_stato_controllo integer,
    asl character varying,
    riferimento_id integer,
    riferimento_nome_tab text,
    id_asl integer,
    aggiornata_categoria boolean,
    categoria_rischio integer,
    data_prossimo_controllo timestamp without time zone,
    congruo_supervisione text,
    supervisionato_in_data timestamp without time zone,
    supervisionato_da integer,
    supervisione_note text,
    note text,
    id_tecnica_cu integer
);


ALTER TABLE "Analisi_dev".h_get_controlli_sorveglianze_backup OWNER TO postgres;

--
-- Name: h_get_dati_scheda_piccioni; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_dati_scheda_piccioni (
    rng int8range,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    cod_azienda text,
    id_fiscale_allevamento text,
    partita_iva text,
    asl text,
    specie_allevata text,
    stima_popolazione text,
    utilizzo_sistemi text,
    reti_protezione text,
    cannoncini_dissuasori text,
    dissuasori_aghi text,
    dissuasori_sonori text,
    altro text
);


ALTER TABLE "Analisi_dev".h_get_dati_scheda_piccioni OWNER TO postgres;

--
-- Name: h_get_elenco_rifugi_pubblici_privati_digemon; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_elenco_rifugi_pubblici_privati_digemon (
    rng int8range,
    id_rel_stab_lp integer,
    ragione_sociale_attuale text,
    asl_attuale text,
    responsabile_attuale text,
    pubblico_privato_attuale text,
    stato_attuale text,
    capienza_attuale integer,
    indice_attuale integer,
    numero_soggetti_detenuti_data bigint,
    numero_soggetti_deceduti_data bigint,
    numero_trasferimenti_fuori_regione_data bigint,
    numero_adozioni_data bigint,
    numero_catture_trasferimento_presso_canile_data bigint,
    data_inizio_estrazione timestamp without time zone,
    data_fine_estrazione timestamp without time zone
);


ALTER TABLE "Analisi_dev".h_get_elenco_rifugi_pubblici_privati_digemon OWNER TO postgres;

--
-- Name: h_get_esami; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_esami (
    rng int8range,
    tipo_richiedente text,
    richiedente_privato text,
    richiedente_coincide_con_proprietario boolean,
    richiedente_asl text,
    richiedente_associazione text,
    richiedente_forza_pubblica_comando text,
    richiedente_forza_pubblica_provincia text,
    richiedente_forza_pubblica_comune text,
    richiedente_altro text,
    sottotipo_macrocategoria text,
    tipo_esame text,
    apparato_esaminato text,
    data_richiesta timestamp without time zone,
    id_utente_inserimento_esame integer,
    numero_accettazione text,
    identificativo_animale text,
    specie_animale text,
    username_utente_apertura_accettazione text,
    nominativo_utente_apertura_accettazione text,
    numero_cc text,
    data_apertura_cc date,
    username_utente_apertura_cc text,
    nominativo_utente_apertura_cc text,
    data_chiusura_cc date,
    clinica text,
    id_asl integer,
    asl text,
    fascicolo_sanitario text,
    tipo_intervento text,
    note_intervento_chirurgico text,
    macrocategoria_esame text,
    username_utente_inserimento_esame text,
    nominativo_utente_inserimento_esame text
);


ALTER TABLE "Analisi_dev".h_get_esami OWNER TO postgres;

--
-- Name: h_get_info_macellazione_domicilio; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_info_macellazione_domicilio (
    rng int8range,
    idcontrollo integer,
    asl character varying,
    data_inserimento_controllo timestamp without time zone,
    controllo_documentale_effettuato text,
    num_capi_macellati text,
    num_capi text,
    data_acquisto_1 text,
    allev_origine_1 text,
    data_acquisto_2 text,
    allev_origine_2 text,
    data_acquisto_3 text,
    allev_origine_3 text,
    codice_interno_piano text,
    data_acquisto_4 text,
    allev_origine_4 text
);


ALTER TABLE "Analisi_dev".h_get_info_macellazione_domicilio OWNER TO postgres;

--
-- Name: h_get_info_masterlist; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_info_masterlist (
    rng int8range,
    codice_univoco text,
    id_norma integer,
    codice_norma text,
    id_macroarea integer,
    macroarea text,
    codice_macroarea text,
    id_aggregazione integer,
    aggregazione text,
    codice_aggregazione text,
    id_linea integer,
    attivita text,
    codice_attivita text,
    mobile boolean,
    fisso boolean,
    apicoltura boolean,
    registrabili boolean,
    riconoscibili boolean,
    sintesis boolean,
    bdu boolean,
    vam boolean,
    no_scia boolean,
    categorizzabili boolean,
    rev integer,
    categoria_rischio_default integer
);


ALTER TABLE "Analisi_dev".h_get_info_masterlist OWNER TO postgres;

--
-- Name: h_get_info_tecnica_cu; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_info_tecnica_cu (
    rng int8range,
    codice integer,
    descrizione character varying,
    info_nc boolean,
    info_campione boolean
);


ALTER TABLE "Analisi_dev".h_get_info_tecnica_cu OWNER TO postgres;

--
-- Name: h_get_istopatologici; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_istopatologici (
    rng int8range,
    numero_esame text,
    data_richiesta timestamp without time zone,
    data_esito timestamp without time zone,
    sede_lesione_id integer,
    sede_lesione_description text,
    tipo_diagnosi_id integer,
    tipo_diagnosi_description text,
    outsidecc boolean,
    cc text,
    asl_id integer,
    asl text,
    clinica text,
    microchip text,
    deceduto_non_anagrafe boolean,
    asl_animale_id integer,
    asl_animale text,
    specie_description text,
    specie_id integer,
    username_utente_inserimento text,
    utente_inserimento text,
    username_utente_modifica text,
    utente_modifica text
);


ALTER TABLE "Analisi_dev".h_get_istopatologici OWNER TO postgres;

--
-- Name: h_get_linee_attivita_controllo; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_linee_attivita_controllo (
    rng int8range,
    id_controllo integer,
    codice_linea text,
    attivita text,
    id_linea integer
);


ALTER TABLE "Analisi_dev".h_get_linee_attivita_controllo OWNER TO postgres;

--
-- Name: h_get_linee_attivita_controllo_old; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_linee_attivita_controllo_old (
    rng int8range,
    id_controllo integer,
    codice_linea text
);


ALTER TABLE "Analisi_dev".h_get_linee_attivita_controllo_old OWNER TO postgres;

--
-- Name: h_get_necroscopie; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_necroscopie (
    rng int8range,
    data timestamp without time zone,
    microchip text,
    deceduto_non_anagrafe boolean,
    asl_animale text,
    asl_animale_id integer,
    specie text,
    specie_id integer,
    cartella_clinica text,
    username_utente_richiesta text,
    nome_utente_richiesta text,
    clinica text,
    asl text,
    asl_id integer,
    sala_settoria_destinazione text,
    comune_ritrovamento text
);


ALTER TABLE "Analisi_dev".h_get_necroscopie OWNER TO postgres;

--
-- Name: h_get_occupazione_canili; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_occupazione_canili (
    rng int8range,
    id_rel_stab_lp integer,
    ragione_sociale text,
    asl text,
    partita_iva text,
    indirizzo text,
    indice text,
    stato text,
    numero_cani_vivi bigint,
    num_cani_proprietari_privati bigint,
    num_cani_proprietari_sindaci bigint,
    num_cani_proprietari_altri bigint,
    posti_disponibili_cani_giganti bigint,
    numero_cani_vivi_disponibile_limite_350 bigint,
    numero_cani_vivi_eccesso_limite_350 bigint
);


ALTER TABLE "Analisi_dev".h_get_occupazione_canili OWNER TO postgres;

--
-- Name: h_get_osa_mai_controllati; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_osa_mai_controllati (
    rng int8range,
    riferimento_id integer,
    riferimento_id_nome text,
    riferimento_id_nome_col text,
    riferimento_id_nome_tab text,
    ragione_sociale character varying,
    asl_rif integer,
    asl character varying,
    id_norma integer,
    codice_norma text,
    norma text,
    codice_fiscale text,
    n_reg character varying,
    num_riconoscimento character varying,
    partita_iva text,
    comune character varying,
    provincia_stab character varying,
    indirizzo character varying,
    latitudine_stab double precision,
    longitudine_stab double precision,
    codice_fiscale_rappresentante character varying,
    nominativo_rappresentante text,
    data_inizio_attivita timestamp without time zone,
    data_fine_attivita timestamp without time zone
);


ALTER TABLE "Analisi_dev".h_get_osa_mai_controllati OWNER TO postgres;

--
-- Name: h_get_osa_non_controllati; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_osa_non_controllati (
    rng int8range,
    riferimento_id integer,
    riferimento_id_nome text,
    riferimento_id_nome_col text,
    riferimento_id_nome_tab text,
    ragione_sociale character varying,
    asl_rif integer,
    asl character varying,
    id_norma integer,
    codice_norma text,
    norma text,
    codice_fiscale text,
    n_reg character varying,
    num_riconoscimento character varying,
    partita_iva text,
    comune character varying,
    provincia_stab character varying,
    indirizzo character varying,
    latitudine_stab double precision,
    longitudine_stab double precision,
    codice_fiscale_rappresentante character varying,
    nominativo_rappresentante text,
    categoria_rischio integer,
    prossimo_controllo timestamp without time zone,
    data_inizio_attivita timestamp without time zone,
    data_fine_attivita timestamp without time zone,
    ultimo_controllo timestamp without time zone
);


ALTER TABLE "Analisi_dev".h_get_osa_non_controllati OWNER TO postgres;

--
-- Name: h_get_registro_trasgressori; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_registro_trasgressori (
    rng int8range,
    num_progressivo text,
    id_controllo integer,
    anno_controllo integer,
    asl_competenza text,
    ente_accertatore_1 text,
    ente_accertatore_2 text,
    ente_accertatore_3 text,
    pv_numero text,
    sequestro_numero text,
    data_accertamento text,
    data_protocollo text,
    trasgressore text,
    obbligato_in_solido text,
    importo_sanzione_ridotta text,
    importo_sanzione_ridotta_del_30_percento text,
    illecito_competenza_uod text,
    data_ultima_notifica text,
    pv_oblato_misura_ridotta text,
    importo_effettivamente_introitato_1 integer,
    data_pagamento text,
    pagamento_effettuato_nei_termini text,
    funzionario_assegnatario text,
    presentati_scritti_difensivi text,
    presentata_richiesta_riduzione_rateizzazione text,
    presentata_richiesta_audizione text,
    ordinanza_emessa text,
    num_ordinanza text,
    data_emissione_ordinanza text,
    giorni_lavorazione_pratica integer,
    importo_sanzione_ingiunta integer,
    data_ultima_notifica_ordinanza text,
    data_pagamento_ordinanza text,
    concessa_rateizzazione text,
    rate_pagate text,
    ordinanza_ingiunzione_oblata text,
    importo_effettivamente_introitato_2 integer,
    presentata_opposizione_ordinanza text,
    sentenza_favorevole_ricorrente text,
    importo_stabilito_ag integer,
    ordinanza_oblata_secondo_sentenza text,
    importo_effettivamente_introitato_3 integer,
    avviata_esecuzione_forzata text,
    importo_effettivamente_introitato_4 integer,
    note_gruppo_1 text,
    note_gruppo_2 text,
    pratica_chiusa text
);


ALTER TABLE "Analisi_dev".h_get_registro_trasgressori OWNER TO postgres;

--
-- Name: h_get_registro_unico_cani_aggressori; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_registro_unico_cani_aggressori (
    rng int8range,
    microchip text,
    tatuaggio text,
    proprietario text,
    asl_proprietario text,
    id_evento integer,
    data_inserimento_registrazione timestamp without time zone,
    data_registrazione timestamp without time zone,
    evento text,
    anno double precision,
    id_cu integer,
    misure_formative text,
    misure_riabilitative text,
    misure_restrittive text
);


ALTER TABLE "Analisi_dev".h_get_registro_unico_cani_aggressori OWNER TO postgres;

--
-- Name: h_get_smaltimento_carogna; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_smaltimento_carogna (
    rng int8range,
    mc text,
    deceduto_non_anagrafe boolean,
    data_smaltimento_carogna date,
    ddt text,
    ditta_autorizzata text,
    asl text,
    asl_id integer,
    specie text,
    specie_id integer,
    asl_animale_id integer,
    asl_animale text
);


ALTER TABLE "Analisi_dev".h_get_smaltimento_carogna OWNER TO postgres;

--
-- Name: h_get_stato_diffide; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_stato_diffide (
    rng int8range,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    id_diffida integer,
    id_controllo_ufficiale integer,
    data_diffida timestamp without time zone,
    norma_diffida text,
    stato_diffida text
);


ALTER TABLE "Analisi_dev".h_get_stato_diffide OWNER TO postgres;

--
-- Name: h_get_tipologia_cu_e_sottoattivita; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_get_tipologia_cu_e_sottoattivita (
    rng int8range,
    code integer,
    description character varying
);


ALTER TABLE "Analisi_dev".h_get_tipologia_cu_e_sottoattivita OWNER TO postgres;

--
-- Name: h_gisa_controlli_ufficiali; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_gisa_controlli_ufficiali (
    id_controllo bigint,
    codice_linea text,
    id_motivo bigint,
    id_unita_operativa bigint,
    data_inizio_controllo timestamp without time zone,
    riferimento_id bigint,
    riferimento_nome_tab text,
    eseguiti bigint,
    fonte text,
    rng int8range
);


ALTER TABLE "Analisi_dev".h_gisa_controlli_ufficiali OWNER TO postgres;

--
-- Name: h_oia_nodo; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_oia_nodo (
    rng int8range,
    id integer,
    id_padre integer,
    id_asl integer,
    descrizione_lunga character varying,
    n_livello smallint,
    entered timestamp with time zone,
    entered_by integer,
    modified timestamp with time zone,
    modified_by integer,
    trashed_date timestamp with time zone,
    tipologia_struttura integer,
    comune text,
    enabled boolean,
    obsoleto boolean,
    confermato boolean,
    id_strumento_calcolo integer,
    codice_interno_fk integer,
    nome character varying,
    id_utente integer,
    mail text,
    indirizzo text,
    delegato integer,
    descrizione_comune text,
    id_oia_nodo_temp integer,
    data_scadenza timestamp without time zone,
    disabilitata boolean,
    stato integer,
    anno integer,
    descrizione_area_struttura_complessa text,
    id_lookup_area_struttura_asl integer,
    ui_struttura_foglio_att_iniziale integer,
    ui_struttura_foglio_att_finale integer,
    id_utente_edit integer,
    percentuale_area_a integer,
    stato_all2 integer,
    stato_all6 integer,
    codice_interno_univoco integer,
    descrizione_area_struttura character varying,
    data_congelamento timestamp without time zone
);


ALTER TABLE "Analisi_dev".h_oia_nodo OWNER TO postgres;

--
-- Name: h_oia_nodo_20191227; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".h_oia_nodo_20191227 (
    rng int8range,
    id integer,
    id_padre integer,
    id_asl integer,
    descrizione_lunga character varying,
    n_livello smallint,
    entered timestamp with time zone,
    entered_by integer,
    modified timestamp with time zone,
    modified_by integer,
    trashed_date timestamp with time zone,
    tipologia_struttura integer,
    comune text,
    enabled boolean,
    obsoleto boolean,
    confermato boolean,
    id_strumento_calcolo integer,
    carico_lavoro_annuo integer,
    percentuale_da_sottrarre integer,
    carico_lavoro_effettivo integer,
    fattori_incidenti_su_carico text,
    codice_interno_fk integer,
    nome character varying,
    id_utente integer,
    mail text,
    indirizzo text,
    delegato integer,
    descrizione_comune text,
    id_oia_nodo_temp integer,
    data_scadenza timestamp without time zone,
    disabilitata boolean,
    stato integer,
    anno integer,
    descrizione_area_struttura_complessa text,
    uba_ui integer,
    somma_ui_area integer,
    somma_uba_area integer,
    id_lookup_area_struttura_asl integer,
    ui_struttura_foglio_att_iniziale integer,
    ui_struttura_foglio_att_finale integer,
    id_utente_edit integer,
    percentuale_area_a integer,
    stato_all2 integer,
    stato_all6 integer,
    codice_interno_univoco integer,
    descrizione_area_struttura character varying,
    data_congelamento timestamp without time zone
);


ALTER TABLE "Analisi_dev".h_oia_nodo_20191227 OWNER TO postgres;

--
-- Name: lookup_aggregazione_motivo_audit; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".lookup_aggregazione_motivo_audit (
    aggregazione text,
    motivo text
);


ALTER TABLE "Analisi_dev".lookup_aggregazione_motivo_audit OWNER TO postgres;

--
-- Name: lookup_asl; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".lookup_asl (
    code integer NOT NULL,
    description character varying(300) NOT NULL,
    short_description character varying(300),
    default_item boolean DEFAULT false,
    level integer DEFAULT 0,
    enabled boolean DEFAULT true,
    codiceistat character varying,
    code_canina integer,
    id_provincia integer
);


ALTER TABLE "Analisi_dev".lookup_asl OWNER TO postgres;

--
-- Name: lookup_asl_code_seq; Type: SEQUENCE; Schema: Analisi_dev; Owner: postgres
--

CREATE SEQUENCE "Analisi_dev".lookup_asl_code_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "Analisi_dev".lookup_asl_code_seq OWNER TO postgres;

--
-- Name: lookup_asl_code_seq; Type: SEQUENCE OWNED BY; Schema: Analisi_dev; Owner: postgres
--

ALTER SEQUENCE "Analisi_dev".lookup_asl_code_seq OWNED BY "Analisi_dev".lookup_asl.code;


--
-- Name: lookup_autorita_competenti_motivo; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".lookup_autorita_competenti_motivo (
    descrizione text,
    tipo_controllo text,
    id_piano bigint
);


ALTER TABLE "Analisi_dev".lookup_autorita_competenti_motivo OWNER TO postgres;

--
-- Name: lookup_congruo_supervisione; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".lookup_congruo_supervisione (
    is_supervisionato boolean,
    descrizione text
);


ALTER TABLE "Analisi_dev".lookup_congruo_supervisione OWNER TO postgres;

--
-- Name: lookup_id_asl; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".lookup_id_asl (
    id_asl integer,
    descrizione_breve text
);


ALTER TABLE "Analisi_dev".lookup_id_asl OWNER TO postgres;

--
-- Name: lookup_norme; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".lookup_norme (
    norma text,
    id_norma integer
);


ALTER TABLE "Analisi_dev".lookup_norme OWNER TO postgres;

--
-- Name: lookup_tipo_controllo; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".lookup_tipo_controllo (
    code integer NOT NULL,
    description character varying(50) NOT NULL,
    default_item boolean DEFAULT false,
    level integer DEFAULT 0,
    enabled boolean DEFAULT true
);


ALTER TABLE "Analisi_dev".lookup_tipo_controllo OWNER TO postgres;

--
-- Name: lookup_tipo_controllo_code_seq; Type: SEQUENCE; Schema: Analisi_dev; Owner: postgres
--

CREATE SEQUENCE "Analisi_dev".lookup_tipo_controllo_code_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "Analisi_dev".lookup_tipo_controllo_code_seq OWNER TO postgres;

--
-- Name: lookup_tipo_controllo_code_seq; Type: SEQUENCE OWNED BY; Schema: Analisi_dev; Owner: postgres
--

ALTER SEQUENCE "Analisi_dev".lookup_tipo_controllo_code_seq OWNED BY "Analisi_dev".lookup_tipo_controllo.code;


--
-- Name: lookup_tipologia_motivo; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".lookup_tipologia_motivo (
    id_tipologia bigint,
    id_struttura_piani bigint,
    anno integer
);


ALTER TABLE "Analisi_dev".lookup_tipologia_motivo OWNER TO postgres;

--
-- Name: macroarea; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".macroarea (
    id bigint,
    id_gisa bigint,
    codice text,
    descrizione text,
    parent bigint,
    livello integer,
    path text
);


ALTER TABLE "Analisi_dev".macroarea OWNER TO postgres;

--
-- Name: macroarea_; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".macroarea_ (
    id bigint,
    id_gisa bigint,
    codice text,
    descrizione text,
    parent bigint,
    livello integer,
    path text
);


ALTER TABLE "Analisi_dev".macroarea_ OWNER TO postgres;

--
-- Name: macroarea_20200730; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".macroarea_20200730 (
    id bigint,
    id_gisa bigint,
    codice text,
    descrizione text,
    parent bigint,
    livello integer,
    path text
);


ALTER TABLE "Analisi_dev".macroarea_20200730 OWNER TO postgres;

--
-- Name: mvw_get_sorveglianze; Type: MATERIALIZED VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE MATERIALIZED VIEW "Analisi_dev".mvw_get_sorveglianze AS
 SELECT DISTINCT s.id_controllo,
    'tot'::text AS text,
    tm.id_struttura_piani AS id_motivo,
    u.id_unita_operativa,
    s.data_inizio_controllo,
    s.riferimento_id,
    s.riferimento_nome_tab,
    1 AS eseguiti,
    'sorveglianze'::text AS fonte,
    tm.id_struttura_piani AS id_motivo_originale,
    '-1'::integer AS id_norma
   FROM (("Analisi_dev".h_get_controlli_sorveglianze s
     JOIN "Analisi_dev".lookup_tipologia_motivo tm ON (((tm.id_tipologia = 4) AND (date_part('year'::text, s.data_inizio_controllo) = (tm.anno)::double precision))))
     JOIN "Analisi_dev".h_get_controlli_audit_sorv_percontodi u ON (((u.id_controllo = s.id_controllo) AND (upper_inf(u.rng) IS TRUE))))
  WHERE ((s.data_inizio_controllo >= '2019-01-01 00:00:00'::timestamp without time zone) AND (upper_inf(s.rng) IS TRUE) AND (s.id_stato_controllo = 2))
  WITH NO DATA;


ALTER TABLE "Analisi_dev".mvw_get_sorveglianze OWNER TO postgres;

--
-- Name: mvw_macroarea_ref; Type: MATERIALIZED VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE MATERIALIZED VIEW "Analisi_dev".mvw_macroarea_ref AS
 WITH RECURSIVE m_r(id, id_gisa, codice, descrizione, parent, id_ref) AS (
         SELECT m.id,
            m.id_gisa,
            m.codice,
            m.descrizione,
            m.parent,
            m.id AS id_ref
           FROM "Analisi_dev".macroarea m
        UNION ALL
         SELECT m_r_1.id,
            m_r_1.id_gisa,
            m2.codice,
            m2.descrizione,
            m2.parent,
            m2.parent AS id_ref
           FROM ("Analisi_dev".macroarea m2
             JOIN m_r m_r_1 ON ((m_r_1.id_ref = m2.id)))
        )
 SELECT m_r.id,
    m_r.id_gisa,
    m_r.codice,
    m_r.descrizione,
    m_r.parent,
    m_r.id_ref
   FROM m_r
  WITH NO DATA;


ALTER TABLE "Analisi_dev".mvw_macroarea_ref OWNER TO postgres;

--
-- Name: ocse_235; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".ocse_235 (
    riferimento_id integer,
    riferimento_nome_tab text,
    id_controllo_ufficiale integer,
    id_asl integer,
    asl text,
    norma text,
    osa_controllato text,
    numero_registrazione text,
    codice_macroarea text,
    codice_aggregazione text,
    codice_attivita text,
    identificativo_linea text,
    linea_attivita_sottoposta_a_controllo text,
    tipo_controllo character varying(50),
    tipo_ispezione_o_audit text,
    tipo_piano_monitoraggio text,
    codice_iterno text,
    nucleo_ispettivo_uno text,
    componente_nucleo_ispettivo_uno text,
    componentenucleoid_uno integer,
    punteggio integer,
    totale_punteggio_nc integer,
    totale_punteggio_formali_nc text,
    totale_punteggio_significative_nc text,
    totale_punteggio_gravi_nc text
);


ALTER TABLE "Analisi_dev".ocse_235 OWNER TO postgres;

--
-- Name: ocse_235_anonimo; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".ocse_235_anonimo AS
 SELECT o.id_controllo_ufficiale,
    o.id_asl,
    o.asl,
    o.norma,
    COALESCE(da.azienda_fittizia, 'NON PREVISTO'::text) AS osa_controllato,
    "Analisi_dev".crypt(o.numero_registrazione, 'chiave'::text) AS numero_registrazione,
    o.codice_macroarea,
    o.codice_aggregazione,
    o.codice_attivita,
    "Analisi_dev".crypt(o.identificativo_linea, 'chiave'::text) AS identificativo_linea,
    o.linea_attivita_sottoposta_a_controllo,
    o.tipo_controllo,
    o.tipo_ispezione_o_audit,
    o.tipo_piano_monitoraggio,
    o.codice_iterno AS codice_interno,
    o.punteggio,
    o.totale_punteggio_nc,
    o.totale_punteggio_formali_nc,
    o.totale_punteggio_significative_nc,
    o.totale_punteggio_gravi_nc,
    o.nucleo_ispettivo_uno,
    dn.nome AS componente_nucleo_ispettivo_uno
   FROM (("Analisi_dev".ocse_235 o
     JOIN "Analisi_dev".dizionario_nomi_random dn ON ((dn.id_originale = o.componentenucleoid_uno)))
     JOIN "Analisi_dev".dizionario_aziende_random da ON (((da.riferimento_id = o.riferimento_id) AND (da.riferimento_nome_tab = o.riferimento_nome_tab))))
  ORDER BY o.id_controllo_ufficiale;


ALTER TABLE "Analisi_dev".ocse_235_anonimo OWNER TO postgres;

--
-- Name: ocse_235_distinct; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".ocse_235_distinct AS
 SELECT DISTINCT ocse_235.componente_nucleo_ispettivo_uno,
    ocse_235.componentenucleoid_uno
   FROM "Analisi_dev".ocse_235;


ALTER TABLE "Analisi_dev".ocse_235_distinct OWNER TO postgres;

--
-- Name: ocse_235_new; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".ocse_235_new (
    id_controllo_ufficiale integer,
    id_asl integer,
    asl character varying,
    norma text,
    osa_controllato text,
    numero_registrazione character varying,
    codice_macroarea text,
    codice_aggregazione text,
    codice_attivita text,
    identificativo_linea text,
    linea_attivita_sottoposta_a_controllo text,
    tipo_controllo character varying(50),
    tipo_ispezione_o_audit text,
    tipo_piano_monitoraggio text,
    codice_interno text,
    punteggio integer,
    totale_punteggio_nc integer,
    totale_punteggio_formali text,
    totale_punteggio_gravi text,
    nucleo_ispettivo_uno text,
    componente_nucleo_ispettivo_uno text,
    componentenucleoid_uno integer,
    id_struttura_uo integer,
    riferimento_id integer,
    riferimento_nome_tab text
);


ALTER TABLE "Analisi_dev".ocse_235_new OWNER TO postgres;

--
-- Name: piani_no_rend; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".piani_no_rend (
    id_piano integer,
    anno integer
);


ALTER TABLE "Analisi_dev".piani_no_rend OWNER TO postgres;

--
-- Name: piano_no_rend; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".piano_no_rend (
    id_piano bigint,
    alias text,
    descrizione text
);


ALTER TABLE "Analisi_dev".piano_no_rend OWNER TO postgres;

--
-- Name: piano_no_rend_new; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".piano_no_rend_new (
    cod_raggruppamento bigint
);


ALTER TABLE "Analisi_dev".piano_no_rend_new OWNER TO postgres;

--
-- Name: struttura_asl; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".struttura_asl (
    id bigint,
    id_gisa integer,
    id_padre integer,
    id_asl integer,
    descrizione character varying(500),
    n_livello smallint,
    ups integer,
    uba integer,
    descrizione_breve text
);


ALTER TABLE "Analisi_dev".struttura_asl OWNER TO postgres;

--
-- Name: vw_struttura_asl; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_struttura_asl AS
 WITH RECURSIVE asl_p(id, id_padre, id_asl, descrizione, n_livello, ups, uba, descrizione_breve, path, path_ord) AS (
         SELECT struttura_asl.id,
            struttura_asl.id_padre,
            struttura_asl.id_asl,
            struttura_asl.descrizione,
            struttura_asl.n_livello,
            struttura_asl.ups,
            struttura_asl.uba,
            struttura_asl.descrizione_breve,
            struttura_asl.descrizione_breve AS path,
            struttura_asl.descrizione_breve AS path_ord
           FROM "Analisi_dev".struttura_asl
          WHERE (struttura_asl.id_padre IS NULL)
        UNION ALL
         SELECT f.id,
            f.id_padre,
            f.id_asl,
            f.descrizione,
            f.n_livello,
            f.ups,
            f.uba,
            f.descrizione_breve,
            ((p.path || '/'::text) || f.descrizione_breve),
            ((p.path_ord || '-'::text) || f.descrizione_breve)
           FROM (asl_p p
             JOIN "Analisi_dev".struttura_asl f ON ((p.id = f.id_padre)))
        )
 SELECT asl_p.id,
    asl_p.id_padre,
    asl_p.id_asl,
    asl_p.descrizione,
    asl_p.n_livello,
    asl_p.ups,
    asl_p.uba,
    asl_p.descrizione_breve,
    asl_p.path,
    asl_p.path_ord
   FROM asl_p;


ALTER TABLE "Analisi_dev".vw_struttura_asl OWNER TO postgres;

--
-- Name: struttura_asl_ref; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".struttura_asl_ref AS
 WITH RECURSIVE a_r(id, id_padre, id_asl, descrizione, n_livello, ups, uba, descrizione_breve, id_ref, path, path_ord) AS (
         SELECT a.id,
            a.id_padre,
            a.id_asl,
            a.descrizione,
            a.n_livello,
            a.ups,
            a.uba,
            a.descrizione_breve,
            a.id AS id_ref,
            a.path,
            a.path_ord
           FROM "Analisi_dev".vw_struttura_asl a
        UNION ALL
         SELECT a_r_1.id,
            a2.id_padre,
            a2.id_asl,
            a2.descrizione,
            a2.n_livello,
            a2.ups,
            a2.uba,
            a2.descrizione_breve,
            a.id_padre,
            a.path,
            a.path_ord
           FROM (("Analisi_dev".vw_struttura_asl a
             JOIN a_r a_r_1 ON ((a_r_1.id_ref = a.id)))
             JOIN "Analisi_dev".struttura_asl a2 ON ((a2.id = a.id_padre)))
          WHERE (a.id_padre IS NOT NULL)
        )
 SELECT a_r.id,
    a_r.id_padre,
    a_r.id_asl,
    a_r.descrizione,
    a_r.n_livello,
    a_r.ups,
    a_r.uba,
    a_r.descrizione_breve,
    a_r.id_ref,
    a_r.path,
    a_r.path_ord
   FROM a_r;


ALTER TABLE "Analisi_dev".struttura_asl_ref OWNER TO postgres;

--
-- Name: struttura_piani; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".struttura_piani (
    id bigint DEFAULT nextval('"Analisi_dev".seq_schema'::regclass) NOT NULL,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    parent bigint,
    alias text,
    path_ord text,
    descrizione_breve text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    id_tipo_tecnica bigint
);


ALTER TABLE "Analisi_dev".struttura_piani OWNER TO postgres;

--
-- Name: tipologia_controllo; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".tipologia_controllo (
    id integer,
    descr character varying
);


ALTER TABLE "Analisi_dev".tipologia_controllo OWNER TO postgres;

--
-- Name: tmp_check_columns; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".tmp_check_columns (
    rng int8range,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    riferimento_id_impresa integer,
    riferimento_nome_tab_impresa text,
    ragione_sociale text,
    asl_rif integer,
    asl text,
    codice_fiscale text,
    codice_fiscale_rappresentante text,
    partita_iva text,
    n_reg text,
    nominativo_rappresentante text,
    comune text,
    provincia_stab text,
    indirizzo text,
    cap_stab text,
    comune_leg text,
    provincia_leg text,
    indirizzo_leg text,
    cap_leg text,
    latitudine_stab double precision,
    longitudine_stab double precision,
    categoria_rischio integer,
    prossimo_controllo timestamp without time zone,
    id_controllo_ultima_categorizzazione integer,
    data_controllo_ultima_categorizzazione timestamp without time zone,
    tipo_categorizzazione text,
    data_inserimento timestamp without time zone,
    livello_rischio text
);


ALTER TABLE "Analisi_dev".tmp_check_columns OWNER TO postgres;

--
-- Name: vers_seq; Type: SEQUENCE; Schema: Analisi_dev; Owner: postgres
--

CREATE SEQUENCE "Analisi_dev".vers_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "Analisi_dev".vers_seq OWNER TO postgres;

--
-- Name: versioni; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".versioni (
    id bigint DEFAULT nextval('"Analisi_dev".vers_seq'::regclass) NOT NULL,
    data timestamp without time zone,
    utente text
);


ALTER TABLE "Analisi_dev".versioni OWNER TO postgres;

--
-- Name: vw_comuni1; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_comuni1 AS
 SELECT t.id,
    t.cod_comune,
    t.cod_regione,
    t.cod_provincia,
    t.nome,
    t.istat,
    t.codiceistatasl,
    t.codice,
    t.codice_old,
    t.codiceistatasl_old,
    t.cap,
    t.notused,
    t.cod_nazione,
    t.codiceasl_bdn,
    t.codice_nuovo,
    t.codice_nuovo_,
    t.istat_comune_provincia,
    t.cap_,
    t.istat_pre,
    t.note_hd,
    t.reverse_cap,
    t.codice_catastale,
    t.denominazione_it
   FROM public.dblink('dbname=gisa_fvg port=5432 host=127.0.0.1 user=postgres'::text, 'select * from public.comuni1'::text) t(id integer, cod_comune character varying, cod_regione character varying, cod_provincia character varying, nome character varying, istat character varying, codiceistatasl character varying, codice character varying, codice_old character varying, codiceistatasl_old character varying, cap text, notused boolean, cod_nazione integer, codiceasl_bdn text, codice_nuovo text, codice_nuovo_ text, istat_comune_provincia character varying, cap_ character varying, istat_pre character varying, note_hd text, reverse_cap text, codice_catastale character varying, denominazione_it character varying);


ALTER TABLE "Analisi_dev".vw_comuni1 OWNER TO postgres;

--
-- Name: vw_comuni1_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_comuni1_validi AS
 SELECT h_comuni1.id,
    regexp_replace((h_comuni1.cod_comune)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cod_comune,
    regexp_replace((h_comuni1.cod_regione)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cod_regione,
    regexp_replace((h_comuni1.cod_provincia)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cod_provincia,
    regexp_replace((h_comuni1.nome)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome,
    regexp_replace((h_comuni1.istat)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS istat,
    regexp_replace((h_comuni1.codiceistatasl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codiceistatasl,
    regexp_replace((h_comuni1.codice)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice,
    regexp_replace((h_comuni1.codice_old)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_old,
    regexp_replace((h_comuni1.codiceistatasl_old)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codiceistatasl_old,
    regexp_replace(h_comuni1.cap, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cap,
    h_comuni1.notused,
    h_comuni1.cod_nazione,
    regexp_replace(h_comuni1.codiceasl_bdn, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codiceasl_bdn,
    regexp_replace(h_comuni1.codice_nuovo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_nuovo,
    regexp_replace(h_comuni1.codice_nuovo_, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_nuovo_,
    regexp_replace((h_comuni1.istat_comune_provincia)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS istat_comune_provincia,
    regexp_replace((h_comuni1.cap_)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cap_,
    regexp_replace((h_comuni1.istat_pre)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS istat_pre,
    regexp_replace(h_comuni1.note_hd, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note_hd,
    regexp_replace(h_comuni1.reverse_cap, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS reverse_cap,
    regexp_replace((h_comuni1.codice_catastale)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_catastale,
    regexp_replace((h_comuni1.denominazione_it)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS denominazione_it
   FROM "Analisi_dev".h_comuni1
  WHERE (upper_inf(h_comuni1.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_comuni1_validi OWNER TO postgres;

--
-- Name: vw_gisa_controlli_ufficiali; Type: TABLE; Schema: ra; Owner: postgres
--

CREATE TABLE ra.vw_gisa_controlli_ufficiali (
    id_controllo integer,
    codice_linea text,
    id_motivo bigint,
    id_unita_operativa integer,
    data_inizio_controllo timestamp without time zone,
    riferimento_id bigint,
    riferimento_nome_tab text,
    eseguiti bigint,
    fonte text,
    id_motivo_originale bigint,
    id_norma integer
);


ALTER TABLE ra.vw_gisa_controlli_ufficiali OWNER TO postgres;

--
-- Name: vw_conteggio_cu_grouped; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_conteggio_cu_grouped AS
 SELECT count(vw_gisa_controlli_ufficiali.id_controllo) AS effettuati,
    vw_gisa_controlli_ufficiali.id_motivo AS id_indicatore,
    vw_gisa_controlli_ufficiali.id_unita_operativa AS id_struttura_uo
   FROM ra.vw_gisa_controlli_ufficiali
  GROUP BY vw_gisa_controlli_ufficiali.id_motivo, vw_gisa_controlli_ufficiali.id_unita_operativa;


ALTER TABLE "Analisi_dev".vw_conteggio_cu_grouped OWNER TO postgres;

--
-- Name: vw_conteggio_cu_grouped_no_rend; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_conteggio_cu_grouped_no_rend AS
 SELECT count(vw_gisa_controlli_ufficiali.id_controllo) AS effettuati,
    vw_gisa_controlli_ufficiali.id_motivo AS id_indicatore,
    vw_gisa_controlli_ufficiali.id_unita_operativa AS id_struttura_uo
   FROM ra.vw_gisa_controlli_ufficiali
  WHERE (NOT (vw_gisa_controlli_ufficiali.id_motivo IN ( SELECT pnr.id_piano
           FROM "Analisi_dev".piano_no_rend pnr)))
  GROUP BY vw_gisa_controlli_ufficiali.id_motivo, vw_gisa_controlli_ufficiali.id_unita_operativa;


ALTER TABLE "Analisi_dev".vw_conteggio_cu_grouped_no_rend OWNER TO postgres;

--
-- Name: vw_controlli_gestori_acque_rete_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_controlli_gestori_acque_rete_validi AS
 SELECT h_controlli_gestori_acque_rete.id_controllo,
    h_controlli_gestori_acque_rete.data_inserimento,
    h_controlli_gestori_acque_rete.data_inizio_controllo,
    h_controlli_gestori_acque_rete.data_chiusura_controllo,
    h_controlli_gestori_acque_rete.data_fine_controllo,
    h_controlli_gestori_acque_rete.id_stato_controllo,
    regexp_replace(h_controlli_gestori_acque_rete.stato_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_controllo,
    h_controlli_gestori_acque_rete.id_asl,
    regexp_replace((h_controlli_gestori_acque_rete.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace(h_controlli_gestori_acque_rete.nome_punto_prelievo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_punto_prelievo,
    regexp_replace(h_controlli_gestori_acque_rete.temperatura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS temperatura,
    regexp_replace(h_controlli_gestori_acque_rete.cloro, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cloro,
    regexp_replace(h_controlli_gestori_acque_rete.ore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ore,
    h_controlli_gestori_acque_rete.prot_routine,
    h_controlli_gestori_acque_rete.prot_verifica,
    h_controlli_gestori_acque_rete.prot_replica_micro,
    h_controlli_gestori_acque_rete.prot_replica_chim,
    h_controlli_gestori_acque_rete.prot_radioattivita,
    h_controlli_gestori_acque_rete.prot_ricerca_fitosanitari,
    regexp_replace(h_controlli_gestori_acque_rete.alfa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS alfa,
    regexp_replace(h_controlli_gestori_acque_rete.beta, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS beta,
    regexp_replace(h_controlli_gestori_acque_rete.radon, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS radon,
    regexp_replace(h_controlli_gestori_acque_rete.dose, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS dose,
    regexp_replace(h_controlli_gestori_acque_rete.trizio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS trizio,
    regexp_replace((h_controlli_gestori_acque_rete.tipo_decreto)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_decreto,
    h_controlli_gestori_acque_rete.id_punto_prelievo
   FROM "Analisi_dev".h_controlli_gestori_acque_rete
  WHERE (upper_inf(h_controlli_gestori_acque_rete.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_controlli_gestori_acque_rete_validi OWNER TO postgres;

--
-- Name: vw_dbi_bdu_animali_anagrafati_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_bdu_animali_anagrafati_validi AS
 SELECT h_dbi_bdu_animali_anagrafati.data_inserimento,
    h_dbi_bdu_animali_anagrafati.data_registrazione,
    regexp_replace(h_dbi_bdu_animali_anagrafati.microchip, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS microchip,
    regexp_replace(h_dbi_bdu_animali_anagrafati.tatuaggio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tatuaggio,
    regexp_replace(h_dbi_bdu_animali_anagrafati.inserito_da, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS inserito_da,
    regexp_replace(h_dbi_bdu_animali_anagrafati.ruolo_inserito_da, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ruolo_inserito_da,
    h_dbi_bdu_animali_anagrafati.id_animale,
    h_dbi_bdu_animali_anagrafati.flag_attivita_itinerante,
    regexp_replace(h_dbi_bdu_animali_anagrafati.comune_attivita_itinerante, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_attivita_itinerante,
    regexp_replace(h_dbi_bdu_animali_anagrafati.luogo_attivita_itinerante, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS luogo_attivita_itinerante,
    h_dbi_bdu_animali_anagrafati.data_attivita_itinerante,
    regexp_replace(h_dbi_bdu_animali_anagrafati.commerciale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS commerciale,
    regexp_replace(h_dbi_bdu_animali_anagrafati.stato_originale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_originale,
    regexp_replace(h_dbi_bdu_animali_anagrafati.asl_originale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_originale,
    h_dbi_bdu_animali_anagrafati.id_asl,
    regexp_replace(h_dbi_bdu_animali_anagrafati.specie, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie,
    regexp_replace(h_dbi_bdu_animali_anagrafati.razza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS razza,
    regexp_replace(h_dbi_bdu_animali_anagrafati.veterinario_chippatore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS veterinario_chippatore,
    h_dbi_bdu_animali_anagrafati.data_microchip,
    regexp_replace(h_dbi_bdu_animali_anagrafati.stato_decesso, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_decesso,
    regexp_replace(h_dbi_bdu_animali_anagrafati.proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS proprietario,
    regexp_replace(h_dbi_bdu_animali_anagrafati.comune_proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_proprietario,
    regexp_replace(h_dbi_bdu_animali_anagrafati.tipo_proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_proprietario,
    h_dbi_bdu_animali_anagrafati.tipo_vet,
    h_dbi_bdu_animali_anagrafati.data_nascita,
    h_dbi_bdu_animali_anagrafati.flag_stampata_richiesta_prima_iscrizione,
    regexp_replace(h_dbi_bdu_animali_anagrafati.sesso, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS sesso
   FROM "Analisi_dev".h_dbi_bdu_animali_anagrafati
  WHERE (upper_inf(h_dbi_bdu_animali_anagrafati.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_bdu_animali_anagrafati_validi OWNER TO postgres;

--
-- Name: vw_dbi_bdu_animali_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_bdu_animali_validi AS
 SELECT h_dbi_bdu_animali.data_inserimento,
    h_dbi_bdu_animali.data_registrazione,
    regexp_replace(h_dbi_bdu_animali.microchip, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS microchip,
    regexp_replace(h_dbi_bdu_animali.tatuaggio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tatuaggio,
    regexp_replace(h_dbi_bdu_animali.inserito_da, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS inserito_da,
    regexp_replace(h_dbi_bdu_animali.ruolo_inserito_da, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ruolo_inserito_da,
    h_dbi_bdu_animali.id_animale,
    regexp_replace(h_dbi_bdu_animali.commerciale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS commerciale,
    regexp_replace(h_dbi_bdu_animali.stato_animale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_animale,
    h_dbi_bdu_animali.id_asl_animale,
    regexp_replace(h_dbi_bdu_animali.descrizione_asl_animale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_asl_animale,
    regexp_replace(h_dbi_bdu_animali.specie, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie,
    regexp_replace(h_dbi_bdu_animali.razza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS razza,
    regexp_replace(h_dbi_bdu_animali.taglia, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS taglia,
    h_dbi_bdu_animali.data_nascita,
    regexp_replace(h_dbi_bdu_animali.sesso, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS sesso,
    regexp_replace(h_dbi_bdu_animali.veterinario_chippatore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS veterinario_chippatore,
    h_dbi_bdu_animali.data_microchip,
    regexp_replace(h_dbi_bdu_animali.proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS proprietario,
    regexp_replace(h_dbi_bdu_animali.comune_proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_proprietario,
    regexp_replace(h_dbi_bdu_animali.tipo_proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_proprietario,
    regexp_replace(h_dbi_bdu_animali.stato_decesso, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_decesso,
    h_dbi_bdu_animali.data_decesso,
    regexp_replace(h_dbi_bdu_animali.detentore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS detentore,
    regexp_replace(h_dbi_bdu_animali.tipo_detentore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_detentore,
    h_dbi_bdu_animali.id_asl_detentore,
    regexp_replace(h_dbi_bdu_animali.asl_detentore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_detentore,
    regexp_replace(h_dbi_bdu_animali.comune_cattura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_cattura,
    h_dbi_bdu_animali.flag_sterilizzato,
    h_dbi_bdu_animali.data_sterilizzazione,
    h_dbi_bdu_animali.flag_contributo_sterilizzazione,
    h_dbi_bdu_animali.flag_contributo_canili,
    regexp_replace(h_dbi_bdu_animali.ente_sterilizzazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ente_sterilizzazione,
    regexp_replace(h_dbi_bdu_animali.valore_ente_sterilizzazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS valore_ente_sterilizzazione,
    h_dbi_bdu_animali.flag_sterilizzazione_pregressa,
    h_dbi_bdu_animali.id_asl_sterilizzazione,
    regexp_replace(h_dbi_bdu_animali.asl_evento_sterilizzazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_evento_sterilizzazione,
    h_dbi_bdu_animali.id_proprietario,
    h_dbi_bdu_animali.id_detentore,
    h_dbi_bdu_animali.flag_randagio,
    h_dbi_bdu_animali.flag_sterilizzazione,
    h_dbi_bdu_animali.detentore_corrente_flag_canile
   FROM "Analisi_dev".h_dbi_bdu_animali
  WHERE (upper_inf(h_dbi_bdu_animali.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_bdu_animali_validi OWNER TO postgres;

--
-- Name: vw_dbi_bdu_animali_vivi_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_bdu_animali_vivi_validi AS
 SELECT h_dbi_bdu_animali_vivi.data_inserimento,
    h_dbi_bdu_animali_vivi.data_registrazione,
    regexp_replace(h_dbi_bdu_animali_vivi.microchip, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS microchip,
    regexp_replace(h_dbi_bdu_animali_vivi.tatuaggio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tatuaggio,
    regexp_replace(h_dbi_bdu_animali_vivi.inserito_da, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS inserito_da,
    regexp_replace(h_dbi_bdu_animali_vivi.ruolo_inserito_da, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ruolo_inserito_da,
    h_dbi_bdu_animali_vivi.id_animale,
    regexp_replace(h_dbi_bdu_animali_vivi.specie, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie,
    regexp_replace(h_dbi_bdu_animali_vivi.razza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS razza,
    h_dbi_bdu_animali_vivi.data_nascita,
    regexp_replace(h_dbi_bdu_animali_vivi.sesso, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS sesso,
    regexp_replace(h_dbi_bdu_animali_vivi.stato_animale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_animale,
    regexp_replace(h_dbi_bdu_animali_vivi.cognome_proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cognome_proprietario,
    regexp_replace(h_dbi_bdu_animali_vivi.nome_proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_proprietario,
    regexp_replace(h_dbi_bdu_animali_vivi.codice_fiscale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale,
    regexp_replace(h_dbi_bdu_animali_vivi.indirizzo_proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo_proprietario,
    regexp_replace(h_dbi_bdu_animali_vivi.cap, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cap,
    regexp_replace(h_dbi_bdu_animali_vivi.comune_proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_proprietario,
    h_dbi_bdu_animali_vivi.id_asl,
    regexp_replace(h_dbi_bdu_animali_vivi.asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl
   FROM "Analisi_dev".h_dbi_bdu_animali_vivi
  WHERE (upper_inf(h_dbi_bdu_animali_vivi.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_bdu_animali_vivi_validi OWNER TO postgres;

--
-- Name: vw_dbi_bdu_caricamenti_mc_lp_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_bdu_caricamenti_mc_lp_validi AS
 SELECT DISTINCT h_dbi_bdu_caricamenti_mc_lp.rng,
    h_dbi_bdu_caricamenti_mc_lp.login_utente_caricamento,
    h_dbi_bdu_caricamenti_mc_lp.nominativo_utente_caricamento,
    h_dbi_bdu_caricamenti_mc_lp.microchip,
    h_dbi_bdu_caricamenti_mc_lp.assegnato,
    h_dbi_bdu_caricamenti_mc_lp.abilitato,
    h_dbi_bdu_caricamenti_mc_lp.data_caricamento,
    h_dbi_bdu_caricamenti_mc_lp.data_registrazione,
    h_dbi_bdu_caricamenti_mc_lp.data_inserimento
   FROM "Analisi_dev".h_dbi_bdu_caricamenti_mc_lp
  WHERE (upper_inf(h_dbi_bdu_caricamenti_mc_lp.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_bdu_caricamenti_mc_lp_validi OWNER TO postgres;

--
-- Name: vw_dbi_bdu_caricamenti_mc_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_bdu_caricamenti_mc_validi AS
 SELECT regexp_replace(h_dbi_bdu_caricamenti_mc.microchip, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS microchip,
    regexp_replace(h_dbi_bdu_caricamenti_mc.asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace(h_dbi_bdu_caricamenti_mc.codice_fiscale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale,
    h_dbi_bdu_caricamenti_mc.assegnato,
    h_dbi_bdu_caricamenti_mc.abilitato,
    h_dbi_bdu_caricamenti_mc.data_caricamento,
    h_dbi_bdu_caricamenti_mc.data_registrazione_animale,
    h_dbi_bdu_caricamenti_mc.data_inserimento_animale,
    h_dbi_bdu_caricamenti_mc.anno,
    h_dbi_bdu_caricamenti_mc.tipovet,
    h_dbi_bdu_caricamenti_mc.id_asl,
    regexp_replace(h_dbi_bdu_caricamenti_mc.attribuito_a, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS attribuito_a
   FROM "Analisi_dev".h_dbi_bdu_caricamenti_mc
  WHERE (upper_inf(h_dbi_bdu_caricamenti_mc.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_bdu_caricamenti_mc_validi OWNER TO postgres;

--
-- Name: vw_dbi_bdu_colonie_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_bdu_colonie_validi AS
 SELECT regexp_replace(h_dbi_bdu_colonie.tutore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tutore,
    regexp_replace(h_dbi_bdu_colonie.nr_protocollo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nr_protocollo,
    regexp_replace(h_dbi_bdu_colonie.asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_dbi_bdu_colonie.id_asl,
    h_dbi_bdu_colonie.data_inserimento,
    h_dbi_bdu_colonie.data_registrazione_colonia,
    h_dbi_bdu_colonie.data_censimento_totale,
    regexp_replace(h_dbi_bdu_colonie.comune, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune,
    h_dbi_bdu_colonie.nr_totale_gatti,
    h_dbi_bdu_colonie.totale_presunto,
    regexp_replace(h_dbi_bdu_colonie.microchip, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS microchip,
    h_dbi_bdu_colonie.flag_sterilizzazione,
    h_dbi_bdu_colonie.data_sterilizzazione
   FROM "Analisi_dev".h_dbi_bdu_colonie
  WHERE (upper_inf(h_dbi_bdu_colonie.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_bdu_colonie_validi OWNER TO postgres;

--
-- Name: vw_dbi_bdu_registrazioni_data_evento_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_bdu_registrazioni_data_evento_validi AS
 SELECT h_dbi_bdu_registrazioni_data_evento.id_animale,
    h_dbi_bdu_registrazioni_data_evento.data_furto,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.luogo_furto, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS luogo_furto,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.dati_denuncia_furto, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS dati_denuncia_furto,
    h_dbi_bdu_registrazioni_data_evento.importo_smarrimento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.luogo_smarrimento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS luogo_smarrimento,
    h_dbi_bdu_registrazioni_data_evento.data_smarrimento,
    h_dbi_bdu_registrazioni_data_evento.data_decesso,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.tipo_decesso, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_decesso,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.luogo_decesso, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS luogo_decesso,
    h_dbi_bdu_registrazioni_data_evento.data_ritrovamento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.ritrovamento_non_denunciato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ritrovamento_non_denunciato,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.luogo_ritrovamento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS luogo_ritrovamento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.comune_ritrovamento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_ritrovamento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.nuovo_proprietario_ritrovamento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nuovo_proprietario_ritrovamento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.asl_proprietario_sterilizzazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_proprietario_sterilizzazione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.comune_cattura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_cattura,
    h_dbi_bdu_registrazioni_data_evento.data_sterilizzazione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.sterilizzazione_con_contributo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS sterilizzazione_con_contributo,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.sterilizzazione_progetto_canili, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS sterilizzazione_progetto_canili,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.ente_sterilizzazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ente_sterilizzazione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.veterinario_1_sterilizzazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS veterinario_1_sterilizzazione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.veterinario_2_sterilizzazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS veterinario_2_sterilizzazione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.evento_pregresso, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS evento_pregresso,
    h_dbi_bdu_registrazioni_data_evento.data_cattura,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.verbale_cattura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS verbale_cattura,
    h_dbi_bdu_registrazioni_data_evento.data_rilascio_passaporto,
    h_dbi_bdu_registrazioni_data_evento.data_scadenza_passaporto,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.numero_passaporto, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS numero_passaporto,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.rinnovo_passaporto, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS rinnovo_passaporto,
    h_dbi_bdu_registrazioni_data_evento.data_trasferimento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.nuovo_proprietario_trasferimento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nuovo_proprietario_trasferimento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.vecchio_proprietario_trasferimento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS vecchio_proprietario_trasferimento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.vecchio_detentore_trasferimento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS vecchio_detentore_trasferimento,
    h_dbi_bdu_registrazioni_data_evento.data_trasferimento_fuoriregione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.regione_destinazione_fuoriregione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS regione_destinazione_fuoriregione,
    h_dbi_bdu_registrazioni_data_evento.data_cessione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.vecchio_proprietario_cessione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS vecchio_proprietario_cessione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.asl_vecchio_proprietario_cessione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_vecchio_proprietario_cessione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.asl_nuovo_proprietario_cessione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_nuovo_proprietario_cessione,
    h_dbi_bdu_registrazioni_data_evento.data_adozione_colonia,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.vecchio_proprietario_adozione_colonia, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS vecchio_proprietario_adozione_colonia,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.vecchio_detentore_adozione_colonia, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS vecchio_detentore_adozione_colonia,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.nuovo_proprietario_adozione_colonia, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nuovo_proprietario_adozione_colonia,
    h_dbi_bdu_registrazioni_data_evento.data_adozione_canile,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.vecchio_proprietario_adozione_canile, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS vecchio_proprietario_adozione_canile,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.vecchio_detentore_adozione_canile, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS vecchio_detentore_adozione_canile,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.tipo_adozione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_adozione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.nuovo_proprietario_adozione_canile, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nuovo_proprietario_adozione_canile,
    h_dbi_bdu_registrazioni_data_evento.data_presa_in_carico,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.nuovo_proprietario_presa_in_carico, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nuovo_proprietario_presa_in_carico,
    h_dbi_bdu_registrazioni_data_evento.data_reimmissione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.comune_reimmissione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_reimmissione,
    h_dbi_bdu_registrazioni_data_evento.data_rientro_fuoriregione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.regione_rientro_fuori_regione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS regione_rientro_fuori_regione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.luogo_rientro_fuori_regione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS luogo_rientro_fuori_regione,
    h_dbi_bdu_registrazioni_data_evento.data_prelievo_leishmania,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.veterinario_prelievo_leishmania, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS veterinario_prelievo_leishmania,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.asl_evento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_evento,
    h_dbi_bdu_registrazioni_data_evento.id_asl,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.inserita_da, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS inserita_da,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.ruolo_inserita_da, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ruolo_inserita_da,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.specie, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.microchip, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS microchip,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.tatuaggio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tatuaggio,
    h_dbi_bdu_registrazioni_data_evento.id_tipologia_registrazione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.descrizione_tipologia_registrazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_tipologia_registrazione,
    h_dbi_bdu_registrazioni_data_evento.id_evento,
    h_dbi_bdu_registrazioni_data_evento.data_operazione_sistema,
    h_dbi_bdu_registrazioni_data_evento.data_evento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.proprietario_pre_evento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS proprietario_pre_evento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.detentore_pre_evento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS detentore_pre_evento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.tipologia_proprietario_pre_evento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipologia_proprietario_pre_evento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.tipologia_detentore_pre_evento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipologia_detentore_pre_evento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.nuovo_proprietario_cessione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nuovo_proprietario_cessione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.nuovo_proprietario_presa_cessione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nuovo_proprietario_presa_cessione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.nuovo_proprietario_presa_in_carico_adozione_fa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nuovo_proprietario_presa_in_carico_adozione_fa,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.vecchio_proprietario_trasferimento_fuori_regione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS vecchio_proprietario_trasferimento_fuori_regione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.nuovo_proprietario_trasferimento_fuori_regione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nuovo_proprietario_trasferimento_fuori_regione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.nuovo_proprietario_trasferimento_canile, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nuovo_proprietario_trasferimento_canile,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.vecchio_detentore_trasferimento_canile, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS vecchio_detentore_trasferimento_canile,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.nuovo_proprietario_trasf_sindaco, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nuovo_proprietario_trasf_sindaco,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.vecchio_proprietario_trasferimento_fuori_stato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS vecchio_proprietario_trasferimento_fuori_stato,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.nuovo_proprietario_trasferimento_fuori_stato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nuovo_proprietario_trasferimento_fuori_stato,
    h_dbi_bdu_registrazioni_data_evento.data_allontanamento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.medico_esecutore_allontanamento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS medico_esecutore_allontanamento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.veterinario_allontanamento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS veterinario_allontanamento,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.causale_allontanamento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS causale_allontanamento,
    h_dbi_bdu_registrazioni_data_evento.data_mutilazione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.medico_esecutore_mutilazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS medico_esecutore_mutilazione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.veterinario_mutilazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS veterinario_mutilazione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.intervento_eseguito_mutilazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS intervento_eseguito_mutilazione,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.causale_mutilazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS causale_mutilazione,
    h_dbi_bdu_registrazioni_data_evento.data_adozione_fuori_asl,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.vecchio_detentore_adozione_fuori_asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS vecchio_detentore_adozione_fuori_asl,
    regexp_replace(h_dbi_bdu_registrazioni_data_evento.nuovo_proprietario_adozione_fuori_asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nuovo_proprietario_adozione_fuori_asl
   FROM "Analisi_dev".h_dbi_bdu_registrazioni_data_evento
  WHERE (upper_inf(h_dbi_bdu_registrazioni_data_evento.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_bdu_registrazioni_data_evento_validi OWNER TO postgres;

--
-- Name: vw_dbi_bdu_ritrovamenti_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_bdu_ritrovamenti_validi AS
 SELECT regexp_replace(h_dbi_bdu_ritrovamenti.specie, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie,
    regexp_replace(h_dbi_bdu_ritrovamenti.microchip, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS microchip,
    regexp_replace(h_dbi_bdu_ritrovamenti.tatuaggio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tatuaggio,
    regexp_replace(h_dbi_bdu_ritrovamenti.stato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato,
    regexp_replace(h_dbi_bdu_ritrovamenti.stato_decesso, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_decesso,
    h_dbi_bdu_ritrovamenti.data_ritrovamento,
    h_dbi_bdu_ritrovamenti.data_restituzione,
    regexp_replace(h_dbi_bdu_ritrovamenti.asl_evento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_evento,
    h_dbi_bdu_ritrovamenti.id_asl,
    regexp_replace(h_dbi_bdu_ritrovamenti.inserita_da, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS inserita_da,
    regexp_replace(h_dbi_bdu_ritrovamenti.ruolo_inserita_da, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ruolo_inserita_da,
    regexp_replace(h_dbi_bdu_ritrovamenti.tipo_evento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_evento,
    h_dbi_bdu_ritrovamenti.ritrovato_restituito_a_proprietario,
    h_dbi_bdu_ritrovamenti.ritrovato_affidato_a_canile_restituito_a_proprietario,
    h_dbi_bdu_ritrovamenti.ritrovato_affidato_a_canile,
    h_dbi_bdu_ritrovamenti.id_canile_affidamento,
    regexp_replace(h_dbi_bdu_ritrovamenti.ragione_sociale_canile_affidamento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ragione_sociale_canile_affidamento,
    h_dbi_bdu_ritrovamenti.canile_municipale
   FROM "Analisi_dev".h_dbi_bdu_ritrovamenti
  WHERE (upper_inf(h_dbi_bdu_ritrovamenti.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_bdu_ritrovamenti_validi OWNER TO postgres;

--
-- Name: vw_dbi_bdu_veterinari_liberi_professionisti_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_bdu_veterinari_liberi_professionisti_validi AS
 SELECT regexp_replace((h_dbi_bdu_veterinari_liberi_professionisti.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace((h_dbi_bdu_veterinari_liberi_professionisti.cognome)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cognome,
    regexp_replace((h_dbi_bdu_veterinari_liberi_professionisti.nome)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome,
    regexp_replace(h_dbi_bdu_veterinari_liberi_professionisti.codice_fiscale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale,
    regexp_replace((h_dbi_bdu_veterinari_liberi_professionisti.n_accreditamento)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS n_accreditamento
   FROM "Analisi_dev".h_dbi_bdu_veterinari_liberi_professionisti
  WHERE (upper_inf(h_dbi_bdu_veterinari_liberi_professionisti.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_bdu_veterinari_liberi_professionisti_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_all_imprese_; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_all_imprese_ AS
 SELECT t.riferimento_id_impresa,
    t.riferimento_nome_tab_impresa,
    t.ragione_sociale,
    t.codice_fiscale,
    t.codice_fiscale_rappresentante,
    t.partita_iva,
    t.nominativo_rappresentante,
    t.comune_leg,
    t.provincia_leg,
    t.indirizzo_leg,
    t.cap_leg,
    t.fatturazione_elettronica,
    t.split_payment,
    t.codice_sdi,
    t.id_indirizzo_fatturazione,
    t.comune_fatturazione,
    t.provincia_fatturazione,
    t.indirizzo_fatturazione,
    t.cap_fatturazione
   FROM public.dblink('dbname=gisa_fvg port=5432 host=127.0.0.1 user=postgres'::text, 'select * from digemon.dbi_get_all_imprese_()'::text) t(riferimento_id_impresa integer, riferimento_nome_tab_impresa text, ragione_sociale text, codice_fiscale text, codice_fiscale_rappresentante text, partita_iva text, nominativo_rappresentante text, comune_leg text, provincia_leg text, indirizzo_leg text, cap_leg text, fatturazione_elettronica boolean, split_payment boolean, codice_sdi text, id_indirizzo_fatturazione integer, comune_fatturazione text, provincia_fatturazione text, indirizzo_fatturazione text, cap_fatturazione text);


ALTER TABLE "Analisi_dev".vw_dbi_get_all_imprese_ OWNER TO postgres;

--
-- Name: vw_dbi_get_all_imprese__validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_all_imprese__validi AS
 SELECT h_dbi_get_all_imprese_.riferimento_id_impresa,
    regexp_replace(h_dbi_get_all_imprese_.riferimento_nome_tab_impresa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_nome_tab_impresa,
    regexp_replace(h_dbi_get_all_imprese_.ragione_sociale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ragione_sociale,
    regexp_replace(h_dbi_get_all_imprese_.codice_fiscale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale,
    regexp_replace(h_dbi_get_all_imprese_.codice_fiscale_rappresentante, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale_rappresentante,
    regexp_replace(h_dbi_get_all_imprese_.partita_iva, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS partita_iva,
    regexp_replace(h_dbi_get_all_imprese_.nominativo_rappresentante, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nominativo_rappresentante,
    regexp_replace(h_dbi_get_all_imprese_.comune_leg, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_leg,
    regexp_replace(h_dbi_get_all_imprese_.provincia_leg, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS provincia_leg,
    regexp_replace(h_dbi_get_all_imprese_.indirizzo_leg, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo_leg,
    regexp_replace(h_dbi_get_all_imprese_.cap_leg, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cap_leg,
    h_dbi_get_all_imprese_.fatturazione_elettronica,
    h_dbi_get_all_imprese_.split_payment,
    regexp_replace(h_dbi_get_all_imprese_.codice_sdi, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_sdi,
    h_dbi_get_all_imprese_.id_indirizzo_fatturazione,
    regexp_replace(h_dbi_get_all_imprese_.comune_fatturazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_fatturazione,
    regexp_replace(h_dbi_get_all_imprese_.provincia_fatturazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS provincia_fatturazione,
    regexp_replace(h_dbi_get_all_imprese_.indirizzo_fatturazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo_fatturazione,
    regexp_replace(h_dbi_get_all_imprese_.cap_fatturazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cap_fatturazione
   FROM "Analisi_dev".h_dbi_get_all_imprese_
  WHERE (upper_inf(h_dbi_get_all_imprese_.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_all_imprese__validi OWNER TO postgres;

--
-- Name: vw_dbi_get_all_linee; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_all_linee AS
 SELECT t.id_attivita,
    t.id_linea,
    t.riferimento_id,
    t.riferimento_id_nome_tab,
    t.num_riconoscimento,
    t.n_linea,
    t.data_inizio_attivita,
    t.data_fine_attivita,
    t.macroarea,
    t.aggregazione,
    t.attivita,
    t.path_attivita_completo,
    t.norma,
    t.id_norma,
    t.codice_macroarea,
    t.codice_aggregazione,
    t.codice_attivita,
    t.stato,
    t.id_stato,
    t.miscela,
    t.tipo_attivita_descrizione,
    t.tipo_attivita,
    t.sintesis
   FROM public.dblink('dbname=gisa_fvg port=5432 host=127.0.0.1 user=postgres'::text, 'select * from digemon.dbi_get_all_linee(''1900-01-01'', now()::timestamp without time zone)'::text) t(id_attivita integer, id_linea integer, riferimento_id integer, riferimento_id_nome_tab text, num_riconoscimento character varying, n_linea character varying, data_inizio_attivita timestamp without time zone, data_fine_attivita timestamp without time zone, macroarea text, aggregazione text, attivita text, path_attivita_completo text, norma text, id_norma integer, codice_macroarea text, codice_aggregazione text, codice_attivita text, stato text, id_stato integer, miscela boolean, tipo_attivita_descrizione character varying, tipo_attivita integer, sintesis boolean);


ALTER TABLE "Analisi_dev".vw_dbi_get_all_linee OWNER TO postgres;

--
-- Name: vw_dbi_get_all_linee_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_all_linee_validi AS
 SELECT h_dbi_get_all_linee.id_attivita,
    h_dbi_get_all_linee.id_linea,
    h_dbi_get_all_linee.riferimento_id,
    regexp_replace(h_dbi_get_all_linee.riferimento_id_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_tab,
    regexp_replace((h_dbi_get_all_linee.num_riconoscimento)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS num_riconoscimento,
    regexp_replace((h_dbi_get_all_linee.n_linea)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS n_linea,
    h_dbi_get_all_linee.data_inizio_attivita,
    h_dbi_get_all_linee.data_fine_attivita,
    regexp_replace(h_dbi_get_all_linee.macroarea, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS macroarea,
    regexp_replace(h_dbi_get_all_linee.aggregazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS aggregazione,
    regexp_replace(h_dbi_get_all_linee.attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS attivita,
    regexp_replace(h_dbi_get_all_linee.path_attivita_completo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS path_attivita_completo,
    regexp_replace(h_dbi_get_all_linee.norma, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS norma,
    h_dbi_get_all_linee.id_norma,
    regexp_replace(h_dbi_get_all_linee.codice_macroarea, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_macroarea,
    regexp_replace(h_dbi_get_all_linee.codice_aggregazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_aggregazione,
    regexp_replace(h_dbi_get_all_linee.codice_attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_attivita,
    regexp_replace(h_dbi_get_all_linee.stato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato,
    h_dbi_get_all_linee.id_stato,
    h_dbi_get_all_linee.miscela,
    regexp_replace((h_dbi_get_all_linee.tipo_attivita_descrizione)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_attivita_descrizione,
    h_dbi_get_all_linee.tipo_attivita,
    h_dbi_get_all_linee.sintesis
   FROM "Analisi_dev".h_dbi_get_all_linee
  WHERE (upper_inf(h_dbi_get_all_linee.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_all_linee_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_all_linee_validi_back; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_all_linee_validi_back AS
 SELECT h_dbi_get_all_linee_back.rng,
    h_dbi_get_all_linee_back.id_linea,
    h_dbi_get_all_linee_back.riferimento_id,
    h_dbi_get_all_linee_back.riferimento_id_nome_tab,
    h_dbi_get_all_linee_back.n_linea,
    h_dbi_get_all_linee_back.data_inizio_attivita,
    h_dbi_get_all_linee_back.data_fine_attivita,
    h_dbi_get_all_linee_back.macroarea,
    h_dbi_get_all_linee_back.aggregazione,
    h_dbi_get_all_linee_back.attivita,
    h_dbi_get_all_linee_back.path_attivita_completo,
    h_dbi_get_all_linee_back.norma,
    h_dbi_get_all_linee_back.id_norma,
    h_dbi_get_all_linee_back.codice_macroarea,
    h_dbi_get_all_linee_back.codice_aggregazione,
    h_dbi_get_all_linee_back.codice_attivita,
    h_dbi_get_all_linee_back.stato,
    h_dbi_get_all_linee_back.id_stato,
    h_dbi_get_all_linee_back.miscela,
    h_dbi_get_all_linee_back.tipo_attivita_descrizione,
    h_dbi_get_all_linee_back.tipo_attivita
   FROM "Analisi_dev".h_dbi_get_all_linee_back
  WHERE (upper_inf(h_dbi_get_all_linee_back.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_all_linee_validi_back OWNER TO postgres;

--
-- Name: vw_dbi_get_all_partite_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_all_partite_validi AS
 SELECT regexp_replace((h_dbi_get_all_partite.descrizione_macello)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_macello,
    regexp_replace((h_dbi_get_all_partite.codice_macello)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_macello,
    h_dbi_get_all_partite.id_asl,
    regexp_replace((h_dbi_get_all_partite.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace((h_dbi_get_all_partite.partita)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS partita,
    regexp_replace((h_dbi_get_all_partite.num_seduta)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS num_seduta,
    regexp_replace((h_dbi_get_all_partite.codice_azienda_provenienza)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_azienda_provenienza,
    regexp_replace((h_dbi_get_all_partite.specie)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie,
    h_dbi_get_all_partite.data_macellazione,
    h_dbi_get_all_partite.num_capi_ovini_cinghiali,
    h_dbi_get_all_partite.num_capi_caprini_suini,
    h_dbi_get_all_partite.num_capi_ovini_cinghiali_macellati,
    h_dbi_get_all_partite.num_capi_caprini_suini_macellati,
    regexp_replace(h_dbi_get_all_partite.partita_sottoposta_a_test_tse, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS partita_sottoposta_a_test_tse,
    h_dbi_get_all_partite.num_capi_caprini_da_testare_tse,
    h_dbi_get_all_partite.num_capi_ovini_da_testare_tse
   FROM "Analisi_dev".h_dbi_get_all_partite
  WHERE (upper_inf(h_dbi_get_all_partite.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_all_partite_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_all_stabilimenti_; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_all_stabilimenti_ AS
 SELECT t.riferimento_id,
    t.riferimento_id_nome_tab,
    t.riferimento_id_impresa,
    t.riferimento_nome_tab_impresa,
    t.ragione_sociale,
    t.asl_rif,
    t.asl,
    t.codice_fiscale,
    t.codice_fiscale_rappresentante,
    t.partita_iva,
    t.n_reg,
    t.nominativo_rappresentante,
    t.comune,
    t.provincia_stab,
    t.indirizzo,
    t.cap_stab,
    t.comune_leg,
    t.provincia_leg,
    t.indirizzo_leg,
    t.cap_leg,
    t.latitudine_stab,
    t.longitudine_stab,
    t.categoria_rischio,
    t.prossimo_controllo,
    t.id_controllo_ultima_categorizzazione,
    t.data_controllo_ultima_categorizzazione,
    t.tipo_categorizzazione,
    t.data_inserimento,
    t.livello_rischio,
    t.tipologia,
    t.categoria_rischio_qualitativa,
    t.approval_number,
    t.impresa_id_opu,
    t.stabilimento_id_opu,
    t.impresa_id_organization,
    t.stabilimento_id_organization
   FROM public.dblink('dbname=gisa_fvg port=5432 host=127.0.0.1 user=postgres'::text, 'select * from digemon.dbi_get_all_stabilimenti_(''1900-01-01'', now()::timestamp without time zone)'::text) t(riferimento_id integer, riferimento_id_nome_tab text, riferimento_id_impresa integer, riferimento_nome_tab_impresa text, ragione_sociale text, asl_rif integer, asl text, codice_fiscale text, codice_fiscale_rappresentante text, partita_iva text, n_reg text, nominativo_rappresentante text, comune text, provincia_stab text, indirizzo text, cap_stab text, comune_leg text, provincia_leg text, indirizzo_leg text, cap_leg text, latitudine_stab double precision, longitudine_stab double precision, categoria_rischio integer, prossimo_controllo timestamp without time zone, id_controllo_ultima_categorizzazione integer, data_controllo_ultima_categorizzazione timestamp without time zone, tipo_categorizzazione text, data_inserimento timestamp without time zone, livello_rischio text, tipologia integer, categoria_rischio_qualitativa text, approval_number text, impresa_id_opu integer, stabilimento_id_opu integer, impresa_id_organization integer, stabilimento_id_organization integer);


ALTER TABLE "Analisi_dev".vw_dbi_get_all_stabilimenti_ OWNER TO postgres;

--
-- Name: vw_dbi_get_all_stabilimenti__validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_all_stabilimenti__validi AS
 SELECT h_dbi_get_all_stabilimenti_.riferimento_id,
    regexp_replace(h_dbi_get_all_stabilimenti_.riferimento_id_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_tab,
    h_dbi_get_all_stabilimenti_.riferimento_id_impresa,
    regexp_replace(h_dbi_get_all_stabilimenti_.riferimento_nome_tab_impresa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_nome_tab_impresa,
    regexp_replace(h_dbi_get_all_stabilimenti_.ragione_sociale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ragione_sociale,
    h_dbi_get_all_stabilimenti_.asl_rif,
    regexp_replace(h_dbi_get_all_stabilimenti_.asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace(h_dbi_get_all_stabilimenti_.codice_fiscale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale,
    regexp_replace(h_dbi_get_all_stabilimenti_.codice_fiscale_rappresentante, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale_rappresentante,
    regexp_replace(h_dbi_get_all_stabilimenti_.partita_iva, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS partita_iva,
    regexp_replace(h_dbi_get_all_stabilimenti_.n_reg, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS n_reg,
    regexp_replace(h_dbi_get_all_stabilimenti_.nominativo_rappresentante, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nominativo_rappresentante,
    regexp_replace(h_dbi_get_all_stabilimenti_.comune, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune,
    regexp_replace(h_dbi_get_all_stabilimenti_.provincia_stab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS provincia_stab,
    regexp_replace(h_dbi_get_all_stabilimenti_.indirizzo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo,
    regexp_replace(h_dbi_get_all_stabilimenti_.cap_stab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cap_stab,
    regexp_replace(h_dbi_get_all_stabilimenti_.comune_leg, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_leg,
    regexp_replace(h_dbi_get_all_stabilimenti_.provincia_leg, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS provincia_leg,
    regexp_replace(h_dbi_get_all_stabilimenti_.indirizzo_leg, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo_leg,
    regexp_replace(h_dbi_get_all_stabilimenti_.cap_leg, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cap_leg,
    h_dbi_get_all_stabilimenti_.latitudine_stab,
    h_dbi_get_all_stabilimenti_.longitudine_stab,
    h_dbi_get_all_stabilimenti_.categoria_rischio,
    h_dbi_get_all_stabilimenti_.prossimo_controllo,
    h_dbi_get_all_stabilimenti_.id_controllo_ultima_categorizzazione,
    h_dbi_get_all_stabilimenti_.data_controllo_ultima_categorizzazione,
    regexp_replace(h_dbi_get_all_stabilimenti_.tipo_categorizzazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_categorizzazione,
    h_dbi_get_all_stabilimenti_.data_inserimento,
    regexp_replace(h_dbi_get_all_stabilimenti_.livello_rischio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS livello_rischio,
    h_dbi_get_all_stabilimenti_.tipologia,
    regexp_replace(h_dbi_get_all_stabilimenti_.categoria_rischio_qualitativa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS categoria_rischio_qualitativa,
    regexp_replace(h_dbi_get_all_stabilimenti_.approval_number, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS approval_number,
    h_dbi_get_all_stabilimenti_.impresa_id_opu,
    h_dbi_get_all_stabilimenti_.stabilimento_id_opu,
    h_dbi_get_all_stabilimenti_.impresa_id_organization,
    h_dbi_get_all_stabilimenti_.stabilimento_id_organization
   FROM "Analisi_dev".h_dbi_get_all_stabilimenti_
  WHERE (upper_inf(h_dbi_get_all_stabilimenti_.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_all_stabilimenti__validi OWNER TO postgres;

--
-- Name: vw_dbi_get_all_stabilimenti_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_all_stabilimenti_validi AS
 SELECT regexp_replace(h_dbi_get_all_stabilimenti.id_record_anagrafica, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS id_record_anagrafica,
    h_dbi_get_all_stabilimenti.riferimento_id,
    regexp_replace(h_dbi_get_all_stabilimenti.riferimento_id_nome, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome,
    regexp_replace(h_dbi_get_all_stabilimenti.riferimento_id_nome_col, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_col,
    regexp_replace(h_dbi_get_all_stabilimenti.riferimento_id_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_tab,
    h_dbi_get_all_stabilimenti.data_inserimento,
    regexp_replace((h_dbi_get_all_stabilimenti.ragione_sociale)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ragione_sociale,
    h_dbi_get_all_stabilimenti.asl_rif,
    regexp_replace((h_dbi_get_all_stabilimenti.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace((h_dbi_get_all_stabilimenti.codice_fiscale)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale,
    regexp_replace((h_dbi_get_all_stabilimenti.codice_fiscale_rappresentante)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale_rappresentante,
    regexp_replace((h_dbi_get_all_stabilimenti.partita_iva)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS partita_iva,
    h_dbi_get_all_stabilimenti.categoria_rischio,
    h_dbi_get_all_stabilimenti.prossimo_controllo,
    regexp_replace((h_dbi_get_all_stabilimenti.num_riconoscimento)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS num_riconoscimento,
    regexp_replace((h_dbi_get_all_stabilimenti.n_reg)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS n_reg,
    regexp_replace((h_dbi_get_all_stabilimenti.n_linea)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS n_linea,
    regexp_replace(h_dbi_get_all_stabilimenti.nominativo_rappresentante, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nominativo_rappresentante,
    regexp_replace((h_dbi_get_all_stabilimenti.tipo_attivita_descrizione)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_attivita_descrizione,
    h_dbi_get_all_stabilimenti.tipo_attivita,
    h_dbi_get_all_stabilimenti.data_inizio_attivita,
    h_dbi_get_all_stabilimenti.data_fine_attivita,
    regexp_replace(h_dbi_get_all_stabilimenti.stato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato,
    h_dbi_get_all_stabilimenti.id_stato,
    regexp_replace((h_dbi_get_all_stabilimenti.comune)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune,
    regexp_replace((h_dbi_get_all_stabilimenti.provincia_stab)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS provincia_stab,
    regexp_replace((h_dbi_get_all_stabilimenti.indirizzo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo,
    regexp_replace((h_dbi_get_all_stabilimenti.cap_stab)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cap_stab,
    regexp_replace((h_dbi_get_all_stabilimenti.comune_leg)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_leg,
    regexp_replace((h_dbi_get_all_stabilimenti.provincia_leg)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS provincia_leg,
    regexp_replace((h_dbi_get_all_stabilimenti.indirizzo_leg)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo_leg,
    regexp_replace((h_dbi_get_all_stabilimenti.cap_leg)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cap_leg,
    regexp_replace(h_dbi_get_all_stabilimenti.macroarea, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS macroarea,
    regexp_replace(h_dbi_get_all_stabilimenti.aggregazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS aggregazione,
    regexp_replace(h_dbi_get_all_stabilimenti.attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS attivita,
    regexp_replace(h_dbi_get_all_stabilimenti.path_attivita_completo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS path_attivita_completo,
    regexp_replace(h_dbi_get_all_stabilimenti.gestione_masterlist, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS gestione_masterlist,
    regexp_replace(h_dbi_get_all_stabilimenti.norma, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS norma,
    h_dbi_get_all_stabilimenti.id_norma,
    h_dbi_get_all_stabilimenti.tipologia_operatore,
    regexp_replace((h_dbi_get_all_stabilimenti.targa)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS targa,
    h_dbi_get_all_stabilimenti.id_controllo_ultima_categorizzazione,
    h_dbi_get_all_stabilimenti.id_tipo_ricerca,
    regexp_replace(h_dbi_get_all_stabilimenti.descrizione_tipo_ricerca, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_tipo_ricerca,
    h_dbi_get_all_stabilimenti.latitudine_stab,
    h_dbi_get_all_stabilimenti.longitudine_stab,
    regexp_replace(h_dbi_get_all_stabilimenti.codice_macroarea, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_macroarea,
    regexp_replace(h_dbi_get_all_stabilimenti.codice_aggregazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_aggregazione,
    regexp_replace(h_dbi_get_all_stabilimenti.codice_attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_attivita,
    h_dbi_get_all_stabilimenti.miscela,
    h_dbi_get_all_stabilimenti.data_controllo_ultima_categorizzazione,
    regexp_replace(h_dbi_get_all_stabilimenti.tipo_categorizzazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_categorizzazione
   FROM "Analisi_dev".h_dbi_get_all_stabilimenti
  WHERE (upper_inf(h_dbi_get_all_stabilimenti.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_all_stabilimenti_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_allcapi_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_allcapi_validi AS
 SELECT regexp_replace((h_dbi_get_allcapi.descrizione_macello)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_macello,
    regexp_replace((h_dbi_get_allcapi.codice_macello)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_macello,
    h_dbi_get_allcapi.id_asl,
    regexp_replace((h_dbi_get_allcapi.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace((h_dbi_get_allcapi.matricola)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS matricola,
    regexp_replace((h_dbi_get_allcapi.codice_azienda_provenienza)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_azienda_provenienza,
    regexp_replace((h_dbi_get_allcapi.specie)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie,
    h_dbi_get_allcapi.data_macellazione,
    regexp_replace((h_dbi_get_allcapi.cd_veterinario_1)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cd_veterinario_1,
    regexp_replace((h_dbi_get_allcapi.cd_veterinario_2)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cd_veterinario_2,
    regexp_replace((h_dbi_get_allcapi.cd_veterinario_3)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cd_veterinario_3,
    h_dbi_get_allcapi.cd_data_nascita,
    regexp_replace(h_dbi_get_allcapi.categoria, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS categoria
   FROM "Analisi_dev".h_dbi_get_allcapi
  WHERE (upper_inf(h_dbi_get_allcapi.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_allcapi_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_allegati_b2_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_allegati_b2_validi AS
 SELECT h_dbi_get_allegati_b2.id_controllo,
    h_dbi_get_allegati_b2.data_controllo,
    regexp_replace(h_dbi_get_allegati_b2.motivo_ispezione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS motivo_ispezione,
    regexp_replace(h_dbi_get_allegati_b2.stato_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_controllo,
    h_dbi_get_allegati_b2.id_asl_controllo,
    regexp_replace(h_dbi_get_allegati_b2.asl_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_controllo,
    regexp_replace(h_dbi_get_allegati_b2.file_nome, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS file_nome,
    h_dbi_get_allegati_b2.file_data_inserimento,
    regexp_replace(h_dbi_get_allegati_b2.file_codice, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS file_codice,
    regexp_replace(h_dbi_get_allegati_b2.operatore_tipo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS operatore_tipo,
    regexp_replace(h_dbi_get_allegati_b2.operatore_norma, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS operatore_norma,
    regexp_replace(h_dbi_get_allegati_b2.operatore_ragione_sociale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS operatore_ragione_sociale,
    regexp_replace(h_dbi_get_allegati_b2.presente, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS presente
   FROM "Analisi_dev".h_dbi_get_allegati_b2
  WHERE (upper_inf(h_dbi_get_allegati_b2.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_allegati_b2_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_allerte_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_allerte_validi AS
 SELECT regexp_replace((h_dbi_get_allerte.id_allerta)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS id_allerta,
    regexp_replace(h_dbi_get_allerte.tipo_operazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_operazione,
    h_dbi_get_allerte.id_asl,
    regexp_replace((h_dbi_get_allerte.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_dbi_get_allerte.data_apertura_o_chiusura,
    regexp_replace(h_dbi_get_allerte.stato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato,
    regexp_replace(h_dbi_get_allerte.data_invio_allegatof, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_invio_allegatof,
    h_dbi_get_allerte.data_inserimento_allerta,
    regexp_replace(h_dbi_get_allerte.matrici, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS matrici,
    regexp_replace(h_dbi_get_allerte.azione_non_conforme_per, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS azione_non_conforme_per,
    regexp_replace(h_dbi_get_allerte.descrizione_breve, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_breve,
    regexp_replace(h_dbi_get_allerte.origine, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS origine
   FROM "Analisi_dev".h_dbi_get_allerte
  WHERE (upper_inf(h_dbi_get_allerte.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_allerte_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_analiti_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_analiti_validi AS
 SELECT h_dbi_get_analiti.progressivo,
    regexp_replace((h_dbi_get_analiti.descrizione_analita_livello_uno)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_analita_livello_uno,
    regexp_replace((h_dbi_get_analiti.descrizione_analita_livello_due)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_analita_livello_due,
    regexp_replace((h_dbi_get_analiti.descrizione_analita_livello_tre)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_analita_livello_tre,
    regexp_replace(h_dbi_get_analiti.codice_analita_livello_uno, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_analita_livello_uno,
    regexp_replace(h_dbi_get_analiti.codice_analita_livello_due, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_analita_livello_due,
    regexp_replace(h_dbi_get_analiti.codice_analita_livello_tre, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_analita_livello_tre,
    h_dbi_get_analiti.id_analita_livello_uno,
    h_dbi_get_analiti.id_analita_livello_due,
    h_dbi_get_analiti.id_analita_livello_tre
   FROM "Analisi_dev".h_dbi_get_analiti
  WHERE (upper_inf(h_dbi_get_analiti.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_analiti_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_apicoltura_censimenti_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_apicoltura_censimenti_validi AS
 SELECT regexp_replace(h_dbi_get_apicoltura_censimenti.codice_azienda, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_azienda,
    regexp_replace(h_dbi_get_apicoltura_censimenti.codice_apiario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_apiario,
    h_dbi_get_apicoltura_censimenti.data_censimento,
    h_dbi_get_apicoltura_censimenti.progressivo,
    h_dbi_get_apicoltura_censimenti.numero_sciami,
    h_dbi_get_apicoltura_censimenti.numero_alveari,
    h_dbi_get_apicoltura_censimenti.data_cessazione_apiario
   FROM "Analisi_dev".h_dbi_get_apicoltura_censimenti
  WHERE (upper_inf(h_dbi_get_apicoltura_censimenti.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_apicoltura_censimenti_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_apicoltura_lista_apiari_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_apicoltura_lista_apiari_validi AS
 SELECT h_dbi_get_apicoltura_lista_apiari.id_apicoltore,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.asl_apicoltore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_apicoltore,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.ragione_sociale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ragione_sociale,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.codice_azienda, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_azienda,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.codice_fiscale_impresa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale_impresa,
    h_dbi_get_apicoltura_lista_apiari.id_apiario,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.codice_fiscale_proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale_proprietario,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.nome_proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_proprietario,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.cognome_proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cognome_proprietario,
    h_dbi_get_apicoltura_lista_apiari.flag_laboratorio_annesso,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.tipo_attivita_apicoltura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_attivita_apicoltura,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.comune_sede_legale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_sede_legale,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.via_sede_legale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS via_sede_legale,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.stato_apicoltore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_apicoltore,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.apicoltore_inviato_bdn, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS apicoltore_inviato_bdn,
    h_dbi_get_apicoltura_lista_apiari.apicoltore_data_registrazione_bdn,
    h_dbi_get_apicoltura_lista_apiari.apicoltore_data_registrazione_bdar,
    h_dbi_get_apicoltura_lista_apiari.data_inizio_attivita,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.codice_fiscale_detentore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale_detentore,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.nome_detentore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_detentore,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.cognome_detentore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cognome_detentore,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.asl_apiario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_apiario,
    h_dbi_get_apicoltura_lista_apiari.progressivo,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.ubicazione_comune, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ubicazione_comune,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.ubicazione_via, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ubicazione_via,
    h_dbi_get_apicoltura_lista_apiari.latitudine,
    h_dbi_get_apicoltura_lista_apiari.longitudine,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.specie, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.modalita_allevamento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS modalita_allevamento,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.classificazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS classificazione,
    h_dbi_get_apicoltura_lista_apiari.data_inizio_attivita_apiario,
    h_dbi_get_apicoltura_lista_apiari.num_alveari,
    h_dbi_get_apicoltura_lista_apiari.num_sciami,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.stato_apiario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_apiario,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.apiario_inviato_bdn, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS apiario_inviato_bdn,
    h_dbi_get_apicoltura_lista_apiari.apiario_data_registrazione_bdn,
    h_dbi_get_apicoltura_lista_apiari.data_inserimento_apiario,
    h_dbi_get_apicoltura_lista_apiari.data_cessazione_apiario,
    h_dbi_get_apicoltura_lista_apiari.id_asl,
    h_dbi_get_apicoltura_lista_apiari.id_utente_access_ext_delegato,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.codice_fiscale_delegato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale_delegato,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.utente_insert_impresa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS utente_insert_impresa,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.ruolo_utente_insert_impresa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ruolo_utente_insert_impresa,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.utente_insert_apicoltore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS utente_insert_apicoltore,
    regexp_replace(h_dbi_get_apicoltura_lista_apiari.ruolo_utente_insert_apicoltore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ruolo_utente_insert_apicoltore
   FROM "Analisi_dev".h_dbi_get_apicoltura_lista_apiari
  WHERE (upper_inf(h_dbi_get_apicoltura_lista_apiari.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_apicoltura_lista_apiari_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_campi_aggiuntivi_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_campi_aggiuntivi_validi AS
 SELECT h_dbi_get_campi_aggiuntivi.id_controllo,
    regexp_replace(h_dbi_get_campi_aggiuntivi.tipo_sospetto, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_sospetto,
    regexp_replace(h_dbi_get_campi_aggiuntivi.codice_buffer, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_buffer,
    regexp_replace(h_dbi_get_campi_aggiuntivi.descrizione_breve, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_breve,
    regexp_replace(h_dbi_get_campi_aggiuntivi.stato_buffer, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_buffer,
    h_dbi_get_campi_aggiuntivi.data_stato,
    h_dbi_get_campi_aggiuntivi.data_evento,
    regexp_replace(h_dbi_get_campi_aggiuntivi.comune_coinvolto_buffer, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_coinvolto_buffer
   FROM "Analisi_dev".h_dbi_get_campi_aggiuntivi
  WHERE (upper_inf(h_dbi_get_campi_aggiuntivi.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_campi_aggiuntivi_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_campi_estesi_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_campi_estesi_validi AS
 SELECT h_dbi_get_campi_estesi.org_id,
    regexp_replace((h_dbi_get_campi_estesi.specie_macelli)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie_macelli,
    regexp_replace((h_dbi_get_campi_estesi.codifica_specie_sintesi)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codifica_specie_sintesi,
    h_dbi_get_campi_estesi.data_ricezione_autorizzazione_ingrosso,
    regexp_replace(h_dbi_get_campi_estesi.numero_autorizzazione_ingrosso, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS numero_autorizzazione_ingrosso,
    h_dbi_get_campi_estesi.data_ricezione_autorizzazione_dettaglio,
    regexp_replace(h_dbi_get_campi_estesi.numero_autorizzazione_dettaglio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS numero_autorizzazione_dettaglio,
    regexp_replace((h_dbi_get_campi_estesi.tipo_trasporto)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_trasporto,
    regexp_replace((h_dbi_get_campi_estesi.animale_trasportato)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS animale_trasportato,
    regexp_replace(h_dbi_get_campi_estesi.targa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS targa,
    regexp_replace(h_dbi_get_campi_estesi.descrizione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione,
    regexp_replace((h_dbi_get_campi_estesi.classe)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS classe,
    h_dbi_get_campi_estesi.tipologia_acque,
    h_dbi_get_campi_estesi.codice_classe,
    h_dbi_get_campi_estesi.dataprovvedimento,
    regexp_replace(h_dbi_get_campi_estesi.provvedimento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS provvedimento,
    h_dbi_get_campi_estesi.data_classificazione,
    h_dbi_get_campi_estesi.data_fine_classificazione,
    regexp_replace(h_dbi_get_campi_estesi.tipo_produzione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_produzione,
    regexp_replace(h_dbi_get_campi_estesi.numero_decreto, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS numero_decreto,
    regexp_replace((h_dbi_get_campi_estesi.ente_gestore)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ente_gestore,
    regexp_replace((h_dbi_get_campi_estesi.codice_punto_prelievo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_punto_prelievo,
    regexp_replace((h_dbi_get_campi_estesi.tipologia_punto_prelievo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipologia_punto_prelievo,
    regexp_replace((h_dbi_get_campi_estesi.tipo_struttura)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_struttura,
    regexp_replace((h_dbi_get_campi_estesi.codice_l30)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_l30,
    regexp_replace((h_dbi_get_campi_estesi.razza)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS razza,
    regexp_replace((h_dbi_get_campi_estesi.provvedimento_autorizzazione)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS provvedimento_autorizzazione,
    regexp_replace((h_dbi_get_campi_estesi.scadenza_autorizzazione)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS scadenza_autorizzazione,
    regexp_replace((h_dbi_get_campi_estesi.sede)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS sede
   FROM "Analisi_dev".h_dbi_get_campi_estesi
  WHERE (upper_inf(h_dbi_get_campi_estesi.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_campi_estesi_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_campioni_eseguiti_macelli_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_campioni_eseguiti_macelli_validi AS
 SELECT h_dbi_get_campioni_eseguiti_macelli.id_asl,
    regexp_replace((h_dbi_get_campioni_eseguiti_macelli.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_dbi_get_campioni_eseguiti_macelli.id_capo,
    regexp_replace((h_dbi_get_campioni_eseguiti_macelli.cd_matricola)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cd_matricola,
    h_dbi_get_campioni_eseguiti_macelli.id_macello,
    regexp_replace((h_dbi_get_campioni_eseguiti_macelli.ragione_sociale_macello)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ragione_sociale_macello,
    regexp_replace((h_dbi_get_campioni_eseguiti_macelli.codice_azienda_provenienza)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_azienda_provenienza,
    regexp_replace((h_dbi_get_campioni_eseguiti_macelli.matrice)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS matrice,
    regexp_replace((h_dbi_get_campioni_eseguiti_macelli.tipo_analisi)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_analisi,
    regexp_replace((h_dbi_get_campioni_eseguiti_macelli.esito)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS esito,
    h_dbi_get_campioni_eseguiti_macelli.data_ricezione_esito,
    regexp_replace(h_dbi_get_campioni_eseguiti_macelli.molecole, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS molecole,
    regexp_replace((h_dbi_get_campioni_eseguiti_macelli.motivo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS motivo,
    h_dbi_get_campioni_eseguiti_macelli.data_inserimento,
    h_dbi_get_campioni_eseguiti_macelli.data_macellazione
   FROM "Analisi_dev".h_dbi_get_campioni_eseguiti_macelli
  WHERE (upper_inf(h_dbi_get_campioni_eseguiti_macelli.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_campioni_eseguiti_macelli_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_capi_libero_consumo_sequestro_organi_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_capi_libero_consumo_sequestro_organi_validi AS
 SELECT h_dbi_get_capi_libero_consumo_sequestro_organi.id_macello,
    regexp_replace((h_dbi_get_capi_libero_consumo_sequestro_organi.descrizione_macello)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_macello,
    regexp_replace((h_dbi_get_capi_libero_consumo_sequestro_organi.codice_macello)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_macello,
    h_dbi_get_capi_libero_consumo_sequestro_organi.id_asl,
    regexp_replace((h_dbi_get_capi_libero_consumo_sequestro_organi.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace((h_dbi_get_capi_libero_consumo_sequestro_organi.matricola)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS matricola,
    regexp_replace((h_dbi_get_capi_libero_consumo_sequestro_organi.codice_azienda_provenienza)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_azienda_provenienza,
    regexp_replace((h_dbi_get_capi_libero_consumo_sequestro_organi.specie)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie,
    h_dbi_get_capi_libero_consumo_sequestro_organi.data_macellazione,
    regexp_replace((h_dbi_get_capi_libero_consumo_sequestro_organi.organo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS organo,
    regexp_replace((h_dbi_get_capi_libero_consumo_sequestro_organi.lesione_anatomopatologica)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS lesione_anatomopatologica
   FROM "Analisi_dev".h_dbi_get_capi_libero_consumo_sequestro_organi
  WHERE (upper_inf(h_dbi_get_capi_libero_consumo_sequestro_organi.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_capi_libero_consumo_sequestro_organi_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_controlli_acque_rete_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_controlli_acque_rete_validi AS
 SELECT h_dbi_get_controlli_acque_rete.id_controllo,
    h_dbi_get_controlli_acque_rete.data_inizio_controllo,
    regexp_replace(h_dbi_get_controlli_acque_rete.temperatura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS temperatura,
    regexp_replace(h_dbi_get_controlli_acque_rete.cloro, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cloro,
    regexp_replace(h_dbi_get_controlli_acque_rete.ore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ore,
    h_dbi_get_controlli_acque_rete.prot_routine,
    h_dbi_get_controlli_acque_rete.prot_verifica,
    h_dbi_get_controlli_acque_rete.prot_replica_micro,
    h_dbi_get_controlli_acque_rete.prot_replica_chim,
    h_dbi_get_controlli_acque_rete.prot_radioattivita,
    h_dbi_get_controlli_acque_rete.prot_ricerca_fitosanitari,
    regexp_replace(h_dbi_get_controlli_acque_rete.alfa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS alfa,
    regexp_replace(h_dbi_get_controlli_acque_rete.beta, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS beta,
    regexp_replace(h_dbi_get_controlli_acque_rete.radon, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS radon,
    regexp_replace(h_dbi_get_controlli_acque_rete.dose, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS dose,
    regexp_replace(h_dbi_get_controlli_acque_rete.trizio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS trizio,
    regexp_replace(h_dbi_get_controlli_acque_rete.tipo_decreto, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_decreto,
    regexp_replace(h_dbi_get_controlli_acque_rete.desc_asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS desc_asl,
    h_dbi_get_controlli_acque_rete.id_punto_prelievo,
    regexp_replace(h_dbi_get_controlli_acque_rete.campione_finalita_misura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS campione_finalita_misura,
    regexp_replace(h_dbi_get_controlli_acque_rete.campione_nota_finalita_misura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS campione_nota_finalita_misura,
    regexp_replace(h_dbi_get_controlli_acque_rete.campione_motivo_prelievo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS campione_motivo_prelievo,
    regexp_replace(h_dbi_get_controlli_acque_rete.campione_nota_motivo_prelievo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS campione_nota_motivo_prelievo,
    regexp_replace(h_dbi_get_controlli_acque_rete.fornitura_denominazione_zona, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS fornitura_denominazione_zona,
    regexp_replace(h_dbi_get_controlli_acque_rete.fornitura_denominazione_gestore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS fornitura_denominazione_gestore,
    regexp_replace(h_dbi_get_controlli_acque_rete.punto_tipo_acqua, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS punto_tipo_acqua,
    regexp_replace(h_dbi_get_controlli_acque_rete.punto_note, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS punto_note,
    regexp_replace(h_dbi_get_controlli_acque_rete.campionamento_numero_prelievi, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS campionamento_numero_prelievi,
    regexp_replace(h_dbi_get_controlli_acque_rete.campionamento_chi, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS campionamento_chi,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_alfa_totale_mar, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_alfa_totale_mar,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_alfa_totale_misura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_alfa_totale_misura,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_alfa_totale_incertezza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_alfa_totale_incertezza,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_alfa_totale_data_misura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_alfa_totale_data_misura,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_alfa_totale_laboratorio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_alfa_totale_laboratorio,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_alfa_totale_metodo_prova, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_alfa_totale_metodo_prova,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_beta_totale_mar, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_beta_totale_mar,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_beta_totale_misura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_beta_totale_misura,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_beta_totale_incertezza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_beta_totale_incertezza,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_beta_totale_data_misura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_beta_totale_data_misura,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_beta_totale_laboratorio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_beta_totale_laboratorio,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_beta_totale_metodo_prova, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_beta_totale_metodo_prova,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_beta_residua_mar, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_beta_residua_mar,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_beta_residua_misura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_beta_residua_misura,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_beta_residua_incertezza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_beta_residua_incertezza,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_beta_residua_data_misura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_beta_residua_data_misura,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_beta_residua_laboratorio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_beta_residua_laboratorio,
    regexp_replace(h_dbi_get_controlli_acque_rete.di_beta_residua_metodo_prova, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS di_beta_residua_metodo_prova,
    regexp_replace(h_dbi_get_controlli_acque_rete.radon_concentrazione_mar, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS radon_concentrazione_mar,
    regexp_replace(h_dbi_get_controlli_acque_rete.radon_concentrazione_misura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS radon_concentrazione_misura,
    regexp_replace(h_dbi_get_controlli_acque_rete.radon_concentrazione_incertezza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS radon_concentrazione_incertezza,
    regexp_replace(h_dbi_get_controlli_acque_rete.radon_concentrazione_data_misura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS radon_concentrazione_data_misura,
    regexp_replace(h_dbi_get_controlli_acque_rete.radon_concentrazione_laboratorio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS radon_concentrazione_laboratorio,
    regexp_replace(h_dbi_get_controlli_acque_rete.radon_concentrazione_metodo_prova, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS radon_concentrazione_metodo_prova,
    regexp_replace(h_dbi_get_controlli_acque_rete.trizio_concentrazione_mar, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS trizio_concentrazione_mar,
    regexp_replace(h_dbi_get_controlli_acque_rete.trizio_concentrazione_misura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS trizio_concentrazione_misura,
    regexp_replace(h_dbi_get_controlli_acque_rete.trizio_concentrazione_incertezza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS trizio_concentrazione_incertezza,
    regexp_replace(h_dbi_get_controlli_acque_rete.trizio_concentrazione_data_misura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS trizio_concentrazione_data_misura,
    regexp_replace(h_dbi_get_controlli_acque_rete.trizio_concentrazione_laboratorio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS trizio_concentrazione_laboratorio,
    regexp_replace(h_dbi_get_controlli_acque_rete.trizio_concentrazione_metodo_prova, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS trizio_concentrazione_metodo_prova
   FROM "Analisi_dev".h_dbi_get_controlli_acque_rete
  WHERE (upper_inf(h_dbi_get_controlli_acque_rete.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_controlli_acque_rete_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_controlli_benessere_dati_aggiuntivi_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_controlli_benessere_dati_aggiuntivi_validi AS
 SELECT h_dbi_get_controlli_benessere_dati_aggiuntivi.id_controllo_ufficiale,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.data_controllo,
    regexp_replace(h_dbi_get_controlli_benessere_dati_aggiuntivi.codice_piano, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_piano,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_bovini,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_suini,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_equidi,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_altre_specie,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_bufali,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_pesci_acqua_dolce,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_pesci_ornamentali,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_oche,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_conigli,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_ovaiole,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_broiler,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_vitelli,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_struzzi,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_cani,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_ovicaprini,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_pollame,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_pesci,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_uccelli,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_rettili,
    h_dbi_get_controlli_benessere_dati_aggiuntivi.num_altro
   FROM "Analisi_dev".h_dbi_get_controlli_benessere_dati_aggiuntivi
  WHERE (upper_inf(h_dbi_get_controlli_benessere_dati_aggiuntivi.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_controlli_benessere_dati_aggiuntivi_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_controlli_mvs_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_controlli_mvs_validi AS
 SELECT h_dbi_get_controlli_mvs.idcontrollo,
    regexp_replace((h_dbi_get_controlli_mvs.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_dbi_get_controlli_mvs.data_inserimento_controllo,
    regexp_replace(h_dbi_get_controlli_mvs.controllo_documentale_effettuato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS controllo_documentale_effettuato,
    regexp_replace(h_dbi_get_controlli_mvs.num_capi_macellati, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS num_capi_macellati,
    regexp_replace(h_dbi_get_controlli_mvs.num_capi, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS num_capi,
    regexp_replace(h_dbi_get_controlli_mvs.data_acquisto_1, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_acquisto_1,
    regexp_replace(h_dbi_get_controlli_mvs.allev_origine_1, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS allev_origine_1,
    regexp_replace(h_dbi_get_controlli_mvs.data_acquisto_2, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_acquisto_2,
    regexp_replace(h_dbi_get_controlli_mvs.allev_origine_2, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS allev_origine_2,
    regexp_replace(h_dbi_get_controlli_mvs.data_acquisto_3, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_acquisto_3,
    regexp_replace(h_dbi_get_controlli_mvs.allev_origine_3, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS allev_origine_3
   FROM "Analisi_dev".h_dbi_get_controlli_mvs
  WHERE (upper_inf(h_dbi_get_controlli_mvs.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_controlli_mvs_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_controlli_ufficiali_eseguitinew_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_controlli_ufficiali_eseguitinew_validi AS
 SELECT h_dbi_get_controlli_ufficiali_eseguitinew.rng,
    h_dbi_get_controlli_ufficiali_eseguitinew.id_controllo_ufficiale,
    h_dbi_get_controlli_ufficiali_eseguitinew.riferimento_id,
    h_dbi_get_controlli_ufficiali_eseguitinew.riferimento_id_nome,
    h_dbi_get_controlli_ufficiali_eseguitinew.riferimento_id_nome_col,
    h_dbi_get_controlli_ufficiali_eseguitinew.riferimento_id_nome_tab,
    h_dbi_get_controlli_ufficiali_eseguitinew.id_asl,
    h_dbi_get_controlli_ufficiali_eseguitinew.asl,
    h_dbi_get_controlli_ufficiali_eseguitinew.tipo_controllo,
    h_dbi_get_controlli_ufficiali_eseguitinew.tipo_ispezione_o_audit,
    h_dbi_get_controlli_ufficiali_eseguitinew.tipo_piano_monitoraggio,
    h_dbi_get_controlli_ufficiali_eseguitinew.id_piano,
    h_dbi_get_controlli_ufficiali_eseguitinew.id_attivita,
    h_dbi_get_controlli_ufficiali_eseguitinew.tipo_controllo_bpi,
    h_dbi_get_controlli_ufficiali_eseguitinew.tipo_controllo_haccp,
    h_dbi_get_controlli_ufficiali_eseguitinew.oggetto_del_controllo,
    h_dbi_get_controlli_ufficiali_eseguitinew.punteggio,
    h_dbi_get_controlli_ufficiali_eseguitinew.data_inizio_controllo,
    h_dbi_get_controlli_ufficiali_eseguitinew.anno_controllo,
    h_dbi_get_controlli_ufficiali_eseguitinew.data_chiusura_controllo,
    h_dbi_get_controlli_ufficiali_eseguitinew.aggiornata_cat_controllo,
    h_dbi_get_controlli_ufficiali_eseguitinew.categoria_rischio,
    h_dbi_get_controlli_ufficiali_eseguitinew.prossimo_controllo,
    h_dbi_get_controlli_ufficiali_eseguitinew.tipo_checklist,
    h_dbi_get_controlli_ufficiali_eseguitinew.linea_attivita_sottoposta_a_controllo,
    h_dbi_get_controlli_ufficiali_eseguitinew.unita_operativa,
    h_dbi_get_controlli_ufficiali_eseguitinew.id_struttura_uo,
    h_dbi_get_controlli_ufficiali_eseguitinew.supervisionato_in_data,
    h_dbi_get_controlli_ufficiali_eseguitinew.supervisionato_da,
    h_dbi_get_controlli_ufficiali_eseguitinew.supervisione_note,
    h_dbi_get_controlli_ufficiali_eseguitinew.congruo_supervisione,
    h_dbi_get_controlli_ufficiali_eseguitinew.note,
    h_dbi_get_controlli_ufficiali_eseguitinew.tipo_piano_monitoraggio_old,
    h_dbi_get_controlli_ufficiali_eseguitinew.codice_interno_univoco_uo,
    h_dbi_get_controlli_ufficiali_eseguitinew.codice_interno_piano,
    h_dbi_get_controlli_ufficiali_eseguitinew.area_appartenenza_uo,
    h_dbi_get_controlli_ufficiali_eseguitinew.id_record_anagrafica,
    h_dbi_get_controlli_ufficiali_eseguitinew.codice_macroarea,
    h_dbi_get_controlli_ufficiali_eseguitinew.codice_aggregazione,
    h_dbi_get_controlli_ufficiali_eseguitinew.codice_attivita
   FROM "Analisi_dev".h_dbi_get_controlli_ufficiali_eseguitinew
  WHERE (upper_inf(h_dbi_get_controlli_ufficiali_eseguitinew.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_controlli_ufficiali_eseguitinew_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_controlli_ufficiali_lista_identificativi_animali_val; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_controlli_ufficiali_lista_identificativi_animali_val AS
 SELECT h_dbi_get_controlli_ufficiali_lista_identificativi_animali.idcontrollo,
    regexp_replace((h_dbi_get_controlli_ufficiali_lista_identificativi_animali.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_dbi_get_controlli_ufficiali_lista_identificativi_animali.data_controllo,
    regexp_replace(h_dbi_get_controlli_ufficiali_lista_identificativi_animali.lista_identificativi, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS lista_identificativi
   FROM "Analisi_dev".h_dbi_get_controlli_ufficiali_lista_identificativi_animali
  WHERE (upper_inf(h_dbi_get_controlli_ufficiali_lista_identificativi_animali.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_controlli_ufficiali_lista_identificativi_animali_val OWNER TO postgres;

--
-- Name: vw_dbi_get_dati_acque_di_rete_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_dati_acque_di_rete_validi AS
 SELECT h_dbi_get_dati_acque_di_rete.riferimento_id,
    regexp_replace(h_dbi_get_dati_acque_di_rete.riferimento_id_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_tab,
    regexp_replace(h_dbi_get_dati_acque_di_rete.tipologia, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipologia,
    regexp_replace((h_dbi_get_dati_acque_di_rete.ente_gestore)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ente_gestore,
    regexp_replace(h_dbi_get_dati_acque_di_rete.stato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato
   FROM "Analisi_dev".h_dbi_get_dati_acque_di_rete
  WHERE (upper_inf(h_dbi_get_dati_acque_di_rete.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_dati_acque_di_rete_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_matrici_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_matrici_validi AS
 SELECT h_dbi_get_matrici.progressivo,
    regexp_replace((h_dbi_get_matrici.descrizione_matrice_livello_uno)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_matrice_livello_uno,
    regexp_replace((h_dbi_get_matrici.descrizione_matrice_livello_due)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_matrice_livello_due,
    regexp_replace((h_dbi_get_matrici.descrizione_matrice_livello_tre)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_matrice_livello_tre,
    regexp_replace(h_dbi_get_matrici.codice_matrice_livello_uno, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_matrice_livello_uno,
    regexp_replace(h_dbi_get_matrici.codice_matrice_livello_due, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_matrice_livello_due,
    regexp_replace(h_dbi_get_matrici.codice_matrice_livello_tre, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_matrice_livello_tre,
    h_dbi_get_matrici.id_matrice_livello_uno,
    h_dbi_get_matrici.id_matrice_livello_due,
    h_dbi_get_matrici.id_matrice_livello_tre
   FROM "Analisi_dev".h_dbi_get_matrici
  WHERE (upper_inf(h_dbi_get_matrici.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_matrici_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_non_conformita_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_non_conformita_validi AS
 SELECT h_dbi_get_non_conformita.id_controllo_ufficiale,
    h_dbi_get_non_conformita.id_singola_nc,
    h_dbi_get_non_conformita.id_non_conformita,
    h_dbi_get_non_conformita.riferimento_id,
    regexp_replace(h_dbi_get_non_conformita.riferimento_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_nome_tab,
    regexp_replace(h_dbi_get_non_conformita.riferimento_id_nome_tab_impresa_sazionata, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_tab_impresa_sazionata,
    h_dbi_get_non_conformita.riferimento_id_impresa_sazionata,
    regexp_replace((h_dbi_get_non_conformita.identificativo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS identificativo,
    h_dbi_get_non_conformita.tipologia,
    h_dbi_get_non_conformita.tipo_nc_int,
    regexp_replace(h_dbi_get_non_conformita.tipo_non_conformita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_non_conformita,
    h_dbi_get_non_conformita.punteggio,
    regexp_replace(h_dbi_get_non_conformita.puntiformali, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS puntiformali,
    regexp_replace(h_dbi_get_non_conformita.nc_formali_valutazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nc_formali_valutazione,
    regexp_replace(h_dbi_get_non_conformita.puntisignificativi, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS puntisignificativi,
    regexp_replace(h_dbi_get_non_conformita.nc_significative_valutazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nc_significative_valutazione,
    regexp_replace(h_dbi_get_non_conformita.puntigravi, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS puntigravi,
    h_dbi_get_non_conformita.entered,
    regexp_replace(h_dbi_get_non_conformita.descrizione_non_conformita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_non_conformita,
    h_dbi_get_non_conformita.id_linea,
    regexp_replace(h_dbi_get_non_conformita.provvedimenti_benessere, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS provvedimenti_benessere,
    h_dbi_get_non_conformita.id_operatore_mercato,
    h_dbi_get_non_conformita.num_sanzioni_intraprese,
    h_dbi_get_non_conformita.num_sequestri_intrapresi,
    h_dbi_get_non_conformita.num_reati_intrapresi,
    h_dbi_get_non_conformita.num_diffide_intraprese,
    h_dbi_get_non_conformita.num_followup_per_nc_formali,
    h_dbi_get_non_conformita.num_followup_per_nc_significative,
    h_dbi_get_non_conformita.num_followup_per_nc_gravi,
    regexp_replace(h_dbi_get_non_conformita.oggetto_non_conformita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS oggetto_non_conformita
   FROM "Analisi_dev".h_dbi_get_non_conformita
  WHERE (upper_inf(h_dbi_get_non_conformita.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_non_conformita_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_norme; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_norme AS
 SELECT t.code,
    t.description,
    t.default_item,
    t.level,
    t.enabled,
    t.tipo_iter,
    t.entered,
    t.modified,
    t.flag_vecchia_gestione,
    t.id_tipologia_organization,
    t.codice_norma
   FROM public.dblink('dbname=gisa_fvg port=5432 host=127.0.0.1 user=postgres'::text, 'select * from public_functions.dbi_get_norme()'::text) t(code integer, description text, default_item boolean, level integer, enabled boolean, tipo_iter integer, entered timestamp without time zone, modified timestamp without time zone, flag_vecchia_gestione boolean, id_tipologia_organization integer, codice_norma text);


ALTER TABLE "Analisi_dev".vw_dbi_get_norme OWNER TO postgres;

--
-- Name: vw_dbi_get_norme_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_norme_validi AS
 SELECT h_dbi_get_norme.code,
    regexp_replace(h_dbi_get_norme.description, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS description,
    h_dbi_get_norme.default_item,
    h_dbi_get_norme.level,
    h_dbi_get_norme.enabled,
    h_dbi_get_norme.tipo_iter,
    h_dbi_get_norme.entered,
    h_dbi_get_norme.modified,
    h_dbi_get_norme.flag_vecchia_gestione,
    h_dbi_get_norme.id_tipologia_organization,
    regexp_replace(h_dbi_get_norme.codice_norma, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_norma
   FROM "Analisi_dev".h_dbi_get_norme
  WHERE (upper_inf(h_dbi_get_norme.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_norme_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_operatori_mercato_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_operatori_mercato_validi AS
 SELECT h_dbi_get_operatori_mercato.riferimento_id_operatore,
    regexp_replace(h_dbi_get_operatori_mercato.riferimento_id_nome_tab_operatore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_tab_operatore,
    regexp_replace((h_dbi_get_operatori_mercato.ragione_sociale_operatore_mercato)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ragione_sociale_operatore_mercato,
    h_dbi_get_operatori_mercato.num_box,
    regexp_replace(h_dbi_get_operatori_mercato.identificativo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS identificativo,
    h_dbi_get_operatori_mercato.data_cessazone,
    h_dbi_get_operatori_mercato.id_linea_mercato,
    regexp_replace(h_dbi_get_operatori_mercato.riferimento_id_linea_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_linea_nome_tab
   FROM "Analisi_dev".h_dbi_get_operatori_mercato
  WHERE (upper_inf(h_dbi_get_operatori_mercato.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_operatori_mercato_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_partite_libero_consumo_sequestro_organi_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_partite_libero_consumo_sequestro_organi_validi AS
 SELECT regexp_replace((h_dbi_get_partite_libero_consumo_sequestro_organi.descrizione_macello)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_macello,
    regexp_replace((h_dbi_get_partite_libero_consumo_sequestro_organi.codice_macello)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_macello,
    h_dbi_get_partite_libero_consumo_sequestro_organi.id_asl,
    regexp_replace((h_dbi_get_partite_libero_consumo_sequestro_organi.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace((h_dbi_get_partite_libero_consumo_sequestro_organi.partita)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS partita,
    regexp_replace((h_dbi_get_partite_libero_consumo_sequestro_organi.num_seduta)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS num_seduta,
    regexp_replace((h_dbi_get_partite_libero_consumo_sequestro_organi.codice_azienda_provenienza)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_azienda_provenienza,
    regexp_replace((h_dbi_get_partite_libero_consumo_sequestro_organi.specie)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie,
    h_dbi_get_partite_libero_consumo_sequestro_organi.data_macellazione,
    h_dbi_get_partite_libero_consumo_sequestro_organi.num_capi_ovini,
    h_dbi_get_partite_libero_consumo_sequestro_organi.num_capi_caprini,
    h_dbi_get_partite_libero_consumo_sequestro_organi.numero_capi_ovini_libero_consumo_sequestro_organi,
    h_dbi_get_partite_libero_consumo_sequestro_organi.numero_capi_caprini_libero_consumo_sequestro_organi,
    regexp_replace((h_dbi_get_partite_libero_consumo_sequestro_organi.organo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS organo,
    regexp_replace((h_dbi_get_partite_libero_consumo_sequestro_organi.lesione_anatomopatologica)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS lesione_anatomopatologica
   FROM "Analisi_dev".h_dbi_get_partite_libero_consumo_sequestro_organi
  WHERE (upper_inf(h_dbi_get_partite_libero_consumo_sequestro_organi.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_partite_libero_consumo_sequestro_organi_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_punti_prelievo_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_punti_prelievo_validi AS
 SELECT h_dbi_get_punti_prelievo.id,
    regexp_replace(h_dbi_get_punti_prelievo.denominazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS denominazione,
    h_dbi_get_punti_prelievo.id_asl,
    h_dbi_get_punti_prelievo.code_tipologia,
    regexp_replace(h_dbi_get_punti_prelievo.codice, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice,
    h_dbi_get_punti_prelievo.id_gestore,
    h_dbi_get_punti_prelievo.data_inserimento,
    regexp_replace(h_dbi_get_punti_prelievo.stato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato,
    regexp_replace(h_dbi_get_punti_prelievo.codice_gisa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_gisa,
    regexp_replace(h_dbi_get_punti_prelievo.nome_gestore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_gestore,
    regexp_replace(h_dbi_get_punti_prelievo.indirizzo_via, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo_via,
    h_dbi_get_punti_prelievo.latitudine,
    h_dbi_get_punti_prelievo.longitudine,
    regexp_replace(h_dbi_get_punti_prelievo.descrizione_tipologia, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_tipologia,
    h_dbi_get_punti_prelievo.id_comune,
    regexp_replace(h_dbi_get_punti_prelievo.descrizione_comune, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_comune,
    regexp_replace(h_dbi_get_punti_prelievo.descrizione_asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_asl
   FROM "Analisi_dev".h_dbi_get_punti_prelievo
  WHERE (upper_inf(h_dbi_get_punti_prelievo.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_punti_prelievo_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_registro_trasgressori_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_registro_trasgressori_validi AS
 SELECT regexp_replace(h_dbi_get_registro_trasgressori."n. prog", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "n. prog",
    regexp_replace(h_dbi_get_registro_trasgressori."Id controllo", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Id controllo",
    regexp_replace(h_dbi_get_registro_trasgressori."ASL di competenza", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "ASL di competenza",
    regexp_replace(h_dbi_get_registro_trasgressori."Ente accertatore 1", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Ente accertatore 1",
    regexp_replace(h_dbi_get_registro_trasgressori."Ente accertatore 2", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Ente accertatore 2",
    regexp_replace(h_dbi_get_registro_trasgressori."Ente accertatore 3", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Ente accertatore 3",
    regexp_replace(h_dbi_get_registro_trasgressori."PV n.", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "PV n.",
    regexp_replace(h_dbi_get_registro_trasgressori."Num. sequestro eventualmente effettuato", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Num. sequestro eventualmente effettuato",
    regexp_replace(h_dbi_get_registro_trasgressori."Data accertamento", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Data accertamento",
    regexp_replace(h_dbi_get_registro_trasgressori."Data prot. in entrata in regione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Data prot. in entrata in regione",
    regexp_replace(h_dbi_get_registro_trasgressori.trasgressore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS trasgressore,
    regexp_replace(h_dbi_get_registro_trasgressori."Obbligato in solido", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Obbligato in solido",
    regexp_replace(h_dbi_get_registro_trasgressori."Importo sanzione ridotta", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Importo sanzione ridotta",
    regexp_replace(h_dbi_get_registro_trasgressori."Importo sanzione ridotta del 30%", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Importo sanzione ridotta del 30%",
    regexp_replace(h_dbi_get_registro_trasgressori."Illecito di competenza della U.O.D. 01", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Illecito di competenza della U.O.D. 01",
    regexp_replace(h_dbi_get_registro_trasgressori."Data ultima notifica", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Data ultima notifica",
    regexp_replace(h_dbi_get_registro_trasgressori."PV oblato in misura ridotta", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "PV oblato in misura ridotta",
    regexp_replace(h_dbi_get_registro_trasgressori."Importo effettivamente introitato (1)", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Importo effettivamente introitato (1)",
    regexp_replace(h_dbi_get_registro_trasgressori."Data pagamento", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Data pagamento",
    regexp_replace(h_dbi_get_registro_trasgressori."Funzionario assegnatario", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Funzionario assegnatario",
    regexp_replace(h_dbi_get_registro_trasgressori."Presentati scritti difensivi", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Presentati scritti difensivi",
    regexp_replace(h_dbi_get_registro_trasgressori."Presentata richiesta riduzione sanzione e/o rateizzazione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Presentata richiesta riduzione sanzione e/o rateizzazione",
    regexp_replace(h_dbi_get_registro_trasgressori."Presentata richiesta audizione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Presentata richiesta audizione",
    regexp_replace(h_dbi_get_registro_trasgressori."Ordinanza emessa", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Ordinanza emessa",
    regexp_replace(h_dbi_get_registro_trasgressori."Num. Ordinanza", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Num. Ordinanza",
    regexp_replace(h_dbi_get_registro_trasgressori."Data di emissione dell'Ordinanza", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Data di emissione dell'Ordinanza",
    regexp_replace(h_dbi_get_registro_trasgressori."Giorni di lavorazione pratica", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Giorni di lavorazione pratica",
    regexp_replace(h_dbi_get_registro_trasgressori."Importo sanzione ingiunta", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Importo sanzione ingiunta",
    regexp_replace(h_dbi_get_registro_trasgressori."Data Ultima Notifica Ordinanza", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Data Ultima Notifica Ordinanza",
    regexp_replace(h_dbi_get_registro_trasgressori."Data Pagamento Ordinanza", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Data Pagamento Ordinanza",
    regexp_replace(h_dbi_get_registro_trasgressori."Pagamento Ordinanza Effettuato nei Termini", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Pagamento Ordinanza Effettuato nei Termini",
    regexp_replace(h_dbi_get_registro_trasgressori."Concessa rateizzazione dell'ordinanza-ingiunzione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Concessa rateizzazione dell'ordinanza-ingiunzione",
    regexp_replace(h_dbi_get_registro_trasgressori."Rate pagate", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Rate pagate",
    regexp_replace(h_dbi_get_registro_trasgressori."Ordinanza ingiunzione oblata", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Ordinanza ingiunzione oblata",
    regexp_replace(h_dbi_get_registro_trasgressori."Importo effettivamente introitato (2)", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Importo effettivamente introitato (2)",
    regexp_replace(h_dbi_get_registro_trasgressori."Presentata opposizione all'ordinanza-ingiunzione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Presentata opposizione all'ordinanza-ingiunzione",
    regexp_replace(h_dbi_get_registro_trasgressori."Sentenza favorevole al ricorrente", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Sentenza favorevole al ricorrente",
    regexp_replace(h_dbi_get_registro_trasgressori."Importo stabilito dalla A.G.", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Importo stabilito dalla A.G.",
    regexp_replace(h_dbi_get_registro_trasgressori."Ordinanza-ingiunzione oblata secondo sentenza", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Ordinanza-ingiunzione oblata secondo sentenza",
    regexp_replace(h_dbi_get_registro_trasgressori."Importo effettivamente introitato (3)", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Importo effettivamente introitato (3)",
    regexp_replace(h_dbi_get_registro_trasgressori."Avviata per esecuzione forzata", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Avviata per esecuzione forzata",
    regexp_replace(h_dbi_get_registro_trasgressori."Importo effettivamente introitato (4)", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Importo effettivamente introitato (4)",
    regexp_replace(h_dbi_get_registro_trasgressori."Note Gruppo 1", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Note Gruppo 1",
    regexp_replace(h_dbi_get_registro_trasgressori."Note Gruppo 2", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Note Gruppo 2",
    regexp_replace(h_dbi_get_registro_trasgressori."Pratica chiusa", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Pratica chiusa"
   FROM "Analisi_dev".h_dbi_get_registro_trasgressori
  WHERE (upper_inf(h_dbi_get_registro_trasgressori.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_registro_trasgressori_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_report_b11_allevamenti_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_report_b11_allevamenti_validi AS
 SELECT DISTINCT h_dbi_get_report_b11_allevamenti.rng,
    h_dbi_get_report_b11_allevamenti.id_bdn,
    h_dbi_get_report_b11_allevamenti.id_bdn_b11,
    h_dbi_get_report_b11_allevamenti.id_controllo,
    h_dbi_get_report_b11_allevamenti.id_fiscale_allevamento,
    h_dbi_get_report_b11_allevamenti.occodice,
    h_dbi_get_report_b11_allevamenti.stato,
    h_dbi_get_report_b11_allevamenti.id_fiscale_detentore,
    h_dbi_get_report_b11_allevamenti.tipo_produzione,
    h_dbi_get_report_b11_allevamenti.codice_orientamento,
    h_dbi_get_report_b11_allevamenti.data_estrazione,
    h_dbi_get_report_b11_allevamenti.data_import,
    h_dbi_get_report_b11_allevamenti.esito_import,
    h_dbi_get_report_b11_allevamenti.descrizione_errore,
    h_dbi_get_report_b11_allevamenti.data_estrazione_b11,
    h_dbi_get_report_b11_allevamenti.data_import_b11,
    h_dbi_get_report_b11_allevamenti.esito_import_b11,
    h_dbi_get_report_b11_allevamenti.descrizione_errore_b11,
    h_dbi_get_report_b11_allevamenti.operazione,
    h_dbi_get_report_b11_allevamenti.esito_controllo,
    h_dbi_get_report_b11_allevamenti.specie_allev,
    h_dbi_get_report_b11_allevamenti.specie_allevamento,
    h_dbi_get_report_b11_allevamenti.tipo_allevamento_codice,
    h_dbi_get_report_b11_allevamenti.flag_preavviso,
    h_dbi_get_report_b11_allevamenti.data_preavviso,
    h_dbi_get_report_b11_allevamenti.flag_copia_checklist,
    h_dbi_get_report_b11_allevamenti.flag_esito_sa,
    h_dbi_get_report_b11_allevamenti.id_alleg,
    h_dbi_get_report_b11_allevamenti.pianomonitoraggio
   FROM "Analisi_dev".h_dbi_get_report_b11_allevamenti
  WHERE (upper_inf(h_dbi_get_report_b11_allevamenti.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_report_b11_allevamenti_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_report_ba_allevamenti_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_report_ba_allevamenti_validi AS
 SELECT DISTINCT h_dbi_get_report_ba_allevamenti.rng,
    h_dbi_get_report_ba_allevamenti.punteggio,
    h_dbi_get_report_ba_allevamenti.id_alleg,
    h_dbi_get_report_ba_allevamenti.nome_lista_riscontro,
    h_dbi_get_report_ba_allevamenti.id_controllo,
    h_dbi_get_report_ba_allevamenti.flag_cee,
    h_dbi_get_report_ba_allevamenti.stato,
    h_dbi_get_report_ba_allevamenti.flag_extra_piano,
    h_dbi_get_report_ba_allevamenti.id_fiscale_detentore,
    h_dbi_get_report_ba_allevamenti.tipo_produzione,
    h_dbi_get_report_ba_allevamenti.codice_orientamento,
    h_dbi_get_report_ba_allevamenti.num_capannoni_suini,
    h_dbi_get_report_ba_allevamenti.num_capannoni_attivi_suini,
    h_dbi_get_report_ba_allevamenti.num_box_suini,
    h_dbi_get_report_ba_allevamenti.num_box_attivi_suini,
    h_dbi_get_report_ba_allevamenti.num_vitelli_max,
    h_dbi_get_report_ba_allevamenti.num_vitelli_presenti,
    h_dbi_get_report_ba_allevamenti.data_estrazione,
    h_dbi_get_report_ba_allevamenti.data_import,
    h_dbi_get_report_ba_allevamenti.esito_import,
    h_dbi_get_report_ba_allevamenti.descrizione_errore,
    h_dbi_get_report_ba_allevamenti.operazione,
    h_dbi_get_report_ba_allevamenti.esito_controllo,
    h_dbi_get_report_ba_allevamenti.specie_allev,
    h_dbi_get_report_ba_allevamenti.tipo_allegato,
    h_dbi_get_report_ba_allevamenti.flag_vitelli,
    h_dbi_get_report_ba_allevamenti.tipo_allevamento_codice,
    h_dbi_get_report_ba_allevamenti.flag_preavviso,
    h_dbi_get_report_ba_allevamenti.data_preavviso,
    h_dbi_get_report_ba_allevamenti.pianomonitoraggio
   FROM "Analisi_dev".h_dbi_get_report_ba_allevamenti
  WHERE (upper_inf(h_dbi_get_report_ba_allevamenti.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_report_ba_allevamenti_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_report_ba_sa_allevamenti_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_report_ba_sa_allevamenti_validi AS
 SELECT h_dbi_get_report_ba_sa_allevamenti.id_bdn,
    regexp_replace((h_dbi_get_report_ba_sa_allevamenti.ragione_sociale)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ragione_sociale,
    h_dbi_get_report_ba_sa_allevamenti.riferimento_id,
    regexp_replace(h_dbi_get_report_ba_sa_allevamenti.riferimento_id_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_tab,
    h_dbi_get_report_ba_sa_allevamenti.id_controllo,
    h_dbi_get_report_ba_sa_allevamenti.data_controllo,
    regexp_replace(h_dbi_get_report_ba_sa_allevamenti.stato_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_controllo,
    regexp_replace(h_dbi_get_report_ba_sa_allevamenti.codice_asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_asl,
    regexp_replace((h_dbi_get_report_ba_sa_allevamenti.codice_azienda)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_azienda,
    regexp_replace(h_dbi_get_report_ba_sa_allevamenti.id_fiscale_proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS id_fiscale_proprietario,
    regexp_replace(h_dbi_get_report_ba_sa_allevamenti.id_fiscale_detentore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS id_fiscale_detentore,
    regexp_replace(h_dbi_get_report_ba_sa_allevamenti.specie_allevata, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie_allevata,
    h_dbi_get_report_ba_sa_allevamenti.id_alleg,
    regexp_replace((h_dbi_get_report_ba_sa_allevamenti.nome_checklist)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_checklist,
    h_dbi_get_report_ba_sa_allevamenti.data_invio,
    regexp_replace(h_dbi_get_report_ba_sa_allevamenti.esito_import_bdn, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS esito_import_bdn,
    regexp_replace(h_dbi_get_report_ba_sa_allevamenti.descrizione_errore_bdn, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_errore_bdn,
    regexp_replace(h_dbi_get_report_ba_sa_allevamenti.flag_preavviso, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS flag_preavviso,
    regexp_replace(h_dbi_get_report_ba_sa_allevamenti.data_preavviso, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_preavviso,
    regexp_replace(h_dbi_get_report_ba_sa_allevamenti.flag_rilascio_copia_checklist, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS flag_rilascio_copia_checklist,
    h_dbi_get_report_ba_sa_allevamenti.id_chk_bns_mod_ist,
    regexp_replace(h_dbi_get_report_ba_sa_allevamenti.stato_checklist, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_checklist,
    regexp_replace(h_dbi_get_report_ba_sa_allevamenti.alias_indicatore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS alias_indicatore,
    regexp_replace(h_dbi_get_report_ba_sa_allevamenti.descrizione_indicatore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_indicatore
   FROM "Analisi_dev".h_dbi_get_report_ba_sa_allevamenti
  WHERE (upper_inf(h_dbi_get_report_ba_sa_allevamenti.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_report_ba_sa_allevamenti_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_sanzioni_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_sanzioni_validi AS
 SELECT h_dbi_get_sanzioni.idcontrollo,
    h_dbi_get_sanzioni.idsanzione,
    h_dbi_get_sanzioni.id_nonconformita,
    regexp_replace(h_dbi_get_sanzioni.trasgressore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS trasgressore,
    regexp_replace(h_dbi_get_sanzioni.obbligato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS obbligato
   FROM "Analisi_dev".h_dbi_get_sanzioni
  WHERE (upper_inf(h_dbi_get_sanzioni.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_sanzioni_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_stabilimenti_sintesis_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_stabilimenti_sintesis_validi AS
 SELECT h_dbi_get_stabilimenti_sintesis.riferimento_id,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.tipo_impresa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_impresa,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.tipo_societa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_societa,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.ragione_sociale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ragione_sociale,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.partita_iva, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS partita_iva,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.codice_fiscale_impresa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale_impresa,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.cf_rapp_sede_legale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cf_rapp_sede_legale,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.nome_rapp_sede_legale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_rapp_sede_legale,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.cognome_rapp_sede_legale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cognome_rapp_sede_legale,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.indirizzo_sede_legale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo_sede_legale,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.comune_sede_legale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_sede_legale,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.cap_sede_legale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cap_sede_legale,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.prov_sede_legale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS prov_sede_legale,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.comune_stab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_stab,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.indirizzo_stab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo_stab,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.cap_stab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cap_stab,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.prov_stab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS prov_stab,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.stab_descrizione_carattere, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stab_descrizione_carattere,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.stab_descrizione_attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stab_descrizione_attivita,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.stab_asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stab_asl,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.lat_stab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS lat_stab,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.long_stab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS long_stab,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.approval_number, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS approval_number,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.norma, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS norma,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.codice_norma, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_norma,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.macroarea, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS macroarea,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.codice_macroarea, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_macroarea,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.aggregazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS aggregazione,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.codice_aggregazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_aggregazione,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS attivita,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.codice_attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_attivita,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.stato_linea, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_linea,
    h_dbi_get_stabilimenti_sintesis.data_inizio_attivita,
    h_dbi_get_stabilimenti_sintesis.data_fine_attivita,
    h_dbi_get_stabilimenti_sintesis.categoria_rischio,
    h_dbi_get_stabilimenti_sintesis.data_prossimo_controllo,
    h_dbi_get_stabilimenti_sintesis.id_controllo_ultima_categorizzazione,
    h_dbi_get_stabilimenti_sintesis.data_controllo_ultima_categorizzazione,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.tipo_categorizzazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_categorizzazione,
    regexp_replace(h_dbi_get_stabilimenti_sintesis.livello_rischio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS livello_rischio
   FROM "Analisi_dev".h_dbi_get_stabilimenti_sintesis
  WHERE (upper_inf(h_dbi_get_stabilimenti_sintesis.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_stabilimenti_sintesis_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_tamponi_macelli_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_tamponi_macelli_validi AS
 SELECT h_dbi_get_tamponi_macelli.id_asl,
    regexp_replace(h_dbi_get_tamponi_macelli.descr_asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descr_asl,
    regexp_replace((h_dbi_get_tamponi_macelli.nome_macello)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_macello,
    regexp_replace((h_dbi_get_tamponi_macelli.matricola_capo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS matricola_capo,
    regexp_replace(h_dbi_get_tamponi_macelli.matrice, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS matrice,
    regexp_replace((h_dbi_get_tamponi_macelli.piano)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS piano,
    regexp_replace(h_dbi_get_tamponi_macelli.distruttivo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS distruttivo,
    h_dbi_get_tamponi_macelli.data_macellazione
   FROM "Analisi_dev".h_dbi_get_tamponi_macelli
  WHERE (upper_inf(h_dbi_get_tamponi_macelli.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_tamponi_macelli_validi OWNER TO postgres;

--
-- Name: vw_dbi_get_targhe_matricole_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dbi_get_targhe_matricole_validi AS
 SELECT h_dbi_get_targhe_matricole.id_linea,
    h_dbi_get_targhe_matricole.riferimento_id,
    regexp_replace(h_dbi_get_targhe_matricole.riferimento_id_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_tab,
    regexp_replace(h_dbi_get_targhe_matricole.targa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS targa,
    regexp_replace(h_dbi_get_targhe_matricole.matricola, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS matricola
   FROM "Analisi_dev".h_dbi_get_targhe_matricole
  WHERE (upper_inf(h_dbi_get_targhe_matricole.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dbi_get_targhe_matricole_validi OWNER TO postgres;

--
-- Name: vw_dpat_get_nominativi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dpat_get_nominativi AS
 SELECT t.id_nominativo,
    t.id_anagrafica_nominativo,
    t.nominativo,
    t.codice_fiscale,
    t.qualifica,
    t.data_scadenza_nominativo,
    t.id_struttura_semplice,
    t.desc_strutt_semplice,
    t.stato_strutt_semplice,
    t.data_scadenza_strutt_semplice,
    t.id_strutt_complessa,
    t.desc_strutt_complessa,
    t.data_scadenza_strutt_complessa,
    t.stato_strutt_complessa,
    t.id_asl,
    t.anno
   FROM public.dblink('dbname=gisa_fvg port=5432 host=127.0.0.1 user=postgres'::text, 'select * from public.dpat_get_nominativi(null, null, null)'::text) t(id_nominativo integer, id_anagrafica_nominativo integer, nominativo text, codice_fiscale text, qualifica text, data_scadenza_nominativo timestamp without time zone, id_struttura_semplice integer, desc_strutt_semplice text, stato_strutt_semplice integer, data_scadenza_strutt_semplice timestamp without time zone, id_strutt_complessa integer, desc_strutt_complessa text, data_scadenza_strutt_complessa timestamp without time zone, stato_strutt_complessa integer, id_asl integer, anno integer);


ALTER TABLE "Analisi_dev".vw_dpat_get_nominativi OWNER TO postgres;

--
-- Name: vw_dpat_get_nominativi_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dpat_get_nominativi_validi AS
 SELECT h_dpat_get_nominativi.id_nominativo,
    h_dpat_get_nominativi.id_anagrafica_nominativo,
    regexp_replace(h_dpat_get_nominativi.nominativo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nominativo,
    regexp_replace(h_dpat_get_nominativi.codice_fiscale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale,
    regexp_replace(h_dpat_get_nominativi.qualifica, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS qualifica,
    h_dpat_get_nominativi.data_scadenza_nominativo,
    h_dpat_get_nominativi.id_struttura_semplice,
    regexp_replace(h_dpat_get_nominativi.desc_strutt_semplice, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS desc_strutt_semplice,
    h_dpat_get_nominativi.stato_strutt_semplice,
    h_dpat_get_nominativi.data_scadenza_strutt_semplice,
    h_dpat_get_nominativi.id_strutt_complessa,
    regexp_replace(h_dpat_get_nominativi.desc_strutt_complessa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS desc_strutt_complessa,
    h_dpat_get_nominativi.data_scadenza_strutt_complessa,
    h_dpat_get_nominativi.stato_strutt_complessa,
    h_dpat_get_nominativi.id_asl,
    h_dpat_get_nominativi.anno
   FROM "Analisi_dev".h_dpat_get_nominativi
  WHERE (upper_inf(h_dpat_get_nominativi.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dpat_get_nominativi_validi OWNER TO postgres;

--
-- Name: vw_dpat_indicatore_new; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dpat_indicatore_new AS
 SELECT t.id,
    t.cod_raggruppamento,
    t.id_piano_attivita,
    t.anno,
    t.descrizione,
    t.ordinamento,
    t.data_scadenza,
    t.stato,
    t.codice_esame,
    t.codice_interno_indicatore,
    t.alias_indicatore,
    t.codice_interno_piani_gestione_cu,
    t.codice_interno_attivita_gestione_cu,
    t.codice_interno_univoco_tipo_attivita_gestione_cu,
    t.codice_alias_indicatore,
    t.flag_benessere,
    t.entered,
    t.modified,
    t.entered_by,
    t.modified_by,
    t.note_hd,
    t.tipo_item_dpat,
    t.rendic_per_campioni
   FROM public.dblink('dbname=gisa_fvg port=5432 host=127.0.0.1 user=postgres'::text, 'select * from public.dpat_indicatore_new'::text) t(id integer, cod_raggruppamento integer, id_piano_attivita integer, anno integer, descrizione text, ordinamento integer, data_scadenza timestamp without time zone, stato integer, codice_esame text, codice_interno_indicatore integer, alias_indicatore text, codice_interno_piani_gestione_cu integer, codice_interno_attivita_gestione_cu text, codice_interno_univoco_tipo_attivita_gestione_cu text, codice_alias_indicatore text, flag_benessere boolean, entered timestamp without time zone, modified timestamp without time zone, entered_by integer, modified_by integer, note_hd text, tipo_item_dpat integer, rendic_per_campioni boolean);


ALTER TABLE "Analisi_dev".vw_dpat_indicatore_new OWNER TO postgres;

--
-- Name: vw_dpat_indicatore_new_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dpat_indicatore_new_validi AS
 SELECT h_dpat_indicatore_new.id,
    h_dpat_indicatore_new.cod_raggruppamento,
    h_dpat_indicatore_new.id_piano_attivita,
    h_dpat_indicatore_new.anno,
    regexp_replace(h_dpat_indicatore_new.descrizione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione,
    h_dpat_indicatore_new.ordinamento,
    h_dpat_indicatore_new.data_scadenza,
    h_dpat_indicatore_new.stato,
    regexp_replace(h_dpat_indicatore_new.codice_esame, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_esame,
    h_dpat_indicatore_new.codice_interno_indicatore,
    regexp_replace(h_dpat_indicatore_new.alias_indicatore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS alias_indicatore,
    h_dpat_indicatore_new.codice_interno_piani_gestione_cu,
    regexp_replace(h_dpat_indicatore_new.codice_interno_attivita_gestione_cu, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_interno_attivita_gestione_cu,
    regexp_replace(h_dpat_indicatore_new.codice_interno_univoco_tipo_attivita_gestione_cu, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_interno_univoco_tipo_attivita_gestione_cu,
    regexp_replace(h_dpat_indicatore_new.codice_alias_indicatore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_alias_indicatore,
    h_dpat_indicatore_new.flag_benessere,
    h_dpat_indicatore_new.entered,
    h_dpat_indicatore_new.modified,
    h_dpat_indicatore_new.entered_by,
    h_dpat_indicatore_new.modified_by,
    regexp_replace(h_dpat_indicatore_new.note_hd, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note_hd,
    h_dpat_indicatore_new.tipo_item_dpat,
    h_dpat_indicatore_new.rendic_per_campioni
   FROM "Analisi_dev".h_dpat_indicatore_new
  WHERE (upper_inf(h_dpat_indicatore_new.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dpat_indicatore_new_validi OWNER TO postgres;

--
-- Name: vw_dpat_indicatore_new_attivi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dpat_indicatore_new_attivi AS
 SELECT a.id,
    a.cod_raggruppamento,
    a.id_piano_attivita,
    a.anno,
    a.descrizione,
    a.ordinamento,
    a.data_scadenza,
    a.stato,
    a.codice_esame,
    a.codice_interno_indicatore,
    a.alias_indicatore,
    a.codice_interno_piani_gestione_cu,
    a.codice_interno_attivita_gestione_cu,
    a.codice_interno_univoco_tipo_attivita_gestione_cu,
    a.codice_alias_indicatore,
    a.flag_benessere,
    a.entered,
    a.modified,
    a.entered_by,
    a.modified_by,
    a.note_hd,
    a.tipo_item_dpat,
    a.rendic_per_campioni,
    a.pos
   FROM ( SELECT vdinv.id,
            vdinv.cod_raggruppamento,
            vdinv.id_piano_attivita,
            vdinv.anno,
            vdinv.descrizione,
            vdinv.ordinamento,
            vdinv.data_scadenza,
            vdinv.stato,
            vdinv.codice_esame,
            vdinv.codice_interno_indicatore,
            vdinv.alias_indicatore,
            vdinv.codice_interno_piani_gestione_cu,
            vdinv.codice_interno_attivita_gestione_cu,
            vdinv.codice_interno_univoco_tipo_attivita_gestione_cu,
            vdinv.codice_alias_indicatore,
            vdinv.flag_benessere,
            vdinv.entered,
            vdinv.modified,
            vdinv.entered_by,
            vdinv.modified_by,
            vdinv.note_hd,
            vdinv.tipo_item_dpat,
            vdinv.rendic_per_campioni,
            row_number() OVER (PARTITION BY vdinv.cod_raggruppamento, vdinv.anno ORDER BY COALESCE(vdinv.data_scadenza, '3000-01-01 00:00:00'::timestamp without time zone) DESC) AS pos
           FROM "Analisi_dev".vw_dpat_indicatore_new_validi vdinv) a
  WHERE (a.pos = 1);


ALTER TABLE "Analisi_dev".vw_dpat_indicatore_new_attivi OWNER TO postgres;

--
-- Name: vw_dpat_piano_attivita_new; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dpat_piano_attivita_new AS
 SELECT t.id,
    t.cod_raggruppamento,
    t.id_sezione,
    t.anno,
    t.descrizione,
    t.ordinamento,
    t.data_scadenza,
    t.stato,
    t.codice_esame,
    t.tipo_attivita,
    t.codice_interno_piano,
    t.codice_interno_attivita,
    t.alias_piano,
    t.alias_attivita,
    t.codice_alias_attivita,
    t.entered,
    t.modified,
    t.entered_by,
    t.modified_by,
    t.note_hd
   FROM public.dblink('dbname=gisa_fvg port=5432 host=127.0.0.1 user=postgres'::text, 'select * from public.dpat_piano_attivita_new'::text) t(id integer, cod_raggruppamento integer, id_sezione integer, anno integer, descrizione text, ordinamento integer, data_scadenza timestamp without time zone, stato integer, codice_esame text, tipo_attivita text, codice_interno_piano integer, codice_interno_attivita integer, alias_piano text, alias_attivita text, codice_alias_attivita text, entered timestamp without time zone, modified timestamp without time zone, entered_by integer, modified_by integer, note_hd text);


ALTER TABLE "Analisi_dev".vw_dpat_piano_attivita_new OWNER TO postgres;

--
-- Name: vw_dpat_piano_attivita_new_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dpat_piano_attivita_new_validi AS
 SELECT h_dpat_piano_attivita_new.id,
    h_dpat_piano_attivita_new.cod_raggruppamento,
    h_dpat_piano_attivita_new.id_sezione,
    h_dpat_piano_attivita_new.anno,
    regexp_replace(h_dpat_piano_attivita_new.descrizione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione,
    h_dpat_piano_attivita_new.ordinamento,
    h_dpat_piano_attivita_new.data_scadenza,
    h_dpat_piano_attivita_new.stato,
    regexp_replace(h_dpat_piano_attivita_new.codice_esame, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_esame,
    regexp_replace(h_dpat_piano_attivita_new.tipo_attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_attivita,
    h_dpat_piano_attivita_new.codice_interno_piano,
    h_dpat_piano_attivita_new.codice_interno_attivita,
    regexp_replace(h_dpat_piano_attivita_new.alias_piano, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS alias_piano,
    regexp_replace(h_dpat_piano_attivita_new.alias_attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS alias_attivita,
    regexp_replace(h_dpat_piano_attivita_new.codice_alias_attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_alias_attivita,
    h_dpat_piano_attivita_new.entered,
    h_dpat_piano_attivita_new.modified,
    h_dpat_piano_attivita_new.entered_by,
    h_dpat_piano_attivita_new.modified_by,
    regexp_replace(h_dpat_piano_attivita_new.note_hd, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note_hd
   FROM "Analisi_dev".h_dpat_piano_attivita_new
  WHERE (upper_inf(h_dpat_piano_attivita_new.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dpat_piano_attivita_new_validi OWNER TO postgres;

--
-- Name: vw_dpat_piano_attivita_new_attivi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dpat_piano_attivita_new_attivi AS
 SELECT a.id,
    a.cod_raggruppamento,
    a.id_sezione,
    a.anno,
    a.descrizione,
    a.ordinamento,
    a.data_scadenza,
    a.stato,
    a.codice_esame,
    a.tipo_attivita,
    a.codice_interno_piano,
    a.codice_interno_attivita,
    a.alias_piano,
    a.alias_attivita,
    a.codice_alias_attivita,
    a.entered,
    a.modified,
    a.entered_by,
    a.modified_by,
    a.note_hd,
    a.pos
   FROM ( SELECT vdpanv.id,
            vdpanv.cod_raggruppamento,
            vdpanv.id_sezione,
            vdpanv.anno,
            vdpanv.descrizione,
            vdpanv.ordinamento,
            vdpanv.data_scadenza,
            vdpanv.stato,
            vdpanv.codice_esame,
            vdpanv.tipo_attivita,
            vdpanv.codice_interno_piano,
            vdpanv.codice_interno_attivita,
            vdpanv.alias_piano,
            vdpanv.alias_attivita,
            vdpanv.codice_alias_attivita,
            vdpanv.entered,
            vdpanv.modified,
            vdpanv.entered_by,
            vdpanv.modified_by,
            vdpanv.note_hd,
            row_number() OVER (PARTITION BY vdpanv.cod_raggruppamento, vdpanv.anno ORDER BY COALESCE(vdpanv.data_scadenza, '3000-01-01 00:00:00'::timestamp without time zone) DESC) AS pos
           FROM "Analisi_dev".vw_dpat_piano_attivita_new_validi vdpanv) a
  WHERE (a.pos = 1);


ALTER TABLE "Analisi_dev".vw_dpat_piano_attivita_new_attivi OWNER TO postgres;

--
-- Name: vw_dpat_sez_new; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dpat_sez_new AS
 SELECT t.id,
    t.cod_raggruppamento,
    t.anno,
    t.descrizione,
    t.ordinamento,
    t.data_scadenza,
    t.stato,
    t.codice_interno,
    t.color,
    t.entered,
    t.modified,
    t.entered_by,
    t.modified_by
   FROM public.dblink('dbname=gisa_fvg port=5432 host=127.0.0.1 user=postgres'::text, 'select * from public.dpat_sez_new'::text) t(id integer, cod_raggruppamento integer, anno integer, descrizione text, ordinamento integer, data_scadenza timestamp without time zone, stato integer, codice_interno integer, color character varying, entered timestamp without time zone, modified timestamp without time zone, entered_by integer, modified_by integer);


ALTER TABLE "Analisi_dev".vw_dpat_sez_new OWNER TO postgres;

--
-- Name: vw_dpat_sez_new_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dpat_sez_new_validi AS
 SELECT h_dpat_sez_new.id,
    h_dpat_sez_new.cod_raggruppamento,
    h_dpat_sez_new.anno,
    regexp_replace(h_dpat_sez_new.descrizione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione,
    h_dpat_sez_new.ordinamento,
    h_dpat_sez_new.data_scadenza,
    h_dpat_sez_new.stato,
    h_dpat_sez_new.codice_interno,
    regexp_replace((h_dpat_sez_new.color)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS color,
    h_dpat_sez_new.entered,
    h_dpat_sez_new.modified,
    h_dpat_sez_new.entered_by,
    h_dpat_sez_new.modified_by
   FROM "Analisi_dev".h_dpat_sez_new
  WHERE (upper_inf(h_dpat_sez_new.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_dpat_sez_new_validi OWNER TO postgres;

--
-- Name: vw_dpat_sez_new_attivi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_dpat_sez_new_attivi AS
 SELECT vdsnv.id,
    vdsnv.cod_raggruppamento,
    vdsnv.anno,
    vdsnv.descrizione,
    vdsnv.ordinamento,
    vdsnv.data_scadenza,
    vdsnv.stato,
    vdsnv.codice_interno,
    vdsnv.color,
    vdsnv.entered,
    vdsnv.modified,
    vdsnv.entered_by,
    vdsnv.modified_by
   FROM "Analisi_dev".vw_dpat_sez_new_validi vdsnv
  WHERE ((vdsnv.stato <> 1) AND ((vdsnv.data_scadenza IS NULL) OR (vdsnv.data_scadenza > CURRENT_TIMESTAMP)) AND (vdsnv.descrizione <> 'SEZIONE E'::text) AND (vdsnv.anno > 0) AND (vdsnv.anno IS NOT NULL));


ALTER TABLE "Analisi_dev".vw_dpat_sez_new_attivi OWNER TO postgres;

--
-- Name: vw_estrazione_campioni_pnaa_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_estrazione_campioni_pnaa_validi AS
 SELECT h_estrazione_campioni_pnaa."id campione",
    h_estrazione_campioni_pnaa."id controllo",
    regexp_replace(h_estrazione_campioni_pnaa."numero scheda", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "numero scheda",
    h_estrazione_campioni_pnaa."Data campione",
    regexp_replace(h_estrazione_campioni_pnaa."Verbale campione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Verbale campione",
    regexp_replace(h_estrazione_campioni_pnaa."Codice preaccettazione campione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Codice preaccettazione campione",
    regexp_replace(h_estrazione_campioni_pnaa."Asl campione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Asl campione",
    regexp_replace(h_estrazione_campioni_pnaa."CU Per conto di", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "CU Per conto di",
    regexp_replace(h_estrazione_campioni_pnaa."Verbale Anno", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Verbale Anno",
    regexp_replace(h_estrazione_campioni_pnaa."Verbale Mese", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Verbale Mese",
    regexp_replace(h_estrazione_campioni_pnaa."Verbale giorno", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Verbale giorno",
    regexp_replace(h_estrazione_campioni_pnaa."Verbale ore", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Verbale ore",
    regexp_replace(h_estrazione_campioni_pnaa."Verbale Presente al prelievo", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Verbale Presente al prelievo",
    regexp_replace(h_estrazione_campioni_pnaa."Verbale sottoscritti", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Verbale sottoscritti",
    regexp_replace(h_estrazione_campioni_pnaa."Verbale Numero campioni prelevati", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Verbale Numero campioni prelevati",
    regexp_replace(h_estrazione_campioni_pnaa."Verbale DPA", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Verbale DPA",
    regexp_replace(h_estrazione_campioni_pnaa."A1. Strategia di campionamento", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A1. Strategia di campionamento",
    regexp_replace(h_estrazione_campioni_pnaa."A2. Metodo di campionamento", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A2. Metodo di campionamento",
    regexp_replace(h_estrazione_campioni_pnaa."A3. Programma di Controllo", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. Programma di Controllo",
    regexp_replace(h_estrazione_campioni_pnaa."A3. specifica principi farmacologicamente attivi", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. specifica principi farmacologicamente attivi",
    regexp_replace(h_estrazione_campioni_pnaa."A3. specifica additivi nutrizionali", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. specifica additivi nutrizionali",
    regexp_replace(h_estrazione_campioni_pnaa."A3. specifica cocciodiostatici/istomonostatici", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. specifica cocciodiostatici/istomonostatici",
    regexp_replace(h_estrazione_campioni_pnaa."A3. specifica additivi tecnologici", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. specifica additivi tecnologici",
    regexp_replace(h_estrazione_campioni_pnaa."A3. specifica Principi additivi organolettici", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. specifica Principi additivi organolettici",
    regexp_replace(h_estrazione_campioni_pnaa."A3. specifica additivi zootecnici", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. specifica additivi zootecnici",
    regexp_replace(h_estrazione_campioni_pnaa."A3. specifica principi farm. attivi carry over", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. specifica principi farm. attivi carry over",
    regexp_replace(h_estrazione_campioni_pnaa."A3. specifica coccidiostatici/istomonastici carry over", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. specifica coccidiostatici/istomonastici carry over",
    regexp_replace(h_estrazione_campioni_pnaa."A3. specifica contamin. inorganici e composti azotati", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. specifica contamin. inorganici e composti azotati",
    regexp_replace(h_estrazione_campioni_pnaa."A3. specifica radionuclidi", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. specifica radionuclidi",
    regexp_replace(h_estrazione_campioni_pnaa."A3. specifica pesticidi", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. specifica pesticidi",
    regexp_replace(h_estrazione_campioni_pnaa."A3. specifica micotossine", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. specifica micotossine",
    regexp_replace(h_estrazione_campioni_pnaa."A3. specifica altro", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. specifica altro",
    regexp_replace(h_estrazione_campioni_pnaa."A3. Principi farmacologicamente attivi", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. Principi farmacologicamente attivi",
    regexp_replace(h_estrazione_campioni_pnaa."A3. Principi farmacologicamente attivi carry over", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. Principi farmacologicamente attivi carry over",
    regexp_replace(h_estrazione_campioni_pnaa."A3. Quantità di P.A/Cocc.", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. Quantità di P.A/Cocc.",
    regexp_replace(h_estrazione_campioni_pnaa."A3. Contaminanti inorganici e composti az, pe, ra", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A3. Contaminanti inorganici e composti az, pe, ra",
    regexp_replace(h_estrazione_campioni_pnaa."A4. Prelevatore", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A4. Prelevatore",
    regexp_replace(h_estrazione_campioni_pnaa."A5. Luogo di prelievo", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A5. Luogo di prelievo",
    regexp_replace(h_estrazione_campioni_pnaa."A6. Codice luogo di prelievo", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A6. Codice luogo di prelievo",
    regexp_replace(h_estrazione_campioni_pnaa."A7. Targa mezzo di trasporto", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A7. Targa mezzo di trasporto",
    regexp_replace(h_estrazione_campioni_pnaa."A8. Indirizzo del luogo di prelievo", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A8. Indirizzo del luogo di prelievo",
    regexp_replace(h_estrazione_campioni_pnaa."A9. Comune", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A9. Comune",
    regexp_replace(h_estrazione_campioni_pnaa."A10. Provincia", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A10. Provincia",
    regexp_replace(h_estrazione_campioni_pnaa."A11. Latitudine luogo", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A11. Latitudine luogo",
    regexp_replace(h_estrazione_campioni_pnaa."A11. Longitudine luogo", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A11. Longitudine luogo",
    regexp_replace(h_estrazione_campioni_pnaa."A12. Ragione sociale", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A12. Ragione sociale",
    regexp_replace(h_estrazione_campioni_pnaa."A13. Rappresentante legale", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A13. Rappresentante legale",
    regexp_replace(h_estrazione_campioni_pnaa."A14. Codice fiscale", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A14. Codice fiscale",
    regexp_replace(h_estrazione_campioni_pnaa."A15. Detentore", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A15. Detentore",
    regexp_replace(h_estrazione_campioni_pnaa."A16. Telefono", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "A16. Telefono",
    regexp_replace(h_estrazione_campioni_pnaa."B1. Matrice del campione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B1. Matrice del campione",
    regexp_replace(h_estrazione_campioni_pnaa."B1. Specie vegetale dichiarata", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B1. Specie vegetale dichiarata",
    regexp_replace(h_estrazione_campioni_pnaa."B1. Specifica materia prima/mangime semplice", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B1. Specifica materia prima/mangime semplice",
    regexp_replace(h_estrazione_campioni_pnaa."B1. Mangime composto", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B1. Mangime composto",
    regexp_replace(h_estrazione_campioni_pnaa."B1. Premiscela additivi", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B1. Premiscela additivi",
    regexp_replace(h_estrazione_campioni_pnaa."B1. Categoria Sottoprodotti", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B1. Categoria Sottoprodotti",
    regexp_replace(h_estrazione_campioni_pnaa."B2. Trattamento mangime", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B2. Trattamento mangime",
    regexp_replace(h_estrazione_campioni_pnaa."B3. Confezionamento", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B3. Confezionamento",
    regexp_replace(h_estrazione_campioni_pnaa."B4. Ragione sociale ditta produttrice", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B4. Ragione sociale ditta produttrice",
    regexp_replace(h_estrazione_campioni_pnaa."B5. Indrizzo ditta produttrice", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B5. Indrizzo ditta produttrice",
    regexp_replace(h_estrazione_campioni_pnaa."B6. Specie e categoria animale per alimento", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B6. Specie e categoria animale per alimento",
    regexp_replace(h_estrazione_campioni_pnaa."B7. Metodo di produzione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B7. Metodo di produzione",
    regexp_replace(h_estrazione_campioni_pnaa."B8. Nome commerciale mangime", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B8. Nome commerciale mangime",
    regexp_replace(h_estrazione_campioni_pnaa."B9. Stato prodotto", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B9. Stato prodotto",
    regexp_replace(h_estrazione_campioni_pnaa."B10. Ragione sociale responsabile etichettatura", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B10. Ragione sociale responsabile etichettatura",
    regexp_replace(h_estrazione_campioni_pnaa."B11. Indirizzo responsabile etichettatura", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B11. Indirizzo responsabile etichettatura",
    regexp_replace(h_estrazione_campioni_pnaa."B12. Paese di produzione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B12. Paese di produzione",
    regexp_replace(h_estrazione_campioni_pnaa."B13. Data di produzione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B13. Data di produzione",
    regexp_replace(h_estrazione_campioni_pnaa."B14. Data di scadenza", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B14. Data di scadenza",
    regexp_replace(h_estrazione_campioni_pnaa."B15. Numero di lotto", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B15. Numero di lotto",
    regexp_replace(h_estrazione_campioni_pnaa."B16. Dimensione del lotto", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B16. Dimensione del lotto",
    regexp_replace(h_estrazione_campioni_pnaa."B17. Ingredienti", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B17. Ingredienti",
    regexp_replace(h_estrazione_campioni_pnaa."B18. Commenti ulteriori sul mangime", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "B18. Commenti ulteriori sul mangime",
    regexp_replace(h_estrazione_campioni_pnaa."C1. Laboratorio destinazione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "C1. Laboratorio destinazione",
    regexp_replace(h_estrazione_campioni_pnaa."D. Informazioni cartellino", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Informazioni cartellino",
    regexp_replace(h_estrazione_campioni_pnaa."D. Descrizione attrezzature", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Descrizione attrezzature",
    regexp_replace(h_estrazione_campioni_pnaa."D. Num punti", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Num punti",
    regexp_replace(h_estrazione_campioni_pnaa."D. Num CE", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Num CE",
    regexp_replace(h_estrazione_campioni_pnaa."D. Peso Volume", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Peso Volume",
    regexp_replace(h_estrazione_campioni_pnaa."D. Operazioni", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Operazioni",
    regexp_replace(h_estrazione_campioni_pnaa."D. Kg/lt", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Kg/lt",
    regexp_replace(h_estrazione_campioni_pnaa."D. Operazioni campione globale", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Operazioni campione globale",
    regexp_replace(h_estrazione_campioni_pnaa."D. CF", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. CF",
    regexp_replace(h_estrazione_campioni_pnaa."D. g/ml", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. g/ml",
    regexp_replace(h_estrazione_campioni_pnaa."D. Dichiarazione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Dichiarazione",
    regexp_replace(h_estrazione_campioni_pnaa."D. Conservazione campione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Conservazione campione",
    regexp_replace(h_estrazione_campioni_pnaa."D. Numero copia/e", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Numero copia/e",
    regexp_replace(h_estrazione_campioni_pnaa."D. Numero campioni finali", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Numero campioni finali",
    regexp_replace(h_estrazione_campioni_pnaa."D. Custode campione", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Custode campione",
    regexp_replace(h_estrazione_campioni_pnaa."D. Per conto di", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Per conto di",
    regexp_replace(h_estrazione_campioni_pnaa."D. Rinuncia per controversia/controperizia", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Rinuncia per controversia/controperizia",
    regexp_replace(h_estrazione_campioni_pnaa."D. Volume finale", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Volume finale",
    regexp_replace(h_estrazione_campioni_pnaa."D. Numero campioni finali inviati", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Numero campioni finali inviati",
    regexp_replace(h_estrazione_campioni_pnaa."D. Numero copie inviate", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Numero copie inviate",
    regexp_replace(h_estrazione_campioni_pnaa."D. Destinazione invio", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Destinazione invio",
    regexp_replace(h_estrazione_campioni_pnaa."D. Data invio", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Data invio",
    regexp_replace(h_estrazione_campioni_pnaa."D. CG ridotto", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. CG ridotto",
    regexp_replace(h_estrazione_campioni_pnaa."D. CG/CR", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. CG/CR",
    regexp_replace(h_estrazione_campioni_pnaa."D. Sequestro partita", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "D. Sequestro partita",
    regexp_replace(h_estrazione_campioni_pnaa."Codice SINVSA", '[\r\n\t\v]'::text, ''::text, 'g'::text) AS "Codice SINVSA"
   FROM "Analisi_dev".h_estrazione_campioni_pnaa
  WHERE (upper_inf(h_estrazione_campioni_pnaa.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_estrazione_campioni_pnaa_validi OWNER TO postgres;

--
-- Name: vw_estrazione_controlli_apicoltura_tipoab_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_estrazione_controlli_apicoltura_tipoab_validi AS
 SELECT regexp_replace(h_estrazione_controlli_apicoltura_tipoab.id_controllo_ufficiale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS id_controllo_ufficiale,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.data_inizio_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_inizio_controllo,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.alias_indicatore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS alias_indicatore,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.piano_monitoraggio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS piano_monitoraggio,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.ragione_sociale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ragione_sociale,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.asl_apiario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_apiario,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.cun, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cun,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.comune_apiario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_apiario,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.provincia_apiario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS provincia_apiario,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.indirizzo_apiario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo_apiario,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.cap_apiario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cap_apiario,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.num_alveari_presenti, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS num_alveari_presenti,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.modalita_selezione_apiario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS modalita_selezione_apiario,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.classificazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS classificazione,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.motivo_controllo_apiario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS motivo_controllo_apiario,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.specifica_altro_motivo_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specifica_altro_motivo_controllo,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.numero_alveari_controllati, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS numero_alveari_controllati,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.esito, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS esito,
    regexp_replace(h_estrazione_controlli_apicoltura_tipoab.note_esito, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note_esito
   FROM "Analisi_dev".h_estrazione_controlli_apicoltura_tipoab
  WHERE (upper_inf(h_estrazione_controlli_apicoltura_tipoab.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_estrazione_controlli_apicoltura_tipoab_validi OWNER TO postgres;

--
-- Name: vw_get_accettazioni_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_accettazioni_validi AS
 SELECT regexp_replace(h_get_accettazioni.numero, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS numero,
    h_get_accettazioni.data,
    h_get_accettazioni.asl_id,
    regexp_replace(h_get_accettazioni.asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace(h_get_accettazioni.clinica, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS clinica,
    regexp_replace(h_get_accettazioni.microchip, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS microchip,
    h_get_accettazioni.deceduto_non_anagrafe,
    h_get_accettazioni.asl_animale_id,
    regexp_replace(h_get_accettazioni.asl_animale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_animale,
    regexp_replace(h_get_accettazioni.proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS proprietario,
    regexp_replace(h_get_accettazioni.specie_description, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie_description,
    h_get_accettazioni.specie_id,
    regexp_replace(h_get_accettazioni.username_utente, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS username_utente,
    regexp_replace(h_get_accettazioni.utente, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS utente,
    h_get_accettazioni.motivazione_id,
    regexp_replace(h_get_accettazioni.motivazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS motivazione,
    h_get_accettazioni.attivita_esterna_id,
    regexp_replace(h_get_accettazioni.attivita_esterna, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS attivita_esterna,
    regexp_replace(h_get_accettazioni.note, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note,
    regexp_replace(h_get_accettazioni.numero_cc, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS numero_cc
   FROM "Analisi_dev".h_get_accettazioni
  WHERE (upper_inf(h_get_accettazioni.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_accettazioni_validi OWNER TO postgres;

--
-- Name: vw_get_campioni_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_campioni_validi AS
 SELECT h_get_campioni.id_asl,
    regexp_replace((h_get_campioni.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace((h_get_campioni.motivazione_campione)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS motivazione_campione,
    h_get_campioni.id_piano,
    h_get_campioni.id_attivita,
    h_get_campioni.id_campione,
    h_get_campioni.data_prelievo,
    regexp_replace((h_get_campioni.identificativo_campione)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS identificativo_campione,
    regexp_replace(h_get_campioni.prelevatore_1_a4, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS prelevatore_1_a4,
    regexp_replace(h_get_campioni.prelevatore_2_a4, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS prelevatore_2_a4,
    regexp_replace(h_get_campioni.prelevatore_3_a4, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS prelevatore_3_a4,
    regexp_replace(h_get_campioni.strategia_campionamento_a1, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS strategia_campionamento_a1,
    regexp_replace(h_get_campioni.capitoli_piani_a3, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS capitoli_piani_a3,
    regexp_replace((h_get_campioni.specie_alimento_b6)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie_alimento_b6,
    regexp_replace(h_get_campioni.metodo_produzione_b7, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS metodo_produzione_b7,
    regexp_replace(h_get_campioni.anno_campione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS anno_campione,
    h_get_campioni.data_chiusura_campione,
    regexp_replace((h_get_campioni.id_controllo_ufficiale)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS id_controllo_ufficiale,
    regexp_replace(h_get_campioni.esito, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS esito,
    h_get_campioni.punteggio_campione,
    regexp_replace((h_get_campioni.responsabilita_positiva)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS responsabilita_positiva,
    h_get_campioni.data_esito_analita,
    regexp_replace(h_get_campioni.esito_motivazione_respingimento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS esito_motivazione_respingimento,
    regexp_replace(h_get_campioni.note_esito_campione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note_esito_campione,
    regexp_replace(h_get_campioni.codice_accettazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_accettazione,
    regexp_replace((h_get_campioni.num_verbale)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS num_verbale,
    regexp_replace((h_get_campioni.barcode)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS barcode,
    regexp_replace(h_get_campioni.analita_lev_1, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS analita_lev_1,
    regexp_replace(h_get_campioni.analita_lev_2, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS analita_lev_2,
    regexp_replace(h_get_campioni.analita_lev_3, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS analita_lev_3,
    regexp_replace(h_get_campioni.analita_lev_4, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS analita_lev_4,
    regexp_replace(h_get_campioni.matrice_lev_1, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS matrice_lev_1,
    regexp_replace(h_get_campioni.matrice_lev_2, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS matrice_lev_2,
    regexp_replace(h_get_campioni.matrice_lev_3, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS matrice_lev_3,
    regexp_replace(h_get_campioni.note_campione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note_campione,
    regexp_replace(h_get_campioni.anno_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS anno_controllo,
    regexp_replace(h_get_campioni.codice_interno_piano, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_interno_piano,
    regexp_replace(h_get_campioni.descrizione_esito_esame, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_esito_esame,
    regexp_replace(h_get_campioni.motivazione_non_conformita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS motivazione_non_conformita,
    h_get_campioni.rendicontabile,
    regexp_replace(h_get_campioni.codice_preaccettazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_preaccettazione
   FROM "Analisi_dev".h_get_campioni
  WHERE (upper_inf(h_get_campioni.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_campioni_validi OWNER TO postgres;

--
-- Name: vw_get_categorie_rischio_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_categorie_rischio_validi AS
 SELECT h_get_categorie_rischio.code,
    regexp_replace(h_get_categorie_rischio.description, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS description,
    h_get_categorie_rischio.tipologia,
    regexp_replace((h_get_categorie_rischio.desc_tipologia)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS desc_tipologia
   FROM "Analisi_dev".h_get_categorie_rischio
  WHERE (upper_inf(h_get_categorie_rischio.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_categorie_rischio_validi OWNER TO postgres;

--
-- Name: vw_get_cc_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_cc_validi AS
 SELECT regexp_replace(h_get_cc.numero, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS numero,
    h_get_cc.data_apertura,
    h_get_cc.data_chiusura,
    regexp_replace(h_get_cc.destinazione_animale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS destinazione_animale,
    regexp_replace(h_get_cc.username_utente_dimissioni, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS username_utente_dimissioni,
    regexp_replace(h_get_cc.utente_dimissioni, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS utente_dimissioni,
    regexp_replace(h_get_cc.tipo_cc, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_cc,
    h_get_cc.necroscopica,
    h_get_cc.day_hospital,
    regexp_replace(h_get_cc.motivo_ricovero, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS motivo_ricovero,
    regexp_replace(h_get_cc.clinica, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS clinica,
    regexp_replace(h_get_cc.asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_get_cc.asl_id,
    regexp_replace(h_get_cc.microchip, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS microchip,
    h_get_cc.deceduto_non_anagrafe,
    regexp_replace(h_get_cc.asl_animale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_animale,
    h_get_cc.asl_animale_id,
    regexp_replace(h_get_cc.username_utente, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS username_utente,
    regexp_replace(h_get_cc.utente, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS utente,
    regexp_replace(h_get_cc.specie, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie,
    h_get_cc.specie_id,
    regexp_replace(h_get_cc.razza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS razza,
    regexp_replace(h_get_cc.numero_accettazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS numero_accettazione,
    h_get_cc.num_reg_sterilizzazione,
    h_get_cc.data_reinvenimento_sinantropo,
    regexp_replace(h_get_cc.comune_reinvenimento_sinantropo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_reinvenimento_sinantropo,
    regexp_replace(h_get_cc.luogo_reinvenimento_sinantropo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS luogo_reinvenimento_sinantropo,
    h_get_cc.data_rilascio_sinantropo,
    regexp_replace(h_get_cc.comune_rilascio_sinantropo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_rilascio_sinantropo,
    regexp_replace(h_get_cc.luogo_rilascio_sinantropo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS luogo_rilascio_sinantropo,
    regexp_replace(h_get_cc.numero_riferimento_mittente_necroscopia, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS numero_riferimento_mittente_necroscopia,
    regexp_replace(h_get_cc.tipologia_riferimento_mittente_necroscopia, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipologia_riferimento_mittente_necroscopia
   FROM "Analisi_dev".h_get_cc
  WHERE (upper_inf(h_get_cc.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_cc_validi OWNER TO postgres;

--
-- Name: vw_get_checklist_sorveglianza_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_checklist_sorveglianza_validi AS
 SELECT h_get_checklist_sorveglianza.id,
    h_get_checklist_sorveglianza.id_controllo,
    h_get_checklist_sorveglianza.is_principale,
    regexp_replace(h_get_checklist_sorveglianza.stato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato,
    h_get_checklist_sorveglianza.livello_rischio,
    h_get_checklist_sorveglianza.tipo_check,
    h_get_checklist_sorveglianza.num_chk
   FROM "Analisi_dev".h_get_checklist_sorveglianza
  WHERE (upper_inf(h_get_checklist_sorveglianza.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_checklist_sorveglianza_validi OWNER TO postgres;

--
-- Name: vw_get_comuni_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_comuni_validi AS
 SELECT h_get_comuni.id,
    regexp_replace((h_get_comuni.cod_comune)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cod_comune,
    regexp_replace((h_get_comuni.cod_regione)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cod_regione,
    h_get_comuni.cod_provincia,
    regexp_replace((h_get_comuni.nome)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome,
    regexp_replace((h_get_comuni.istat)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS istat,
    regexp_replace((h_get_comuni.cap)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cap,
    h_get_comuni.cod_nazione,
    h_get_comuni.id_asl
   FROM "Analisi_dev".h_get_comuni
  WHERE (upper_inf(h_get_comuni.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_comuni_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_altri_congiunti_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_altri_congiunti_validi AS
 SELECT h_get_controlli_altri_congiunti.id_controllo_ufficiale,
    h_get_controlli_altri_congiunti.id_tecnica_cu,
    regexp_replace(h_get_controlli_altri_congiunti.nome_componente_nucleo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_componente_nucleo,
    regexp_replace((h_get_controlli_altri_congiunti.ruolo_componente_nucleo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ruolo_componente_nucleo,
    regexp_replace(h_get_controlli_altri_congiunti.gruppo_ruolo_componente_nucleo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS gruppo_ruolo_componente_nucleo
   FROM "Analisi_dev".h_get_controlli_altri_congiunti
  WHERE (upper_inf(h_get_controlli_altri_congiunti.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_altri_congiunti_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_audit_autorita_competenti_oggetto_audit_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_audit_autorita_competenti_oggetto_audit_validi AS
 SELECT h_get_controlli_audit_autorita_competenti_oggetto_audit.id_oggetto,
    regexp_replace(h_get_controlli_audit_autorita_competenti_oggetto_audit.oggetto_audit, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS oggetto_audit,
    h_get_controlli_audit_autorita_competenti_oggetto_audit.id_controllo,
    h_get_controlli_audit_autorita_competenti_oggetto_audit.audit_di_followup,
    regexp_replace(h_get_controlli_audit_autorita_competenti_oggetto_audit.tipo_audit, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_audit
   FROM "Analisi_dev".h_get_controlli_audit_autorita_competenti_oggetto_audit
  WHERE (upper_inf(h_get_controlli_audit_autorita_competenti_oggetto_audit.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_audit_autorita_competenti_oggetto_audit_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_audit_autorita_competenti_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_audit_autorita_competenti_validi AS
 SELECT h_get_controlli_audit_autorita_competenti.id_controllo,
    h_get_controlli_audit_autorita_competenti.data_inserimento,
    h_get_controlli_audit_autorita_competenti.data_inizio_controllo,
    h_get_controlli_audit_autorita_competenti.data_chiusura_controllo,
    h_get_controlli_audit_autorita_competenti.data_fine_controllo,
    h_get_controlli_audit_autorita_competenti.id_stato_controllo,
    regexp_replace(h_get_controlli_audit_autorita_competenti.stato_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_controllo,
    regexp_replace(h_get_controlli_audit_autorita_competenti.tipo_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_controllo,
    regexp_replace((h_get_controlli_audit_autorita_competenti.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_get_controlli_audit_autorita_competenti.id_asl,
    h_get_controlli_audit_autorita_competenti.id_struttura_controllata,
    regexp_replace(h_get_controlli_audit_autorita_competenti.struttura_controllata, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS struttura_controllata,
    regexp_replace(h_get_controlli_audit_autorita_competenti.path_completo_struttura, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS path_completo_struttura,
    regexp_replace(h_get_controlli_audit_autorita_competenti.congruo_supervisione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS congruo_supervisione,
    h_get_controlli_audit_autorita_competenti.supervisionato_in_data,
    h_get_controlli_audit_autorita_competenti.supervisionato_da,
    regexp_replace(h_get_controlli_audit_autorita_competenti.supervisione_note, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS supervisione_note,
    regexp_replace(h_get_controlli_audit_autorita_competenti.note, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note,
    h_get_controlli_audit_autorita_competenti.id_tecnica_cu,
    h_get_controlli_audit_autorita_competenti.punteggio
   FROM "Analisi_dev".h_get_controlli_audit_autorita_competenti
  WHERE (upper_inf(h_get_controlli_audit_autorita_competenti.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_audit_autorita_competenti_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_audit_motivi_2020_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_audit_motivi_2020_validi AS
 SELECT h_get_controlli_audit_motivi_2020.id_controllo,
    h_get_controlli_audit_motivi_2020.id_motivo_audit,
    h_get_controlli_audit_motivi_2020.id_piano,
    regexp_replace((h_get_controlli_audit_motivi_2020.descrizione_motivo_padre)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_motivo_padre,
    regexp_replace(h_get_controlli_audit_motivi_2020.descrizione_motivo_figlio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_motivo_figlio,
    regexp_replace(h_get_controlli_audit_motivi_2020.codice_interno_piano_attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_interno_piano_attivita,
    regexp_replace(h_get_controlli_audit_motivi_2020.alias_padre, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS alias_padre,
    regexp_replace(h_get_controlli_audit_motivi_2020.alias_indicatore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS alias_indicatore
   FROM "Analisi_dev".h_get_controlli_audit_motivi_2020
  WHERE (upper_inf(h_get_controlli_audit_motivi_2020.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_audit_motivi_2020_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_audit_oggetto_del_controllo_2020_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_audit_oggetto_del_controllo_2020_validi AS
 SELECT h_get_controlli_audit_oggetto_del_controllo_2020.id_controllo,
    h_get_controlli_audit_oggetto_del_controllo_2020.id_oggetto_del_controllo,
    regexp_replace(h_get_controlli_audit_oggetto_del_controllo_2020.oggetto_del_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS oggetto_del_controllo,
    h_get_controlli_audit_oggetto_del_controllo_2020.id_macrocategoria,
    regexp_replace(h_get_controlli_audit_oggetto_del_controllo_2020.descrizione_macrocategoria, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_macrocategoria
   FROM "Analisi_dev".h_get_controlli_audit_oggetto_del_controllo_2020
  WHERE (upper_inf(h_get_controlli_audit_oggetto_del_controllo_2020.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_audit_oggetto_del_controllo_2020_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_audit_oggettodelcontrollo_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_audit_oggettodelcontrollo_validi AS
 SELECT h_get_controlli_audit_oggettodelcontrollo.id_controllo,
    h_get_controlli_audit_oggettodelcontrollo.id_motivo,
    regexp_replace(h_get_controlli_audit_oggettodelcontrollo.motivo_audit, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS motivo_audit,
    h_get_controlli_audit_oggettodelcontrollo.id_tipo_audit,
    regexp_replace(h_get_controlli_audit_oggettodelcontrollo.tipo_audit, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_audit,
    h_get_controlli_audit_oggettodelcontrollo.id_oggetto_bpi,
    regexp_replace(h_get_controlli_audit_oggettodelcontrollo.oggetto_bpi, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS oggetto_bpi,
    h_get_controlli_audit_oggettodelcontrollo.id_oggetto_haccp,
    regexp_replace(h_get_controlli_audit_oggettodelcontrollo.oggetto_haccp, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS oggetto_haccp
   FROM "Analisi_dev".h_get_controlli_audit_oggettodelcontrollo
  WHERE (upper_inf(h_get_controlli_audit_oggettodelcontrollo.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_audit_oggettodelcontrollo_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_audit_percontodi_2020_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_audit_percontodi_2020_validi AS
 SELECT h_get_controlli_audit_percontodi_2020.id_controllo,
    regexp_replace(h_get_controlli_audit_percontodi_2020.struttura_complessa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS struttura_complessa,
    regexp_replace(h_get_controlli_audit_percontodi_2020.struttura_semplice, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS struttura_semplice,
    regexp_replace(h_get_controlli_audit_percontodi_2020.per_conto_di_completo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS per_conto_di_completo,
    h_get_controlli_audit_percontodi_2020.id_unita_operativa,
    h_get_controlli_audit_percontodi_2020.id_asl_struttura,
    h_get_controlli_audit_percontodi_2020.codice_interno_univoco_uo,
    regexp_replace((h_get_controlli_audit_percontodi_2020.area_appartenenza_uo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS area_appartenenza_uo,
    h_get_controlli_audit_percontodi_2020.id_motivo_audit,
    h_get_controlli_audit_percontodi_2020.id_piano_audit
   FROM "Analisi_dev".h_get_controlli_audit_percontodi_2020
  WHERE (upper_inf(h_get_controlli_audit_percontodi_2020.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_audit_percontodi_2020_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_audit_sorv_percontodi_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_audit_sorv_percontodi_validi AS
 SELECT h_get_controlli_audit_sorv_percontodi.id_controllo,
    regexp_replace(h_get_controlli_audit_sorv_percontodi.struttura_complessa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS struttura_complessa,
    regexp_replace(h_get_controlli_audit_sorv_percontodi.struttura_semplice, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS struttura_semplice,
    regexp_replace(h_get_controlli_audit_sorv_percontodi.per_conto_di_completo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS per_conto_di_completo,
    h_get_controlli_audit_sorv_percontodi.id_unita_operativa,
    h_get_controlli_audit_sorv_percontodi.id_asl_struttura,
    h_get_controlli_audit_sorv_percontodi.codice_interno_univoco_uo,
    regexp_replace((h_get_controlli_audit_sorv_percontodi.area_appartenenza_uo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS area_appartenenza_uo
   FROM "Analisi_dev".h_get_controlli_audit_sorv_percontodi
  WHERE (upper_inf(h_get_controlli_audit_sorv_percontodi.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_audit_sorv_percontodi_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_audit_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_audit_validi AS
 SELECT h_get_controlli_audit.id_controllo,
    h_get_controlli_audit.data_inserimento,
    h_get_controlli_audit.data_inizio_controllo,
    h_get_controlli_audit.data_chiusura_controllo,
    h_get_controlli_audit.data_fine_controllo,
    h_get_controlli_audit.id_stato_controllo,
    regexp_replace(h_get_controlli_audit.stato_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_controllo,
    regexp_replace((h_get_controlli_audit.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_get_controlli_audit.riferimento_id,
    regexp_replace(h_get_controlli_audit.riferimento_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_nome_tab,
    h_get_controlli_audit.id_asl,
    regexp_replace(h_get_controlli_audit.congruo_supervisione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS congruo_supervisione,
    h_get_controlli_audit.supervisionato_in_data,
    h_get_controlli_audit.supervisionato_da,
    regexp_replace(h_get_controlli_audit.supervisione_note, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS supervisione_note,
    regexp_replace(h_get_controlli_audit.note, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note,
    h_get_controlli_audit.id_tecnica_cu,
    h_get_controlli_audit.punteggio,
    regexp_replace(h_get_controlli_audit.utente_inserimento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS utente_inserimento
   FROM "Analisi_dev".h_get_controlli_audit
  WHERE (upper_inf(h_get_controlli_audit.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_audit_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_congiunti_asl_crr_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_congiunti_asl_crr_validi AS
 SELECT h_get_controlli_congiunti_asl_crr.id_controllo_ufficiale,
    h_get_controlli_congiunti_asl_crr.id_tecnica_cu,
    regexp_replace(h_get_controlli_congiunti_asl_crr.nome_componente_nucleo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_componente_nucleo,
    regexp_replace((h_get_controlli_congiunti_asl_crr.ruolo_componente_nucleo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ruolo_componente_nucleo,
    regexp_replace(h_get_controlli_congiunti_asl_crr.gruppo_ruolo_componente_nucleo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS gruppo_ruolo_componente_nucleo
   FROM "Analisi_dev".h_get_controlli_congiunti_asl_crr
  WHERE (upper_inf(h_get_controlli_congiunti_asl_crr.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_congiunti_asl_crr_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_congiunti_asl_extra_asl_fdo_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_congiunti_asl_extra_asl_fdo_validi AS
 SELECT h_get_controlli_congiunti_asl_extra_asl_fdo.id_controllo_ufficiale,
    h_get_controlli_congiunti_asl_extra_asl_fdo.id_tecnica_cu,
    regexp_replace(h_get_controlli_congiunti_asl_extra_asl_fdo.nome_componente_nucleo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_componente_nucleo,
    regexp_replace((h_get_controlli_congiunti_asl_extra_asl_fdo.ruolo_componente_nucleo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ruolo_componente_nucleo,
    regexp_replace(h_get_controlli_congiunti_asl_extra_asl_fdo.gruppo_ruolo_componente_nucleo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS gruppo_ruolo_componente_nucleo
   FROM "Analisi_dev".h_get_controlli_congiunti_asl_extra_asl_fdo
  WHERE (upper_inf(h_get_controlli_congiunti_asl_extra_asl_fdo.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_congiunti_asl_extra_asl_fdo_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_congiunti_asl_extra_asl_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_congiunti_asl_extra_asl_validi AS
 SELECT h_get_controlli_congiunti_asl_extra_asl.id_controllo_ufficiale,
    h_get_controlli_congiunti_asl_extra_asl.id_tecnica_cu,
    regexp_replace(h_get_controlli_congiunti_asl_extra_asl.nome_componente_nucleo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_componente_nucleo,
    regexp_replace((h_get_controlli_congiunti_asl_extra_asl.ruolo_componente_nucleo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ruolo_componente_nucleo,
    regexp_replace(h_get_controlli_congiunti_asl_extra_asl.gruppo_ruolo_componente_nucleo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS gruppo_ruolo_componente_nucleo
   FROM "Analisi_dev".h_get_controlli_congiunti_asl_extra_asl
  WHERE (upper_inf(h_get_controlli_congiunti_asl_extra_asl.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_congiunti_asl_extra_asl_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_crr_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_crr_validi AS
 SELECT h_get_controlli_crr.id_controllo_ufficiale,
    h_get_controlli_crr.id_tecnica_cu,
    regexp_replace(h_get_controlli_crr.nome_componente_nucleo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_componente_nucleo,
    regexp_replace((h_get_controlli_crr.ruolo_componente_nucleo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ruolo_componente_nucleo,
    regexp_replace(h_get_controlli_crr.gruppo_ruolo_componente_nucleo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS gruppo_ruolo_componente_nucleo
   FROM "Analisi_dev".h_get_controlli_crr
  WHERE (upper_inf(h_get_controlli_crr.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_crr_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_extra_asl_fdo_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_extra_asl_fdo_validi AS
 SELECT h_get_controlli_extra_asl_fdo.id_controllo_ufficiale,
    h_get_controlli_extra_asl_fdo.id_tecnica_cu,
    regexp_replace(h_get_controlli_extra_asl_fdo.nome_componente_nucleo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_componente_nucleo,
    regexp_replace((h_get_controlli_extra_asl_fdo.ruolo_componente_nucleo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ruolo_componente_nucleo,
    regexp_replace(h_get_controlli_extra_asl_fdo.gruppo_ruolo_componente_nucleo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS gruppo_ruolo_componente_nucleo
   FROM "Analisi_dev".h_get_controlli_extra_asl_fdo
  WHERE (upper_inf(h_get_controlli_extra_asl_fdo.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_extra_asl_fdo_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_ispezioni_carni_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_ispezioni_carni_validi AS
 SELECT h_get_controlli_ispezioni_carni.id_controllo,
    h_get_controlli_ispezioni_carni.data_inserimento,
    h_get_controlli_ispezioni_carni.data_inizio_controllo,
    h_get_controlli_ispezioni_carni.data_chiusura_controllo,
    h_get_controlli_ispezioni_carni.data_fine_controllo,
    h_get_controlli_ispezioni_carni.id_stato_controllo,
    regexp_replace(h_get_controlli_ispezioni_carni.stato_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_controllo,
    regexp_replace((h_get_controlli_ispezioni_carni.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_get_controlli_ispezioni_carni.riferimento_id,
    regexp_replace(h_get_controlli_ispezioni_carni.riferimento_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_nome_tab,
    h_get_controlli_ispezioni_carni.id_asl,
    regexp_replace(h_get_controlli_ispezioni_carni.congruo_supervisione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS congruo_supervisione,
    h_get_controlli_ispezioni_carni.supervisionato_in_data,
    h_get_controlli_ispezioni_carni.supervisionato_da,
    regexp_replace(h_get_controlli_ispezioni_carni.supervisione_note, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS supervisione_note,
    regexp_replace(h_get_controlli_ispezioni_carni.note, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note,
    h_get_controlli_ispezioni_carni.id_tecnica_cu,
    h_get_controlli_ispezioni_carni.punteggio,
    regexp_replace(h_get_controlli_ispezioni_carni.utente_inserimento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS utente_inserimento
   FROM "Analisi_dev".h_get_controlli_ispezioni_carni
  WHERE (upper_inf(h_get_controlli_ispezioni_carni.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_ispezioni_carni_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_ispezioni_semplici_motivi_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_ispezioni_semplici_motivi_validi AS
 SELECT h_get_controlli_ispezioni_semplici_motivi.id_controllo,
    h_get_controlli_ispezioni_semplici_motivi.id_motivo_ispezione,
    h_get_controlli_ispezioni_semplici_motivi.id_piano,
    regexp_replace((h_get_controlli_ispezioni_semplici_motivi.descrizione_motivo_padre)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_motivo_padre,
    regexp_replace(h_get_controlli_ispezioni_semplici_motivi.descrizione_motivo_figlio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_motivo_figlio,
    regexp_replace(h_get_controlli_ispezioni_semplici_motivi.codice_interno_piano_attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_interno_piano_attivita,
    regexp_replace(h_get_controlli_ispezioni_semplici_motivi.alias_padre, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS alias_padre,
    regexp_replace(h_get_controlli_ispezioni_semplici_motivi.alias_indicatore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS alias_indicatore
   FROM "Analisi_dev".h_get_controlli_ispezioni_semplici_motivi
  WHERE (upper_inf(h_get_controlli_ispezioni_semplici_motivi.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_ispezioni_semplici_motivi_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_ispezioni_semplici_oggetto_del_controllo_valid; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_ispezioni_semplici_oggetto_del_controllo_valid AS
 SELECT h_get_controlli_ispezioni_semplici_oggetto_del_controllo.id_controllo,
    h_get_controlli_ispezioni_semplici_oggetto_del_controllo.id_oggetto_del_controllo,
    regexp_replace(h_get_controlli_ispezioni_semplici_oggetto_del_controllo.oggetto_del_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS oggetto_del_controllo,
    h_get_controlli_ispezioni_semplici_oggetto_del_controllo.id_macrocategoria,
    regexp_replace(h_get_controlli_ispezioni_semplici_oggetto_del_controllo.descrizione_macrocategoria, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_macrocategoria
   FROM "Analisi_dev".h_get_controlli_ispezioni_semplici_oggetto_del_controllo
  WHERE (upper_inf(h_get_controlli_ispezioni_semplici_oggetto_del_controllo.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_ispezioni_semplici_oggetto_del_controllo_valid OWNER TO postgres;

--
-- Name: vw_get_controlli_ispezioni_semplici_percontodi_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_ispezioni_semplici_percontodi_validi AS
 SELECT h_get_controlli_ispezioni_semplici_percontodi.id_controllo,
    h_get_controlli_ispezioni_semplici_percontodi.id_motivo_ispezione,
    h_get_controlli_ispezioni_semplici_percontodi.id_piano_ispezione,
    regexp_replace((h_get_controlli_ispezioni_semplici_percontodi.struttura_complessa)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS struttura_complessa,
    regexp_replace((h_get_controlli_ispezioni_semplici_percontodi.struttura_semplice)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS struttura_semplice,
    regexp_replace((h_get_controlli_ispezioni_semplici_percontodi.per_conto_di_completo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS per_conto_di_completo,
    h_get_controlli_ispezioni_semplici_percontodi.id_unita_operativa,
    h_get_controlli_ispezioni_semplici_percontodi.id_asl_struttura,
    h_get_controlli_ispezioni_semplici_percontodi.codice_interno_univoco_uo
   FROM "Analisi_dev".h_get_controlli_ispezioni_semplici_percontodi
  WHERE (upper_inf(h_get_controlli_ispezioni_semplici_percontodi.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_ispezioni_semplici_percontodi_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_ispezioni_semplici_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_ispezioni_semplici_validi AS
 SELECT h_get_controlli_ispezioni_semplici.id_controllo,
    h_get_controlli_ispezioni_semplici.data_inserimento,
    h_get_controlli_ispezioni_semplici.data_inizio_controllo,
    h_get_controlli_ispezioni_semplici.data_chiusura_controllo,
    h_get_controlli_ispezioni_semplici.data_fine_controllo,
    h_get_controlli_ispezioni_semplici.id_stato_controllo,
    regexp_replace(h_get_controlli_ispezioni_semplici.stato_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_controllo,
    h_get_controlli_ispezioni_semplici.id_asl,
    regexp_replace((h_get_controlli_ispezioni_semplici.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_get_controlli_ispezioni_semplici.riferimento_id,
    regexp_replace(h_get_controlli_ispezioni_semplici.riferimento_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_nome_tab,
    regexp_replace(h_get_controlli_ispezioni_semplici.congruo_supervisione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS congruo_supervisione,
    h_get_controlli_ispezioni_semplici.supervisionato_in_data,
    h_get_controlli_ispezioni_semplici.supervisionato_da,
    regexp_replace(h_get_controlli_ispezioni_semplici.supervisione_note, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS supervisione_note,
    regexp_replace(h_get_controlli_ispezioni_semplici.note, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note,
    h_get_controlli_ispezioni_semplici.id_tecnica_cu,
    regexp_replace(h_get_controlli_ispezioni_semplici.targa_matricola, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS targa_matricola,
    h_get_controlli_ispezioni_semplici.punteggio,
    regexp_replace(h_get_controlli_ispezioni_semplici.utente_inserimento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS utente_inserimento
   FROM "Analisi_dev".h_get_controlli_ispezioni_semplici
  WHERE (upper_inf(h_get_controlli_ispezioni_semplici.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_ispezioni_semplici_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_non_eseguito_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_non_eseguito_validi AS
 SELECT h_get_controlli_non_eseguito.id_controllo,
    h_get_controlli_non_eseguito.data_inserimento,
    h_get_controlli_non_eseguito.data_inizio_controllo,
    h_get_controlli_non_eseguito.data_chiusura_controllo,
    h_get_controlli_non_eseguito.data_fine_controllo,
    h_get_controlli_non_eseguito.id_stato_controllo,
    regexp_replace(h_get_controlli_non_eseguito.stato_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_controllo,
    regexp_replace((h_get_controlli_non_eseguito.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_get_controlli_non_eseguito.riferimento_id,
    regexp_replace(h_get_controlli_non_eseguito.riferimento_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_nome_tab,
    regexp_replace(h_get_controlli_non_eseguito.tipo_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_controllo,
    h_get_controlli_non_eseguito.id_asl,
    regexp_replace(h_get_controlli_non_eseguito.congruo_supervisione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS congruo_supervisione,
    h_get_controlli_non_eseguito.supervisionato_in_data,
    h_get_controlli_non_eseguito.supervisionato_da,
    regexp_replace(h_get_controlli_non_eseguito.supervisione_note, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS supervisione_note,
    regexp_replace(h_get_controlli_non_eseguito.note, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note,
    h_get_controlli_non_eseguito.id_tecnica_cu,
    h_get_controlli_non_eseguito.punteggio
   FROM "Analisi_dev".h_get_controlli_non_eseguito
  WHERE (upper_inf(h_get_controlli_non_eseguito.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_non_eseguito_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_nucleoispettivo_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_nucleoispettivo_validi AS
 SELECT h_get_controlli_nucleoispettivo.id_controllo,
    regexp_replace(h_get_controlli_nucleoispettivo.ruolo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ruolo,
    regexp_replace(h_get_controlli_nucleoispettivo.cognome, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cognome,
    regexp_replace(h_get_controlli_nucleoispettivo.nome, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome,
    h_get_controlli_nucleoispettivo.id_componente
   FROM "Analisi_dev".h_get_controlli_nucleoispettivo
  WHERE (upper_inf(h_get_controlli_nucleoispettivo.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_nucleoispettivo_validi OWNER TO postgres;

--
-- Name: vw_get_controlli_sorveglianze_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_controlli_sorveglianze_validi AS
 SELECT h_get_controlli_sorveglianze.id_controllo,
    h_get_controlli_sorveglianze.data_inserimento,
    h_get_controlli_sorveglianze.data_inizio_controllo,
    h_get_controlli_sorveglianze.data_chiusura_controllo,
    h_get_controlli_sorveglianze.data_fine_controllo,
    regexp_replace(h_get_controlli_sorveglianze.stato_controllo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_controllo,
    h_get_controlli_sorveglianze.id_stato_controllo,
    regexp_replace((h_get_controlli_sorveglianze.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_get_controlli_sorveglianze.riferimento_id,
    regexp_replace(h_get_controlli_sorveglianze.riferimento_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_nome_tab,
    h_get_controlli_sorveglianze.id_asl,
    h_get_controlli_sorveglianze.aggiornata_categoria,
    h_get_controlli_sorveglianze.categoria_rischio,
    h_get_controlli_sorveglianze.data_prossimo_controllo,
    regexp_replace(h_get_controlli_sorveglianze.congruo_supervisione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS congruo_supervisione,
    h_get_controlli_sorveglianze.supervisionato_in_data,
    h_get_controlli_sorveglianze.supervisionato_da,
    regexp_replace(h_get_controlli_sorveglianze.supervisione_note, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS supervisione_note,
    regexp_replace(h_get_controlli_sorveglianze.note, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note,
    h_get_controlli_sorveglianze.id_tecnica_cu,
    h_get_controlli_sorveglianze.punteggio,
    regexp_replace(h_get_controlli_sorveglianze.utente_inserimento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS utente_inserimento
   FROM "Analisi_dev".h_get_controlli_sorveglianze
  WHERE (upper_inf(h_get_controlli_sorveglianze.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_controlli_sorveglianze_validi OWNER TO postgres;

--
-- Name: vw_get_dati_scheda_piccioni_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_dati_scheda_piccioni_validi AS
 SELECT h_get_dati_scheda_piccioni.riferimento_id,
    regexp_replace(h_get_dati_scheda_piccioni.riferimento_id_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_tab,
    regexp_replace(h_get_dati_scheda_piccioni.cod_azienda, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cod_azienda,
    regexp_replace(h_get_dati_scheda_piccioni.id_fiscale_allevamento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS id_fiscale_allevamento,
    regexp_replace(h_get_dati_scheda_piccioni.partita_iva, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS partita_iva,
    regexp_replace(h_get_dati_scheda_piccioni.asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace(h_get_dati_scheda_piccioni.specie_allevata, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie_allevata,
    regexp_replace(h_get_dati_scheda_piccioni.stima_popolazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stima_popolazione,
    regexp_replace(h_get_dati_scheda_piccioni.utilizzo_sistemi, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS utilizzo_sistemi,
    regexp_replace(h_get_dati_scheda_piccioni.reti_protezione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS reti_protezione,
    regexp_replace(h_get_dati_scheda_piccioni.cannoncini_dissuasori, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cannoncini_dissuasori,
    regexp_replace(h_get_dati_scheda_piccioni.dissuasori_aghi, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS dissuasori_aghi,
    regexp_replace(h_get_dati_scheda_piccioni.dissuasori_sonori, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS dissuasori_sonori,
    regexp_replace(h_get_dati_scheda_piccioni.altro, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS altro
   FROM "Analisi_dev".h_get_dati_scheda_piccioni
  WHERE (upper_inf(h_get_dati_scheda_piccioni.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_dati_scheda_piccioni_validi OWNER TO postgres;

--
-- Name: vw_get_elenco_rifugi_pubblici_privati_digemon_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_elenco_rifugi_pubblici_privati_digemon_validi AS
 SELECT h_get_elenco_rifugi_pubblici_privati_digemon.id_rel_stab_lp,
    regexp_replace(h_get_elenco_rifugi_pubblici_privati_digemon.ragione_sociale_attuale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ragione_sociale_attuale,
    regexp_replace(h_get_elenco_rifugi_pubblici_privati_digemon.asl_attuale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_attuale,
    regexp_replace(h_get_elenco_rifugi_pubblici_privati_digemon.responsabile_attuale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS responsabile_attuale,
    regexp_replace(h_get_elenco_rifugi_pubblici_privati_digemon.pubblico_privato_attuale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS pubblico_privato_attuale,
    regexp_replace(h_get_elenco_rifugi_pubblici_privati_digemon.stato_attuale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_attuale,
    h_get_elenco_rifugi_pubblici_privati_digemon.capienza_attuale,
    h_get_elenco_rifugi_pubblici_privati_digemon.indice_attuale,
    h_get_elenco_rifugi_pubblici_privati_digemon.numero_soggetti_detenuti_data,
    h_get_elenco_rifugi_pubblici_privati_digemon.numero_soggetti_deceduti_data,
    h_get_elenco_rifugi_pubblici_privati_digemon.numero_trasferimenti_fuori_regione_data,
    h_get_elenco_rifugi_pubblici_privati_digemon.numero_adozioni_data,
    h_get_elenco_rifugi_pubblici_privati_digemon.numero_catture_trasferimento_presso_canile_data,
    h_get_elenco_rifugi_pubblici_privati_digemon.data_inizio_estrazione,
    h_get_elenco_rifugi_pubblici_privati_digemon.data_fine_estrazione
   FROM "Analisi_dev".h_get_elenco_rifugi_pubblici_privati_digemon
  WHERE (upper_inf(h_get_elenco_rifugi_pubblici_privati_digemon.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_elenco_rifugi_pubblici_privati_digemon_validi OWNER TO postgres;

--
-- Name: vw_get_esami_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_esami_validi AS
 SELECT regexp_replace(h_get_esami.tipo_richiedente, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_richiedente,
    regexp_replace(h_get_esami.richiedente_privato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS richiedente_privato,
    h_get_esami.richiedente_coincide_con_proprietario,
    regexp_replace(h_get_esami.richiedente_asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS richiedente_asl,
    regexp_replace(h_get_esami.richiedente_associazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS richiedente_associazione,
    regexp_replace(h_get_esami.richiedente_forza_pubblica_comando, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS richiedente_forza_pubblica_comando,
    regexp_replace(h_get_esami.richiedente_forza_pubblica_provincia, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS richiedente_forza_pubblica_provincia,
    regexp_replace(h_get_esami.richiedente_forza_pubblica_comune, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS richiedente_forza_pubblica_comune,
    regexp_replace(h_get_esami.richiedente_altro, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS richiedente_altro,
    regexp_replace(h_get_esami.sottotipo_macrocategoria, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS sottotipo_macrocategoria,
    regexp_replace(h_get_esami.tipo_esame, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_esame,
    regexp_replace(h_get_esami.apparato_esaminato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS apparato_esaminato,
    h_get_esami.data_richiesta,
    h_get_esami.id_utente_inserimento_esame,
    regexp_replace(h_get_esami.numero_accettazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS numero_accettazione,
    regexp_replace(h_get_esami.identificativo_animale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS identificativo_animale,
    regexp_replace(h_get_esami.specie_animale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie_animale,
    regexp_replace(h_get_esami.username_utente_apertura_accettazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS username_utente_apertura_accettazione,
    regexp_replace(h_get_esami.nominativo_utente_apertura_accettazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nominativo_utente_apertura_accettazione,
    regexp_replace(h_get_esami.numero_cc, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS numero_cc,
    h_get_esami.data_apertura_cc,
    regexp_replace(h_get_esami.username_utente_apertura_cc, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS username_utente_apertura_cc,
    regexp_replace(h_get_esami.nominativo_utente_apertura_cc, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nominativo_utente_apertura_cc,
    h_get_esami.data_chiusura_cc,
    regexp_replace(h_get_esami.clinica, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS clinica,
    h_get_esami.id_asl,
    regexp_replace(h_get_esami.asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace(h_get_esami.fascicolo_sanitario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS fascicolo_sanitario,
    regexp_replace(h_get_esami.tipo_intervento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_intervento,
    regexp_replace(h_get_esami.note_intervento_chirurgico, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note_intervento_chirurgico,
    regexp_replace(h_get_esami.macrocategoria_esame, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS macrocategoria_esame,
    regexp_replace(h_get_esami.username_utente_inserimento_esame, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS username_utente_inserimento_esame,
    regexp_replace(h_get_esami.nominativo_utente_inserimento_esame, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nominativo_utente_inserimento_esame
   FROM "Analisi_dev".h_get_esami
  WHERE (upper_inf(h_get_esami.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_esami_validi OWNER TO postgres;

--
-- Name: vw_get_info_macellazione_domicilio_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_info_macellazione_domicilio_validi AS
 SELECT h_get_info_macellazione_domicilio.idcontrollo,
    regexp_replace((h_get_info_macellazione_domicilio.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_get_info_macellazione_domicilio.data_inserimento_controllo,
    regexp_replace(h_get_info_macellazione_domicilio.controllo_documentale_effettuato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS controllo_documentale_effettuato,
    regexp_replace(h_get_info_macellazione_domicilio.num_capi_macellati, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS num_capi_macellati,
    regexp_replace(h_get_info_macellazione_domicilio.num_capi, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS num_capi,
    regexp_replace(h_get_info_macellazione_domicilio.data_acquisto_1, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_acquisto_1,
    regexp_replace(h_get_info_macellazione_domicilio.allev_origine_1, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS allev_origine_1,
    regexp_replace(h_get_info_macellazione_domicilio.data_acquisto_2, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_acquisto_2,
    regexp_replace(h_get_info_macellazione_domicilio.allev_origine_2, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS allev_origine_2,
    regexp_replace(h_get_info_macellazione_domicilio.data_acquisto_3, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_acquisto_3,
    regexp_replace(h_get_info_macellazione_domicilio.allev_origine_3, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS allev_origine_3,
    regexp_replace(h_get_info_macellazione_domicilio.codice_interno_piano, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_interno_piano,
    regexp_replace(h_get_info_macellazione_domicilio.data_acquisto_4, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_acquisto_4,
    regexp_replace(h_get_info_macellazione_domicilio.allev_origine_4, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS allev_origine_4
   FROM "Analisi_dev".h_get_info_macellazione_domicilio
  WHERE (upper_inf(h_get_info_macellazione_domicilio.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_info_macellazione_domicilio_validi OWNER TO postgres;

--
-- Name: vw_get_info_masterlist; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_info_masterlist AS
 SELECT t.codice_univoco,
    t.id_norma,
    t.codice_norma,
    t.id_macroarea,
    t.macroarea,
    t.codice_macroarea,
    t.id_aggregazione,
    t.aggregazione,
    t.codice_aggregazione,
    t.id_linea,
    t.attivita,
    t.codice_attivita,
    t.mobile,
    t.fisso,
    t.apicoltura,
    t.registrabili,
    t.riconoscibili,
    t.sintesis,
    t.bdu,
    t.vam,
    t.no_scia,
    t.categorizzabili,
    t.rev,
    t.categoria_rischio_default
   FROM public.dblink('dbname=gisa_fvg port=5432 host=127.0.0.1 user=postgres'::text, 'select * from digemon.get_info_masterlist(null)'::text) t(codice_univoco text, id_norma integer, codice_norma text, id_macroarea integer, macroarea text, codice_macroarea text, id_aggregazione integer, aggregazione text, codice_aggregazione text, id_linea integer, attivita text, codice_attivita text, mobile boolean, fisso boolean, apicoltura boolean, registrabili boolean, riconoscibili boolean, sintesis boolean, bdu boolean, vam boolean, no_scia boolean, categorizzabili boolean, rev integer, categoria_rischio_default integer);


ALTER TABLE "Analisi_dev".vw_get_info_masterlist OWNER TO postgres;

--
-- Name: vw_get_info_masterlist_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_info_masterlist_validi AS
 SELECT regexp_replace(h_get_info_masterlist.codice_univoco, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_univoco,
    h_get_info_masterlist.id_norma,
    regexp_replace(h_get_info_masterlist.codice_norma, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_norma,
    h_get_info_masterlist.id_macroarea,
    regexp_replace(h_get_info_masterlist.macroarea, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS macroarea,
    regexp_replace(h_get_info_masterlist.codice_macroarea, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_macroarea,
    h_get_info_masterlist.id_aggregazione,
    regexp_replace(h_get_info_masterlist.aggregazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS aggregazione,
    regexp_replace(h_get_info_masterlist.codice_aggregazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_aggregazione,
    h_get_info_masterlist.id_linea,
    regexp_replace(h_get_info_masterlist.attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS attivita,
    regexp_replace(h_get_info_masterlist.codice_attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_attivita,
    h_get_info_masterlist.mobile,
    h_get_info_masterlist.fisso,
    h_get_info_masterlist.apicoltura,
    h_get_info_masterlist.registrabili,
    h_get_info_masterlist.riconoscibili,
    h_get_info_masterlist.sintesis,
    h_get_info_masterlist.bdu,
    h_get_info_masterlist.vam,
    h_get_info_masterlist.no_scia,
    h_get_info_masterlist.categorizzabili,
    h_get_info_masterlist.rev,
    h_get_info_masterlist.categoria_rischio_default
   FROM "Analisi_dev".h_get_info_masterlist
  WHERE (upper_inf(h_get_info_masterlist.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_info_masterlist_validi OWNER TO postgres;

--
-- Name: vw_get_info_tecnica_cu_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_info_tecnica_cu_validi AS
 SELECT h_get_info_tecnica_cu.codice,
    regexp_replace((h_get_info_tecnica_cu.descrizione)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione,
    h_get_info_tecnica_cu.info_nc,
    h_get_info_tecnica_cu.info_campione
   FROM "Analisi_dev".h_get_info_tecnica_cu
  WHERE (upper_inf(h_get_info_tecnica_cu.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_info_tecnica_cu_validi OWNER TO postgres;

--
-- Name: vw_get_istopatologici_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_istopatologici_validi AS
 SELECT regexp_replace(h_get_istopatologici.numero_esame, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS numero_esame,
    h_get_istopatologici.data_richiesta,
    h_get_istopatologici.data_esito,
    h_get_istopatologici.sede_lesione_id,
    regexp_replace(h_get_istopatologici.sede_lesione_description, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS sede_lesione_description,
    h_get_istopatologici.tipo_diagnosi_id,
    regexp_replace(h_get_istopatologici.tipo_diagnosi_description, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tipo_diagnosi_description,
    h_get_istopatologici.outsidecc,
    regexp_replace(h_get_istopatologici.cc, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cc,
    h_get_istopatologici.asl_id,
    regexp_replace(h_get_istopatologici.asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace(h_get_istopatologici.clinica, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS clinica,
    regexp_replace(h_get_istopatologici.microchip, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS microchip,
    h_get_istopatologici.deceduto_non_anagrafe,
    h_get_istopatologici.asl_animale_id,
    regexp_replace(h_get_istopatologici.asl_animale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_animale,
    regexp_replace(h_get_istopatologici.specie_description, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie_description,
    h_get_istopatologici.specie_id,
    regexp_replace(h_get_istopatologici.username_utente_inserimento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS username_utente_inserimento,
    regexp_replace(h_get_istopatologici.utente_inserimento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS utente_inserimento,
    regexp_replace(h_get_istopatologici.username_utente_modifica, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS username_utente_modifica,
    regexp_replace(h_get_istopatologici.utente_modifica, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS utente_modifica
   FROM "Analisi_dev".h_get_istopatologici
  WHERE (upper_inf(h_get_istopatologici.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_istopatologici_validi OWNER TO postgres;

--
-- Name: vw_get_linee_attivita_controllo_test_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_linee_attivita_controllo_test_validi AS
 SELECT h_get_linee_attivita_controllo.rng,
    h_get_linee_attivita_controllo.id_controllo,
    h_get_linee_attivita_controllo.codice_linea,
    h_get_linee_attivita_controllo.attivita
   FROM "Analisi_dev".h_get_linee_attivita_controllo
  WHERE (upper_inf(h_get_linee_attivita_controllo.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_linee_attivita_controllo_test_validi OWNER TO postgres;

--
-- Name: vw_get_linee_attivita_controllo_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_linee_attivita_controllo_validi AS
 SELECT h_get_linee_attivita_controllo.id_controllo,
    regexp_replace(h_get_linee_attivita_controllo.codice_linea, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_linea,
    regexp_replace(h_get_linee_attivita_controllo.attivita, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS attivita,
    h_get_linee_attivita_controllo.id_linea
   FROM "Analisi_dev".h_get_linee_attivita_controllo
  WHERE (upper_inf(h_get_linee_attivita_controllo.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_linee_attivita_controllo_validi OWNER TO postgres;

--
-- Name: vw_get_necroscopie_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_necroscopie_validi AS
 SELECT h_get_necroscopie.data,
    regexp_replace(h_get_necroscopie.microchip, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS microchip,
    h_get_necroscopie.deceduto_non_anagrafe,
    regexp_replace(h_get_necroscopie.asl_animale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_animale,
    h_get_necroscopie.asl_animale_id,
    regexp_replace(h_get_necroscopie.specie, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie,
    h_get_necroscopie.specie_id,
    regexp_replace(h_get_necroscopie.cartella_clinica, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS cartella_clinica,
    regexp_replace(h_get_necroscopie.username_utente_richiesta, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS username_utente_richiesta,
    regexp_replace(h_get_necroscopie.nome_utente_richiesta, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome_utente_richiesta,
    regexp_replace(h_get_necroscopie.clinica, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS clinica,
    regexp_replace(h_get_necroscopie.asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_get_necroscopie.asl_id,
    regexp_replace(h_get_necroscopie.sala_settoria_destinazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS sala_settoria_destinazione,
    regexp_replace(h_get_necroscopie.comune_ritrovamento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune_ritrovamento
   FROM "Analisi_dev".h_get_necroscopie
  WHERE (upper_inf(h_get_necroscopie.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_necroscopie_validi OWNER TO postgres;

--
-- Name: vw_get_occupazione_canili_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_occupazione_canili_validi AS
 SELECT h_get_occupazione_canili.id_rel_stab_lp,
    regexp_replace(h_get_occupazione_canili.ragione_sociale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ragione_sociale,
    regexp_replace(h_get_occupazione_canili.asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    regexp_replace(h_get_occupazione_canili.partita_iva, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS partita_iva,
    regexp_replace(h_get_occupazione_canili.indirizzo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo,
    regexp_replace(h_get_occupazione_canili.indice, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indice,
    regexp_replace(h_get_occupazione_canili.stato, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato,
    h_get_occupazione_canili.numero_cani_vivi,
    h_get_occupazione_canili.num_cani_proprietari_privati,
    h_get_occupazione_canili.num_cani_proprietari_sindaci,
    h_get_occupazione_canili.num_cani_proprietari_altri,
    h_get_occupazione_canili.posti_disponibili_cani_giganti,
    h_get_occupazione_canili.numero_cani_vivi_disponibile_limite_350,
    h_get_occupazione_canili.numero_cani_vivi_eccesso_limite_350
   FROM "Analisi_dev".h_get_occupazione_canili
  WHERE (upper_inf(h_get_occupazione_canili.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_occupazione_canili_validi OWNER TO postgres;

--
-- Name: vw_get_osa_mai_controllati_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_osa_mai_controllati_validi AS
 SELECT h_get_osa_mai_controllati.riferimento_id,
    regexp_replace(h_get_osa_mai_controllati.riferimento_id_nome, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome,
    regexp_replace(h_get_osa_mai_controllati.riferimento_id_nome_col, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_col,
    regexp_replace(h_get_osa_mai_controllati.riferimento_id_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_tab,
    regexp_replace((h_get_osa_mai_controllati.ragione_sociale)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ragione_sociale,
    h_get_osa_mai_controllati.asl_rif,
    regexp_replace((h_get_osa_mai_controllati.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_get_osa_mai_controllati.id_norma,
    regexp_replace(h_get_osa_mai_controllati.codice_norma, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_norma,
    regexp_replace(h_get_osa_mai_controllati.norma, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS norma,
    regexp_replace(h_get_osa_mai_controllati.codice_fiscale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale,
    regexp_replace((h_get_osa_mai_controllati.n_reg)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS n_reg,
    regexp_replace((h_get_osa_mai_controllati.num_riconoscimento)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS num_riconoscimento,
    regexp_replace(h_get_osa_mai_controllati.partita_iva, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS partita_iva,
    regexp_replace((h_get_osa_mai_controllati.comune)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune,
    regexp_replace((h_get_osa_mai_controllati.provincia_stab)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS provincia_stab,
    regexp_replace((h_get_osa_mai_controllati.indirizzo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo,
    h_get_osa_mai_controllati.latitudine_stab,
    h_get_osa_mai_controllati.longitudine_stab,
    regexp_replace((h_get_osa_mai_controllati.codice_fiscale_rappresentante)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale_rappresentante,
    regexp_replace(h_get_osa_mai_controllati.nominativo_rappresentante, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nominativo_rappresentante,
    h_get_osa_mai_controllati.data_inizio_attivita,
    h_get_osa_mai_controllati.data_fine_attivita
   FROM "Analisi_dev".h_get_osa_mai_controllati
  WHERE (upper_inf(h_get_osa_mai_controllati.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_osa_mai_controllati_validi OWNER TO postgres;

--
-- Name: vw_get_osa_non_controllati_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_osa_non_controllati_validi AS
 SELECT h_get_osa_non_controllati.riferimento_id,
    regexp_replace(h_get_osa_non_controllati.riferimento_id_nome, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome,
    regexp_replace(h_get_osa_non_controllati.riferimento_id_nome_col, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_col,
    regexp_replace(h_get_osa_non_controllati.riferimento_id_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_tab,
    regexp_replace((h_get_osa_non_controllati.ragione_sociale)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ragione_sociale,
    h_get_osa_non_controllati.asl_rif,
    regexp_replace((h_get_osa_non_controllati.asl)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_get_osa_non_controllati.id_norma,
    regexp_replace(h_get_osa_non_controllati.codice_norma, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_norma,
    regexp_replace(h_get_osa_non_controllati.norma, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS norma,
    regexp_replace(h_get_osa_non_controllati.codice_fiscale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale,
    regexp_replace((h_get_osa_non_controllati.n_reg)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS n_reg,
    regexp_replace((h_get_osa_non_controllati.num_riconoscimento)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS num_riconoscimento,
    regexp_replace(h_get_osa_non_controllati.partita_iva, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS partita_iva,
    regexp_replace((h_get_osa_non_controllati.comune)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune,
    regexp_replace((h_get_osa_non_controllati.provincia_stab)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS provincia_stab,
    regexp_replace((h_get_osa_non_controllati.indirizzo)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo,
    h_get_osa_non_controllati.latitudine_stab,
    h_get_osa_non_controllati.longitudine_stab,
    regexp_replace((h_get_osa_non_controllati.codice_fiscale_rappresentante)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS codice_fiscale_rappresentante,
    regexp_replace(h_get_osa_non_controllati.nominativo_rappresentante, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nominativo_rappresentante,
    h_get_osa_non_controllati.categoria_rischio,
    h_get_osa_non_controllati.prossimo_controllo,
    h_get_osa_non_controllati.data_inizio_attivita,
    h_get_osa_non_controllati.data_fine_attivita,
    h_get_osa_non_controllati.ultimo_controllo
   FROM "Analisi_dev".h_get_osa_non_controllati
  WHERE (upper_inf(h_get_osa_non_controllati.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_osa_non_controllati_validi OWNER TO postgres;

--
-- Name: vw_get_registro_trasgressori_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_registro_trasgressori_validi AS
 SELECT regexp_replace(h_get_registro_trasgressori.num_progressivo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS num_progressivo,
    h_get_registro_trasgressori.id_controllo,
    h_get_registro_trasgressori.anno_controllo,
    regexp_replace(h_get_registro_trasgressori.asl_competenza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_competenza,
    regexp_replace(h_get_registro_trasgressori.ente_accertatore_1, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ente_accertatore_1,
    regexp_replace(h_get_registro_trasgressori.ente_accertatore_2, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ente_accertatore_2,
    regexp_replace(h_get_registro_trasgressori.ente_accertatore_3, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ente_accertatore_3,
    regexp_replace(h_get_registro_trasgressori.pv_numero, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS pv_numero,
    regexp_replace(h_get_registro_trasgressori.sequestro_numero, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS sequestro_numero,
    regexp_replace(h_get_registro_trasgressori.data_accertamento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_accertamento,
    regexp_replace(h_get_registro_trasgressori.data_protocollo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_protocollo,
    regexp_replace(h_get_registro_trasgressori.trasgressore, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS trasgressore,
    regexp_replace(h_get_registro_trasgressori.obbligato_in_solido, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS obbligato_in_solido,
    regexp_replace(h_get_registro_trasgressori.importo_sanzione_ridotta, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS importo_sanzione_ridotta,
    regexp_replace(h_get_registro_trasgressori.importo_sanzione_ridotta_del_30_percento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS importo_sanzione_ridotta_del_30_percento,
    regexp_replace(h_get_registro_trasgressori.illecito_competenza_uod, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS illecito_competenza_uod,
    regexp_replace(h_get_registro_trasgressori.data_ultima_notifica, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_ultima_notifica,
    regexp_replace(h_get_registro_trasgressori.pv_oblato_misura_ridotta, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS pv_oblato_misura_ridotta,
    h_get_registro_trasgressori.importo_effettivamente_introitato_1,
    regexp_replace(h_get_registro_trasgressori.data_pagamento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_pagamento,
    regexp_replace(h_get_registro_trasgressori.pagamento_effettuato_nei_termini, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS pagamento_effettuato_nei_termini,
    regexp_replace(h_get_registro_trasgressori.funzionario_assegnatario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS funzionario_assegnatario,
    regexp_replace(h_get_registro_trasgressori.presentati_scritti_difensivi, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS presentati_scritti_difensivi,
    regexp_replace(h_get_registro_trasgressori.presentata_richiesta_riduzione_rateizzazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS presentata_richiesta_riduzione_rateizzazione,
    regexp_replace(h_get_registro_trasgressori.presentata_richiesta_audizione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS presentata_richiesta_audizione,
    regexp_replace(h_get_registro_trasgressori.ordinanza_emessa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ordinanza_emessa,
    regexp_replace(h_get_registro_trasgressori.num_ordinanza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS num_ordinanza,
    regexp_replace(h_get_registro_trasgressori.data_emissione_ordinanza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_emissione_ordinanza,
    h_get_registro_trasgressori.giorni_lavorazione_pratica,
    h_get_registro_trasgressori.importo_sanzione_ingiunta,
    regexp_replace(h_get_registro_trasgressori.data_ultima_notifica_ordinanza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_ultima_notifica_ordinanza,
    regexp_replace(h_get_registro_trasgressori.data_pagamento_ordinanza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS data_pagamento_ordinanza,
    regexp_replace(h_get_registro_trasgressori.concessa_rateizzazione, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS concessa_rateizzazione,
    regexp_replace(h_get_registro_trasgressori.rate_pagate, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS rate_pagate,
    regexp_replace(h_get_registro_trasgressori.ordinanza_ingiunzione_oblata, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ordinanza_ingiunzione_oblata,
    h_get_registro_trasgressori.importo_effettivamente_introitato_2,
    regexp_replace(h_get_registro_trasgressori.presentata_opposizione_ordinanza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS presentata_opposizione_ordinanza,
    regexp_replace(h_get_registro_trasgressori.sentenza_favorevole_ricorrente, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS sentenza_favorevole_ricorrente,
    h_get_registro_trasgressori.importo_stabilito_ag,
    regexp_replace(h_get_registro_trasgressori.ordinanza_oblata_secondo_sentenza, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ordinanza_oblata_secondo_sentenza,
    h_get_registro_trasgressori.importo_effettivamente_introitato_3,
    regexp_replace(h_get_registro_trasgressori.avviata_esecuzione_forzata, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS avviata_esecuzione_forzata,
    h_get_registro_trasgressori.importo_effettivamente_introitato_4,
    regexp_replace(h_get_registro_trasgressori.note_gruppo_1, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note_gruppo_1,
    regexp_replace(h_get_registro_trasgressori.note_gruppo_2, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS note_gruppo_2,
    regexp_replace(h_get_registro_trasgressori.pratica_chiusa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS pratica_chiusa
   FROM "Analisi_dev".h_get_registro_trasgressori
  WHERE (upper_inf(h_get_registro_trasgressori.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_registro_trasgressori_validi OWNER TO postgres;

--
-- Name: vw_get_registro_unico_cani_aggressori_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_registro_unico_cani_aggressori_validi AS
 SELECT regexp_replace(h_get_registro_unico_cani_aggressori.microchip, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS microchip,
    regexp_replace(h_get_registro_unico_cani_aggressori.tatuaggio, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS tatuaggio,
    regexp_replace(h_get_registro_unico_cani_aggressori.proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS proprietario,
    regexp_replace(h_get_registro_unico_cani_aggressori.asl_proprietario, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_proprietario,
    h_get_registro_unico_cani_aggressori.id_evento,
    h_get_registro_unico_cani_aggressori.data_inserimento_registrazione,
    h_get_registro_unico_cani_aggressori.data_registrazione,
    regexp_replace(h_get_registro_unico_cani_aggressori.evento, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS evento,
    h_get_registro_unico_cani_aggressori.anno,
    h_get_registro_unico_cani_aggressori.id_cu,
    regexp_replace(h_get_registro_unico_cani_aggressori.misure_formative, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS misure_formative,
    regexp_replace(h_get_registro_unico_cani_aggressori.misure_riabilitative, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS misure_riabilitative,
    regexp_replace(h_get_registro_unico_cani_aggressori.misure_restrittive, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS misure_restrittive
   FROM "Analisi_dev".h_get_registro_unico_cani_aggressori
  WHERE (upper_inf(h_get_registro_unico_cani_aggressori.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_registro_unico_cani_aggressori_validi OWNER TO postgres;

--
-- Name: vw_get_smaltimento_carogna_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_smaltimento_carogna_validi AS
 SELECT regexp_replace(h_get_smaltimento_carogna.mc, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS mc,
    h_get_smaltimento_carogna.deceduto_non_anagrafe,
    h_get_smaltimento_carogna.data_smaltimento_carogna,
    regexp_replace(h_get_smaltimento_carogna.ddt, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ddt,
    regexp_replace(h_get_smaltimento_carogna.ditta_autorizzata, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS ditta_autorizzata,
    regexp_replace(h_get_smaltimento_carogna.asl, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl,
    h_get_smaltimento_carogna.asl_id,
    regexp_replace(h_get_smaltimento_carogna.specie, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS specie,
    h_get_smaltimento_carogna.specie_id,
    h_get_smaltimento_carogna.asl_animale_id,
    regexp_replace(h_get_smaltimento_carogna.asl_animale, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS asl_animale
   FROM "Analisi_dev".h_get_smaltimento_carogna
  WHERE (upper_inf(h_get_smaltimento_carogna.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_smaltimento_carogna_validi OWNER TO postgres;

--
-- Name: vw_get_stato_diffide_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_stato_diffide_validi AS
 SELECT h_get_stato_diffide.riferimento_id,
    regexp_replace(h_get_stato_diffide.riferimento_id_nome_tab, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS riferimento_id_nome_tab,
    h_get_stato_diffide.id_diffida,
    h_get_stato_diffide.id_controllo_ufficiale,
    h_get_stato_diffide.data_diffida,
    regexp_replace(h_get_stato_diffide.norma_diffida, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS norma_diffida,
    regexp_replace(h_get_stato_diffide.stato_diffida, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS stato_diffida
   FROM "Analisi_dev".h_get_stato_diffide
  WHERE (upper_inf(h_get_stato_diffide.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_stato_diffide_validi OWNER TO postgres;

--
-- Name: vw_get_tipologia_cu_e_sottoattivita_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_get_tipologia_cu_e_sottoattivita_validi AS
 SELECT h_get_tipologia_cu_e_sottoattivita.code,
    regexp_replace((h_get_tipologia_cu_e_sottoattivita.description)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS description
   FROM "Analisi_dev".h_get_tipologia_cu_e_sottoattivita
  WHERE (upper_inf(h_get_tipologia_cu_e_sottoattivita.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_get_tipologia_cu_e_sottoattivita_validi OWNER TO postgres;

--
-- Name: vw_gisa_controlli_ufficiali_new; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".vw_gisa_controlli_ufficiali_new (
    id_controllo integer,
    codice_linea text,
    id_motivo bigint,
    id_unita_operativa integer,
    data_inizio_controllo timestamp without time zone,
    riferimento_id bigint,
    riferimento_nome_tab text,
    eseguiti bigint,
    fonte text,
    id_motivo_originale bigint,
    id_norma integer
);


ALTER TABLE "Analisi_dev".vw_gisa_controlli_ufficiali_new OWNER TO postgres;

--
-- Name: vw_gisa_controlli_ufficiali_new_2; Type: TABLE; Schema: Analisi_dev; Owner: postgres
--

CREATE TABLE "Analisi_dev".vw_gisa_controlli_ufficiali_new_2 (
    id_controllo integer,
    codice_linea text,
    id_motivo bigint,
    id_unita_operativa integer,
    data_inizio_controllo timestamp without time zone,
    riferimento_id bigint,
    riferimento_nome_tab text,
    eseguiti bigint,
    fonte text,
    id_motivo_originale bigint,
    id_norma integer
);


ALTER TABLE "Analisi_dev".vw_gisa_controlli_ufficiali_new_2 OWNER TO postgres;

--
-- Name: vw_macroarea_ref; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_macroarea_ref AS
 WITH RECURSIVE m_r(id, id_gisa, codice, descrizione, parent, id_ref) AS (
         SELECT m.id,
            m.id_gisa,
            m.codice,
            m.descrizione,
            m.parent,
            m.id AS id_ref
           FROM "Analisi_dev".macroarea m
        UNION ALL
         SELECT m_r_1.id,
            m_r_1.id_gisa,
            m2.codice,
            m2.descrizione,
            m2.parent,
            m2.parent AS id_ref
           FROM ("Analisi_dev".macroarea m2
             JOIN m_r m_r_1 ON ((m_r_1.id_ref = m2.id)))
        )
 SELECT m_r.id,
    m_r.id_gisa,
    m_r.codice,
    m_r.descrizione,
    m_r.parent,
    m_r.id_ref
   FROM m_r;


ALTER TABLE "Analisi_dev".vw_macroarea_ref OWNER TO postgres;

--
-- Name: vw_macroarea_ref_full; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_macroarea_ref_full AS
 SELECT ((((mr3.codice || '-'::text) || mr2.codice) || '-'::text) || mr.codice) AS codice,
    mr.id_ref
   FROM ((("Analisi_dev".vw_macroarea_ref mr
     JOIN "Analisi_dev".vw_macroarea_ref mr2 ON ((mr.parent = mr2.id_gisa)))
     JOIN "Analisi_dev".vw_macroarea_ref mr3 ON ((mr2.parent = mr3.id_gisa)))
     JOIN "Analisi_dev".vw_macroarea_ref mr4 ON ((mr3.parent = mr4.id_gisa)));


ALTER TABLE "Analisi_dev".vw_macroarea_ref_full OWNER TO postgres;

--
-- Name: vw_oia_nodo; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_oia_nodo AS
 SELECT t.id,
    t.id_padre,
    t.id_asl,
    t.descrizione_lunga,
    t.n_livello,
    t.entered,
    t.entered_by,
    t.modified,
    t.modified_by,
    t.trashed_date,
    t.tipologia_struttura,
    t.comune,
    t.enabled,
    t.obsoleto,
    t.confermato,
    t.id_strumento_calcolo,
    t.codice_interno_fk,
    t.nome,
    t.id_utente,
    t.mail,
    t.indirizzo,
    t.delegato,
    t.descrizione_comune,
    t.id_oia_nodo_temp,
    t.data_scadenza,
    t.disabilitata,
    t.stato,
    t.anno,
    t.descrizione_area_struttura_complessa,
    t.id_lookup_area_struttura_asl,
    t.ui_struttura_foglio_att_iniziale,
    t.ui_struttura_foglio_att_finale,
    t.id_utente_edit,
    t.percentuale_area_a,
    t.stato_all2,
    t.stato_all6,
    t.codice_interno_univoco,
    t.descrizione_area_struttura,
    t.data_congelamento
   FROM public.dblink('dbname=gisa_fvg port=5432 host=127.0.0.1 user=postgres'::text, 'select * from public.oia_nodo'::text) t(id integer, id_padre integer, id_asl integer, descrizione_lunga character varying, n_livello smallint, entered timestamp with time zone, entered_by integer, modified timestamp with time zone, modified_by integer, trashed_date timestamp with time zone, tipologia_struttura integer, comune text, enabled boolean, obsoleto boolean, confermato boolean, id_strumento_calcolo integer, codice_interno_fk integer, nome character varying, id_utente integer, mail text, indirizzo text, delegato integer, descrizione_comune text, id_oia_nodo_temp integer, data_scadenza timestamp without time zone, disabilitata boolean, stato integer, anno integer, descrizione_area_struttura_complessa text, id_lookup_area_struttura_asl integer, ui_struttura_foglio_att_iniziale integer, ui_struttura_foglio_att_finale integer, id_utente_edit integer, percentuale_area_a integer, stato_all2 integer, stato_all6 integer, codice_interno_univoco integer, descrizione_area_struttura character varying, data_congelamento timestamp without time zone);


ALTER TABLE "Analisi_dev".vw_oia_nodo OWNER TO postgres;

--
-- Name: vw_oia_nodo_validi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_oia_nodo_validi AS
 SELECT h_oia_nodo.id,
    h_oia_nodo.id_padre,
    h_oia_nodo.id_asl,
    regexp_replace((h_oia_nodo.descrizione_lunga)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_lunga,
    h_oia_nodo.n_livello,
    h_oia_nodo.entered,
    h_oia_nodo.entered_by,
    h_oia_nodo.modified,
    h_oia_nodo.modified_by,
    h_oia_nodo.trashed_date,
    h_oia_nodo.tipologia_struttura,
    regexp_replace(h_oia_nodo.comune, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS comune,
    h_oia_nodo.enabled,
    h_oia_nodo.obsoleto,
    h_oia_nodo.confermato,
    h_oia_nodo.id_strumento_calcolo,
    h_oia_nodo.codice_interno_fk,
    regexp_replace((h_oia_nodo.nome)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS nome,
    h_oia_nodo.id_utente,
    regexp_replace(h_oia_nodo.mail, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS mail,
    regexp_replace(h_oia_nodo.indirizzo, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS indirizzo,
    h_oia_nodo.delegato,
    regexp_replace(h_oia_nodo.descrizione_comune, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_comune,
    h_oia_nodo.id_oia_nodo_temp,
    h_oia_nodo.data_scadenza,
    h_oia_nodo.disabilitata,
    h_oia_nodo.stato,
    h_oia_nodo.anno,
    regexp_replace(h_oia_nodo.descrizione_area_struttura_complessa, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_area_struttura_complessa,
    h_oia_nodo.id_lookup_area_struttura_asl,
    h_oia_nodo.ui_struttura_foglio_att_iniziale,
    h_oia_nodo.ui_struttura_foglio_att_finale,
    h_oia_nodo.id_utente_edit,
    h_oia_nodo.percentuale_area_a,
    h_oia_nodo.stato_all2,
    h_oia_nodo.stato_all6,
    h_oia_nodo.codice_interno_univoco,
    regexp_replace((h_oia_nodo.descrizione_area_struttura)::text, '[\r\n\t\v]'::text, ''::text, 'g'::text) AS descrizione_area_struttura,
    h_oia_nodo.data_congelamento
   FROM "Analisi_dev".h_oia_nodo
  WHERE (upper_inf(h_oia_nodo.rng) IS TRUE);


ALTER TABLE "Analisi_dev".vw_oia_nodo_validi OWNER TO postgres;

--
-- Name: vw_oia_nodo_attivi; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_oia_nodo_attivi AS
 SELECT a.id,
    a.id_padre,
    a.id_asl,
    a.descrizione_lunga,
    a.n_livello,
    a.entered,
    a.entered_by,
    a.modified,
    a.modified_by,
    a.trashed_date,
    a.tipologia_struttura,
    a.comune,
    a.enabled,
    a.obsoleto,
    a.confermato,
    a.id_strumento_calcolo,
    a.codice_interno_fk,
    a.nome,
    a.id_utente,
    a.mail,
    a.indirizzo,
    a.delegato,
    a.descrizione_comune,
    a.id_oia_nodo_temp,
    a.data_scadenza,
    a.disabilitata,
    a.stato,
    a.anno,
    a.descrizione_area_struttura_complessa,
    a.id_lookup_area_struttura_asl,
    a.ui_struttura_foglio_att_iniziale,
    a.ui_struttura_foglio_att_finale,
    a.id_utente_edit,
    a.percentuale_area_a,
    a.stato_all2,
    a.stato_all6,
    a.codice_interno_univoco,
    a.descrizione_area_struttura,
    a.data_congelamento,
    a.pos
   FROM ( SELECT vw_oia_nodo_validi.id,
            vw_oia_nodo_validi.id_padre,
            vw_oia_nodo_validi.id_asl,
            vw_oia_nodo_validi.descrizione_lunga,
            vw_oia_nodo_validi.n_livello,
            vw_oia_nodo_validi.entered,
            vw_oia_nodo_validi.entered_by,
            vw_oia_nodo_validi.modified,
            vw_oia_nodo_validi.modified_by,
            vw_oia_nodo_validi.trashed_date,
            vw_oia_nodo_validi.tipologia_struttura,
            vw_oia_nodo_validi.comune,
            vw_oia_nodo_validi.enabled,
            vw_oia_nodo_validi.obsoleto,
            vw_oia_nodo_validi.confermato,
            vw_oia_nodo_validi.id_strumento_calcolo,
            vw_oia_nodo_validi.codice_interno_fk,
            vw_oia_nodo_validi.nome,
            vw_oia_nodo_validi.id_utente,
            vw_oia_nodo_validi.mail,
            vw_oia_nodo_validi.indirizzo,
            vw_oia_nodo_validi.delegato,
            vw_oia_nodo_validi.descrizione_comune,
            vw_oia_nodo_validi.id_oia_nodo_temp,
            vw_oia_nodo_validi.data_scadenza,
            vw_oia_nodo_validi.disabilitata,
            vw_oia_nodo_validi.stato,
            vw_oia_nodo_validi.anno,
            vw_oia_nodo_validi.descrizione_area_struttura_complessa,
            vw_oia_nodo_validi.id_lookup_area_struttura_asl,
            vw_oia_nodo_validi.ui_struttura_foglio_att_iniziale,
            vw_oia_nodo_validi.ui_struttura_foglio_att_finale,
            vw_oia_nodo_validi.id_utente_edit,
            vw_oia_nodo_validi.percentuale_area_a,
            vw_oia_nodo_validi.stato_all2,
            vw_oia_nodo_validi.stato_all6,
            vw_oia_nodo_validi.codice_interno_univoco,
            vw_oia_nodo_validi.descrizione_area_struttura,
            vw_oia_nodo_validi.data_congelamento,
            row_number() OVER (PARTITION BY vw_oia_nodo_validi.codice_interno_univoco, vw_oia_nodo_validi.anno ORDER BY COALESCE(vw_oia_nodo_validi.data_scadenza, '3000-01-01 00:00:00'::timestamp without time zone) DESC) AS pos
           FROM "Analisi_dev".vw_oia_nodo_validi
          WHERE ((vw_oia_nodo_validi.stato = ANY (ARRAY[0, 2])) AND (NOT vw_oia_nodo_validi.disabilitata) AND (vw_oia_nodo_validi.data_scadenza IS NULL) AND (vw_oia_nodo_validi.anno > 0) AND (vw_oia_nodo_validi.anno IS NOT NULL) AND (vw_oia_nodo_validi.trashed_date IS NULL))) a
  WHERE (a.pos = 1);


ALTER TABLE "Analisi_dev".vw_oia_nodo_attivi OWNER TO postgres;

--
-- Name: formule_20201020; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.formule_20201020 (
    id bigint NOT NULL,
    descrizione text NOT NULL,
    testo text NOT NULL,
    contiene_uba boolean NOT NULL,
    valida_ups boolean NOT NULL,
    valida_uba boolean NOT NULL,
    fattore_fin double precision NOT NULL
);


ALTER TABLE matrix.formule_20201020 OWNER TO postgres;

--
-- Name: struttura_piani_old; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piani_old (
    id bigint NOT NULL,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    parent bigint,
    alias text,
    path_ord text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    fattore_ups double precision,
    fattore_uba double precision,
    descrizione_breve character varying,
    ha_campioni boolean,
    id_tipo_tecnica bigint
);


ALTER TABLE matrix.struttura_piani_old OWNER TO postgres;

--
-- Name: vw_struttura_piani_ref_no_rend; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_struttura_piani_ref_no_rend AS
 WITH RECURSIVE p_r(id, cod_raggruppamento, anno, descrizione, ordinamento, data_scadenza, stato, codice_interno, color, path, livello, parent, alias, path_ord, id_formula_ups, id_formula_uba, fattore_ups, fattore_uba, descrizione_breve, id_ref) AS (
         SELECT struttura_piani_old.id,
            struttura_piani_old.cod_raggruppamento,
            struttura_piani_old.anno,
            struttura_piani_old.descrizione,
            struttura_piani_old.ordinamento,
            struttura_piani_old.data_scadenza,
            struttura_piani_old.stato,
            struttura_piani_old.codice_interno,
            struttura_piani_old.color,
            struttura_piani_old.path,
            struttura_piani_old.livello,
            struttura_piani_old.parent,
            struttura_piani_old.alias,
            struttura_piani_old.path_ord,
            struttura_piani_old.id_formula_ups,
            struttura_piani_old.id_formula_uba,
            fu.fattore_fin AS fattore_ups,
            fb.fattore_fin AS fattore_uba,
            struttura_piani_old.descrizione_breve,
            struttura_piani_old.id AS id_ref
           FROM ((matrix.struttura_piani_old
             LEFT JOIN matrix.formule_20201020 fu ON ((fu.id = struttura_piani_old.id_formula_ups)))
             LEFT JOIN matrix.formule_20201020 fb ON (((fb.id = struttura_piani_old.id_formula_uba) AND (NOT (struttura_piani_old.id IN ( SELECT r.id_piano
                   FROM "Analisi_dev".piano_no_rend r))))))
        UNION ALL
         SELECT p_r_1.id,
            p2.cod_raggruppamento,
            p2.anno,
            p2.descrizione,
            p2.ordinamento,
            p2.data_scadenza,
            p2.stato,
            p2.codice_interno,
            p2.color,
            p2.path,
            p2.livello,
            p2.parent,
            p2.alias,
            p2.path_ord,
            p2.id_formula_ups,
            p2.id_formula_uba,
            p_r_1.fattore_ups,
            p_r_1.fattore_uba,
            p2.descrizione_breve,
            p.parent
           FROM ((matrix.struttura_piani_old p
             JOIN p_r p_r_1 ON ((p_r_1.id_ref = p.id)))
             JOIN matrix.struttura_piani_old p2 ON ((p.parent = p2.id)))
          WHERE ((p.parent IS NOT NULL) AND (NOT (p.id IN ( SELECT r.id_piano
                   FROM "Analisi_dev".piano_no_rend r))))
        )
 SELECT p_r.id,
    p_r.cod_raggruppamento,
    p_r.anno,
    p_r.descrizione,
    p_r.ordinamento,
    p_r.data_scadenza,
    p_r.stato,
    p_r.codice_interno,
    p_r.color,
    p_r.path,
    p_r.livello,
    p_r.parent,
    p_r.alias,
    p_r.path_ord,
    p_r.id_formula_ups,
    p_r.id_formula_uba,
    p_r.fattore_ups,
    p_r.fattore_uba,
    p_r.descrizione_breve,
    p_r.id_ref
   FROM p_r;


ALTER TABLE "Analisi_dev".vw_struttura_piani_ref_no_rend OWNER TO postgres;

--
-- Name: formule; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.formule (
    id bigint,
    descrizione text,
    testo text,
    contiene_uba boolean,
    valida_ups boolean,
    valida_uba boolean,
    fattore_fin double precision
);


ALTER TABLE matrix.formule OWNER TO postgres;

--
-- Name: struttura_piani; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piani (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying,
    ha_campioni boolean DEFAULT false,
    id_tipo_tecnica bigint
);


ALTER TABLE matrix.struttura_piani OWNER TO postgres;

--
-- Name: tree_nodes; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.tree_nodes (
    id bigint NOT NULL,
    id_tree bigint NOT NULL,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL
);


ALTER TABLE matrix.tree_nodes OWNER TO postgres;

--
-- Name: trees; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.trees (
    id bigint NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE matrix.trees OWNER TO postgres;

--
-- Name: vw_tree_nodes; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes AS
 SELECT t.name AS name_tree,
    n.id AS id_node,
    n.id_tree,
    n.id_parent AS id_node_parent,
    n.ordinamento,
    n.node_descr,
    n.validita
   FROM (matrix.tree_nodes n
     JOIN matrix.trees t ON ((n.id_tree = t.id)));


ALTER TABLE matrix.vw_tree_nodes OWNER TO postgres;

--
-- Name: vw_tree_nodes_piani; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_piani AS
 SELECT vw_tree_nodes.name_tree,
    vw_tree_nodes.id_node,
    vw_tree_nodes.id_tree,
    vw_tree_nodes.id_node_parent
   FROM matrix.vw_tree_nodes
  WHERE ((vw_tree_nodes.name_tree)::text = 'Struttura Piani'::text);


ALTER TABLE matrix.vw_tree_nodes_piani OWNER TO postgres;

--
-- Name: vw_tree_nodes_up; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_up AS
 WITH RECURSIVE vw_tree_nodes_up(name_tree, id_node, id_tree, id_node_parent, path) AS (
         SELECT vw_tree_nodes.name_tree,
            vw_tree_nodes.id_node,
            vw_tree_nodes.id_tree,
            vw_tree_nodes.id_node_parent,
            (vw_tree_nodes.id_node)::text AS path,
            vw_tree_nodes.ordinamento AS path_ord,
            vw_tree_nodes.node_descr AS path_descr,
            0 AS lv,
            vw_tree_nodes.ordinamento,
            vw_tree_nodes.validita
           FROM matrix.vw_tree_nodes
          WHERE (vw_tree_nodes.id_node_parent IS NULL)
        UNION ALL
         SELECT n.name_tree,
            n.id_node,
            n.id_tree,
            n.id_node_parent,
            ((up.path || '/'::text) || n.id_node),
            (((up.path_ord)::text || '/'::text) || (n.ordinamento)::text),
            (((up.path_descr)::text || '/'::text) || (n.node_descr)::text),
            (up.lv + 1) AS lv,
            n.ordinamento,
            n.validita
           FROM (vw_tree_nodes_up up
             JOIN matrix.vw_tree_nodes n ON ((up.id_node = n.id_node_parent)))
        )
 SELECT vw_tree_nodes_up.name_tree,
    vw_tree_nodes_up.id_node,
    vw_tree_nodes_up.id_tree,
    vw_tree_nodes_up.id_node_parent,
    vw_tree_nodes_up.path,
    vw_tree_nodes_up.path_ord,
    vw_tree_nodes_up.path_descr,
    vw_tree_nodes_up.lv,
    vw_tree_nodes_up.ordinamento,
    vw_tree_nodes_up.validita
   FROM vw_tree_nodes_up
  ORDER BY vw_tree_nodes_up.path;


ALTER TABLE matrix.vw_tree_nodes_up OWNER TO postgres;

--
-- Name: vw_tree_nodes_piani_descr; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_piani_descr AS
 SELECT ta.name_tree,
    ta.id_node,
    ta.id_tree,
    ta.id_node_parent,
    a.id,
    a.id_gisa,
    a.cod_raggruppamento,
    a.anno,
    a.descrizione,
    a.ordinamento,
    a.data_scadenza,
    a.stato,
    a.codice_interno,
    a.color,
    a.livello,
    (a.alias ||
        CASE
            WHEN ((a.data_scadenza IS NULL) OR (a.data_scadenza > now())) THEN ''::text
            ELSE ' [Abrogato]'::text
        END) AS alias,
    a.codice_interno_univoco,
    ap.id AS p_id,
    ap.id_gisa AS p_id_gisa,
    ap.cod_raggruppamento AS p_cod_raggruppamento,
    ap.anno AS p_anno,
    ap.descrizione AS p_descrizione,
    ap.ordinamento AS p_ordinamento,
    ap.data_scadenza AS p_data_scadenza,
    ap.stato AS p_stato,
    ap.codice_interno AS p_codice_interno,
    ap.color AS p_color,
    ap.livello AS p_livello,
    ap.alias AS p_alias,
    ap.codice_interno_univoco AS p_codice_interno_univoco,
    a.ha_campioni,
    a.id_tipo_tecnica,
        CASE
            WHEN (a.livello = 4) THEN ((((ap.codice_interno_univoco)::text || '.'::text) || (a.codice_interno_univoco)::text))::character varying
            ELSE a.codice_interno_univoco
        END AS codice_interno_univoco_piano,
    up.path_ord
   FROM (((matrix.vw_tree_nodes_piani ta
     JOIN matrix.struttura_piani a ON ((a.id = ta.id_node)))
     LEFT JOIN matrix.struttura_piani ap ON ((ap.id = ta.id_node_parent)))
     LEFT JOIN matrix.vw_tree_nodes_up up ON ((up.id_node = ta.id_node)));


ALTER TABLE matrix.vw_tree_nodes_piani_descr OWNER TO postgres;

--
-- Name: vw_struttura_piani_ref_no_rend_new; Type: VIEW; Schema: Analisi_dev; Owner: gisa_fvg
--

CREATE VIEW "Analisi_dev".vw_struttura_piani_ref_no_rend_new AS
 WITH RECURSIVE p_r(id, id_gisa, cod_raggruppamento, anno, descrizione, ordinamento, data_scadenza, stato, codice_interno, color, livello, parent, alias, id_formula_ups, id_formula_uba, fattore_ups, fattore_uba, descrizione_breve, id_ref) AS (
         SELECT struttura_piani.id,
            struttura_piani.id_gisa,
            struttura_piani.cod_raggruppamento,
            struttura_piani.anno,
            struttura_piani.descrizione,
            struttura_piani.ordinamento,
            struttura_piani.data_scadenza,
            struttura_piani.stato,
            struttura_piani.codice_interno,
            struttura_piani.color,
            struttura_piani.livello,
            struttura_piani.p_id AS parent,
            struttura_piani.alias,
            pp.id_formula_ups,
            pp.id_formula_uba,
            fu.fattore_fin AS fattore_ups,
            fb.fattore_fin AS fattore_uba,
            pp.descrizione_breve,
            struttura_piani.id AS id_ref
           FROM (((matrix.vw_tree_nodes_piani_descr struttura_piani
             JOIN matrix.struttura_piani pp ON ((pp.id = struttura_piani.id)))
             LEFT JOIN matrix.formule fu ON ((fu.id = pp.id_formula_ups)))
             LEFT JOIN matrix.formule fb ON (((fb.id = pp.id_formula_uba) AND (NOT ((struttura_piani.id_gisa, struttura_piani.anno) IN ( SELECT r.id_piano,
                    r.anno
                   FROM "Analisi_dev".piani_no_rend r))))))
        UNION ALL
         SELECT p_r_1.id,
            p_r_1.id_gisa,
            p2.cod_raggruppamento,
            p2.anno,
            p2.descrizione,
            p2.ordinamento,
            p2.data_scadenza,
            p2.stato,
            p2.codice_interno,
            p2.color,
            p2.livello,
            p.p_id AS parent,
            p2.alias,
            pp2.id_formula_ups,
            pp2.id_formula_uba,
            p_r_1.fattore_ups,
            p_r_1.fattore_uba,
            pp2.descrizione_breve,
            p.p_id AS parent
           FROM (((matrix.vw_tree_nodes_piani_descr p
             JOIN matrix.struttura_piani pp2 ON ((pp2.id = p.id)))
             JOIN p_r p_r_1 ON ((p_r_1.id_ref = p.id)))
             JOIN matrix.vw_tree_nodes_piani_descr p2 ON ((p.p_id = p2.id)))
          WHERE ((p.p_id IS NOT NULL) AND (NOT ((p.id_gisa, p.anno) IN ( SELECT r.id_piano,
                    r.anno
                   FROM "Analisi_dev".piani_no_rend r))))
        )
 SELECT p_r.id,
    p_r.id_gisa,
    p_r.cod_raggruppamento,
    p_r.anno,
    p_r.descrizione,
    p_r.ordinamento,
    p_r.data_scadenza,
    p_r.stato,
    p_r.codice_interno,
    p_r.color,
    p_r.livello,
    p_r.parent,
    p_r.alias,
    p_r.id_formula_ups,
    p_r.id_formula_uba,
    p_r.fattore_ups,
    p_r.fattore_uba,
    p_r.descrizione_breve,
    p_r.id_ref
   FROM p_r;


ALTER TABLE "Analisi_dev".vw_struttura_piani_ref_no_rend_new OWNER TO gisa_fvg;

--
-- Name: struttura_piano_target_2019; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piano_target_2019 (
    id integer NOT NULL,
    id_struttura integer,
    id_piano integer,
    target double precision
);


ALTER TABLE matrix.struttura_piano_target_2019 OWNER TO postgres;

--
-- Name: struttura_piano_target_id_seq; Type: SEQUENCE; Schema: matrix; Owner: postgres
--

ALTER TABLE matrix.struttura_piano_target_2019 ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME matrix.struttura_piano_target_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: struttura_piano_target; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piano_target (
    id integer DEFAULT 'matrix.struttura_piano_target_id_seq'::regclass,
    id_struttura integer,
    id_piano integer,
    target double precision
);


ALTER TABLE matrix.struttura_piano_target OWNER TO postgres;

--
-- Name: vw_target_no_rend; Type: VIEW; Schema: Analisi_dev; Owner: postgres
--

CREATE VIEW "Analisi_dev".vw_target_no_rend AS
 SELECT t.id_struttura,
    p_r.id_ref AS id_piano,
    sum(t.target) AS target,
    '2019'::text AS anno_controllo,
    sum((t.target * p_r.fattore_ups)) AS target_ups,
    sum((t.target * p_r.fattore_uba)) AS target_uba
   FROM (matrix.struttura_piano_target t
     JOIN "Analisi_dev".vw_struttura_piani_ref_no_rend p_r ON ((p_r.id = t.id_piano)))
  GROUP BY t.id_struttura, p_r.id_ref;


ALTER TABLE "Analisi_dev".vw_target_no_rend OWNER TO postgres;

--
-- Name: ag_conf; Type: TABLE; Schema: ag_conf; Owner: postgres
--

CREATE TABLE ag_conf.ag_conf (
    id bigint NOT NULL,
    area character varying NOT NULL,
    cod character varying NOT NULL,
    descr character varying NOT NULL,
    value character varying NOT NULL,
    tipo character varying NOT NULL,
    validita tsrange DEFAULT tsrange('2023-01-01 00:00:00'::timestamp without time zone, NULL::timestamp without time zone, '[)'::text) NOT NULL,
    idx integer
);


ALTER TABLE ag_conf.ag_conf OWNER TO postgres;

--
-- Name: ag_conf_id_seq; Type: SEQUENCE; Schema: ag_conf; Owner: postgres
--

CREATE SEQUENCE ag_conf.ag_conf_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_conf.ag_conf_id_seq OWNER TO postgres;

--
-- Name: ag_conf_id_seq; Type: SEQUENCE OWNED BY; Schema: ag_conf; Owner: postgres
--

ALTER SEQUENCE ag_conf.ag_conf_id_seq OWNED BY ag_conf.ag_conf.id;


--
-- Name: ag_tree_nodes_up_tipo_linee_old; Type: TABLE; Schema: ag_conf; Owner: postgres
--

CREATE TABLE ag_conf.ag_tree_nodes_up_tipo_linee_old (
    name_tree text,
    id_node integer,
    id_tree integer,
    id_node_parent integer,
    path character varying,
    path_ord text,
    path_descr text,
    id integer,
    cod text,
    descr text,
    livello integer,
    ordinamento character varying
);


ALTER TABLE ag_conf.ag_tree_nodes_up_tipo_linee_old OWNER TO postgres;

--
-- Name: manuali; Type: TABLE; Schema: ag_conf; Owner: postgres
--

CREATE TABLE ag_conf.manuali (
    id bigint NOT NULL,
    cod character varying,
    sigla character varying,
    descr character varying,
    file character varying
);


ALTER TABLE ag_conf.manuali OWNER TO postgres;

--
-- Name: manuali_id_seq; Type: SEQUENCE; Schema: ag_conf; Owner: postgres
--

CREATE SEQUENCE ag_conf.manuali_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_conf.manuali_id_seq OWNER TO postgres;

--
-- Name: manuali_id_seq; Type: SEQUENCE OWNED BY; Schema: ag_conf; Owner: postgres
--

ALTER SEQUENCE ag_conf.manuali_id_seq OWNED BY ag_conf.manuali.id;


--
-- Name: provincie; Type: TABLE; Schema: ag_conf; Owner: postgres
--

CREATE TABLE ag_conf.provincie (
    idprovinciaistat integer,
    siglaprovincia character varying(50)
);


ALTER TABLE ag_conf.provincie OWNER TO postgres;

--
-- Name: r2t; Type: TABLE; Schema: ag_conf; Owner: postgres
--

CREATE TABLE ag_conf.r2t (
    json_agg json
);


ALTER TABLE ag_conf.r2t OWNER TO postgres;

--
-- Name: rt; Type: TABLE; Schema: ag_conf; Owner: postgres
--

CREATE TABLE ag_conf.rt (
    json_agg json
);


ALTER TABLE ag_conf.rt OWNER TO postgres;

--
-- Name: vw_ag_conf; Type: VIEW; Schema: ag_conf; Owner: postgres
--

CREATE VIEW ag_conf.vw_ag_conf AS
 SELECT ag_conf.id AS id_ag_conf,
    ag_conf.id,
    ag_conf.area,
    ag_conf.cod,
    ag_conf.descr,
    ag_conf.value,
    ag_conf.tipo,
    ag_conf.validita,
    lower(ag_conf.validita) AS valido_da,
    upper(ag_conf.validita) AS valido_a,
    ag_conf.idx
   FROM ag_conf.ag_conf
  WHERE (ag_conf.validita @> (CURRENT_TIMESTAMP)::timestamp without time zone);


ALTER TABLE ag_conf.vw_ag_conf OWNER TO postgres;

--
-- Name: agenda_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.agenda_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.agenda_id_seq OWNER TO postgres;

--
-- Name: ag_trees; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.ag_trees (
    id bigint DEFAULT nextval('agenda.agenda_id_seq'::regclass) NOT NULL,
    name character varying
);


ALTER TABLE agenda.ag_trees OWNER TO postgres;

--
-- Name: get_info_masterlist; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.get_info_masterlist (
    codice_univoco text,
    id_norma integer,
    codice_norma text,
    id_macroarea integer,
    macroarea text,
    codice_macroarea text,
    id_aggregazione integer,
    aggregazione text,
    codice_aggregazione text,
    id_linea integer,
    attivita text,
    codice_attivita text,
    mobile boolean,
    fisso boolean,
    apicoltura boolean,
    registrabili boolean,
    riconoscibili boolean,
    sintesis boolean,
    bdu boolean,
    vam boolean,
    no_scia boolean,
    categorizzabili boolean,
    rev integer,
    categoria_rischio_default integer
);


ALTER TABLE matrix.get_info_masterlist OWNER TO postgres;

--
-- Name: vw_ml_allev_da_gisa; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.vw_ml_allev_da_gisa AS
 SELECT t.id,
    t.descr,
    t.cod,
    t.path_ord,
    t.path_descr,
    t.id_node_parent,
    t.lev,
    t.ordinamento,
    t.path_cod
   FROM public.dblink((((((('dbname='::text || (( SELECT config.value
           FROM "Analisi_dev".config
          WHERE ((config.descr)::text = 'GISA_DB'::text)))::text) || ' port='::text) || (( SELECT config.value
           FROM "Analisi_dev".config
          WHERE ((config.descr)::text = 'GISA_PORT'::text)))::text) || ' host='::text) || (( SELECT config.value
           FROM "Analisi_dev".config
          WHERE ((config.descr)::text = 'GISA_ADDRESS'::text)))::text) || ' user=postgres'::text), 'select *
from conf_public.vw_ml_allevamenti_lev o'::text) t(id integer, descr text, cod text, path_ord text, path_descr text, id_node_parent integer, lev integer, ordinamento character varying, path_cod character varying);


ALTER TABLE public.vw_ml_allev_da_gisa OWNER TO postgres;

--
-- Name: vw_ag_tree_nodes_up_tipo_linee_for_table; Type: VIEW; Schema: ag_conf; Owner: postgres
--

CREATE VIEW ag_conf.vw_ag_tree_nodes_up_tipo_linee_for_table AS
 SELECT DISTINCT a.name_tree,
    a.id_node,
    (( SELECT at2.id
           FROM agenda.ag_trees at2
          WHERE ((at2.name)::text = 'tipo_linee'::text)))::integer AS id_tree,
    a.id_node_parent,
    a.path,
    a.path_ord,
    a.path_descr,
    a.id,
    a.cod,
    a.descr,
    a.livello,
    a.ordinamento
   FROM ( SELECT 'tipo_linee'::text AS name_tree,
            10 AS id_node,
            1 AS id_tree,
            NULL::integer AS id_node_parent,
            ''::character varying AS path,
            ''::text AS path_ord,
            ''::text AS path_descr,
            '-1'::integer AS id,
            'Tipo linee'::text AS cod,
            'Master List'::text AS descr,
            0 AS livello,
            '0001'::character varying AS ordinamento
        UNION
         SELECT 'tipo_linee'::text AS name_tree,
            ((vgim.id_norma * 10) + 1) AS id_node,
            1 AS id_tree,
            10 AS id_node_parent,
            (vgim.id_norma)::character varying AS path,
            TRIM(BOTH FROM vgim.codice_norma) AS path_ord,
            TRIM(BOTH FROM vgim.codice_norma) AS path_descr,
            vgim.id_norma AS id,
            TRIM(BOTH FROM vgim.codice_norma) AS cod,
            TRIM(BOTH FROM vgim.codice_norma) AS descr,
            1 AS livello,
            (TRIM(BOTH FROM vgim.codice_norma))::character varying AS ordinamento
           FROM matrix.get_info_masterlist vgim
        UNION
         SELECT 'tipo_linee'::text AS name_tree,
            '-20'::integer AS id_node,
            1 AS id_tree,
            10 AS id_node_parent,
            'ALLEVAMENTI'::character varying AS path,
            'ALLEVAMENTI'::text AS path_ord,
            'ALLEVAMENTI'::text AS path_descr,
            '-20'::integer AS id,
            'ALLEVAMENTI'::text AS cod,
            'ALLEVAMENTI'::text AS descr,
            1 AS livello,
            '9000'::character varying AS ordinamento
        UNION
         SELECT 'tipo_linee'::text AS name_tree,
            g.id AS id_node,
            1 AS id_tree,
            COALESCE(g.id_node_parent, '-20'::integer) AS id_parent,
            g.descr AS path,
            g.path_ord,
            g.path_descr,
            g.id,
            g.descr,
            g.descr,
            (g.lev + 1) AS livello,
            g.ordinamento
           FROM public.vw_ml_allev_da_gisa g
        UNION
         SELECT 'tipo_linee'::text AS name_tree,
            ((vgim.id_macroarea * 10) + 2) AS id_node,
            1 AS id_tree,
            ((vgim.id_norma * 10) + 1),
            ((vgim.id_norma || '/'::text) || vgim.id_macroarea) AS path,
            ((TRIM(BOTH FROM vgim.codice_norma) || '/'::text) || TRIM(BOTH FROM vgim.macroarea)) AS path_ord,
            ((TRIM(BOTH FROM vgim.codice_norma) || '/'::text) || TRIM(BOTH FROM vgim.macroarea)) AS path_descr,
            vgim.id_macroarea AS id,
            TRIM(BOTH FROM vgim.macroarea) AS cod,
            TRIM(BOTH FROM vgim.macroarea) AS descr,
            2 AS livello,
            (TRIM(BOTH FROM vgim.macroarea))::character varying AS ordinamento
           FROM matrix.get_info_masterlist vgim
        UNION
         SELECT 'tipo_linee'::text AS name_tree,
            ((vgim.id_aggregazione * 10) + 3) AS id_node,
            1 AS id_tree,
            ((vgim.id_macroarea * 10) + 2),
            ((((vgim.id_norma || '/'::text) || vgim.id_macroarea) || '/'::text) || vgim.id_aggregazione) AS path,
            ((((TRIM(BOTH FROM vgim.codice_norma) || '/'::text) || TRIM(BOTH FROM vgim.macroarea)) || '/'::text) || vgim.codice_aggregazione) AS path_ord,
            ((((TRIM(BOTH FROM vgim.codice_norma) || '/'::text) || TRIM(BOTH FROM vgim.macroarea)) || '/'::text) || vgim.aggregazione) AS path_descr,
            vgim.id_aggregazione AS id,
            TRIM(BOTH FROM vgim.codice_aggregazione) AS cod,
            TRIM(BOTH FROM vgim.aggregazione) AS descr,
            3 AS livello,
            (vgim.codice_aggregazione)::character varying AS ordinamento
           FROM matrix.get_info_masterlist vgim
        UNION
         SELECT 'tipo_linee'::text AS name_tree,
            ((vgim.id_linea * 10) + 4) AS id_node,
            1 AS id_tree,
            ((vgim.id_aggregazione * 10) + 3),
            ((((((vgim.id_norma || '/'::text) || vgim.id_macroarea) || '/'::text) || vgim.id_aggregazione) || '/'::text) || vgim.id_linea) AS path,
            lower(((((((TRIM(BOTH FROM vgim.codice_norma) || '/'::text) || TRIM(BOTH FROM vgim.macroarea)) || '/'::text) || vgim.codice_aggregazione) || '/'::text) || vgim.attivita)) AS path_ord,
            ((((((TRIM(BOTH FROM vgim.codice_norma) || '/'::text) || TRIM(BOTH FROM vgim.macroarea)) || '/'::text) || vgim.aggregazione) || '/'::text) || vgim.attivita) AS path_descr,
            vgim.id_linea AS id,
            TRIM(BOTH FROM vgim.attivita) AS cod,
            TRIM(BOTH FROM vgim.attivita) AS descr,
            4 AS livello,
            (vgim.attivita)::character varying AS ordinamento
           FROM matrix.get_info_masterlist vgim) a;


ALTER TABLE ag_conf.vw_ag_tree_nodes_up_tipo_linee_for_table OWNER TO postgres;

--
-- Name: vw_manuali; Type: VIEW; Schema: ag_conf; Owner: postgres
--

CREATE VIEW ag_conf.vw_manuali AS
 SELECT manuali.id AS id_manuale,
    manuali.id,
    manuali.cod,
    manuali.sigla,
    manuali.descr,
    manuali.file
   FROM ag_conf.manuali
  ORDER BY manuali.descr;


ALTER TABLE ag_conf.vw_manuali OWNER TO postgres;

--
-- Name: vw_provincie; Type: VIEW; Schema: ag_conf; Owner: postgres
--

CREATE VIEW ag_conf.vw_provincie AS
 SELECT p.idprovinciaistat,
    p.siglaprovincia
   FROM ag_conf.provincie p;


ALTER TABLE ag_conf.vw_provincie OWNER TO postgres;

--
-- Name: asl_piani; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.asl_piani (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_struttura bigint NOT NULL,
    id_piano bigint NOT NULL
);


ALTER TABLE ag_his.asl_piani OWNER TO postgres;

--
-- Name: attivita; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.attivita (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_elab_cal bigint NOT NULL,
    id_struttura bigint NOT NULL,
    id_piano bigint NOT NULL,
    id_linea bigint,
    dt timestamp without time zone,
    id_risorsa bigint,
    target integer,
    contatore integer,
    ups numeric,
    durata interval,
    validita tsrange,
    prog integer,
    id_partner bigint,
    id_struttura_partner bigint,
    validita_interna boolean DEFAULT true NOT NULL
);


ALTER TABLE ag_his.attivita OWNER TO postgres;

--
-- Name: avvisi; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.avvisi (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    codice character varying,
    sigla character varying,
    descrizione character varying,
    id_tipo_avviso bigint,
    id_livello_avviso bigint NOT NULL,
    validita tsrange,
    id_user_create bigint,
    ts_create timestamp without time zone
);


ALTER TABLE ag_his.avvisi OWNER TO postgres;

--
-- Name: avviso_risorse; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.avviso_risorse (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_avviso bigint,
    id_risorsa bigint,
    dt_prima_visualizzazione timestamp without time zone,
    visualizzabile boolean DEFAULT true NOT NULL
);


ALTER TABLE ag_his.avviso_risorse OWNER TO postgres;

--
-- Name: cf_liste; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.cf_liste (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    anno integer,
    dt timestamp without time zone,
    id_cf_tipo_lista bigint
);


ALTER TABLE ag_his.cf_liste OWNER TO postgres;

--
-- Name: cf_liste_id_seq; Type: SEQUENCE; Schema: ag_his; Owner: postgres
--

CREATE SEQUENCE ag_his.cf_liste_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_his.cf_liste_id_seq OWNER TO postgres;

--
-- Name: cf_liste_id_seq; Type: SEQUENCE OWNED BY; Schema: ag_his; Owner: postgres
--

ALTER SEQUENCE ag_his.cf_liste_id_seq OWNED BY ag_his.cf_liste.id;


--
-- Name: elab_cal_param_ns_piani; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.elab_cal_param_ns_piani (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_elab_cal bigint NOT NULL,
    id_piano bigint NOT NULL
);


ALTER TABLE ag_his.elab_cal_param_ns_piani OWNER TO postgres;

--
-- Name: elab_cals; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.elab_cals (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    descr character varying NOT NULL,
    tm timestamp without time zone NOT NULL,
    id_user bigint,
    nota character varying,
    id_calendario bigint,
    tm_last_elab timestamp without time zone,
    tm_last_elab_start timestamp without time zone
);


ALTER TABLE ag_his.elab_cals OWNER TO postgres;

--
-- Name: elab_cals_param; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.elab_cals_param (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_elab_cal bigint NOT NULL,
    type_param character varying NOT NULL,
    value character varying NOT NULL
);


ALTER TABLE ag_his.elab_cals_param OWNER TO postgres;

--
-- Name: eventi; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.eventi (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint,
    id_nominativo bigint,
    id_tipo_evento bigint,
    inizio timestamp without time zone,
    fine timestamp without time zone,
    id_linea bigint,
    id_attivita bigint,
    id_piano bigint,
    effettuata boolean,
    id_partner bigint,
    valido_da timestamp without time zone,
    valido_a timestamp without time zone,
    per_conto bigint,
    id_elab_cal bigint,
    id_cu bigint,
    partner_per_conto bigint,
    validita_interna boolean DEFAULT true NOT NULL,
    quantita numeric,
    id_user_create bigint,
    ts_create timestamp without time zone
);


ALTER TABLE ag_his.eventi OWNER TO postgres;

--
-- Name: eventi_id_seq; Type: SEQUENCE; Schema: ag_his; Owner: postgres
--

CREATE SEQUENCE ag_his.eventi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_his.eventi_id_seq OWNER TO postgres;

--
-- Name: linea_piani; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.linea_piani (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_linea bigint,
    id_piano bigint
);


ALTER TABLE ag_his.linea_piani OWNER TO postgres;

--
-- Name: linee_selezionate; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.linee_selezionate (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_elab_cal bigint NOT NULL,
    id_linea bigint NOT NULL,
    id_piano bigint NOT NULL,
    ordine integer
);


ALTER TABLE ag_his.linee_selezionate OWNER TO postgres;

--
-- Name: lista_import; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.lista_import (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    anno integer,
    dt timestamp without time zone,
    id_tipo_lista bigint
);


ALTER TABLE ag_his.lista_import OWNER TO postgres;

--
-- Name: lista_import_id_seq; Type: SEQUENCE; Schema: ag_his; Owner: postgres
--

CREATE SEQUENCE ag_his.lista_import_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_his.lista_import_id_seq OWNER TO postgres;

--
-- Name: lista_import_id_seq; Type: SEQUENCE OWNED BY; Schema: ag_his; Owner: postgres
--

ALTER SEQUENCE ag_his.lista_import_id_seq OWNED BY ag_his.lista_import.id;


--
-- Name: nominativo_az_sedi; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.nominativo_az_sedi (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_nominativo_struttura bigint,
    id_az_sede bigint
);


ALTER TABLE ag_his.nominativo_az_sedi OWNER TO postgres;

--
-- Name: nominativo_comuni; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.nominativo_comuni (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_nominativo_struttura bigint NOT NULL,
    id_struttura_comune bigint NOT NULL
);


ALTER TABLE ag_his.nominativo_comuni OWNER TO postgres;

--
-- Name: nominativo_linee; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.nominativo_linee (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_nominativo_struttura bigint,
    id_linea bigint
);


ALTER TABLE ag_his.nominativo_linee OWNER TO postgres;

--
-- Name: nominativo_piani; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.nominativo_piani (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_nominativo_struttura bigint,
    id_piano bigint
);


ALTER TABLE ag_his.nominativo_piani OWNER TO postgres;

--
-- Name: piano_freq; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.piano_freq (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_piano bigint,
    livello integer,
    num numeric,
    den numeric
);


ALTER TABLE ag_his.piano_freq OWNER TO postgres;

--
-- Name: piano_periodo; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.piano_periodo (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_piano bigint NOT NULL,
    periodo tsrange NOT NULL,
    validita_interna boolean DEFAULT true NOT NULL
);


ALTER TABLE ag_his.piano_periodo OWNER TO postgres;

--
-- Name: piano_tipo_linea; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.piano_tipo_linea (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id_piano integer,
    id_tipo_linea integer,
    id bigint NOT NULL
);


ALTER TABLE ag_his.piano_tipo_linea OWNER TO postgres;

--
-- Name: struttura_asl; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.struttura_asl (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint,
    id_gisa bigint,
    id_asl bigint,
    codice_interno_fk bigint,
    descrizione text,
    n_livello integer,
    anno integer,
    descrizione_breve text,
    ups double precision,
    uba double precision,
    codice_interno_univoco bigint,
    ordinamento integer
);


ALTER TABLE ag_his.struttura_asl OWNER TO postgres;

--
-- Name: struttura_comuni; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.struttura_comuni (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_comune bigint NOT NULL,
    id_struttura bigint NOT NULL
);


ALTER TABLE ag_his.struttura_comuni OWNER TO postgres;

--
-- Name: struttura_piani; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.struttura_piani (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying,
    ha_campioni boolean DEFAULT false,
    id_tipo_tecnica bigint
);


ALTER TABLE ag_his.struttura_piani OWNER TO postgres;

--
-- Name: tipo_lista_piano; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.tipo_lista_piano (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id_piano integer,
    id_tipo_lista integer,
    id bigint NOT NULL
);


ALTER TABLE ag_his.tipo_lista_piano OWNER TO postgres;

--
-- Name: tipo_liste; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.tipo_liste (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    descr character varying NOT NULL,
    cod character varying,
    tm timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    id_user bigint,
    formato character varying,
    validita tsrange DEFAULT '(,)'::tsrange NOT NULL
);


ALTER TABLE ag_his.tipo_liste OWNER TO postgres;

--
-- Name: tipologia_controllo_piani; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.tipologia_controllo_piani (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_tipologia_controllo bigint,
    id_piano bigint
);


ALTER TABLE ag_his.tipologia_controllo_piani OWNER TO postgres;

--
-- Name: tree_nodes; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.tree_nodes (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_tree bigint NOT NULL,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL
);


ALTER TABLE ag_his.tree_nodes OWNER TO postgres;

--
-- Name: unita_di_crisi; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.unita_di_crisi (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    ruolo character varying,
    responsabile_titolo character varying,
    responsabile_nome character varying,
    responsabile_cognome character varying,
    email character varying,
    telefono character varying,
    cellulare character varying,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL,
    id_asl bigint
);


ALTER TABLE ag_his.unita_di_crisi OWNER TO postgres;

--
-- Name: utente_strutture; Type: TABLE; Schema: ag_his; Owner: postgres
--

CREATE TABLE ag_his.utente_strutture (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_utente bigint NOT NULL,
    id_struttura bigint NOT NULL,
    validita tsrange,
    id_nominativo bigint
);


ALTER TABLE ag_his.utente_strutture OWNER TO postgres;

--
-- Name: transazioni; Type: TABLE; Schema: ag_log; Owner: postgres
--

CREATE TABLE ag_log.transazioni (
    id bigint NOT NULL,
    id_user bigint NOT NULL,
    ts timestamp without time zone NOT NULL,
    descr character varying
);


ALTER TABLE ag_log.transazioni OWNER TO postgres;

--
-- Name: anpr_archivio_comuni; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.anpr_archivio_comuni (
    id integer,
    dataistituzione character varying(50),
    datacessazione character varying(50),
    codistat integer,
    codcatastale character varying(50),
    denominazione_it character varying(50),
    denomtraslitterata character varying(50),
    altradenominazione character varying(50),
    altradenomtraslitterata character varying(50),
    id_provincia integer,
    idprovinciaistat integer,
    idregione character varying(50),
    idprefettura character varying(50),
    stato character varying(50),
    siglaprovincia character varying(50),
    fonte character varying(50),
    dataultimoagg character varying(50),
    cod_denom integer,
    codice_istat character varying
);


ALTER TABLE conf_ext.anpr_archivio_comuni OWNER TO postgres;

--
-- Name: stati_esteri; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.stati_esteri (
    stato_territorio character varying,
    continente integer,
    denom_continente character varying,
    codicearea integer,
    denom_area character varying,
    cod_istat integer,
    denom_it character varying,
    denom_en character varying,
    cod_min character varying,
    codice_at character varying,
    codice_unsd_m49 character varying,
    codice_3166_a2 character varying,
    codice_3166_a3 character varying,
    cod_istat_padre integer,
    codice_a3_padre character varying
);


ALTER TABLE conf_ext.stati_esteri OWNER TO postgres;

--
-- Name: vw_anpr_archivio_comuni; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_anpr_archivio_comuni AS
 SELECT aac.id,
    aac.dataistituzione,
    aac.datacessazione,
    aac.codistat,
    aac.codcatastale,
    aac.denominazione_it,
    aac.denomtraslitterata,
    aac.altradenominazione,
    aac.altradenomtraslitterata,
    aac.id_provincia,
    aac.idprovinciaistat,
    aac.idregione,
    aac.idprefettura,
    aac.stato,
    aac.siglaprovincia,
    aac.fonte,
    aac.dataultimoagg,
    aac.cod_denom,
        CASE
            WHEN ((aac.altradenominazione IS NULL) OR ((aac.altradenominazione)::text = ''::text)) THEN (aac.denominazione_it)::text
            ELSE (((aac.denominazione_it)::text || ' - '::text) || (aac.altradenominazione)::text)
        END AS denominazione_composta,
        CASE
            WHEN ((aac.altradenomtraslitterata IS NULL) OR ((aac.altradenomtraslitterata)::text = ''::text)) THEN (aac.denomtraslitterata)::text
            ELSE (((aac.denomtraslitterata)::text || ' - '::text) || (aac.altradenomtraslitterata)::text)
        END AS denominazione_composta_traslitterata,
    aac.codice_istat
   FROM conf_ext.anpr_archivio_comuni aac;


ALTER TABLE conf_ext.vw_anpr_archivio_comuni OWNER TO postgres;

--
-- Name: vwm_comuni_vigenti; Type: MATERIALIZED VIEW; Schema: conf_ext; Owner: postgres
--

CREATE MATERIALIZED VIEW conf_ext.vwm_comuni_vigenti AS
 SELECT DISTINCT ON (c.codcatastale, c.denominazione_it, c.altradenominazione) c.codistat,
    c.id,
    c.dataistituzione,
    c.datacessazione,
    c.codcatastale,
    c.denominazione_it,
    c.denomtraslitterata,
    c.altradenominazione,
    c.altradenomtraslitterata,
    c.id_provincia,
    c.idprovinciaistat,
    c.idregione,
    c.idprefettura,
    c.stato,
    c.siglaprovincia,
    c.fonte,
    c.dataultimoagg,
    c.cod_denom,
    c.denominazione_composta,
    c.denominazione_composta_traslitterata,
    lpad(((c.codistat)::character varying)::text, 6, '0'::text) AS istat,
    c.codice_istat
   FROM conf_ext.vw_anpr_archivio_comuni c
  ORDER BY c.codcatastale, c.denominazione_it, c.altradenominazione, c.datacessazione DESC
  WITH NO DATA;


ALTER TABLE conf_ext.vwm_comuni_vigenti OWNER TO postgres;

--
-- Name: vw_comuni_vigenti; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_comuni_vigenti AS
 SELECT vwm_comuni_vigenti.codistat,
    vwm_comuni_vigenti.id,
    vwm_comuni_vigenti.dataistituzione,
    vwm_comuni_vigenti.datacessazione,
    vwm_comuni_vigenti.codcatastale,
    vwm_comuni_vigenti.denominazione_it,
    vwm_comuni_vigenti.denomtraslitterata,
    vwm_comuni_vigenti.altradenominazione,
    vwm_comuni_vigenti.altradenomtraslitterata,
    vwm_comuni_vigenti.id_provincia,
    vwm_comuni_vigenti.idprovinciaistat,
    vwm_comuni_vigenti.idregione,
    vwm_comuni_vigenti.idprefettura,
    vwm_comuni_vigenti.stato,
    vwm_comuni_vigenti.siglaprovincia,
    vwm_comuni_vigenti.fonte,
    vwm_comuni_vigenti.dataultimoagg,
    vwm_comuni_vigenti.cod_denom,
    vwm_comuni_vigenti.denominazione_composta,
    vwm_comuni_vigenti.denominazione_composta_traslitterata,
    vwm_comuni_vigenti.istat,
    vwm_comuni_vigenti.codice_istat
   FROM conf_ext.vwm_comuni_vigenti;


ALTER TABLE conf_ext.vw_comuni_vigenti OWNER TO postgres;

--
-- Name: vwm_comuni_vigenti_catastali; Type: MATERIALIZED VIEW; Schema: conf_ext; Owner: postgres
--

CREATE MATERIALIZED VIEW conf_ext.vwm_comuni_vigenti_catastali AS
 SELECT DISTINCT ON (vw_comuni_vigenti.codcatastale) vw_comuni_vigenti.codistat,
    vw_comuni_vigenti.id,
    vw_comuni_vigenti.dataistituzione,
    vw_comuni_vigenti.datacessazione,
    vw_comuni_vigenti.codcatastale,
    vw_comuni_vigenti.denominazione_it,
    vw_comuni_vigenti.denomtraslitterata,
    vw_comuni_vigenti.altradenominazione,
    vw_comuni_vigenti.altradenomtraslitterata,
    vw_comuni_vigenti.id_provincia,
    vw_comuni_vigenti.idprovinciaistat,
    vw_comuni_vigenti.idregione,
    vw_comuni_vigenti.idprefettura,
    vw_comuni_vigenti.stato,
    vw_comuni_vigenti.siglaprovincia,
    vw_comuni_vigenti.fonte,
    vw_comuni_vigenti.dataultimoagg,
    vw_comuni_vigenti.cod_denom,
    vw_comuni_vigenti.denominazione_composta,
    vw_comuni_vigenti.denominazione_composta_traslitterata,
    vw_comuni_vigenti.codice_istat
   FROM conf_ext.vw_comuni_vigenti
  ORDER BY vw_comuni_vigenti.codcatastale, vw_comuni_vigenti.datacessazione DESC
  WITH NO DATA;


ALTER TABLE conf_ext.vwm_comuni_vigenti_catastali OWNER TO postgres;

--
-- Name: vw_comuni_vigenti_catastali; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_comuni_vigenti_catastali AS
 SELECT vwm_comuni_vigenti_catastali.codistat,
    vwm_comuni_vigenti_catastali.id,
    vwm_comuni_vigenti_catastali.dataistituzione,
    vwm_comuni_vigenti_catastali.datacessazione,
    vwm_comuni_vigenti_catastali.codcatastale,
    vwm_comuni_vigenti_catastali.denominazione_it,
    vwm_comuni_vigenti_catastali.denomtraslitterata,
    vwm_comuni_vigenti_catastali.altradenominazione,
    vwm_comuni_vigenti_catastali.altradenomtraslitterata,
    vwm_comuni_vigenti_catastali.id_provincia,
    vwm_comuni_vigenti_catastali.idprovinciaistat,
    vwm_comuni_vigenti_catastali.idregione,
    vwm_comuni_vigenti_catastali.idprefettura,
    vwm_comuni_vigenti_catastali.stato,
    vwm_comuni_vigenti_catastali.siglaprovincia,
    vwm_comuni_vigenti_catastali.fonte,
    vwm_comuni_vigenti_catastali.dataultimoagg,
    vwm_comuni_vigenti_catastali.cod_denom,
    vwm_comuni_vigenti_catastali.denominazione_composta,
    vwm_comuni_vigenti_catastali.denominazione_composta_traslitterata,
    vwm_comuni_vigenti_catastali.codice_istat
   FROM conf_ext.vwm_comuni_vigenti_catastali;


ALTER TABLE conf_ext.vw_comuni_vigenti_catastali OWNER TO postgres;

--
-- Name: vw_stati_esteri; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_stati_esteri AS
 SELECT stati_esteri.stato_territorio,
    stati_esteri.continente,
    stati_esteri.denom_continente,
    stati_esteri.codicearea,
    stati_esteri.denom_area,
    stati_esteri.cod_istat,
    stati_esteri.denom_it,
    stati_esteri.denom_en,
    stati_esteri.cod_min,
    stati_esteri.codice_at,
    stati_esteri.codice_unsd_m49,
    stati_esteri.codice_3166_a2,
    stati_esteri.codice_3166_a3,
    stati_esteri.cod_istat_padre,
    stati_esteri.codice_a3_padre,
    upper((stati_esteri.denom_it)::text) AS denom_upper
   FROM conf_ext.stati_esteri;


ALTER TABLE conf_ext.vw_stati_esteri OWNER TO postgres;

--
-- Name: vwm_codici_vigenti_catastali; Type: MATERIALIZED VIEW; Schema: conf_ext; Owner: postgres
--

CREATE MATERIALIZED VIEW conf_ext.vwm_codici_vigenti_catastali AS
 SELECT vw_comuni_vigenti_catastali.codcatastale,
    vw_comuni_vigenti_catastali.denominazione_it,
    vw_comuni_vigenti_catastali.codice_istat
   FROM conf_ext.vw_comuni_vigenti_catastali
UNION
 SELECT vw_stati_esteri.codice_at AS codcatastale,
    vw_stati_esteri.denom_it AS denominazione_it,
    NULL::character varying AS codice_istat
   FROM conf_ext.vw_stati_esteri
  WITH NO DATA;


ALTER TABLE conf_ext.vwm_codici_vigenti_catastali OWNER TO postgres;

--
-- Name: vw_codici_vigenti_catastali; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_codici_vigenti_catastali AS
 SELECT vwm_codici_vigenti_catastali.codcatastale,
    vwm_codici_vigenti_catastali.denominazione_it,
    vwm_codici_vigenti_catastali.codice_istat
   FROM conf_ext.vwm_codici_vigenti_catastali;


ALTER TABLE conf_ext.vw_codici_vigenti_catastali OWNER TO postgres;

--
-- Name: vw_comuni_vigenti_attivi; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_comuni_vigenti_attivi AS
 SELECT vw_comuni_vigenti.codistat,
    vw_comuni_vigenti.id,
    vw_comuni_vigenti.dataistituzione,
    vw_comuni_vigenti.datacessazione,
    vw_comuni_vigenti.codcatastale,
    vw_comuni_vigenti.denominazione_it,
    vw_comuni_vigenti.denomtraslitterata,
    vw_comuni_vigenti.altradenominazione,
    vw_comuni_vigenti.altradenomtraslitterata,
    vw_comuni_vigenti.id_provincia,
    vw_comuni_vigenti.idprovinciaistat,
    vw_comuni_vigenti.idregione,
    vw_comuni_vigenti.idprefettura,
    vw_comuni_vigenti.stato,
    vw_comuni_vigenti.siglaprovincia,
    vw_comuni_vigenti.fonte,
    vw_comuni_vigenti.dataultimoagg,
    vw_comuni_vigenti.cod_denom,
    vw_comuni_vigenti.denominazione_composta,
    vw_comuni_vigenti.denominazione_composta_traslitterata,
    vw_comuni_vigenti.istat,
    vw_comuni_vigenti.codice_istat
   FROM conf_ext.vw_comuni_vigenti
  WHERE ((vw_comuni_vigenti.datacessazione)::text > '2100-01-01'::text);


ALTER TABLE conf_ext.vw_comuni_vigenti_attivi OWNER TO postgres;

--
-- Name: indirizzi; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.indirizzi (
    id bigint NOT NULL,
    toponimo character varying,
    indirizzo character varying,
    cap text,
    stato_prov character varying,
    nazione text,
    istat_comune character varying,
    comune character varying,
    localita text,
    civico character varying,
    latitudine character varying,
    longitudine character varying,
    verificato boolean,
    fonte text
);


ALTER TABLE cu_anag.indirizzi OWNER TO postgres;

--
-- Name: soggetti_fisici; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.soggetti_fisici (
    id bigint,
    titolo character varying,
    cognome character varying,
    nome character varying,
    comune_nascita character varying,
    codice_fiscale character varying,
    sesso character varying,
    telefono character varying,
    email character varying,
    pec character varying,
    telefono2 character varying,
    data_nascita date,
    documento_identita character varying,
    indirizzo_id bigint,
    verificato boolean,
    fonte character varying
);


ALTER TABLE cu_anag.soggetti_fisici OWNER TO postgres;

--
-- Name: vw_indirizzi; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_indirizzi AS
 SELECT i.id AS id_indirizzo,
    i.id,
    i.toponimo,
    i.indirizzo,
    i.cap,
    COALESCE(c.siglaprovincia, i.stato_prov) AS stato_prov,
    i.nazione,
    i.istat_comune,
    COALESCE(c.denominazione_it, i.comune) AS comune,
    i.localita,
    i.civico,
    i.latitudine,
    i.longitudine,
    i.verificato,
    i.fonte,
    TRIM(BOTH FROM (COALESCE(NULLIF(TRIM(BOTH FROM COALESCE((((((COALESCE(((i.toponimo)::text || ' '::text), (''::character varying)::text) || COALESCE((i.indirizzo)::text, ''::text)) || COALESCE((COALESCE((', '::text || (i.civico)::text), ''::text) || ' '::text), ' '::text)) || COALESCE((COALESCE((c.denominazione_it)::text, (i.comune)::text) || ' '::text), ''::text)) || COALESCE((i.cap || ' '::text), ''::text)) || COALESCE(((COALESCE(c.siglaprovincia, i.stato_prov))::text || ' '::text), ''::text)), ''::text)), ','::text), ''::text) || COALESCE(i.nazione, ''::text))) AS indirizzo_completo,
    TRIM(BOTH FROM ((COALESCE(((i.toponimo)::text || ' '::text), (''::character varying)::text) || COALESCE((i.indirizzo)::text, ''::text)) || COALESCE(((', '::text || (i.civico)::text) || ' '::text), ' '::text))) AS indirizzo_luogo,
    c.siglaprovincia,
    (i.istat_comune IS NULL) AS estero
   FROM (cu_anag.indirizzi i
     LEFT JOIN conf_ext.vw_comuni_vigenti_attivi c ON (((c.codice_istat)::text = (i.istat_comune)::text)));


ALTER TABLE cu_anag.vw_indirizzi OWNER TO postgres;

--
-- Name: vw_soggetti_fisici; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_soggetti_fisici AS
 SELECT f.id AS id_soggetto_fisico,
    f.id,
    f.titolo,
    f.cognome,
    f.nome,
    f.comune_nascita,
    f.codice_fiscale,
    f.sesso,
    f.telefono,
    f.email,
    f.pec,
    f.telefono2,
    f.data_nascita,
    f.documento_identita,
    f.indirizzo_id,
    f.verificato,
    f.fonte,
    (i.indirizzo)::character varying(300) AS via,
    (i.cap)::character(20) AS cap,
    0 AS comune,
    (i.nazione)::character varying(500) AS nazione,
    (i.civico)::text AS civico,
    (i.comune)::text AS comune_testo,
    i.indirizzo_completo,
    i.indirizzo_luogo,
    (COALESCE(c.denominazione_it, ((('>'::text || (f.comune_nascita)::text) || '<'::text))::character varying))::character varying(50) AS comune_nascita_descr,
    (c.codice_istat)::text AS istat_nascita,
    i.istat_comune AS istat_indirizzo,
    ((COALESCE(f.nome, ''::character varying))::text || COALESCE((' '::text || (f.cognome)::text), ''::text)) AS nome_completo
   FROM ((cu_anag.soggetti_fisici f
     LEFT JOIN cu_anag.vw_indirizzi i ON ((i.id = f.indirizzo_id)))
     LEFT JOIN conf_ext.vw_codici_vigenti_catastali c ON (((c.codcatastale)::text = (f.comune_nascita)::text)));


ALTER TABLE cu_anag.vw_soggetti_fisici OWNER TO postgres;

--
-- Name: struttura_asl; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_asl (
    id bigint,
    id_gisa bigint,
    id_asl bigint,
    codice_interno_fk bigint,
    descrizione text,
    n_livello integer,
    anno integer,
    descrizione_breve text,
    ups double precision,
    uba double precision,
    codice_interno_univoco bigint,
    ordinamento integer
);


ALTER TABLE matrix.struttura_asl OWNER TO postgres;

--
-- Name: vw_asl; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_asl AS
 SELECT DISTINCT ON (struttura_asl.id_asl) struttura_asl.id_asl,
    struttura_asl.anno,
    struttura_asl.descrizione,
    struttura_asl.descrizione_breve
   FROM matrix.struttura_asl
  WHERE (struttura_asl.n_livello <= 1)
  ORDER BY struttura_asl.id_asl, struttura_asl.anno DESC;


ALTER TABLE matrix.vw_asl OWNER TO postgres;

--
-- Name: vw_strutture_asl; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_strutture_asl AS
 SELECT vw_asl.id_asl,
    vw_asl.anno,
    vw_asl.descrizione,
    vw_asl.descrizione_breve
   FROM matrix.vw_asl
  WHERE ((vw_asl.id_asl > 0) AND (vw_asl.anno = ( SELECT (config.value)::integer AS value
           FROM "Analisi_dev".config
          WHERE ((config.descr)::text = 'ANNO CORRENTE'::text))))
  ORDER BY vw_asl.id_asl;


ALTER TABLE cu_types.vw_strutture_asl OWNER TO postgres;

--
-- Name: vw_tree_nodes_up_asl; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_up_asl AS
 SELECT vw_tree_nodes_up.name_tree,
    vw_tree_nodes_up.id_node,
    vw_tree_nodes_up.id_tree,
    vw_tree_nodes_up.id_node_parent,
    vw_tree_nodes_up.path,
    vw_tree_nodes_up.path_ord,
    vw_tree_nodes_up.path_descr,
    struttura_asl.id,
    struttura_asl.id_gisa,
    struttura_asl.id_asl,
    struttura_asl.codice_interno_fk,
    struttura_asl.descrizione,
    struttura_asl.n_livello,
    struttura_asl.anno,
    struttura_asl.descrizione_breve,
    struttura_asl.ups,
    struttura_asl.uba
   FROM (matrix.vw_tree_nodes_up
     JOIN matrix.struttura_asl ON ((vw_tree_nodes_up.id_node = struttura_asl.id)))
  WHERE ((vw_tree_nodes_up.name_tree)::text = 'Struttura ASL'::text);


ALTER TABLE matrix.vw_tree_nodes_up_asl OWNER TO postgres;

--
-- Name: ruoli; Type: TABLE; Schema: rbac; Owner: postgres
--

CREATE TABLE rbac.ruoli (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    responsabile boolean,
    livello bigint
);


ALTER TABLE rbac.ruoli OWNER TO postgres;

--
-- Name: utente_strutture; Type: TABLE; Schema: rbac; Owner: postgres
--

CREATE TABLE rbac.utente_strutture (
    id bigint NOT NULL,
    id_utente bigint NOT NULL,
    id_struttura bigint NOT NULL,
    validita tsrange,
    id_nominativo bigint
);


ALTER TABLE rbac.utente_strutture OWNER TO postgres;

--
-- Name: utente_strutture_ruoli; Type: TABLE; Schema: rbac; Owner: postgres
--

CREATE TABLE rbac.utente_strutture_ruoli (
    id bigint NOT NULL,
    id_utente_struttura bigint NOT NULL,
    id_ruolo bigint NOT NULL
);


ALTER TABLE rbac.utente_strutture_ruoli OWNER TO postgres;

--
-- Name: utenti; Type: TABLE; Schema: rbac; Owner: postgres
--

CREATE TABLE rbac.utenti (
    id bigint NOT NULL,
    cf character varying NOT NULL,
    id_qualifica bigint NOT NULL,
    id_asl character varying,
    mail character varying,
    tel character varying,
    dpat boolean,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL
);


ALTER TABLE rbac.utenti OWNER TO postgres;

--
-- Name: vw_ruoli; Type: VIEW; Schema: rbac; Owner: postgres
--

CREATE VIEW rbac.vw_ruoli AS
 SELECT ruoli.id AS id_ruolo,
    ruoli.id,
    ruoli.cod,
    ruoli.sigla,
    ruoli.descr,
    ruoli.responsabile,
    ruoli.livello
   FROM rbac.ruoli;


ALTER TABLE rbac.vw_ruoli OWNER TO postgres;

--
-- Name: qualifiche; Type: TABLE; Schema: rbac_conf; Owner: postgres
--

CREATE TABLE rbac_conf.qualifiche (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL
);


ALTER TABLE rbac_conf.qualifiche OWNER TO postgres;

--
-- Name: vw_qualifiche; Type: VIEW; Schema: rbac_conf; Owner: postgres
--

CREATE VIEW rbac_conf.vw_qualifiche AS
 SELECT t.id AS id_qualifica,
    t.id,
    t.cod,
    t.sigla,
    t.descr
   FROM rbac_conf.qualifiche t;


ALTER TABLE rbac_conf.vw_qualifiche OWNER TO postgres;

--
-- Name: vw_utenti; Type: VIEW; Schema: rbac; Owner: postgres
--

CREATE VIEW rbac.vw_utenti AS
 SELECT u.id AS id_utente,
    u.id,
    u.cf,
    u.id_qualifica,
    t.descr AS descr_qualifica,
    t.sigla AS sigla_qualifica,
    sf.nome,
    sf.cognome,
    u.id_asl,
        CASE
            WHEN ((u.id_asl)::text = '-1'::text) THEN 'REGIONE'::text
            ELSE a.descrizione_breve
        END AS asl_descr,
    lower(u.validita) AS inizio_validita,
    upper(u.validita) AS fine_validita,
    sf.data_nascita,
    sf.comune_nascita,
    sf.comune_nascita_descr,
    u.mail,
    u.tel,
    u.dpat,
    (((sf.nome)::text || ' '::text) || (sf.cognome)::text) AS nominativo,
    u.validita
   FROM (((rbac.utenti u
     JOIN rbac_conf.vw_qualifiche t ON ((u.id_qualifica = t.id_qualifica)))
     LEFT JOIN cu_anag.vw_soggetti_fisici sf ON (((u.cf)::text = (sf.codice_fiscale)::text)))
     LEFT JOIN cu_types.vw_strutture_asl a ON ((a.id_asl = (u.id_asl)::integer)));


ALTER TABLE rbac.vw_utenti OWNER TO postgres;

--
-- Name: vw_utente_strutture; Type: VIEW; Schema: rbac; Owner: postgres
--

CREATE VIEW rbac.vw_utente_strutture AS
 SELECT us.id AS id_utente_struttura,
    us.id_utente,
    us.id_struttura,
    lower(us.validita) AS inizio_validita,
    upper(us.validita) AS fine_validita,
    (u.id_asl)::bigint AS id_asl,
    t.descrizione,
    t.descrizione_breve,
    u.nome,
    u.cognome,
    u.cf,
    u.descr_qualifica,
    u.sigla_qualifica,
    us.validita,
    u.id_qualifica,
    us.id_nominativo
   FROM ((rbac.utente_strutture us
     JOIN matrix.vw_tree_nodes_up_asl t ON ((t.id_node = us.id_struttura)))
     JOIN rbac.vw_utenti u ON ((u.id_utente = us.id_utente)))
  WHERE (us.validita && tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));


ALTER TABLE rbac.vw_utente_strutture OWNER TO postgres;

--
-- Name: vw_utente_strutture_ruoli; Type: VIEW; Schema: rbac; Owner: postgres
--

CREATE VIEW rbac.vw_utente_strutture_ruoli AS
 SELECT usr.id AS id_utente_struttura_ruolo,
    usr.id,
    usr.id_utente_struttura,
    usr.id_ruolo,
    r.sigla AS ruolo_sigla,
    r.descr AS ruolo_descr,
    us.id_utente,
    us.nome,
    us.cognome,
    us.cf,
    us.id_asl,
    us.descrizione_breve,
    us.id_struttura,
    us.id_qualifica,
    us.sigla_qualifica,
    us.descr_qualifica,
    r.responsabile,
    r.livello
   FROM ((rbac.utente_strutture_ruoli usr
     JOIN rbac.vw_utente_strutture us ON ((usr.id_utente_struttura = us.id_utente_struttura)))
     JOIN rbac.vw_ruoli r ON ((usr.id_ruolo = r.id_ruolo)));


ALTER TABLE rbac.vw_utente_strutture_ruoli OWNER TO postgres;

--
-- Name: vw_transazioni; Type: VIEW; Schema: ag_log; Owner: postgres
--

CREATE VIEW ag_log.vw_transazioni AS
 SELECT t.id AS id_transazione,
    t.id,
    t.id_user,
    t.ts,
    t.descr,
        CASE
            WHEN ((((vus.nome)::text || ' '::text) || (vus.cognome)::text) IS NULL) THEN (((vusr.nome)::text || ' '::text) || (vusr.cognome)::text)
            ELSE (((vus.nome)::text || ' '::text) || (vus.cognome)::text)
        END AS nominativo
   FROM ((ag_log.transazioni t
     LEFT JOIN rbac.vw_utente_strutture vus ON ((vus.id_utente = t.id_user)))
     LEFT JOIN rbac.vw_utente_strutture_ruoli vusr ON ((vusr.id_utente_struttura_ruolo = t.id_user)));


ALTER TABLE ag_log.vw_transazioni OWNER TO postgres;

--
-- Name: vw_asl_piani; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_asl_piani AS
 SELECT ap.id_his,
    ap.his_validita,
    ap.his_id_transazione,
    ap.his_ts,
    ap.ts_transazione,
    ap.id,
    ap.id_struttura,
    ap.id_piano,
    lower(ap.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(ap.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    a.descrizione AS descrizione_asl,
    sp.descrizione AS descrizione_piano,
    a.descrizione_breve AS descrizione_breve_asl,
    sp.descrizione_breve AS descrizione_breve_piano,
    a.anno AS anno_asl,
    sp.anno AS anno_piano,
    sp.cod_raggruppamento,
    sp.descrizione_breve,
    sp.alias
   FROM (((ag_his.asl_piani ap
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = ap.his_id_transazione)))
     LEFT JOIN matrix.struttura_asl a ON ((a.id = ap.id_struttura)))
     LEFT JOIN matrix.struttura_piani sp ON ((sp.id = ap.id_piano)));


ALTER TABLE ag_his.vw_asl_piani OWNER TO postgres;

--
-- Name: attivita; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.attivita (
    id bigint NOT NULL,
    id_elab_cal bigint NOT NULL,
    id_struttura bigint NOT NULL,
    id_piano bigint NOT NULL,
    id_linea bigint,
    dt timestamp without time zone,
    id_risorsa bigint,
    target integer,
    contatore integer,
    ups numeric,
    durata interval,
    validita tsrange,
    prog integer,
    id_partner bigint,
    id_struttura_partner bigint,
    validita_interna boolean DEFAULT true NOT NULL
);


ALTER TABLE agenda.attivita OWNER TO postgres;

--
-- Name: tipo_linee; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.tipo_linee (
    id bigint,
    cod character varying,
    descr character varying,
    cod_mod character varying,
    descr_completa character varying
);


ALTER TABLE matrix.tipo_linee OWNER TO postgres;

--
-- Name: vw_attivita; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_attivita AS
 SELECT a.id AS id_attivita,
    a.id,
    a.id_elab_cal,
    a.id_struttura,
    a.id_piano,
    a.id_linea,
    a.dt,
    a.id_risorsa,
    a.target,
    a.contatore,
    a.ups,
    a.durata,
    a.validita,
    a.prog,
    a.id_partner,
    a.id_struttura_partner,
    a.validita_interna,
    sp.alias,
    sp.descrizione_breve AS descrizione_piano,
    (((ur.nome)::text || ' '::text) || (ur.cognome)::text) AS nominativo_utente,
    tl.cod,
    tl.descr,
    (((up.nome)::text || ' '::text) || (up.cognome)::text) AS nominativo_partner
   FROM ((((agenda.attivita a
     JOIN matrix.struttura_piani sp ON ((sp.id = a.id_piano)))
     JOIN rbac.vw_utente_strutture ur ON ((ur.id_utente_struttura = a.id_risorsa)))
     JOIN matrix.tipo_linee tl ON ((tl.id = a.id_linea)))
     JOIN rbac.vw_utente_strutture up ON ((up.id_utente_struttura = a.id_partner)));


ALTER TABLE agenda.vw_attivita OWNER TO postgres;

--
-- Name: vw_attivita; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_attivita AS
 SELECT a.id_his,
    a.his_validita,
    a.his_id_transazione,
    a.his_ts,
    a.ts_transazione,
    a.id,
    a.id_elab_cal,
    a.id_struttura,
    a.id_piano,
    a.id_linea,
    a.dt,
    a.id_risorsa,
    a.target,
    a.contatore,
    a.ups,
    a.durata,
    a.validita,
    a.prog,
    a.id_partner,
    a.id_struttura_partner,
    a.validita_interna,
    lower(a.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(a.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    va.alias,
    va.descrizione_piano,
    va.nominativo_utente,
    va.nominativo_partner,
    va.cod,
    va.descr AS descrizione_linea
   FROM ((ag_his.attivita a
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = a.his_id_transazione)))
     JOIN agenda.vw_attivita va ON ((va.id = a.id)));


ALTER TABLE ag_his.vw_attivita OWNER TO postgres;

--
-- Name: ag_livelli_avviso; Type: TABLE; Schema: ag_types; Owner: postgres
--

CREATE TABLE ag_types.ag_livelli_avviso (
    id bigint NOT NULL,
    cod character varying,
    sigla character varying,
    descr character varying,
    colore character varying,
    ordine character varying,
    icona character varying
);


ALTER TABLE ag_types.ag_livelli_avviso OWNER TO postgres;

--
-- Name: ag_tipo_avvisi; Type: TABLE; Schema: ag_types; Owner: postgres
--

CREATE TABLE ag_types.ag_tipo_avvisi (
    id bigint NOT NULL,
    cod character varying,
    sigla character varying,
    descr character varying
);


ALTER TABLE ag_types.ag_tipo_avvisi OWNER TO postgres;

--
-- Name: vw_ag_livelli_avviso; Type: VIEW; Schema: ag_types; Owner: postgres
--

CREATE VIEW ag_types.vw_ag_livelli_avviso AS
 SELECT ag_livelli_avviso.id AS id_livello_avviso,
    ag_livelli_avviso.id,
    ag_livelli_avviso.cod,
    ag_livelli_avviso.sigla,
    ag_livelli_avviso.descr,
    ag_livelli_avviso.colore,
    ag_livelli_avviso.ordine,
    ag_livelli_avviso.icona
   FROM ag_types.ag_livelli_avviso;


ALTER TABLE ag_types.vw_ag_livelli_avviso OWNER TO postgres;

--
-- Name: vw_ag_tipo_avvisi; Type: VIEW; Schema: ag_types; Owner: postgres
--

CREATE VIEW ag_types.vw_ag_tipo_avvisi AS
 SELECT ag_tipo_avvisi.id AS id_tipo_avviso,
    ag_tipo_avvisi.id,
    ag_tipo_avvisi.cod,
    ag_tipo_avvisi.sigla,
    ag_tipo_avvisi.descr
   FROM ag_types.ag_tipo_avvisi;


ALTER TABLE ag_types.vw_ag_tipo_avvisi OWNER TO postgres;

--
-- Name: avvisi; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.avvisi (
    id bigint NOT NULL,
    codice character varying,
    sigla character varying,
    descrizione character varying,
    id_tipo_avviso bigint,
    id_livello_avviso bigint NOT NULL,
    validita tsrange,
    id_user_create bigint,
    ts_create timestamp without time zone
);


ALTER TABLE agenda.avvisi OWNER TO postgres;

--
-- Name: vw_avvisi; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_avvisi AS
 SELECT a.id AS id_avviso,
    a.id,
    a.codice,
    a.sigla,
    a.descrizione,
    a.id_tipo_avviso,
    a.id_livello_avviso,
    a.validita,
    l.descr AS descr_livello,
    l.ordine,
    l.colore,
    t.descr AS descr_tipo,
    to_char(lower(a.validita), 'YYYY-MM-DD HH24:MI'::text) AS inizio_validita,
    to_char(upper(a.validita), 'YYYY-MM-DD HH24:MI'::text) AS fine_validita,
    l.icona,
    a.id_user_create,
    a.ts_create
   FROM ((agenda.avvisi a
     JOIN ag_types.vw_ag_livelli_avviso l ON ((l.id_livello_avviso = a.id_livello_avviso)))
     JOIN ag_types.vw_ag_tipo_avvisi t ON ((t.id_tipo_avviso = a.id_tipo_avviso)));


ALTER TABLE agenda.vw_avvisi OWNER TO postgres;

--
-- Name: vw_avvisi; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_avvisi AS
 SELECT a.id_his,
    a.his_validita,
    a.his_id_transazione,
    a.his_ts,
    a.ts_transazione,
    a.id,
    a.codice,
    a.sigla,
    a.descrizione,
    a.id_tipo_avviso,
    a.id_livello_avviso,
    a.validita,
    a.id_user_create,
    a.ts_create,
    lower(a.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(a.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    va.descr_livello,
    va.descr_tipo
   FROM ((ag_his.avvisi a
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = a.his_id_transazione)))
     JOIN agenda.vw_avvisi va ON ((va.id = a.id)));


ALTER TABLE ag_his.vw_avvisi OWNER TO postgres;

--
-- Name: avviso_risorse; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.avviso_risorse (
    id bigint NOT NULL,
    id_avviso bigint,
    id_risorsa bigint,
    dt_prima_visualizzazione timestamp without time zone,
    visualizzabile boolean DEFAULT true NOT NULL
);


ALTER TABLE agenda.avviso_risorse OWNER TO postgres;

--
-- Name: nominativi_struttura; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.nominativi_struttura AS
 SELECT us.id,
    us.id_nominativo,
    us.id_struttura,
    u.nominativo,
    a.descrizione_breve,
    a.id AS id_node_struttura,
    u.id_utente AS id_anagrafica,
    a.anno,
    a.codice_interno_fk,
    a.descrizione,
    (u.cf)::text AS codice_fiscale,
    a.id_asl
   FROM ((rbac.utente_strutture us
     JOIN rbac.vw_utenti u ON ((u.id = us.id_utente)))
     JOIN matrix.struttura_asl a ON ((a.id = us.id_struttura)))
  WHERE ((u.id_asl)::integer > 0);


ALTER TABLE matrix.nominativi_struttura OWNER TO postgres;

--
-- Name: vw_nominativi_struttura; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_nominativi_struttura AS
 SELECT (nominativi_struttura.id)::integer AS id,
    nominativi_struttura.id_nominativo,
    nominativi_struttura.id_struttura,
    nominativi_struttura.nominativo,
    nominativi_struttura.descrizione_breve,
    nominativi_struttura.id_node_struttura,
    nominativi_struttura.id_anagrafica,
    nominativi_struttura.anno,
    nominativi_struttura.codice_interno_fk,
    nominativi_struttura.descrizione,
    nominativi_struttura.codice_fiscale,
    nominativi_struttura.id_asl
   FROM matrix.nominativi_struttura;


ALTER TABLE matrix.vw_nominativi_struttura OWNER TO postgres;

--
-- Name: vw_avviso_risorse; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_avviso_risorse AS
 SELECT ar.id AS id_avviso_risorsa,
    a.id_avviso,
    ar.id_risorsa,
    ar.dt_prima_visualizzazione,
    ar.visualizzabile,
    a.codice,
    a.sigla,
    a.descrizione,
    a.id_tipo_avviso,
    a.descr_tipo,
    a.id_livello_avviso,
    a.descr_livello,
    a.ordine,
    a.colore,
    a.icona,
    a.validita,
    a.inizio_validita,
    a.fine_validita,
    vns.id_asl
   FROM ((agenda.avviso_risorse ar
     JOIN agenda.vw_avvisi a ON ((ar.id_avviso = a.id_avviso)))
     JOIN matrix.vw_nominativi_struttura vns ON ((ar.id_risorsa = vns.id)))
  WHERE ar.visualizzabile;


ALTER TABLE agenda.vw_avviso_risorse OWNER TO postgres;

--
-- Name: vw_avviso_risorse; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_avviso_risorse AS
 SELECT ar.id_his,
    ar.his_validita,
    ar.his_id_transazione,
    ar.his_ts,
    ar.ts_transazione,
    ar.id,
    ar.id_avviso,
    ar.id_risorsa,
    ar.dt_prima_visualizzazione,
    ar.visualizzabile,
    lower(ar.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(ar.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    var.descrizione,
    var.descr_tipo,
    var.descr_livello,
    (((vus.nome)::text || ' '::text) || (vus.cognome)::text) AS nominativo_risorsa
   FROM (((ag_his.avviso_risorse ar
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = ar.his_id_transazione)))
     JOIN agenda.vw_avviso_risorse var ON ((var.id_avviso_risorsa = ar.id)))
     JOIN rbac.vw_utente_strutture vus ON ((vus.id_utente_struttura = ar.id_risorsa)));


ALTER TABLE ag_his.vw_avviso_risorse OWNER TO postgres;

--
-- Name: cf_liste; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.cf_liste (
    id bigint NOT NULL,
    anno integer,
    dt timestamp without time zone,
    id_cf_tipo_lista bigint
);


ALTER TABLE agenda.cf_liste OWNER TO postgres;

--
-- Name: cf_tipo_liste; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.cf_tipo_liste (
    id bigint NOT NULL,
    descr character varying NOT NULL,
    cod character varying,
    tm timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    id_user bigint,
    anno integer DEFAULT EXTRACT(year FROM CURRENT_TIMESTAMP),
    enabled boolean DEFAULT true NOT NULL,
    validita tsrange DEFAULT '(,)'::tsrange NOT NULL
);


ALTER TABLE agenda.cf_tipo_liste OWNER TO postgres;

--
-- Name: vw_cf_tipo_liste; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_cf_tipo_liste AS
 SELECT cf_tipo_liste.id AS id_cf_tipo_lista,
    cf_tipo_liste.id,
    cf_tipo_liste.descr,
    cf_tipo_liste.cod,
    cf_tipo_liste.validita,
    lower(cf_tipo_liste.validita) AS valido_da,
    upper(cf_tipo_liste.validita) AS valido_a
   FROM agenda.cf_tipo_liste
  WHERE (cf_tipo_liste.validita @> (CURRENT_TIMESTAMP)::timestamp without time zone);


ALTER TABLE agenda.vw_cf_tipo_liste OWNER TO postgres;

--
-- Name: vw_cf_liste; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_cf_liste AS
 SELECT l.id AS id_lista,
    l.id,
    l.anno,
    l.dt,
    l.id_cf_tipo_lista,
    tl.descr AS descr_tipo_lista
   FROM (agenda.cf_liste l
     JOIN agenda.vw_cf_tipo_liste tl ON ((tl.id_cf_tipo_lista = l.id_cf_tipo_lista)));


ALTER TABLE agenda.vw_cf_liste OWNER TO postgres;

--
-- Name: vw_cf_liste; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_cf_liste AS
 SELECT cl.id_his,
    cl.his_validita,
    cl.his_id_transazione,
    cl.his_ts,
    cl.ts_transazione,
    cl.id,
    cl.anno,
    cl.dt,
    cl.id_cf_tipo_lista,
    lower(cl.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(cl.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vcl.descr_tipo_lista
   FROM ((ag_his.cf_liste cl
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = cl.his_id_transazione)))
     JOIN agenda.vw_cf_liste vcl ON ((vcl.id = cl.id)));


ALTER TABLE ag_his.vw_cf_liste OWNER TO postgres;

--
-- Name: calendario_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.calendario_id_seq
    START WITH 10
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.calendario_id_seq OWNER TO postgres;

--
-- Name: calendari; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.calendari (
    id bigint DEFAULT nextval('agenda.calendario_id_seq'::regclass),
    descr character varying,
    tm timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    id_user bigint,
    nota character varying,
    anno integer DEFAULT EXTRACT(year FROM CURRENT_TIMESTAMP)
);


ALTER TABLE agenda.calendari OWNER TO postgres;

--
-- Name: elab_cal_param_ns; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.elab_cal_param_ns (
    id bigint NOT NULL,
    id_elab_cal bigint NOT NULL,
    id_ns bigint NOT NULL,
    cap_tot numeric,
    cap_used numeric,
    cap_ev numeric,
    excluded boolean,
    to_be_excluded boolean,
    fact_disponibilita numeric
);


ALTER TABLE agenda.elab_cal_param_ns OWNER TO postgres;

--
-- Name: elab_cal_param_piani; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.elab_cal_param_piani (
    id bigint NOT NULL,
    id_elab_cal bigint NOT NULL,
    id_piano bigint NOT NULL
);


ALTER TABLE agenda.elab_cal_param_piani OWNER TO postgres;

--
-- Name: elab_cals_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.elab_cals_id_seq
    START WITH 10
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.elab_cals_id_seq OWNER TO postgres;

--
-- Name: elab_cals; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.elab_cals (
    id bigint DEFAULT nextval('agenda.elab_cals_id_seq'::regclass) NOT NULL,
    descr character varying NOT NULL,
    tm timestamp without time zone NOT NULL,
    id_user bigint,
    nota character varying,
    id_calendario bigint,
    tm_last_elab timestamp without time zone,
    tm_last_elab_start timestamp without time zone
);


ALTER TABLE agenda.elab_cals OWNER TO postgres;

--
-- Name: eventi_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.eventi_id_seq
    START WITH 13
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.eventi_id_seq OWNER TO postgres;

--
-- Name: eventi; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.eventi (
    id bigint DEFAULT nextval('agenda.eventi_id_seq'::regclass) NOT NULL,
    id_nominativo bigint,
    id_tipo_evento bigint,
    inizio timestamp without time zone,
    fine timestamp without time zone,
    id_linea bigint,
    id_attivita bigint,
    id_piano bigint,
    effettuata boolean DEFAULT false NOT NULL,
    id_partner bigint,
    valido_da timestamp without time zone,
    valido_a timestamp without time zone,
    per_conto bigint,
    id_elab_cal bigint,
    id_cu bigint,
    partner_per_conto bigint,
    validita_interna boolean DEFAULT true NOT NULL,
    quantita numeric DEFAULT 1 NOT NULL,
    id_user_create bigint,
    ts_create timestamp without time zone
);


ALTER TABLE agenda.eventi OWNER TO postgres;

--
-- Name: COLUMN eventi.quantita; Type: COMMENT; Schema: agenda; Owner: postgres
--

COMMENT ON COLUMN agenda.eventi.quantita IS 'Qunatità di attività per quel piano';


--
-- Name: vw_lista_calendari; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_lista_calendari AS
 SELECT ec.id,
    ec.descr,
    ec.tm,
    ec.id_user,
    ec.nota,
    ec.id AS id_calendario,
    ec.anno
   FROM agenda.calendari ec;


ALTER TABLE agenda.vw_lista_calendari OWNER TO postgres;

--
-- Name: vw_elab_cals; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_elab_cals AS
 SELECT c.descr AS descr_cal,
    c.tm AS tm_cal,
    c.id_user AS id_user_cal,
    c.nota AS nota_cal,
    ec.id,
    ec.descr,
    ec.tm,
    c.id_user,
    ec.nota,
    c.id_calendario,
    ec.id AS id_elab_cal,
        CASE
            WHEN ((r.cnt_riversate IS NOT NULL) AND (r.cnt_riversate > 0)) THEN true
            ELSE false
        END AS bloccato,
    c.tm AS data_calendario,
    ec.tm_last_elab,
        CASE
            WHEN (ec.tm_last_elab IS NULL) THEN false
            ELSE true
        END AS elaborato,
    c.anno
   FROM ((agenda.elab_cals ec
     JOIN agenda.vw_lista_calendari c ON ((c.id_calendario = ec.id_calendario)))
     LEFT JOIN ( SELECT a.id_elab_cal,
            count(*) AS cnt_riversate
           FROM (agenda.attivita a
             JOIN agenda.eventi e ON ((a.id = e.id_attivita)))
          GROUP BY a.id_elab_cal) r ON ((r.id_elab_cal = ec.id)))
  ORDER BY c.id_calendario, ec.id;


ALTER TABLE agenda.vw_elab_cals OWNER TO postgres;

--
-- Name: vw_elab_cal_param_ns; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_elab_cal_param_ns AS
 SELECT pns.id,
    pns.id_elab_cal,
    pns.id_ns,
    ns.id_nominativo,
    ns.nominativo,
    ns.id_struttura,
    ns.descrizione_breve,
    ns.descrizione,
    ec.descr,
    ec.descr_cal,
    ns.id_node_struttura,
    pns.cap_tot,
    pns.cap_used,
    pns.cap_ev,
    pns.excluded,
    pns.to_be_excluded
   FROM ((agenda.elab_cal_param_ns pns
     JOIN matrix.vw_nominativi_struttura ns ON ((ns.id = pns.id_ns)))
     JOIN agenda.vw_elab_cals ec ON ((ec.id = pns.id_elab_cal)));


ALTER TABLE agenda.vw_elab_cal_param_ns OWNER TO postgres;

--
-- Name: vw_elab_cal_param_piani; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_elab_cal_param_piani AS
 SELECT ecpp.id,
    ecpp.id_elab_cal,
    ecpp.id_piano,
    sp.alias,
    ec.descr,
    ec.descr_cal
   FROM ((agenda.elab_cal_param_piani ecpp
     JOIN matrix.struttura_piani sp ON ((sp.id = ecpp.id_piano)))
     JOIN agenda.vw_elab_cals ec ON ((ec.id = ecpp.id_elab_cal)));


ALTER TABLE agenda.vw_elab_cal_param_piani OWNER TO postgres;

--
-- Name: vw_elab_cal_param_ns_piani; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_elab_cal_param_ns_piani AS
 SELECT vecpp.id,
    vecpp.id_elab_cal,
    vecpp.id_piano,
    vecpp.alias,
    vecpp.descr,
    vecpp.descr_cal
   FROM agenda.vw_elab_cal_param_piani vecpp
UNION
 SELECT vecpn.id,
    vecpn.id_elab_cal,
    vecpn.id_ns AS id_piano,
    vecpn.descrizione_breve AS alias,
    vecpn.descr,
    vecpn.descr_cal
   FROM agenda.vw_elab_cal_param_ns vecpn;


ALTER TABLE agenda.vw_elab_cal_param_ns_piani OWNER TO postgres;

--
-- Name: vw_elab_cal_param_ns_piani; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_elab_cal_param_ns_piani AS
 SELECT ecpnp.id_his,
    ecpnp.his_validita,
    ecpnp.his_id_transazione,
    ecpnp.his_ts,
    ecpnp.ts_transazione,
    ecpnp.id,
    ecpnp.id_elab_cal,
    ecpnp.id_piano,
    vecpnp.alias,
    vecpnp.descr,
    vecpnp.descr_cal,
    lower(ecpnp.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(ecpnp.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log
   FROM ((ag_his.elab_cal_param_ns_piani ecpnp
     JOIN agenda.vw_elab_cal_param_ns_piani vecpnp ON ((vecpnp.id = ecpnp.id)))
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = ecpnp.his_id_transazione)));


ALTER TABLE ag_his.vw_elab_cal_param_ns_piani OWNER TO postgres;

--
-- Name: vw_elab_cals; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_elab_cals AS
 SELECT ec.his_id,
    ec.his_validita,
    ec.his_id_transazione,
    ec.his_ts,
    ec.his_ts_transazione,
    ec.id,
    ec.descr,
    ec.tm,
    ec.id_user,
    ec.nota,
    ec.id_calendario,
    ec.tm_last_elab,
    ec.tm_last_elab_start,
    lower(ec.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(ec.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    c.descr AS descr_cal,
    c.nota AS nota_cal
   FROM (((ag_his.elab_cals ec
     JOIN agenda.vw_lista_calendari c ON ((c.id_calendario = ec.id_calendario)))
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = ec.his_id_transazione)))
     LEFT JOIN ( SELECT a.id_elab_cal,
            count(*) AS cnt_riversate
           FROM (agenda.attivita a
             JOIN agenda.eventi e ON ((a.id = e.id_attivita)))
          GROUP BY a.id_elab_cal) r ON ((r.id_elab_cal = ec.id)))
  ORDER BY c.id_calendario, ec.id;


ALTER TABLE ag_his.vw_elab_cals OWNER TO postgres;

--
-- Name: vw_elab_cals_params; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_elab_cals_params AS
 SELECT ecp.id_his,
    ecp.his_validita,
    ecp.his_id_transazione,
    ecp.his_ts,
    ecp.ts_transazione,
    ecp.id,
    ecp.id_elab_cal,
    ecp.type_param,
    ecp.value,
    ec.descr_cal,
    ec.id_user_cal,
    ec.anno,
    lower(ecp.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(ecp.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log
   FROM ((ag_his.elab_cals_param ecp
     JOIN agenda.vw_elab_cals ec ON ((ec.id = ecp.id_elab_cal)))
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = ecp.his_id_transazione)));


ALTER TABLE ag_his.vw_elab_cals_params OWNER TO postgres;

--
-- Name: ag_stato_eventi; Type: TABLE; Schema: ag_types; Owner: postgres
--

CREATE TABLE ag_types.ag_stato_eventi (
    id bigint NOT NULL,
    descr character varying NOT NULL,
    colore character varying,
    id_tipo_evento bigint,
    effettuata boolean,
    scaduta boolean,
    colore_bordo character varying
);


ALTER TABLE ag_types.ag_stato_eventi OWNER TO postgres;

--
-- Name: ag_tipo_eventi; Type: TABLE; Schema: ag_types; Owner: postgres
--

CREATE TABLE ag_types.ag_tipo_eventi (
    id bigint NOT NULL,
    descr character varying,
    modifica_inizio boolean,
    modifica_durata boolean,
    elimina boolean,
    inserisci boolean,
    sigla character varying,
    crea_controllo boolean DEFAULT false,
    operativa boolean DEFAULT false NOT NULL,
    tariffabile boolean DEFAULT false NOT NULL,
    chiusura character varying DEFAULT 'NO'::character varying NOT NULL,
    durata_max interval
);


ALTER TABLE ag_types.ag_tipo_eventi OWNER TO postgres;

--
-- Name: ag_ui_tipo_eventi; Type: TABLE; Schema: ag_ui; Owner: postgres
--

CREATE TABLE ag_ui.ag_ui_tipo_eventi (
    id bigint,
    sigla character varying,
    form_richieste json
);


ALTER TABLE ag_ui.ag_ui_tipo_eventi OWNER TO postgres;

--
-- Name: vw_ag_tipo_eventi; Type: VIEW; Schema: ag_types; Owner: postgres
--

CREATE VIEW ag_types.vw_ag_tipo_eventi AS
 SELECT te.id,
    te.descr,
    te.modifica_inizio,
    te.modifica_durata,
    te.elimina,
    te.inserisci,
    te.sigla,
    ute.form_richieste AS campi_richiesti,
    te.crea_controllo,
    te.operativa,
    te.tariffabile,
    te.chiusura,
    te.durata_max,
    (EXTRACT(epoch FROM te.durata_max) * (1000)::numeric) AS durata_max_ms
   FROM (ag_types.ag_tipo_eventi te
     LEFT JOIN ag_ui.ag_ui_tipo_eventi ute ON ((te.id = ute.id)));


ALTER TABLE ag_types.vw_ag_tipo_eventi OWNER TO postgres;

--
-- Name: vw_ag_stato_eventi; Type: VIEW; Schema: ag_types; Owner: postgres
--

CREATE VIEW ag_types.vw_ag_stato_eventi AS
 SELECT ase.id,
    ase.descr,
    ase.colore,
    ase.id_tipo_evento,
    ase.effettuata,
    ase.scaduta,
    vate.descr AS descr_tipo,
    vate.sigla AS sigla_tipo,
        CASE
            WHEN ase.effettuata THEN 'SI'::text
            ELSE 'NO'::text
        END AS effettuata_descr,
        CASE
            WHEN ase.scaduta THEN 'SI'::text
            ELSE 'NO'::text
        END AS scaduta_descr,
    ase.colore_bordo
   FROM (ag_types.ag_stato_eventi ase
     JOIN ag_types.vw_ag_tipo_eventi vate ON ((ase.id_tipo_evento = vate.id)));


ALTER TABLE ag_types.vw_ag_stato_eventi OWNER TO postgres;

--
-- Name: linee; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.linee (
    id bigint NOT NULL,
    id_stabilimento bigint,
    id_tipo_linea integer,
    validita tsrange,
    attivita_fissa boolean,
    linea_principale boolean,
    verificato boolean,
    fonte text,
    data_ultima_visita timestamp without time zone DEFAULT (CURRENT_TIMESTAMP - '1 year'::interval),
    id_esterno character varying
);


ALTER TABLE cu_anag.linee OWNER TO postgres;

--
-- Name: stabilimenti; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.stabilimenti (
    id bigint NOT NULL,
    id_impresa bigint,
    nome character varying,
    sd_id numeric(12,0),
    id_indirizzo bigint,
    cod_regionale character varying,
    verificato boolean,
    fonte character varying,
    categoria_rischio numeric,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL,
    cod_nazionale character varying,
    id_tipologia_struttura bigint,
    pec character varying,
    telefono character varying,
    sdi character varying
);


ALTER TABLE cu_anag.stabilimenti OWNER TO postgres;

--
-- Name: vw_eventi_singoli; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_eventi_singoli AS
 SELECT e.id,
    e.inizio,
    e.fine,
    (((t.sigla)::text || ' '::text) || COALESCE(sp.alias, ''::text)) AS evento,
    e.id_nominativo AS id_risorsa,
    n.nominativo AS risorsa,
    COALESCE(sp.alias, (t.sigla)::text) AS alias,
    t.descr AS descr_tipo_evento,
    t.sigla AS sigla_tipo_evento,
    (i.indirizzo_luogo)::character varying AS indirizzo,
    e.id_attivita AS id_calendario,
    COALESCE(sp.descrizione_breve, (t.sigla)::text) AS descrizione_breve,
    COALESCE(sp.descrizione, (t.sigla)::text) AS descrizione,
        CASE
            WHEN e.effettuata THEN false
            ELSE t.modifica_inizio
        END AS modifica_inizio,
        CASE
            WHEN e.effettuata THEN false
            ELSE t.modifica_durata
        END AS modifica_durata,
    t.elimina,
    st.colore,
    st.descr AS stato,
    date_part('epoch'::text, (e.fine - e.inizio)) AS durata,
    (e.fine - e.inizio) AS durata_int,
    e.effettuata,
    s.nome AS presso,
    (i.comune)::text AS comune,
    e.valido_da,
    e.valido_a,
    sa.descrizione_breve AS per_conto,
    e.id_partner,
    p.nominativo AS partner,
    n.id_anagrafica,
    p.id_anagrafica AS id_anagrafica_partner,
    e.id_linea,
    e.id_elab_cal,
    e.id_attivita,
    e.id_tipo_evento,
    e.id_piano,
    e.per_conto AS id_per_conto,
    e.id_cu,
    e.partner_per_conto,
    e.validita_interna,
    s.id AS id_az_sede,
    t.crea_controllo,
    t.operativa,
    t.chiusura,
        CASE
            WHEN (e.effettuata = true) THEN 'Chiusa'::text
            ELSE 'Aperta'::text
        END AS stato_attivita,
    st.colore_bordo,
    e.id_user_create,
    s.cod_regionale,
    (t.crea_controllo AND (e.id_cu IS NULL)) AS crea_cu,
    (t.crea_controllo AND (e.id_cu IS NOT NULL)) AS apri_cu
   FROM (((((((((agenda.eventi e
     JOIN matrix.nominativi_struttura n ON ((e.id_nominativo = n.id_nominativo)))
     JOIN ag_types.vw_ag_tipo_eventi t ON ((e.id_tipo_evento = t.id)))
     LEFT JOIN matrix.struttura_piani sp ON ((sp.id = e.id_piano)))
     LEFT JOIN ag_types.vw_ag_stato_eventi st ON (((e.id_tipo_evento = st.id_tipo_evento) AND (st.effettuata = e.effettuata) AND (st.scaduta = (date_trunc('day'::text, e.fine) < date_trunc('day'::text, CURRENT_TIMESTAMP))))))
     LEFT JOIN matrix.struttura_asl sa ON ((sa.id = e.per_conto)))
     LEFT JOIN matrix.nominativi_struttura p ON ((p.id_nominativo = e.id_partner)))
     LEFT JOIN cu_anag.linee a ON ((a.id = e.id_linea)))
     LEFT JOIN cu_anag.stabilimenti s ON ((s.id = a.id_stabilimento)))
     LEFT JOIN cu_anag.vw_indirizzi i ON ((i.id = s.id_indirizzo)));


ALTER TABLE agenda.vw_eventi_singoli OWNER TO postgres;

--
-- Name: vw_eventi; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_eventi AS
 SELECT es.id,
    es.inizio,
    es.fine,
    es.evento,
    es.id_risorsa,
    es.risorsa,
    es.alias,
    es.descr_tipo_evento,
    es.sigla_tipo_evento,
    es.indirizzo,
    es.id_calendario,
    es.descrizione_breve,
    es.descrizione,
    es.modifica_inizio,
    es.modifica_durata,
    es.elimina,
    es.colore,
    es.stato,
    es.durata,
    es.durata_int,
    es.effettuata,
    es.presso,
    es.comune,
    es.valido_da,
    es.valido_a,
    es.per_conto,
    es.id_partner,
    es.partner,
    'Responsabile'::text AS ruolo,
    es.id_anagrafica,
    es.id_anagrafica_partner,
    es.id_cu,
    es.validita_interna,
    es.id_linea,
    es.id_piano,
    es.id_per_conto,
    es.id_az_sede,
    es.crea_controllo,
    es.operativa,
    'Partner'::text AS ruolo_partner,
    es.chiusura,
    es.stato_attivita,
    es.colore_bordo,
    es.id_user_create,
    es.crea_cu,
    es.apri_cu,
    es.cod_regionale
   FROM agenda.vw_eventi_singoli es
UNION
 SELECT es.id,
    es.inizio,
    es.fine,
    es.evento,
    es.id_partner AS id_risorsa,
    es.partner AS risorsa,
    es.alias,
    es.descr_tipo_evento,
    es.sigla_tipo_evento,
    es.indirizzo,
    es.id_calendario,
    es.descrizione_breve,
    es.descrizione,
    false AS modifica_inizio,
    false AS modifica_durata,
    false AS elimina,
    es.colore,
    es.stato,
    es.durata,
    es.durata_int,
    es.effettuata,
    es.presso,
    es.comune,
    es.valido_da,
    es.valido_a,
    es.per_conto,
    es.id_risorsa AS id_partner,
    es.risorsa AS partner,
    'Partner'::text AS ruolo,
    es.id_anagrafica_partner AS id_anagrafica,
    es.id_anagrafica AS id_anagrafica_partner,
    es.id_cu,
    es.validita_interna,
    es.id_linea,
    es.id_piano,
    es.id_per_conto,
    es.id_az_sede,
    es.crea_controllo,
    es.operativa,
    'Responsabile'::text AS ruolo_partner,
    es.chiusura,
    es.stato_attivita,
    es.colore_bordo,
    es.id_user_create,
    es.crea_cu,
    es.apri_cu,
    es.cod_regionale
   FROM agenda.vw_eventi_singoli es
  WHERE (es.id_partner IS NOT NULL);


ALTER TABLE agenda.vw_eventi OWNER TO postgres;

--
-- Name: vw_eventi; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_eventi AS
 SELECT e.his_id,
    e.his_validita,
    e.his_id_transazione,
    e.his_ts,
    e.his_ts_transazione,
    e.id,
    e.id_nominativo,
    e.id_tipo_evento,
    e.inizio,
    e.fine,
    e.id_linea,
    e.id_attivita,
    e.id_piano,
    e.effettuata,
    e.id_partner,
    e.valido_da,
    e.valido_a,
    e.per_conto,
    e.id_elab_cal,
    e.id_cu,
    e.partner_per_conto,
    e.validita_interna,
    e.quantita,
    e.id_user_create,
    e.ts_create,
    lower(e.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(e.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    ve.evento,
    ve.descr_tipo_evento,
    ve.descrizione_breve,
    ve.stato,
    ve.stato_attivita,
    ve.ruolo,
    ve.ruolo_partner
   FROM ((ag_his.eventi e
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = e.his_id_transazione)))
     JOIN agenda.vw_eventi ve ON ((ve.id = e.id)));


ALTER TABLE ag_his.vw_eventi OWNER TO postgres;

--
-- Name: linee; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.linee (
    id integer,
    allev_id integer,
    id_fiscale character varying,
    denominazione character varying,
    indirizzo character varying,
    cap integer,
    flag_carne_latte character varying,
    dt_durata character varying,
    id_az_sede integer,
    id_tipo_allevamento integer,
    id_comune integer,
    id_specie integer,
    id_tipo_produzione integer,
    id_propretario integer,
    id_detentore integer,
    id_asl integer,
    ref_id integer,
    tipo_delegato character varying,
    telefono character varying,
    localita character varying,
    id_gruppospecie integer,
    tipo character varying,
    id_sede bigint,
    id_ml bigint,
    stato character varying,
    tipo_aut character varying,
    imballaggio bigint,
    id_tipo_linea character varying
);


ALTER TABLE agenda.linee OWNER TO postgres;

--
-- Name: vw_linea_piani; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_linea_piani AS
 SELECT lp.id_his,
    lp.his_validita,
    lp.his_id_transazione,
    lp.his_ts,
    lp.ts_transazione,
    lp.id,
    lp.id_linea,
    lp.id_piano,
    lower(lp.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(lp.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    l.denominazione,
    sp.descrizione,
    sp.alias
   FROM (((ag_his.linea_piani lp
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = lp.his_id_transazione)))
     JOIN agenda.linee l ON ((l.id = lp.id_linea)))
     LEFT JOIN matrix.struttura_piani sp ON ((sp.id = lp.id_piano)));


ALTER TABLE ag_his.vw_linea_piani OWNER TO postgres;

--
-- Name: comuni; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.comuni (
    id bigint,
    comune character varying(32),
    id_asl bigint,
    descr_alt character varying DEFAULT ''::character varying NOT NULL,
    cod_istat integer,
    denominazione_composta character varying,
    cod_catastale character varying,
    cap_default character varying,
    istat_comune character varying
);


ALTER TABLE agenda.comuni OWNER TO postgres;

--
-- Name: imprese; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.imprese (
    id bigint NOT NULL,
    nome character varying,
    cf character varying,
    piva character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    az_id bigint,
    az_cod_aziendale character varying,
    az_cod_regionale character varying,
    sd_id bigint,
    verificato boolean,
    fonte character varying,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL,
    tipo_soggetto character varying,
    CONSTRAINT imprese_check CHECK (((cod_tipo_impresa)::text = ANY (ARRAY[('A'::character varying)::text, ('D'::character varying)::text, ('P'::character varying)::text, ('S'::character varying)::text, ('Z'::character varying)::text]))),
    CONSTRAINT imprese_check_1 CHECK (((split_payement)::text = ANY (ARRAY[('S'::character varying)::text, ('N'::character varying)::text])))
);


ALTER TABLE cu_anag.imprese OWNER TO postgres;

--
-- Name: cu_tipo_imprese; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.cu_tipo_imprese (
    cod character varying NOT NULL,
    descr character varying,
    tipo_soggetto character varying
);


ALTER TABLE cu_types.cu_tipo_imprese OWNER TO postgres;

--
-- Name: vw_cu_tipo_imprese; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_cu_tipo_imprese AS
 SELECT cti.cod,
    cti.descr,
    cti.tipo_soggetto
   FROM cu_types.cu_tipo_imprese cti;


ALTER TABLE cu_types.vw_cu_tipo_imprese OWNER TO postgres;

--
-- Name: vw_imprese_all; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_imprese_all AS
 SELECT i.id AS id_impresa,
    i.id,
    COALESCE(i.nome, (sf.nome_completo)::character varying) AS nome,
    i.cf,
    (regexp_replace((i.piva)::text, '^IT'::text, ''::text))::character varying AS piva,
    i.pec,
    i.email,
    i.sdi,
    i.split_payement,
    i.cod_tipo_impresa,
    i.az_id,
    i.az_cod_aziendale,
    i.az_cod_regionale,
    i.sd_id,
    i.verificato,
    i.fonte,
    sf.cognome,
    sf.nome AS soggetto_fisico_nome,
    lower(i.validita) AS inizio_validita,
    (upper(i.validita) - '1 day'::interval) AS fine_validita,
    i.validita,
    NULL::bigint AS id_asl,
    sf.telefono,
    sf.data_nascita,
    sf.comune_nascita,
    sf.istat_nascita,
    sf.indirizzo_id AS id_indirizzo,
    i.tipo_soggetto,
    ti.descr AS descr_tipo_impresa,
    upper_inf(i.validita) AS modificabile
   FROM ((cu_anag.imprese i
     LEFT JOIN cu_types.vw_cu_tipo_imprese ti ON (((i.cod_tipo_impresa)::text = (ti.cod)::text)))
     LEFT JOIN cu_anag.vw_soggetti_fisici sf ON ((((i.tipo_soggetto)::text = 'F'::text) AND ((i.cf)::text = (sf.codice_fiscale)::text) AND (i.cf IS NOT NULL))));


ALTER TABLE cu_anag.vw_imprese_all OWNER TO postgres;

--
-- Name: vw_imprese; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_imprese AS
 SELECT i.id_impresa,
    i.id,
    i.nome,
    i.cf,
    i.piva,
    i.pec,
    i.email,
    i.sdi,
    i.split_payement,
    i.cod_tipo_impresa,
    i.az_id,
    i.az_cod_aziendale,
    i.az_cod_regionale,
    i.sd_id,
    i.verificato,
    i.fonte,
    i.cognome,
    i.soggetto_fisico_nome,
    i.inizio_validita,
    i.fine_validita,
    i.validita,
    i.id_asl,
    i.tipo_soggetto
   FROM cu_anag.vw_imprese_all i
  WHERE (i.validita && tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));


ALTER TABLE cu_anag.vw_imprese OWNER TO postgres;

--
-- Name: vw_aziende; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_aziende AS
 SELECT v.id,
    v.id AS id_azienda,
    v.az_cod_aziendale AS app_number,
    v.nome AS rag_soc,
    v.piva,
    v.cf AS codfis,
    (v.az_id)::character varying AS idua,
    v.az_cod_regionale AS codreg,
    (v.sdi IS NOT NULL) AS inviaresdi,
    v.sdi,
    ((v.split_payement)::text = 'S'::text) AS is_split,
    NULL::character varying AS nome,
    NULL::character varying AS cognome,
    v.az_cod_aziendale,
    v.az_cod_regionale
   FROM cu_anag.vw_imprese v;


ALTER TABLE agenda.vw_aziende OWNER TO postgres;

--
-- Name: vw_comuni; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_comuni AS
 SELECT comuni.id,
    comuni.comune,
    comuni.id_asl,
    comuni.descr_alt,
    comuni.cod_istat,
    comuni.denominazione_composta,
    comuni.id AS id_comune,
    "right"((comuni.istat_comune)::text, 3) AS comune_istat,
    "left"((comuni.istat_comune)::text, 3) AS provincia_istat,
    p.siglaprovincia,
    comuni.istat_comune
   FROM (agenda.comuni
     JOIN ag_conf.vw_provincie p ON ((("left"(TRIM(BOTH FROM to_char(comuni.cod_istat, '000000'::text)), 3))::integer = p.idprovinciaistat)));


ALTER TABLE agenda.vw_comuni OWNER TO postgres;

--
-- Name: cu_categ_evals_storico; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_categ_evals_storico (
    id integer NOT NULL,
    id_cu bigint,
    id_stabilimento bigint NOT NULL,
    valore numeric NOT NULL,
    dt_storico timestamp without time zone NOT NULL,
    albero_cs json
);


ALTER TABLE cu.cu_categ_evals_storico OWNER TO postgres;

--
-- Name: vw_cu_categ_evals_storico_latest; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_categ_evals_storico_latest AS
 SELECT a.id_stabilimento,
    a.valore,
    a.dt_storico
   FROM (cu.cu_categ_evals_storico a
     JOIN ( SELECT cu_categ_evals_storico.id_stabilimento,
            max(cu_categ_evals_storico.dt_storico) AS dt_storico
           FROM cu.cu_categ_evals_storico
          GROUP BY cu_categ_evals_storico.id_stabilimento) b ON (((a.id_stabilimento = b.id_stabilimento) AND (a.dt_storico = b.dt_storico))));


ALTER TABLE cu.vw_cu_categ_evals_storico_latest OWNER TO postgres;

--
-- Name: pratiche; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.pratiche (
    id integer NOT NULL,
    id_tipo_pratica integer,
    n_pratica text,
    dt timestamp without time zone,
    id_stabilimento bigint,
    stato integer,
    dt_autorizzazione timestamp without time zone
);


ALTER TABLE cu_anag.pratiche OWNER TO postgres;

--
-- Name: stabilimenti_storico; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.stabilimenti_storico (
    id integer NOT NULL,
    id_stabilimento bigint NOT NULL,
    id_impresa bigint NOT NULL,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL,
    note text
);


ALTER TABLE cu_anag.stabilimenti_storico OWNER TO postgres;

--
-- Name: vw_pratiche_latest; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_pratiche_latest AS
 SELECT a.id AS id_pratica,
    a.id_stabilimento,
    a.dt,
    a.n_pratica
   FROM (cu_anag.pratiche a
     JOIN ( SELECT DISTINCT pratiche.id_stabilimento,
            max(pratiche.id) AS id
           FROM cu_anag.pratiche
          GROUP BY pratiche.id_stabilimento) b ON (((a.id_stabilimento = b.id_stabilimento) AND (a.id = b.id))));


ALTER TABLE cu_anag.vw_pratiche_latest OWNER TO postgres;

--
-- Name: vw_stabilimenti_storico; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_stabilimenti_storico AS
 SELECT ss.id AS id_stabilimento_storico,
    ss.id,
    ss.id_stabilimento,
    ss.id_impresa,
    ss.validita,
    ss.note,
    i.nome,
    i.piva,
    i.cf,
    lower(ss.validita) AS inizio_validita,
    upper(ss.validita) AS fine_validita
   FROM (cu_anag.stabilimenti_storico ss
     JOIN cu_anag.vw_imprese i ON ((i.id = ss.id_impresa)));


ALTER TABLE cu_anag.vw_stabilimenti_storico OWNER TO postgres;

--
-- Name: cu_categ_esiti; Type: TABLE; Schema: cu_conf; Owner: postgres
--

CREATE TABLE cu_conf.cu_categ_esiti (
    id bigint NOT NULL,
    rng numrange NOT NULL,
    validita tsrange NOT NULL,
    codice character varying NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    valore numeric
);


ALTER TABLE cu_conf.cu_categ_esiti OWNER TO postgres;

--
-- Name: vw_cu_categ_esiti; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_categ_esiti AS
 SELECT cu_categ_esiti.id AS id_cu_categ_esiti,
    cu_categ_esiti.id,
    cu_categ_esiti.rng,
    cu_categ_esiti.validita,
    cu_categ_esiti.codice,
    cu_categ_esiti.sigla,
    cu_categ_esiti.descr,
    lower(cu_categ_esiti.rng) AS rng_da,
    upper(cu_categ_esiti.rng) AS rng_a,
    lower(cu_categ_esiti.validita) AS validita_da,
    upper(cu_categ_esiti.validita) AS validita_a,
    cu_categ_esiti.valore
   FROM cu_conf.cu_categ_esiti;


ALTER TABLE cu_conf.vw_cu_categ_esiti OWNER TO postgres;

--
-- Name: tipologie_struttura; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.tipologie_struttura (
    id bigint NOT NULL,
    codice character varying,
    sigla character varying,
    descrizione character varying,
    descr_cod_naz character varying,
    descr_cod_reg character varying,
    modificabile boolean DEFAULT false NOT NULL,
    modifica boolean DEFAULT false NOT NULL,
    sedi boolean DEFAULT false NOT NULL,
    figure boolean DEFAULT false NOT NULL,
    linee boolean DEFAULT false NOT NULL,
    richiede_codice_regionale boolean DEFAULT false NOT NULL,
    richiede_legale boolean DEFAULT true NOT NULL
);


ALTER TABLE cu_types.tipologie_struttura OWNER TO postgres;

--
-- Name: vw_tipologie_struttura; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_tipologie_struttura AS
 SELECT tipologie_struttura.id AS id_tipologia_struttura,
    tipologie_struttura.id,
    tipologie_struttura.codice,
    tipologie_struttura.sigla,
    tipologie_struttura.descrizione,
    tipologie_struttura.descr_cod_naz,
    tipologie_struttura.descr_cod_reg,
    tipologie_struttura.modificabile,
    tipologie_struttura.modifica,
    tipologie_struttura.sedi,
    tipologie_struttura.figure,
    tipologie_struttura.linee,
    tipologie_struttura.richiede_codice_regionale
   FROM cu_types.tipologie_struttura;


ALTER TABLE cu_types.vw_tipologie_struttura OWNER TO postgres;

--
-- Name: vw_stabilimenti_all; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_stabilimenti_all AS
 SELECT s.id AS id_stabilimento,
    s.id,
    s.id_impresa,
    s.sd_id,
    s.nome,
    ind.istat_comune AS istat,
    ind.comune,
    ind.toponimo,
    ind.indirizzo,
    ind.civico,
    i.nome AS ragsoc,
    i.cf AS cf_impresa,
    i.piva AS piva_impresa,
    s.cod_regionale AS sd_cod_regionale,
    ind.nazione,
    ind.cap,
    ts.codice AS cod_tipologia_struttura,
    s.fonte,
    s.cod_regionale AS az_cod_aziendale,
    i.az_cod_regionale,
    i.cod_tipo_impresa,
    ind.siglaprovincia,
    ind.indirizzo_luogo,
        CASE
            WHEN ((s.fonte)::text = 'SICER_B'::text) THEN 'No'::text
            ELSE 'Si'::text
        END AS valida,
    c.id_asl,
    s.verificato,
    COALESCE(e.valore, s.categoria_rischio) AS categoria_rischio,
    s.id_indirizzo,
    NULL::character varying AS cod_registrazione,
    ind.stato_prov,
    ind.istat_comune,
    lower(s.validita) AS inizio_validita,
    (upper(s.validita) - '1 day'::interval) AS fine_validita,
    s.validita,
    ind.indirizzo_completo,
    ts.descr_cod_naz,
    ts.descr_cod_reg,
    s.cod_nazionale,
    ts.sigla AS sigla_tipologia_struttura,
    s.id_tipologia_struttura,
    NULL::bigint AS id_asl_stabilimento,
    NULL::bigint AS id_asl_impresa,
    ts.modificabile,
    c.id AS id_comune,
    asl.descrizione_breve AS asl_descr,
    e.descr AS categoria_rischio_descr,
    s.pec,
    s.telefono,
    (NOT (upper_inf(s.validita) OR (LOCALTIMESTAMP < upper(s.validita)))) AS chiuso,
    i.split_payement,
        CASE
            WHEN ((i.cod_tipo_impresa)::text <> 'Z'::text) THEN i.sdi
            ELSE s.sdi
        END AS sdi,
    ts.descrizione AS descrizione_tipologia_struttura,
    s.cod_regionale,
    s.verificato AS verificato_str,
        CASE
            WHEN s.verificato THEN 'SI'::text
            ELSE 'NO'::text
        END AS verificato_descr,
    ts.modifica AS stabilimento_modificabile,
    ts.sedi AS sedi_modificabili,
    ts.figure AS figure_modificabili,
    ts.linee AS linee_modificabili,
    ts.richiede_codice_regionale,
    ind.estero,
    COALESCE(( SELECT max(ss.fine_validita) AS max
           FROM cu_anag.vw_stabilimenti_storico ss
          WHERE (ss.id_stabilimento = s.id)), (lower(s.validita) + '1 day'::interval)) AS latest_storico,
    i.pec AS pec_impresa,
    pl.n_pratica
   FROM ((((((((cu_anag.stabilimenti s
     JOIN cu_anag.vw_imprese_all i ON ((i.id_impresa = s.id_impresa)))
     LEFT JOIN cu_anag.vw_indirizzi ind ON ((ind.id = s.id_indirizzo)))
     LEFT JOIN agenda.comuni c ON (((c.istat_comune)::text = (ind.istat_comune)::text)))
     LEFT JOIN cu.vw_cu_categ_evals_storico_latest cs ON ((cs.id_stabilimento = s.id)))
     LEFT JOIN cu_conf.vw_cu_categ_esiti e ON ((e.rng @> COALESCE(cs.valore, s.categoria_rischio))))
     LEFT JOIN cu_types.vw_strutture_asl asl ON ((c.id_asl = asl.id_asl)))
     LEFT JOIN cu_types.vw_tipologie_struttura ts ON ((ts.id_tipologia_struttura = s.id_tipologia_struttura)))
     LEFT JOIN cu_anag.vw_pratiche_latest pl ON ((pl.id_stabilimento = s.id)));


ALTER TABLE cu_anag.vw_stabilimenti_all OWNER TO postgres;

--
-- Name: vw_stabilimenti; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_stabilimenti AS
 SELECT s.id_stabilimento,
    s.id,
    s.id_impresa,
    s.sd_id,
    s.nome,
    s.istat,
    s.comune,
    s.toponimo,
    s.indirizzo,
    s.civico,
    s.ragsoc,
    s.cf_impresa,
    s.piva_impresa,
    s.sd_cod_regionale,
    s.nazione,
    s.cap,
    s.cod_tipologia_struttura,
    s.fonte,
    s.az_cod_aziendale,
    s.az_cod_regionale,
    s.cod_tipo_impresa,
    s.siglaprovincia,
    s.indirizzo_luogo,
    s.valida,
    s.id_asl,
    s.verificato,
    s.categoria_rischio,
    s.id_indirizzo,
    s.cod_registrazione,
    s.stato_prov,
    s.istat_comune,
    s.inizio_validita,
    s.fine_validita,
    s.validita,
    s.indirizzo_completo,
    s.descr_cod_naz,
    s.descr_cod_reg,
    s.cod_nazionale,
    s.sigla_tipologia_struttura,
    s.id_tipologia_struttura,
    s.id_asl_stabilimento,
    s.id_asl_impresa,
    s.modificabile,
    i.verificato AS verificato_impresa,
    s.id_comune,
    s.categoria_rischio_descr,
    s.pec,
    s.telefono,
    COALESCE(s.sdi, i.sdi) AS sdi,
    s.descrizione_tipologia_struttura,
    s.cod_regionale,
    s.verificato_descr,
    s.stabilimento_modificabile,
    s.sedi_modificabili,
    s.figure_modificabili,
    s.linee_modificabili,
    s.richiede_codice_regionale,
    s.estero
   FROM (cu_anag.vw_stabilimenti_all s
     LEFT JOIN cu_anag.vw_imprese_all i ON ((i.id_impresa = s.id_impresa)))
  WHERE (i.validita && tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));


ALTER TABLE cu_anag.vw_stabilimenti OWNER TO postgres;

--
-- Name: vw_az_sedi; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_az_sedi AS
 SELECT s.id,
    s.id AS id_az_sede,
    s.id_impresa AS id_azienda,
    NULL::character varying AS stato_sede_operativa,
    s.nome AS denominazione_sede_operativa,
    s.indirizzo,
    c.id AS id_comune,
    c.id_asl AS id_struttura,
    s.sd_cod_regionale AS app_number,
    a.rag_soc,
    a.piva,
    a.codfis,
    (s.comune)::character varying(32) AS comune,
    a.codreg,
    a.idua,
    (s.cap)::character varying AS cap,
    a.inviaresdi,
    a.sdi,
    a.is_split,
    (s.nazione)::character varying AS nazione,
    c.cod_istat,
    c.comune_istat,
    c.provincia_istat,
    a.nome,
    a.cognome,
    s.sd_id,
    s.fonte,
    a.az_cod_aziendale,
    a.az_cod_regionale,
    s.istat,
    s.toponimo,
    s.civico,
    s.cod_tipologia_struttura,
    s.sd_cod_regionale,
    s.categoria_rischio,
    s.cod_registrazione,
    s.indirizzo_completo,
    s.id_impresa,
    s.cod_nazionale,
    s.id_tipologia_struttura
   FROM ((agenda.vw_aziende a
     JOIN cu_anag.vw_stabilimenti s ON ((s.id_impresa = a.id)))
     LEFT JOIN agenda.vw_comuni c ON (((c.istat_comune)::text = (s.istat)::text)));


ALTER TABLE agenda.vw_az_sedi OWNER TO postgres;

--
-- Name: vw_tipo_linee; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_tipo_linee AS
 SELECT (tipo_linee.id)::integer AS id,
    (tipo_linee.id)::integer AS id_tipo_linea,
    (tipo_linee.cod)::text AS cod,
    (tipo_linee.descr)::text AS descr,
    (tipo_linee.cod_mod)::text AS cod_mod,
    (tipo_linee.descr_completa)::text AS descr_completa
   FROM matrix.tipo_linee;


ALTER TABLE agenda.vw_tipo_linee OWNER TO postgres;

--
-- Name: vw_linee_all; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_linee_all AS
 SELECT l.id AS id_linea,
    l.id,
    l.id_stabilimento,
    l.id_tipo_linea,
    l.validita,
    l.attivita_fissa,
    l.linea_principale,
    l.verificato,
    l.fonte,
    tl.cod AS cod_tipo_linea,
    tl.descr AS desc_tipo_linea,
    tl.cod_mod AS cod_tipo_linea_mod,
    l.data_ultima_visita,
        CASE
            WHEN l.linea_principale THEN 'SI'::text
            ELSE 'NO'::text
        END AS pr,
    l.id_esterno,
    lower(l.validita) AS inizio_validita,
    (upper(l.validita) - '1 day'::interval) AS fine_validita,
    s.inizio_validita AS stab_inizio_validita,
    s.fine_validita AS stab_fine_validita,
    s.sd_id,
    s.linee_modificabili,
    s.id_asl,
    tl.descr_completa AS descr_completa_tipo_linea
   FROM ((cu_anag.linee l
     LEFT JOIN agenda.vw_tipo_linee tl ON ((tl.id_tipo_linea = l.id_tipo_linea)))
     LEFT JOIN cu_anag.vw_stabilimenti_all s ON ((s.id_stabilimento = l.id_stabilimento)));


ALTER TABLE cu_anag.vw_linee_all OWNER TO postgres;

--
-- Name: vw_linee; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_linee AS
 SELECT l.id_linea,
    l.id,
    l.id_stabilimento,
    l.id_tipo_linea,
    l.validita,
    l.attivita_fissa,
    l.linea_principale,
    l.verificato,
    l.fonte,
    l.cod_tipo_linea,
    l.desc_tipo_linea,
    l.cod_tipo_linea_mod,
    l.data_ultima_visita,
    l.pr,
    l.id_esterno,
    l.inizio_validita,
    l.fine_validita,
    l.sd_id
   FROM cu_anag.vw_linee_all l
  WHERE (l.validita && tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));


ALTER TABLE cu_anag.vw_linee OWNER TO postgres;

--
-- Name: vw_linee; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_linee AS
 SELECT l.id,
    s.id AS id_az_sede,
    s.id_azienda,
    s.stato_sede_operativa,
    s.denominazione_sede_operativa,
    s.indirizzo,
    s.id_comune,
    s.id_struttura,
    s.app_number,
    s.rag_soc,
    s.piva,
    s.codfis,
    l.id_linea,
    s.comune,
    (l.id_tipo_linea)::character varying AS id_tipo_linea,
    l.cod_tipo_linea AS attivita,
    l.cod_tipo_linea,
    l.desc_tipo_linea,
    s.cap,
    s.sdi,
    s.inviaresdi,
    s.is_split,
    s.nazione,
    s.comune_istat,
    s.provincia_istat,
    s.nome,
    s.cognome,
    l.id_tipo_linea AS id_attivita,
    (s.categoria_rischio)::integer AS livello_di_rischio,
    l.fonte AS riferimento_id_nome_tab,
    (s.idua)::text AS num_riconoscimento,
    (s.id)::integer AS riferimento_id,
    l.cod_tipo_linea_mod,
    s.sd_id,
    l.fonte,
    l.data_ultima_visita,
    s.categoria_rischio,
    s.cod_registrazione,
    l.pr,
    l.id_esterno,
    l.linea_principale,
    s.indirizzo_completo,
    s.id_impresa,
    s.cod_nazionale,
    s.id_tipologia_struttura,
    s.cod_tipologia_struttura,
    s.sd_cod_regionale
   FROM (cu_anag.vw_linee l
     JOIN agenda.vw_az_sedi s ON ((l.id_stabilimento = s.id)));


ALTER TABLE agenda.vw_linee OWNER TO postgres;

--
-- Name: vw_struttura_piani; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_struttura_piani AS
 SELECT p.id,
    p.cod_raggruppamento,
    p.anno,
    p.descrizione,
    p.ordinamento,
    p.data_scadenza,
    p.stato,
    p.codice_interno,
    p.color,
    p.path,
    p.livello,
    p.alias,
    p.id_formula_ups,
    p.id_formula_uba,
    p.descrizione_breve,
    (fups.fattore_fin *
        CASE
            WHEN fups.contiene_uba THEN fuba.fattore_fin
            ELSE (1)::double precision
        END) AS fattore_ups,
    fuba.fattore_fin AS fattore_uba,
    p.id_gisa,
    (COALESCE((p.alias || ' - '::text), ''::text) || p.descrizione) AS descrizione_piano,
    (upper(p.descrizione) ~ '.*CLASS[IY]FARM.*'::text) AS flag_cf
   FROM ((matrix.struttura_piani p
     LEFT JOIN matrix.formule fuba ON ((fuba.id = p.id_formula_uba)))
     LEFT JOIN matrix.formule fups ON ((fups.id = p.id_formula_ups)));


ALTER TABLE matrix.vw_struttura_piani OWNER TO postgres;

--
-- Name: vw_linee_selezionate; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_linee_selezionate AS
 SELECT ls.id_his,
    ls.his_validita,
    ls.his_id_transazione,
    ls.his_ts,
    ls.ts_transazione,
    ls.id,
    ls.id_elab_cal,
    ls.id_linea,
    ls.id_piano,
    ls.ordine,
    lower(ls.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(ls.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    l.denominazione_sede_operativa,
    (COALESCE((p.alias || ' '::text), ''::text) || p.descrizione) AS descrizione
   FROM (((ag_his.linee_selezionate ls
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = ls.his_id_transazione)))
     JOIN agenda.vw_linee l ON ((l.id_linea = ls.id_linea)))
     JOIN matrix.vw_struttura_piani p ON ((p.id = ls.id_piano)));


ALTER TABLE ag_his.vw_linee_selezionate OWNER TO postgres;

--
-- Name: formato_import_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.formato_import_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.formato_import_id_seq OWNER TO postgres;

--
-- Name: formato_import; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.formato_import (
    id bigint DEFAULT nextval('agenda.formato_import_id_seq'::regclass) NOT NULL,
    descr character varying NOT NULL,
    cod character varying
);


ALTER TABLE agenda.formato_import OWNER TO postgres;

--
-- Name: lista_import; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.lista_import (
    id bigint NOT NULL,
    anno integer,
    dt timestamp without time zone,
    id_tipo_lista bigint
);


ALTER TABLE agenda.lista_import OWNER TO postgres;

--
-- Name: tipo_lista_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.tipo_lista_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.tipo_lista_id_seq OWNER TO postgres;

--
-- Name: tipo_liste; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.tipo_liste (
    id bigint DEFAULT nextval('agenda.tipo_lista_id_seq'::regclass) NOT NULL,
    descr character varying NOT NULL,
    cod character varying,
    tm timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    id_user bigint,
    formato character varying,
    validita tsrange DEFAULT '(,)'::tsrange NOT NULL
);


ALTER TABLE agenda.tipo_liste OWNER TO postgres;

--
-- Name: vw_tipo_liste; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_tipo_liste AS
 SELECT tipo_liste.id AS id_tipo_lista,
    tipo_liste.id,
    tipo_liste.descr,
    tipo_liste.cod,
    tipo_liste.validita,
    lower(tipo_liste.validita) AS valido_da,
    upper(tipo_liste.validita) AS valido_a,
    tipo_liste.formato,
    fi.descr AS formato_descr
   FROM (agenda.tipo_liste tipo_liste
     JOIN agenda.formato_import fi ON (((fi.cod)::text = (tipo_liste.formato)::text)))
  WHERE (tipo_liste.validita @> (CURRENT_TIMESTAMP)::timestamp without time zone);


ALTER TABLE agenda.vw_tipo_liste OWNER TO postgres;

--
-- Name: vw_lista_import; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_lista_import AS
 SELECT l.id AS id_lista,
    l.id,
    l.anno,
    l.dt,
    l.id_tipo_lista,
    tl.descr AS descr_tipo_lista
   FROM (agenda.lista_import l
     JOIN agenda.vw_tipo_liste tl ON ((tl.id_tipo_lista = l.id_tipo_lista)));


ALTER TABLE agenda.vw_lista_import OWNER TO postgres;

--
-- Name: vw_lista_import; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_lista_import AS
 SELECT li.id_his,
    li.his_validita,
    li.his_id_transazione,
    li.his_ts,
    li.ts_transazione,
    li.id,
    li.anno,
    li.dt,
    li.id_tipo_lista,
    lower(li.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(li.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vli.descr_tipo_lista
   FROM ((ag_his.lista_import li
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = li.his_id_transazione)))
     JOIN agenda.vw_lista_import vli ON ((vli.id = li.id)));


ALTER TABLE ag_his.vw_lista_import OWNER TO postgres;

--
-- Name: vw_nominativo_az_sedi; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_nominativo_az_sedi AS
 SELECT nas.id_his,
    nas.his_validita,
    nas.his_id_transazione,
    nas.his_ts,
    nas.ts_transazione,
    nas.id,
    nas.id_nominativo_struttura,
    nas.id_az_sede,
    lower(nas.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(nas.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    a_s.denominazione_sede_operativa,
    ns.descrizione_breve,
    ns.nominativo AS nominativo_az_sedi,
    ns.descrizione_breve AS descrizione_breve_asl
   FROM (((ag_his.nominativo_az_sedi nas
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = nas.his_id_transazione)))
     JOIN matrix.vw_nominativi_struttura ns ON ((ns.id = nas.id_nominativo_struttura)))
     JOIN agenda.vw_az_sedi a_s ON ((nas.id_az_sede = a_s.id)));


ALTER TABLE ag_his.vw_nominativo_az_sedi OWNER TO postgres;

--
-- Name: struttura_comuni; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.struttura_comuni (
    id bigint NOT NULL,
    id_comune bigint NOT NULL,
    id_struttura bigint NOT NULL
);


ALTER TABLE agenda.struttura_comuni OWNER TO postgres;

--
-- Name: vw_struttura_comuni; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_struttura_comuni AS
 SELECT sc.id,
    sc.id_comune,
    sc.id_struttura,
    c.comune,
    sa.descrizione_breve,
    true AS selezionato,
    sc.id AS id_struttura_comune,
    sa.anno,
    sa.descrizione,
    c.cod_istat,
    c.comune_istat,
    c.provincia_istat,
    c.siglaprovincia,
    c.istat_comune
   FROM ((agenda.struttura_comuni sc
     JOIN agenda.vw_comuni c ON ((c.id = sc.id_comune)))
     JOIN matrix.struttura_asl sa ON ((sa.id = sc.id_struttura)));


ALTER TABLE agenda.vw_struttura_comuni OWNER TO postgres;

--
-- Name: nominativi; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.nominativi AS
 SELECT vw_utente_strutture.id_nominativo AS id,
    vw_utente_strutture.id_utente AS id_nominativo_gisa,
    vw_utente_strutture.id_utente AS id_anagrafica,
    (((vw_utente_strutture.nome)::text || ' '::text) || (vw_utente_strutture.cognome)::text) AS nominativo,
    vw_utente_strutture.cf AS codice_fiscale,
    vw_utente_strutture.descr_qualifica AS qualifica
   FROM rbac.vw_utente_strutture
  WHERE ((vw_utente_strutture.id_asl)::integer > 0);


ALTER TABLE matrix.nominativi OWNER TO postgres;

--
-- Name: vw_nominativo_comuni; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_nominativo_comuni AS
 SELECT nc.id_his,
    nc.his_validita,
    nc.his_id_transazione,
    nc.his_ts,
    nc.ts_transazione,
    nc.id,
    nc.id_nominativo_struttura,
    nc.id_struttura_comune,
    lower(nc.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(nc.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    sa.descrizione,
    sc.descrizione_breve,
    sa.descrizione_breve AS descrizione_breve_asl,
    n.nominativo AS nominativo_comuni
   FROM (((((ag_his.nominativo_comuni nc
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = nc.his_id_transazione)))
     JOIN matrix.vw_nominativi_struttura ns ON ((ns.id = nc.id_nominativo_struttura)))
     JOIN matrix.nominativi n ON ((n.id = ns.id_nominativo)))
     JOIN matrix.struttura_asl sa ON ((sa.id = ns.id_node_struttura)))
     JOIN agenda.vw_struttura_comuni sc ON ((nc.id_struttura_comune = sc.id)));


ALTER TABLE ag_his.vw_nominativo_comuni OWNER TO postgres;

--
-- Name: vw_nominativo_linee; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_nominativo_linee AS
 SELECT nl.id_his,
    nl.his_validita,
    nl.his_id_transazione,
    nl.his_ts,
    nl.ts_transazione,
    nl.id,
    nl.id_nominativo_struttura,
    nl.id_linea,
    lower(nl.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(nl.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    l.denominazione_sede_operativa,
    ns.descrizione_breve AS descrizione_breve_asl,
    ns.descrizione_breve,
    ns.nominativo AS nominativo_linee
   FROM (((ag_his.nominativo_linee nl
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = nl.his_id_transazione)))
     JOIN matrix.vw_nominativi_struttura ns ON ((ns.id = nl.id_nominativo_struttura)))
     JOIN agenda.vw_linee l ON ((nl.id_linea = l.id)));


ALTER TABLE ag_his.vw_nominativo_linee OWNER TO postgres;

--
-- Name: vw_nominativo_piani; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_nominativo_piani AS
 SELECT np.id_his,
    np.his_validita,
    np.his_id_transazione,
    np.his_ts,
    np.ts_transazione,
    np.id,
    np.id_nominativo_struttura,
    np.id_piano,
    lower(np.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(np.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    sp.descrizione_breve,
    ns.descrizione_breve AS descrizione_breve_asl,
    sp.descrizione,
    sp.alias,
    ns.nominativo AS nominativo_piani
   FROM (((ag_his.nominativo_piani np
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = np.his_id_transazione)))
     JOIN matrix.vw_nominativi_struttura ns ON ((ns.id = np.id_nominativo_struttura)))
     JOIN matrix.struttura_piani sp ON ((sp.id = np.id_piano)));


ALTER TABLE ag_his.vw_nominativo_piani OWNER TO postgres;

--
-- Name: vw_piano_freq; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_piano_freq AS
 SELECT pf.id_his,
    pf.his_validita,
    pf.his_id_transazione,
    pf.his_ts,
    pf.ts_transazione,
    pf.id,
    pf.id_piano,
    pf.livello,
    pf.num,
    pf.den,
    lower(pf.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(pf.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    sp.descrizione,
    sp.descrizione_breve,
    sp.alias AS alias_piano
   FROM ((ag_his.piano_freq pf
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = pf.his_id_transazione)))
     JOIN matrix.vw_struttura_piani sp ON ((sp.id = pf.id_piano)));


ALTER TABLE ag_his.vw_piano_freq OWNER TO postgres;

--
-- Name: vw_piano_periodo; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_piano_periodo AS
 SELECT pp.id_his,
    pp.his_validita,
    pp.his_id_transazione,
    pp.his_ts,
    pp.ts_transazione,
    pp.id,
    pp.id_piano,
    pp.periodo,
    pp.validita_interna,
    lower(pp.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(pp.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    sp.alias,
    sp.descrizione,
    sp.descrizione_piano
   FROM ((ag_his.piano_periodo pp
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = pp.his_id_transazione)))
     JOIN matrix.vw_struttura_piani sp ON ((sp.id = pp.id_piano)));


ALTER TABLE ag_his.vw_piano_periodo OWNER TO postgres;

--
-- Name: ag_tree_nodes; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.ag_tree_nodes (
    id bigint DEFAULT nextval('agenda.agenda_id_seq'::regclass) NOT NULL,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying,
    id_node_parent integer
);


ALTER TABLE agenda.ag_tree_nodes OWNER TO postgres;

--
-- Name: vw_ag_tree_nodes; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_ag_tree_nodes AS
 SELECT t.name AS name_tree,
    n.id AS id_node,
    n.id_tree,
    n.id_parent AS id_node_parent,
    n.ordinamento,
    n.node_descr
   FROM (agenda.ag_tree_nodes n
     JOIN agenda.ag_trees t ON ((n.id_tree = t.id)));


ALTER TABLE agenda.vw_ag_tree_nodes OWNER TO postgres;

--
-- Name: vw_ag_tree_nodes_up; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_ag_tree_nodes_up AS
 WITH RECURSIVE vw_ag_tree_nodes_up(name_tree, id_node, id_tree, id_node_parent, path) AS (
         SELECT vw_ag_tree_nodes.name_tree,
            vw_ag_tree_nodes.id_node,
            vw_ag_tree_nodes.id_tree,
            vw_ag_tree_nodes.id_node_parent,
            (vw_ag_tree_nodes.id_node)::text AS path,
            vw_ag_tree_nodes.ordinamento AS path_ord,
            vw_ag_tree_nodes.node_descr AS path_descr,
            0 AS lv,
            vw_ag_tree_nodes.node_descr,
            vw_ag_tree_nodes.ordinamento
           FROM agenda.vw_ag_tree_nodes
          WHERE (vw_ag_tree_nodes.id_node_parent IS NULL)
        UNION ALL
         SELECT n.name_tree,
            n.id_node,
            n.id_tree,
            n.id_node_parent,
            ((up.path || '/'::text) || n.id_node),
            (((up.path_ord)::text || '/'::text) || (n.ordinamento)::text),
            (((up.path_descr)::text || '/'::text) || (n.node_descr)::text),
            (up.lv + 1) AS lv,
            (n.node_descr)::text AS node_descr,
            up.ordinamento
           FROM (vw_ag_tree_nodes_up up
             JOIN agenda.vw_ag_tree_nodes n ON ((up.id_node = n.id_node_parent)))
        )
 SELECT vw_ag_tree_nodes_up.name_tree,
    vw_ag_tree_nodes_up.id_node,
    vw_ag_tree_nodes_up.id_tree,
    vw_ag_tree_nodes_up.id_node_parent,
    vw_ag_tree_nodes_up.path,
    vw_ag_tree_nodes_up.path_ord,
    vw_ag_tree_nodes_up.path_descr,
    vw_ag_tree_nodes_up.lv,
    vw_ag_tree_nodes_up.node_descr,
    vw_ag_tree_nodes_up.ordinamento
   FROM vw_ag_tree_nodes_up
  ORDER BY vw_ag_tree_nodes_up.path;


ALTER TABLE agenda.vw_ag_tree_nodes_up OWNER TO postgres;

--
-- Name: vw_ag_tree_nodes_up_tipo_linee; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_ag_tree_nodes_up_tipo_linee AS
 SELECT (t.name_tree)::text AS name_tree,
    (t.id_node)::integer AS id_node,
    (t.id_tree)::integer AS id_tree,
    (t.id_node_parent)::integer AS id_node_parent,
    (t.path)::character varying AS path,
    (t.path_ord)::text AS path_ord,
    (t.path_descr)::text AS path_descr,
    tl.id,
    tl.cod,
    tl.descr,
    t.lv AS livello,
    t.ordinamento,
    tl.cod_mod
   FROM (agenda.vw_ag_tree_nodes_up t
     JOIN agenda.vw_tipo_linee tl ON ((t.id_node = tl.id)))
  WHERE ((t.name_tree)::text = 'tipo_linee'::text);


ALTER TABLE agenda.vw_ag_tree_nodes_up_tipo_linee OWNER TO postgres;

--
-- Name: vw_piano_tipo_linea; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_piano_tipo_linea AS
 SELECT ptl.id_his,
    ptl.his_validita,
    ptl.his_id_transazione,
    ptl.his_ts,
    ptl.ts_transazione,
    ptl.id_piano,
    ptl.id_tipo_linea,
    ptl.id,
    lower(ptl.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(ptl.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    p.descrizione AS descr_piano,
    p.descrizione_breve AS descr_breve_piano,
    t.descr AS descr_tipo_linea,
    p.alias AS alias_piano,
    t.cod
   FROM (((ag_his.piano_tipo_linea ptl
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = ptl.his_id_transazione)))
     JOIN matrix.vw_struttura_piani p ON ((ptl.id_piano = p.id)))
     JOIN agenda.vw_ag_tree_nodes_up_tipo_linee t ON ((ptl.id_tipo_linea = t.id)));


ALTER TABLE ag_his.vw_piano_tipo_linea OWNER TO postgres;

--
-- Name: transazioni; Type: TABLE; Schema: cu_log; Owner: postgres
--

CREATE TABLE cu_log.transazioni (
    id bigint NOT NULL,
    id_user bigint NOT NULL,
    ts timestamp without time zone NOT NULL,
    descr character varying
);


ALTER TABLE cu_log.transazioni OWNER TO postgres;

--
-- Name: vw_transazioni; Type: VIEW; Schema: cu_log; Owner: postgres
--

CREATE VIEW cu_log.vw_transazioni AS
 SELECT t.id AS id_transazione,
    t.id,
    t.id_user,
    t.ts,
    t.descr,
    n.nominativo
   FROM (cu_log.transazioni t
     LEFT JOIN matrix.nominativi n ON ((n.id_anagrafica = t.id_user)));


ALTER TABLE cu_log.vw_transazioni OWNER TO postgres;

--
-- Name: vw_ref_asl_piani; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_asl_piani AS
 SELECT ap.his_id_transazione,
    ap.id,
    vap.alias AS descr_oggetto,
    'asl_piani'::text AS tabella,
    t.id_user,
    t.nominativo,
    ap.his_validita
   FROM ((ag_his.asl_piani ap
     LEFT JOIN cu_log.vw_transazioni t ON ((ap.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_asl_piani vap ON ((vap.id = ap.id)));


ALTER TABLE ag_his.vw_ref_asl_piani OWNER TO postgres;

--
-- Name: vw_ref_asl_piani_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_asl_piani_fast AS
 SELECT ap.his_id_transazione,
    ap.id,
    vap.alias AS descr_oggetto,
    'asl_piani'::text AS tabella,
    ap.his_validita
   FROM (ag_his.asl_piani ap
     JOIN ag_his.vw_asl_piani vap ON ((vap.id = ap.id)));


ALTER TABLE ag_his.vw_ref_asl_piani_fast OWNER TO postgres;

--
-- Name: vw_ref_attivita; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_attivita AS
 SELECT a.his_id_transazione,
    a.id,
    va.alias AS descr_oggetto,
    'attivita'::text AS tabella,
    t.id_user,
    t.nominativo,
    a.his_validita
   FROM ((ag_his.attivita a
     LEFT JOIN cu_log.vw_transazioni t ON ((a.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_attivita va ON ((va.id = a.id)));


ALTER TABLE ag_his.vw_ref_attivita OWNER TO postgres;

--
-- Name: vw_ref_attivita_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_attivita_fast AS
 SELECT a.his_id_transazione,
    a.id,
    va.alias AS descr_oggetto,
    'attivita'::text AS tabella,
    a.his_validita
   FROM (ag_his.attivita a
     JOIN ag_his.vw_attivita va ON ((va.id = a.id)));


ALTER TABLE ag_his.vw_ref_attivita_fast OWNER TO postgres;

--
-- Name: vw_ref_avvisi; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_avvisi AS
 SELECT DISTINCT a.his_id_transazione,
    a.id,
    va.codice AS descr_oggetto,
    'avvisi'::text AS tabella,
    t.id_user,
    t.nominativo,
    a.his_validita
   FROM ((ag_his.avvisi a
     LEFT JOIN cu_log.vw_transazioni t ON ((a.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_avvisi va ON ((va.id = a.id)));


ALTER TABLE ag_his.vw_ref_avvisi OWNER TO postgres;

--
-- Name: vw_ref_avvisi_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_avvisi_fast AS
 SELECT DISTINCT a.his_id_transazione,
    a.id,
    va.codice AS descr_oggetto,
    'avvisi'::text AS tabella,
    a.his_validita
   FROM (ag_his.avvisi a
     JOIN ag_his.vw_avvisi va ON ((va.id = a.id)));


ALTER TABLE ag_his.vw_ref_avvisi_fast OWNER TO postgres;

--
-- Name: vw_ref_avviso_risorse; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_avviso_risorse AS
 SELECT ar.his_id_transazione,
    ar.id,
    var.sigla AS descr_oggetto,
    'avviso_risorse'::text AS tabella,
    t.id_user,
    t.nominativo,
    ar.his_validita
   FROM ((ag_his.avviso_risorse ar
     LEFT JOIN cu_log.vw_transazioni t ON ((ar.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_avvisi var ON ((var.id = ar.id_avviso)));


ALTER TABLE ag_his.vw_ref_avviso_risorse OWNER TO postgres;

--
-- Name: vw_ref_avviso_risorse_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_avviso_risorse_fast AS
 SELECT ar.his_id_transazione,
    ar.id,
    var.sigla AS descr_oggetto,
    'avviso_risorse'::text AS tabella,
    ar.his_validita
   FROM (ag_his.avviso_risorse ar
     JOIN ag_his.vw_avvisi var ON ((var.id = ar.id_avviso)));


ALTER TABLE ag_his.vw_ref_avviso_risorse_fast OWNER TO postgres;

--
-- Name: vw_ref_cf_liste; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_cf_liste AS
 SELECT cl.his_id_transazione,
    cl.id,
    vcl.descr_tipo_lista AS descr_oggetto,
    'cf_liste'::text AS tabella,
    t.id_user,
    t.nominativo,
    cl.his_validita
   FROM ((ag_his.cf_liste cl
     LEFT JOIN cu_log.vw_transazioni t ON ((cl.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_cf_liste vcl ON ((vcl.id = cl.id)));


ALTER TABLE ag_his.vw_ref_cf_liste OWNER TO postgres;

--
-- Name: vw_ref_cf_liste_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_cf_liste_fast AS
 SELECT cl.his_id_transazione,
    cl.id,
    vcl.descr_tipo_lista AS descr_oggetto,
    'cf_liste'::text AS tabella,
    cl.his_validita
   FROM (ag_his.cf_liste cl
     JOIN ag_his.vw_cf_liste vcl ON ((vcl.id = cl.id)));


ALTER TABLE ag_his.vw_ref_cf_liste_fast OWNER TO postgres;

--
-- Name: vw_ref_elab_cal_params_ns_piani; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_elab_cal_params_ns_piani AS
 SELECT ecpnp.his_id_transazione,
    ecpnp.id,
    vecpnp.alias AS descr_oggetto,
    'elab_cal_param_ns_piani'::text AS tabella,
    t.id_user,
    t.nominativo,
    ecpnp.his_validita
   FROM ((ag_his.elab_cal_param_ns_piani ecpnp
     LEFT JOIN cu_log.vw_transazioni t ON ((ecpnp.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_elab_cal_param_ns_piani vecpnp ON ((vecpnp.id = ecpnp.id)));


ALTER TABLE ag_his.vw_ref_elab_cal_params_ns_piani OWNER TO postgres;

--
-- Name: vw_ref_elab_cal_params_ns_piani_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_elab_cal_params_ns_piani_fast AS
 SELECT ecpnp.his_id_transazione,
    ecpnp.id,
    vecpnp.alias AS descr_oggetto,
    'elab_cal_param_ns_piani'::text AS tabella,
    ecpnp.his_validita
   FROM (ag_his.elab_cal_param_ns_piani ecpnp
     JOIN ag_his.vw_elab_cal_param_ns_piani vecpnp ON ((vecpnp.id = ecpnp.id)));


ALTER TABLE ag_his.vw_ref_elab_cal_params_ns_piani_fast OWNER TO postgres;

--
-- Name: vw_ref_elab_cals; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_elab_cals AS
 SELECT ec.his_id_transazione,
    ec.id,
    vec.descr_cal AS descr_oggetto,
    'elab_cals'::text AS tabella,
    t.id_user,
    t.nominativo,
    ec.his_validita
   FROM ((ag_his.elab_cals ec
     LEFT JOIN cu_log.vw_transazioni t ON ((ec.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_elab_cals vec ON ((vec.id = ec.id)));


ALTER TABLE ag_his.vw_ref_elab_cals OWNER TO postgres;

--
-- Name: vw_ref_elab_cals_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_elab_cals_fast AS
 SELECT ec.his_id_transazione,
    ec.id,
    vec.descr_cal AS descr_oggetto,
    'elab_cals'::text AS tabella,
    ec.his_validita
   FROM (ag_his.elab_cals ec
     JOIN ag_his.vw_elab_cals vec ON ((vec.id = ec.id)));


ALTER TABLE ag_his.vw_ref_elab_cals_fast OWNER TO postgres;

--
-- Name: vw_ref_elab_cals_params; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_elab_cals_params AS
 SELECT ecp.his_id_transazione,
    ecp.id,
    vecp.descr_cal AS descr_oggetto,
    'elab_cals_param'::text AS tabella,
    t.id_user,
    t.nominativo,
    ecp.his_validita
   FROM ((ag_his.elab_cals_param ecp
     LEFT JOIN cu_log.vw_transazioni t ON ((ecp.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_elab_cals_params vecp ON ((vecp.id = ecp.id)));


ALTER TABLE ag_his.vw_ref_elab_cals_params OWNER TO postgres;

--
-- Name: vw_ref_elab_cals_params_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_elab_cals_params_fast AS
 SELECT ecp.his_id_transazione,
    ecp.id,
    vecp.descr_cal AS descr_oggetto,
    'elab_cals_param'::text AS tabella,
    ecp.his_validita
   FROM (ag_his.elab_cals_param ecp
     JOIN ag_his.vw_elab_cals_params vecp ON ((vecp.id = ecp.id)));


ALTER TABLE ag_his.vw_ref_elab_cals_params_fast OWNER TO postgres;

--
-- Name: vw_ref_eventi; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_eventi AS
 SELECT e.his_id_transazione,
    e.id,
    ve.evento AS descr_oggetto,
    'eventi'::text AS tabella,
    t.id_user,
    t.nominativo,
    e.his_validita
   FROM ((ag_his.eventi e
     LEFT JOIN cu_log.vw_transazioni t ON ((e.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_eventi ve ON ((ve.id = e.id)));


ALTER TABLE ag_his.vw_ref_eventi OWNER TO postgres;

--
-- Name: vw_ref_eventi_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_eventi_fast AS
 SELECT e.his_id_transazione,
    e.id,
    ve.evento AS descr_oggetto,
    'eventi'::text AS tabella,
    e.his_validita
   FROM (ag_his.eventi e
     JOIN ag_his.vw_eventi ve ON ((ve.id = e.id)));


ALTER TABLE ag_his.vw_ref_eventi_fast OWNER TO postgres;

--
-- Name: vw_ref_linea_piani; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_linea_piani AS
 SELECT lp.his_id_transazione,
    lp.id,
    vlp.alias AS descr_oggetto,
    'linea_piani'::text AS tabella,
    t.id_user,
    t.nominativo,
    lp.his_validita
   FROM ((ag_his.linea_piani lp
     LEFT JOIN cu_log.vw_transazioni t ON ((lp.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_linea_piani vlp ON ((vlp.id = lp.id)));


ALTER TABLE ag_his.vw_ref_linea_piani OWNER TO postgres;

--
-- Name: vw_ref_linea_piani_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_linea_piani_fast AS
 SELECT lp.his_id_transazione,
    lp.id,
    vlp.alias AS descr_oggetto,
    'linea_piani'::text AS tabella,
    lp.his_validita
   FROM (ag_his.linea_piani lp
     JOIN ag_his.vw_linea_piani vlp ON ((vlp.id = lp.id)));


ALTER TABLE ag_his.vw_ref_linea_piani_fast OWNER TO postgres;

--
-- Name: vw_ref_linee_selezionate; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_linee_selezionate AS
 SELECT ls.his_id_transazione,
    ls.id,
    vls.descrizione AS descr_oggetto,
    'linee_selezionate'::text AS tabella,
    t.id_user,
    t.nominativo,
    ls.his_validita
   FROM ((ag_his.linee_selezionate ls
     LEFT JOIN cu_log.vw_transazioni t ON ((ls.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_linee_selezionate vls ON ((vls.id = ls.id)));


ALTER TABLE ag_his.vw_ref_linee_selezionate OWNER TO postgres;

--
-- Name: vw_ref_linee_selezionate_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_linee_selezionate_fast AS
 SELECT ls.his_id_transazione,
    ls.id,
    vls.descrizione AS descr_oggetto,
    'linee_selezionate'::text AS tabella,
    ls.his_validita
   FROM (ag_his.linee_selezionate ls
     JOIN ag_his.vw_linee_selezionate vls ON ((vls.id = ls.id)));


ALTER TABLE ag_his.vw_ref_linee_selezionate_fast OWNER TO postgres;

--
-- Name: vw_ref_lista_import; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_lista_import AS
 SELECT li.his_id_transazione,
    li.id,
    vli.descr_tipo_lista AS descr_oggetto,
    'lista_import'::text AS tabella,
    t.id_user,
    t.nominativo,
    li.his_validita
   FROM ((ag_his.lista_import li
     LEFT JOIN cu_log.vw_transazioni t ON ((li.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_lista_import vli ON ((vli.id = li.id)));


ALTER TABLE ag_his.vw_ref_lista_import OWNER TO postgres;

--
-- Name: vw_ref_lista_import_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_lista_import_fast AS
 SELECT li.his_id_transazione,
    li.id,
    vli.descr_tipo_lista AS descr_oggetto,
    'lista_import'::text AS tabella,
    li.his_validita
   FROM (ag_his.lista_import li
     JOIN ag_his.vw_lista_import vli ON ((vli.id = li.id)));


ALTER TABLE ag_his.vw_ref_lista_import_fast OWNER TO postgres;

--
-- Name: vw_ref_nominativo_az_sedi; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_nominativo_az_sedi AS
 SELECT nas.his_id_transazione,
    nas.id,
    vnas.descrizione_breve AS descr_oggetto,
    'nominativo_az_sedi'::text AS tabella,
    t.id_user,
    t.nominativo,
    nas.his_validita
   FROM ((ag_his.nominativo_az_sedi nas
     LEFT JOIN cu_log.vw_transazioni t ON ((nas.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_nominativo_az_sedi vnas ON ((vnas.id = nas.id)));


ALTER TABLE ag_his.vw_ref_nominativo_az_sedi OWNER TO postgres;

--
-- Name: vw_ref_nominativo_az_sedi_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_nominativo_az_sedi_fast AS
 SELECT nas.his_id_transazione,
    nas.id,
    vnas.descrizione_breve AS descr_oggetto,
    'nominativo_az_sedi'::text AS tabella,
    nas.his_validita
   FROM (ag_his.nominativo_az_sedi nas
     JOIN ag_his.vw_nominativo_az_sedi vnas ON ((vnas.id = nas.id)));


ALTER TABLE ag_his.vw_ref_nominativo_az_sedi_fast OWNER TO postgres;

--
-- Name: vw_ref_nominativo_comuni; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_nominativo_comuni AS
 SELECT nc.his_id_transazione,
    nc.id,
    vnc.descrizione_breve AS descr_oggetto,
    'nominativo_comuni'::text AS tabella,
    t.id_user,
    t.nominativo,
    nc.his_validita
   FROM ((ag_his.nominativo_comuni nc
     LEFT JOIN cu_log.vw_transazioni t ON ((nc.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_nominativo_comuni vnc ON ((vnc.id = nc.id)));


ALTER TABLE ag_his.vw_ref_nominativo_comuni OWNER TO postgres;

--
-- Name: vw_ref_nominativo_comuni_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_nominativo_comuni_fast AS
 SELECT nc.his_id_transazione,
    nc.id,
    vnc.descrizione_breve AS descr_oggetto,
    'nominativo_comuni'::text AS tabella,
    nc.his_validita
   FROM (ag_his.nominativo_comuni nc
     JOIN ag_his.vw_nominativo_comuni vnc ON ((vnc.id = nc.id)));


ALTER TABLE ag_his.vw_ref_nominativo_comuni_fast OWNER TO postgres;

--
-- Name: vw_ref_nominativo_linee; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_nominativo_linee AS
 SELECT nl.his_id_transazione,
    nl.id,
    vnl.descrizione_breve AS descr_oggetto,
    'nominativo_linee'::text AS tabella,
    t.id_user,
    t.nominativo,
    nl.his_validita
   FROM ((ag_his.nominativo_linee nl
     LEFT JOIN cu_log.vw_transazioni t ON ((nl.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_nominativo_linee vnl ON ((vnl.id = nl.id)));


ALTER TABLE ag_his.vw_ref_nominativo_linee OWNER TO postgres;

--
-- Name: vw_ref_nominativo_linee_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_nominativo_linee_fast AS
 SELECT nl.his_id_transazione,
    nl.id,
    vnl.descrizione_breve AS descr_oggetto,
    'nominativo_linee'::text AS tabella,
    nl.his_validita
   FROM (ag_his.nominativo_linee nl
     JOIN ag_his.vw_nominativo_linee vnl ON ((vnl.id = nl.id)));


ALTER TABLE ag_his.vw_ref_nominativo_linee_fast OWNER TO postgres;

--
-- Name: vw_ref_nominativo_piani; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_nominativo_piani AS
 SELECT np.his_id_transazione,
    np.id,
    vnp.descrizione_breve AS descr_oggetto,
    'nominativo_piani'::text AS tabella,
    t.id_user,
    t.nominativo,
    np.his_validita
   FROM ((ag_his.nominativo_piani np
     LEFT JOIN cu_log.vw_transazioni t ON ((np.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_nominativo_piani vnp ON ((vnp.id = np.id)));


ALTER TABLE ag_his.vw_ref_nominativo_piani OWNER TO postgres;

--
-- Name: vw_ref_nominativo_piani_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_nominativo_piani_fast AS
 SELECT np.his_id_transazione,
    np.id,
    vnp.descrizione_breve AS descr_oggetto,
    'nominativo_piani'::text AS tabella,
    np.his_validita
   FROM (ag_his.nominativo_piani np
     JOIN ag_his.vw_nominativo_piani vnp ON ((vnp.id = np.id)));


ALTER TABLE ag_his.vw_ref_nominativo_piani_fast OWNER TO postgres;

--
-- Name: vw_ref_piano_freq; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_piano_freq AS
 SELECT pf.his_id_transazione,
    pf.id,
    vpf.alias_piano AS descr_oggetto,
    'piano_freq'::text AS tabella,
    t.id_user,
    t.nominativo,
    pf.his_validita
   FROM ((ag_his.piano_freq pf
     LEFT JOIN cu_log.vw_transazioni t ON ((pf.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_piano_freq vpf ON ((vpf.id = pf.id)));


ALTER TABLE ag_his.vw_ref_piano_freq OWNER TO postgres;

--
-- Name: vw_ref_piano_freq_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_piano_freq_fast AS
 SELECT pf.his_id_transazione,
    pf.id,
    vpf.alias_piano AS descr_oggetto,
    'piano_freq'::text AS tabella,
    pf.his_validita
   FROM (ag_his.piano_freq pf
     JOIN ag_his.vw_piano_freq vpf ON ((vpf.id = pf.id)));


ALTER TABLE ag_his.vw_ref_piano_freq_fast OWNER TO postgres;

--
-- Name: vw_ref_piano_periodo; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_piano_periodo AS
 SELECT pp.his_id_transazione,
    pp.id,
    vpp.alias AS descr_oggetto,
    'piano_periodo'::text AS tabella,
    t.id_user,
    t.nominativo,
    pp.his_validita
   FROM ((ag_his.piano_periodo pp
     LEFT JOIN cu_log.vw_transazioni t ON ((pp.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_piano_periodo vpp ON ((vpp.id = pp.id)));


ALTER TABLE ag_his.vw_ref_piano_periodo OWNER TO postgres;

--
-- Name: vw_ref_piano_periodo_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_piano_periodo_fast AS
 SELECT pp.his_id_transazione,
    pp.id,
    vpp.alias AS descr_oggetto,
    'piano_periodo'::text AS tabella,
    pp.his_validita
   FROM (ag_his.piano_periodo pp
     JOIN ag_his.vw_piano_periodo vpp ON ((vpp.id = pp.id)));


ALTER TABLE ag_his.vw_ref_piano_periodo_fast OWNER TO postgres;

--
-- Name: vw_ref_piano_tipo_linea; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_piano_tipo_linea AS
 SELECT ptl.his_id_transazione,
    ptl.id,
    vptl.alias_piano AS descr_oggetto,
    'piano_tipo_linea'::text AS tabella,
    t.id_user,
    t.nominativo,
    ptl.his_validita
   FROM ((ag_his.piano_tipo_linea ptl
     LEFT JOIN cu_log.vw_transazioni t ON ((ptl.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_piano_tipo_linea vptl ON ((vptl.id = ptl.id)));


ALTER TABLE ag_his.vw_ref_piano_tipo_linea OWNER TO postgres;

--
-- Name: vw_ref_piano_tipo_linea_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_piano_tipo_linea_fast AS
 SELECT ptl.his_id_transazione,
    ptl.id,
    vptl.alias_piano AS descr_oggetto,
    'piano_tipo_linea'::text AS tabella,
    ptl.his_validita
   FROM (ag_his.piano_tipo_linea ptl
     JOIN ag_his.vw_piano_tipo_linea vptl ON ((vptl.id = ptl.id)));


ALTER TABLE ag_his.vw_ref_piano_tipo_linea_fast OWNER TO postgres;

--
-- Name: vw_struttura_asl; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_struttura_asl AS
 SELECT sa.id_his,
    sa.his_validita,
    sa.his_id_transazione,
    sa.his_ts,
    sa.ts_transazione,
    sa.id,
    sa.id_gisa,
    sa.id_asl,
    sa.codice_interno_fk,
    sa.descrizione,
    sa.n_livello,
    sa.anno,
    sa.descrizione_breve,
    sa.ups,
    sa.uba,
    sa.codice_interno_univoco,
    sa.ordinamento,
    lower(sa.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(sa.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log
   FROM (ag_his.struttura_asl sa
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = sa.his_id_transazione)));


ALTER TABLE ag_his.vw_struttura_asl OWNER TO postgres;

--
-- Name: vw_ref_struttura_asl; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_struttura_asl AS
 SELECT sa.his_id_transazione,
    sa.id,
    vsa.descrizione_breve AS descr_oggetto,
    'struttura_asl'::text AS tabella,
    t.id_user,
    t.nominativo,
    sa.his_validita
   FROM ((ag_his.struttura_asl sa
     LEFT JOIN cu_log.vw_transazioni t ON ((sa.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_struttura_asl vsa ON ((vsa.id = sa.id)));


ALTER TABLE ag_his.vw_ref_struttura_asl OWNER TO postgres;

--
-- Name: vw_ref_struttura_asl_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_struttura_asl_fast AS
 SELECT sa.his_id_transazione,
    sa.id,
    vsa.descrizione_breve AS descr_oggetto,
    'struttura_asl'::text AS tabella,
    sa.his_validita
   FROM (ag_his.struttura_asl sa
     JOIN ag_his.vw_struttura_asl vsa ON ((vsa.id = sa.id)));


ALTER TABLE ag_his.vw_ref_struttura_asl_fast OWNER TO postgres;

--
-- Name: vw_struttura_comuni; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_struttura_comuni AS
 SELECT sc.id_his,
    sc.his_validita,
    sc.his_id_transazione,
    sc.his_ts,
    sc.ts_transazione,
    sc.id,
    sc.id_comune,
    sc.id_struttura,
    lower(sc.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(sc.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    sa.descrizione_breve,
    sa.descrizione,
    c.comune
   FROM (((ag_his.struttura_comuni sc
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = sc.his_id_transazione)))
     JOIN agenda.vw_comuni c ON ((c.id = sc.id_comune)))
     JOIN matrix.struttura_asl sa ON ((sa.id = sc.id_struttura)));


ALTER TABLE ag_his.vw_struttura_comuni OWNER TO postgres;

--
-- Name: vw_ref_struttura_comuni; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_struttura_comuni AS
 SELECT sc.his_id_transazione,
    sc.id,
    vsc.descrizione_breve AS descr_oggetto,
    'struttura_comuni'::text AS tabella,
    t.id_user,
    t.nominativo,
    sc.his_validita
   FROM ((ag_his.struttura_comuni sc
     LEFT JOIN cu_log.vw_transazioni t ON ((sc.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_struttura_comuni vsc ON ((vsc.id = sc.id)));


ALTER TABLE ag_his.vw_ref_struttura_comuni OWNER TO postgres;

--
-- Name: vw_ref_struttura_comuni_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_struttura_comuni_fast AS
 SELECT sc.his_id_transazione,
    sc.id,
    vsc.descrizione_breve AS descr_oggetto,
    'struttura_comuni'::text AS tabella,
    sc.his_validita
   FROM (ag_his.struttura_comuni sc
     JOIN ag_his.vw_struttura_comuni vsc ON ((vsc.id = sc.id)));


ALTER TABLE ag_his.vw_ref_struttura_comuni_fast OWNER TO postgres;

--
-- Name: vw_struttura_piani; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_struttura_piani AS
 SELECT sp.id_his,
    sp.his_validita,
    sp.his_id_transazione,
    sp.his_ts,
    sp.ts_transazione,
    sp.id,
    sp.id_gisa,
    sp.cod_raggruppamento,
    sp.anno,
    sp.descrizione,
    sp.ordinamento,
    sp.data_scadenza,
    sp.stato,
    sp.codice_interno,
    sp.color,
    sp.path,
    sp.livello,
    sp.alias,
    sp.id_formula_ups,
    sp.id_formula_uba,
    sp.descrizione_breve,
    sp.codice_interno_univoco,
    sp.ha_campioni,
    sp.id_tipo_tecnica,
    lower(sp.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(sp.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log
   FROM (ag_his.struttura_piani sp
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = sp.his_id_transazione)));


ALTER TABLE ag_his.vw_struttura_piani OWNER TO postgres;

--
-- Name: vw_ref_struttura_piani; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_struttura_piani AS
 SELECT sp.his_id_transazione,
    sp.id,
    vsp.descrizione_breve AS descr_oggetto,
    'struttura_piani'::text AS tabella,
    t.id_user,
    t.nominativo,
    sp.his_validita
   FROM ((ag_his.struttura_piani sp
     LEFT JOIN cu_log.vw_transazioni t ON ((sp.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_struttura_piani vsp ON ((vsp.id = sp.id)));


ALTER TABLE ag_his.vw_ref_struttura_piani OWNER TO postgres;

--
-- Name: vw_ref_struttura_piani_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_struttura_piani_fast AS
 SELECT sp.his_id_transazione,
    sp.id,
    vsp.descrizione_breve AS descr_oggetto,
    'struttura_piani'::text AS tabella,
    sp.his_validita
   FROM (ag_his.struttura_piani sp
     JOIN ag_his.vw_struttura_piani vsp ON ((vsp.id = sp.id)));


ALTER TABLE ag_his.vw_ref_struttura_piani_fast OWNER TO postgres;

--
-- Name: vw_tipo_lista_piano; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_tipo_lista_piano AS
 SELECT tlp.id_his,
    tlp.his_validita,
    tlp.his_id_transazione,
    tlp.his_ts,
    tlp.ts_transazione,
    tlp.id_piano,
    tlp.id_tipo_lista,
    tlp.id,
    lower(tlp.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(tlp.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    sp.alias,
    sp.descrizione,
    sp.descrizione_piano
   FROM ((ag_his.tipo_lista_piano tlp
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = tlp.his_id_transazione)))
     JOIN matrix.vw_struttura_piani sp ON ((sp.id = tlp.id_piano)));


ALTER TABLE ag_his.vw_tipo_lista_piano OWNER TO postgres;

--
-- Name: vw_ref_tipo_lista_piano; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_tipo_lista_piano AS
 SELECT tlp.his_id_transazione,
    tlp.id,
    vtlp.alias AS descr_oggetto,
    'tipo_lista_piano'::text AS tabella,
    t.id_user,
    t.nominativo,
    tlp.his_validita
   FROM ((ag_his.tipo_lista_piano tlp
     LEFT JOIN cu_log.vw_transazioni t ON ((tlp.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_tipo_lista_piano vtlp ON ((vtlp.id = tlp.id)));


ALTER TABLE ag_his.vw_ref_tipo_lista_piano OWNER TO postgres;

--
-- Name: vw_ref_tipo_lista_piano_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_tipo_lista_piano_fast AS
 SELECT tlp.his_id_transazione,
    tlp.id,
    vtlp.alias AS descr_oggetto,
    'tipo_lista_piano'::text AS tabella,
    tlp.his_validita
   FROM (ag_his.tipo_lista_piano tlp
     JOIN ag_his.vw_tipo_lista_piano vtlp ON ((vtlp.id = tlp.id)));


ALTER TABLE ag_his.vw_ref_tipo_lista_piano_fast OWNER TO postgres;

--
-- Name: vw_tipo_liste; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_tipo_liste AS
 SELECT tl.id_his,
    tl.his_validita,
    tl.his_id_transazione,
    tl.his_ts,
    tl.ts_transazione,
    tl.id,
    tl.descr,
    tl.cod,
    tl.tm,
    tl.id_user,
    tl.formato,
    tl.validita,
    lower(tl.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(tl.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vtl.formato_descr
   FROM ((ag_his.tipo_liste tl
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = tl.his_id_transazione)))
     JOIN agenda.vw_tipo_liste vtl ON ((vtl.id = tl.id)));


ALTER TABLE ag_his.vw_tipo_liste OWNER TO postgres;

--
-- Name: vw_ref_tipo_liste; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_tipo_liste AS
 SELECT tl.his_id_transazione,
    tl.id,
    vtl.formato_descr AS descr_oggetto,
    'tipo_liste'::text AS tabella,
    t.id_user,
    t.nominativo,
    tl.his_validita
   FROM ((ag_his.tipo_liste tl
     LEFT JOIN cu_log.vw_transazioni t ON ((tl.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_tipo_liste vtl ON ((vtl.id = tl.id)));


ALTER TABLE ag_his.vw_ref_tipo_liste OWNER TO postgres;

--
-- Name: vw_ref_tipo_liste_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_tipo_liste_fast AS
 SELECT tl.his_id_transazione,
    tl.id,
    vtl.formato_descr AS descr_oggetto,
    'tipo_liste'::text AS tabella,
    tl.his_validita
   FROM (ag_his.tipo_liste tl
     JOIN ag_his.vw_tipo_liste vtl ON ((vtl.id = tl.id)));


ALTER TABLE ag_his.vw_ref_tipo_liste_fast OWNER TO postgres;

--
-- Name: vw_tipologia_controllo_piani; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_tipologia_controllo_piani AS
 SELECT tcp.id_his,
    tcp.his_validita,
    tcp.his_id_transazione,
    tcp.his_ts,
    tcp.ts_transazione,
    tcp.id,
    tcp.id_tipologia_controllo,
    tcp.id_piano,
    lower(tcp.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(tcp.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    sp.alias,
    sp.descrizione,
    sp.descrizione_piano
   FROM ((ag_his.tipologia_controllo_piani tcp
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = tcp.his_id_transazione)))
     JOIN matrix.vw_struttura_piani sp ON ((sp.id = tcp.id_piano)));


ALTER TABLE ag_his.vw_tipologia_controllo_piani OWNER TO postgres;

--
-- Name: vw_ref_tipologia_controllo_piani; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_tipologia_controllo_piani AS
 SELECT tcp.his_id_transazione,
    tcp.id,
    vtcp.alias AS descr_oggetto,
    'tipologia_controllo_piani'::text AS tabella,
    t.id_user,
    t.nominativo,
    tcp.his_validita
   FROM ((ag_his.tipologia_controllo_piani tcp
     LEFT JOIN cu_log.vw_transazioni t ON ((tcp.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_tipologia_controllo_piani vtcp ON ((vtcp.id = tcp.id)));


ALTER TABLE ag_his.vw_ref_tipologia_controllo_piani OWNER TO postgres;

--
-- Name: vw_ref_tipologia_controllo_piani_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_tipologia_controllo_piani_fast AS
 SELECT tcp.his_id_transazione,
    tcp.id,
    vtcp.alias AS descr_oggetto,
    'tipologia_controllo_piani'::text AS tabella,
    tcp.his_validita
   FROM (ag_his.tipologia_controllo_piani tcp
     JOIN ag_his.vw_tipologia_controllo_piani vtcp ON ((vtcp.id = tcp.id)));


ALTER TABLE ag_his.vw_ref_tipologia_controllo_piani_fast OWNER TO postgres;

--
-- Name: vw_tree_nodes; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_tree_nodes AS
 SELECT tn.id_his,
    tn.his_validita,
    tn.his_id_transazione,
    tn.his_ts,
    tn.ts_transazione,
    tn.id,
    tn.id_tree,
    tn.id_parent,
    tn.ordinamento,
    tn.node_descr,
    tn.validita,
    lower(tn.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(tn.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log
   FROM (ag_his.tree_nodes tn
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = tn.his_id_transazione)));


ALTER TABLE ag_his.vw_tree_nodes OWNER TO postgres;

--
-- Name: vw_ref_tree_nodes; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_tree_nodes AS
 SELECT tn.his_id_transazione,
    tn.id,
    vtn.node_descr AS descr_oggetto,
    'tree_nodes'::text AS tabella,
    t.id_user,
    t.nominativo,
    tn.his_validita
   FROM ((ag_his.tree_nodes tn
     LEFT JOIN cu_log.vw_transazioni t ON ((tn.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_tree_nodes vtn ON ((vtn.id = tn.id)));


ALTER TABLE ag_his.vw_ref_tree_nodes OWNER TO postgres;

--
-- Name: vw_ref_tree_nodes_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_tree_nodes_fast AS
 SELECT tn.his_id_transazione,
    tn.id,
    vtn.node_descr AS descr_oggetto,
    'tree_nodes'::text AS tabella,
    tn.his_validita
   FROM (ag_his.tree_nodes tn
     JOIN ag_his.vw_tree_nodes vtn ON ((vtn.id = tn.id)));


ALTER TABLE ag_his.vw_ref_tree_nodes_fast OWNER TO postgres;

--
-- Name: vw_unita_di_crisi; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_unita_di_crisi AS
 SELECT udc.id_his,
    udc.his_validita,
    udc.his_id_transazione,
    udc.his_ts,
    udc.ts_transazione,
    udc.id,
    udc.ruolo,
    udc.responsabile_titolo,
    udc.responsabile_nome,
    udc.responsabile_cognome,
    udc.email,
    udc.telefono,
    udc.cellulare,
    udc.validita,
    udc.id_asl,
    lower(udc.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(udc.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    (((udc.responsabile_nome)::text || ' '::text) || (udc.responsabile_cognome)::text) AS responsabile
   FROM (ag_his.unita_di_crisi udc
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = udc.his_id_transazione)));


ALTER TABLE ag_his.vw_unita_di_crisi OWNER TO postgres;

--
-- Name: vw_ref_unita_di_crisi; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_unita_di_crisi AS
 SELECT udc.his_id_transazione,
    udc.id,
    vudc.responsabile AS descr_oggetto,
    'unita_di_crisi'::text AS tabella,
    t.id_user,
    t.nominativo,
    udc.his_validita
   FROM ((ag_his.unita_di_crisi udc
     LEFT JOIN cu_log.vw_transazioni t ON ((udc.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_unita_di_crisi vudc ON ((vudc.id = udc.id)));


ALTER TABLE ag_his.vw_ref_unita_di_crisi OWNER TO postgres;

--
-- Name: vw_ref_unita_di_crisi_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_unita_di_crisi_fast AS
 SELECT udc.his_id_transazione,
    udc.id,
    vudc.responsabile AS descr_oggetto,
    'unita_di_crisi'::text AS tabella,
    udc.his_validita
   FROM (ag_his.unita_di_crisi udc
     JOIN ag_his.vw_unita_di_crisi vudc ON ((vudc.id = udc.id)));


ALTER TABLE ag_his.vw_ref_unita_di_crisi_fast OWNER TO postgres;

--
-- Name: vw_utente_strutture; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_utente_strutture AS
 SELECT us.id_his,
    us.his_validita,
    us.his_id_transazione,
    us.his_ts,
    us.ts_transazione,
    us.id,
    us.id_utente,
    us.id_struttura,
    us.validita,
    lower(us.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(us.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    t.descrizione_breve,
    t.descrizione,
    u.cf,
    u.descr_qualifica,
    (((u.nome)::text || ' '::text) || (u.cognome)::text) AS nominativo_utente
   FROM (((ag_his.utente_strutture us
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = us.his_id_transazione)))
     JOIN matrix.vw_tree_nodes_up_asl t ON ((t.id_node = us.id_struttura)))
     JOIN rbac.vw_utenti u ON ((u.id_utente = us.id_utente)));


ALTER TABLE ag_his.vw_utente_strutture OWNER TO postgres;

--
-- Name: vw_ref_utente_strutture; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_utente_strutture AS
 SELECT us.his_id_transazione,
    us.id,
    vus.cf AS descr_oggetto,
    'utente_strutture'::text AS tabella,
    t.id_user,
    t.nominativo,
    us.his_validita
   FROM ((ag_his.utente_strutture us
     LEFT JOIN cu_log.vw_transazioni t ON ((us.his_id_transazione = t.id_transazione)))
     JOIN ag_his.vw_utente_strutture vus ON ((vus.id = us.id)));


ALTER TABLE ag_his.vw_ref_utente_strutture OWNER TO postgres;

--
-- Name: vw_ref_utente_strutture_fast; Type: VIEW; Schema: ag_his; Owner: postgres
--

CREATE VIEW ag_his.vw_ref_utente_strutture_fast AS
 SELECT us.his_id_transazione,
    us.id,
    vus.cf AS descr_oggetto,
    'utente_strutture'::text AS tabella,
    us.his_validita
   FROM (ag_his.utente_strutture us
     JOIN ag_his.vw_utente_strutture vus ON ((vus.id = us.id)));


ALTER TABLE ag_his.vw_ref_utente_strutture_fast OWNER TO postgres;

--
-- Name: call_logs; Type: TABLE; Schema: ag_log; Owner: postgres
--

CREATE TABLE ag_log.call_logs (
    id bigint NOT NULL,
    id_transazione bigint,
    procedura character varying,
    fase character varying,
    ts timestamp without time zone,
    val character varying
);


ALTER TABLE ag_log.call_logs OWNER TO postgres;

--
-- Name: call_logs_id_seq; Type: SEQUENCE; Schema: ag_log; Owner: postgres
--

CREATE SEQUENCE ag_log.call_logs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_log.call_logs_id_seq OWNER TO postgres;

--
-- Name: call_logs_id_seq; Type: SEQUENCE OWNED BY; Schema: ag_log; Owner: postgres
--

ALTER SEQUENCE ag_log.call_logs_id_seq OWNED BY ag_log.call_logs.id;


--
-- Name: his_id_seq; Type: SEQUENCE; Schema: ag_log; Owner: postgres
--

CREATE SEQUENCE ag_log.his_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_log.his_id_seq OWNER TO postgres;

--
-- Name: operazioni; Type: TABLE; Schema: ag_log; Owner: postgres
--

CREATE TABLE ag_log.operazioni (
    id bigint NOT NULL,
    id_transazione bigint,
    procedura character varying,
    fase character varying,
    ts_start timestamp without time zone,
    ts_transazione timestamp without time zone,
    val character varying,
    ts_end timestamp without time zone,
    ret character varying,
    id_trattato bigint
);


ALTER TABLE ag_log.operazioni OWNER TO postgres;

--
-- Name: operazioni_id_seq; Type: SEQUENCE; Schema: ag_log; Owner: postgres
--

CREATE SEQUENCE ag_log.operazioni_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_log.operazioni_id_seq OWNER TO postgres;

--
-- Name: operazioni_id_seq; Type: SEQUENCE OWNED BY; Schema: ag_log; Owner: postgres
--

ALTER SEQUENCE ag_log.operazioni_id_seq OWNED BY ag_log.operazioni.id;


--
-- Name: transazioni_id_seq; Type: SEQUENCE; Schema: ag_log; Owner: postgres
--

CREATE SEQUENCE ag_log.transazioni_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_log.transazioni_id_seq OWNER TO postgres;

--
-- Name: transazioni_id_seq; Type: SEQUENCE OWNED BY; Schema: ag_log; Owner: postgres
--

ALTER SEQUENCE ag_log.transazioni_id_seq OWNED BY ag_log.transazioni.id;


--
-- Name: vw_ag_tipo_eventi; Type: VIEW; Schema: ag_srv; Owner: postgres
--

CREATE VIEW ag_srv.vw_ag_tipo_eventi AS
 SELECT vw_ag_tipo_eventi.id,
    vw_ag_tipo_eventi.descr,
    vw_ag_tipo_eventi.sigla
   FROM ag_types.vw_ag_tipo_eventi;


ALTER TABLE ag_srv.vw_ag_tipo_eventi OWNER TO postgres;

--
-- Name: ag_livelli_avviso_id_seq; Type: SEQUENCE; Schema: ag_types; Owner: postgres
--

CREATE SEQUENCE ag_types.ag_livelli_avviso_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_types.ag_livelli_avviso_id_seq OWNER TO postgres;

--
-- Name: ag_livelli_avviso_id_seq; Type: SEQUENCE OWNED BY; Schema: ag_types; Owner: postgres
--

ALTER SEQUENCE ag_types.ag_livelli_avviso_id_seq OWNED BY ag_types.ag_livelli_avviso.id;


--
-- Name: ag_stato_eventi_id_seq; Type: SEQUENCE; Schema: ag_types; Owner: postgres
--

CREATE SEQUENCE ag_types.ag_stato_eventi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_types.ag_stato_eventi_id_seq OWNER TO postgres;

--
-- Name: ag_stato_eventi_id_seq; Type: SEQUENCE OWNED BY; Schema: ag_types; Owner: postgres
--

ALTER SEQUENCE ag_types.ag_stato_eventi_id_seq OWNED BY ag_types.ag_stato_eventi.id;


--
-- Name: ag_tipo_avvisi_id_seq; Type: SEQUENCE; Schema: ag_types; Owner: postgres
--

CREATE SEQUENCE ag_types.ag_tipo_avvisi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_types.ag_tipo_avvisi_id_seq OWNER TO postgres;

--
-- Name: ag_tipo_avvisi_id_seq; Type: SEQUENCE OWNED BY; Schema: ag_types; Owner: postgres
--

ALTER SEQUENCE ag_types.ag_tipo_avvisi_id_seq OWNED BY ag_types.ag_tipo_avvisi.id;


--
-- Name: ag_tipo_eventi_id_seq; Type: SEQUENCE; Schema: ag_types; Owner: postgres
--

CREATE SEQUENCE ag_types.ag_tipo_eventi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_types.ag_tipo_eventi_id_seq OWNER TO postgres;

--
-- Name: ag_tipo_eventi_id_seq; Type: SEQUENCE OWNED BY; Schema: ag_types; Owner: postgres
--

ALTER SEQUENCE ag_types.ag_tipo_eventi_id_seq OWNED BY ag_types.ag_tipo_eventi.id;


--
-- Name: az_lookup_comuni; Type: TABLE; Schema: ag_types; Owner: postgres
--

CREATE TABLE ag_types.az_lookup_comuni (
    id integer,
    com_id integer,
    istat integer,
    descrizione character varying,
    cap integer,
    id_fiscale character varying,
    superficie real,
    id_provincia integer,
    ref_id integer,
    utente_id integer,
    latitudine_min real,
    latitudine_max real,
    longitudine_min real,
    longitudine_max real,
    id_comune integer,
    dt_timerange character varying
);


ALTER TABLE ag_types.az_lookup_comuni OWNER TO postgres;

--
-- Name: gruppispecie; Type: TABLE; Schema: ag_types; Owner: postgres
--

CREATE TABLE ag_types.gruppispecie (
    id integer,
    grspe_id integer,
    istat integer,
    codice integer,
    descrizione character varying,
    codice_transponder integer
);


ALTER TABLE ag_types.gruppispecie OWNER TO postgres;

--
-- Name: ml; Type: TABLE; Schema: ag_types; Owner: postgres
--

CREATE TABLE ag_types.ml (
    id bigint,
    att character varying,
    sez character varying
);


ALTER TABLE ag_types.ml OWNER TO postgres;

--
-- Name: tipi_indirizzo; Type: TABLE; Schema: ag_types; Owner: postgres
--

CREATE TABLE ag_types.tipi_indirizzo (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL
);


ALTER TABLE ag_types.tipi_indirizzo OWNER TO postgres;

--
-- Name: tipi_indirizzo_id_seq; Type: SEQUENCE; Schema: ag_types; Owner: postgres
--

CREATE SEQUENCE ag_types.tipi_indirizzo_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_types.tipi_indirizzo_id_seq OWNER TO postgres;

--
-- Name: tipi_indirizzo_id_seq; Type: SEQUENCE OWNED BY; Schema: ag_types; Owner: postgres
--

ALTER SEQUENCE ag_types.tipi_indirizzo_id_seq OWNED BY ag_types.tipi_indirizzo.id;


--
-- Name: tipi_persona; Type: TABLE; Schema: ag_types; Owner: postgres
--

CREATE TABLE ag_types.tipi_persona (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL
);


ALTER TABLE ag_types.tipi_persona OWNER TO postgres;

--
-- Name: tipi_persona_id_seq; Type: SEQUENCE; Schema: ag_types; Owner: postgres
--

CREATE SEQUENCE ag_types.tipi_persona_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_types.tipi_persona_id_seq OWNER TO postgres;

--
-- Name: tipi_persona_id_seq; Type: SEQUENCE OWNED BY; Schema: ag_types; Owner: postgres
--

ALTER SEQUENCE ag_types.tipi_persona_id_seq OWNED BY ag_types.tipi_persona.id;


--
-- Name: vw_tipi_indirizzo; Type: VIEW; Schema: ag_types; Owner: postgres
--

CREATE VIEW ag_types.vw_tipi_indirizzo AS
 SELECT tipi_indirizzo.id AS id_tipo_indirizzo,
    tipi_indirizzo.id,
    tipi_indirizzo.cod,
    tipi_indirizzo.sigla,
    tipi_indirizzo.descr
   FROM ag_types.tipi_indirizzo;


ALTER TABLE ag_types.vw_tipi_indirizzo OWNER TO postgres;

--
-- Name: vw_tipi_persona; Type: VIEW; Schema: ag_types; Owner: postgres
--

CREATE VIEW ag_types.vw_tipi_persona AS
 SELECT tipi_persona.id AS id_tipo_persona,
    tipi_persona.id,
    tipi_persona.cod,
    tipi_persona.sigla,
    tipi_persona.descr
   FROM ag_types.tipi_persona;


ALTER TABLE ag_types.vw_tipi_persona OWNER TO postgres;

--
-- Name: grid_definition; Type: TABLE; Schema: ag_ui; Owner: postgres
--

CREATE TABLE ag_ui.grid_definition (
    id bigint NOT NULL,
    funct character varying,
    id_user bigint,
    type_user character varying,
    str_conf character varying,
    note character varying
);


ALTER TABLE ag_ui.grid_definition OWNER TO postgres;

--
-- Name: grid_definition_id_seq; Type: SEQUENCE; Schema: ag_ui; Owner: postgres
--

CREATE SEQUENCE ag_ui.grid_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ag_ui.grid_definition_id_seq OWNER TO postgres;

--
-- Name: grid_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: ag_ui; Owner: postgres
--

ALTER SEQUENCE ag_ui.grid_definition_id_seq OWNED BY ag_ui.grid_definition.id;


--
-- Name: messaggi_ui; Type: TABLE; Schema: ag_ui; Owner: postgres
--

CREATE TABLE ag_ui.messaggi_ui (
    id bigint NOT NULL,
    procedura character varying,
    valore character varying,
    msg character varying
);


ALTER TABLE ag_ui.messaggi_ui OWNER TO postgres;

--
-- Name: asl_piani; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.asl_piani (
    id bigint NOT NULL,
    id_struttura bigint NOT NULL,
    id_piano bigint NOT NULL
);


ALTER TABLE agenda.asl_piani OWNER TO postgres;

--
-- Name: asl_piani_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.asl_piani_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.asl_piani_id_seq OWNER TO postgres;

--
-- Name: asl_piani_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.asl_piani_id_seq OWNED BY agenda.asl_piani.id;


--
-- Name: attivita_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.attivita_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.attivita_id_seq OWNER TO postgres;

--
-- Name: attivita_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.attivita_id_seq OWNED BY agenda.attivita.id;


--
-- Name: avvisi_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.avvisi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.avvisi_id_seq OWNER TO postgres;

--
-- Name: avvisi_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.avvisi_id_seq OWNED BY agenda.avvisi.id;


--
-- Name: avviso_risorse_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.avviso_risorse_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.avviso_risorse_id_seq OWNER TO postgres;

--
-- Name: avviso_risorse_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.avviso_risorse_id_seq OWNED BY agenda.avviso_risorse.id;


--
-- Name: az_sedi; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.az_sedi (
    id bigint,
    id_azienda bigint,
    stato_sede_operativa character varying,
    denominazione_sede_operativa character varying,
    indirizzo character varying,
    id_comune bigint,
    id_struttura bigint,
    cap character varying,
    nazione character varying
);


ALTER TABLE agenda.az_sedi OWNER TO postgres;

--
-- Name: az_sedi_selezionate; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.az_sedi_selezionate (
    id bigint NOT NULL,
    id_elab_cal bigint NOT NULL,
    id_az_sede bigint NOT NULL,
    id_piano bigint NOT NULL,
    ordine integer
);


ALTER TABLE agenda.az_sedi_selezionate OWNER TO postgres;

--
-- Name: az_sedi_selezionate_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.az_sedi_selezionate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.az_sedi_selezionate_id_seq OWNER TO postgres;

--
-- Name: az_sedi_selezionate_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.az_sedi_selezionate_id_seq OWNED BY agenda.az_sedi_selezionate.id;


--
-- Name: azienda_indirizzi; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.azienda_indirizzi (
    id bigint NOT NULL,
    id_azienda bigint NOT NULL,
    id_tipo_indirizzo bigint NOT NULL,
    id_indirizzo bigint NOT NULL,
    valido tsrange NOT NULL
);


ALTER TABLE agenda.azienda_indirizzi OWNER TO postgres;

--
-- Name: azienda_indirizzi_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.azienda_indirizzi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.azienda_indirizzi_id_seq OWNER TO postgres;

--
-- Name: azienda_indirizzi_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.azienda_indirizzi_id_seq OWNED BY agenda.azienda_indirizzi.id;


--
-- Name: azienda_persone; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.azienda_persone (
    id bigint NOT NULL,
    id_azienda bigint NOT NULL,
    id_tipo_persona bigint NOT NULL,
    id_persona bigint NOT NULL,
    valido tsrange
);


ALTER TABLE agenda.azienda_persone OWNER TO postgres;

--
-- Name: azienda_persone_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.azienda_persone_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.azienda_persone_id_seq OWNER TO postgres;

--
-- Name: azienda_persone_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.azienda_persone_id_seq OWNED BY agenda.azienda_persone.id;


--
-- Name: aziende; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.aziende (
    id bigint,
    app_number character varying,
    rag_soc character varying,
    piva character varying,
    codfis character varying,
    codreg character varying,
    idua character varying,
    sdi character varying,
    inviaresdi boolean,
    is_split boolean,
    nome character varying,
    cognome character varying
);


ALTER TABLE agenda.aziende OWNER TO postgres;

--
-- Name: cal_risorse_riepilogo; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.cal_risorse_riepilogo AS
 SELECT n.nominativo,
    a.id_risorsa,
    count(*) AS pianificati,
    sum(
        CASE
            WHEN (a.id_linea IS NULL) THEN 0
            ELSE 1
        END) AS programmati
   FROM (agenda.attivita a
     JOIN matrix.nominativi n ON ((a.id_risorsa = n.id)))
  GROUP BY n.nominativo, a.id_risorsa;


ALTER TABLE agenda.cal_risorse_riepilogo OWNER TO postgres;

--
-- Name: cal_uos_riepilogo; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.cal_uos_riepilogo AS
 SELECT sa.descrizione_breve,
    a.id_struttura,
    count(*) AS pianificati,
    sum(
        CASE
            WHEN (a.id_linea IS NULL) THEN 0
            ELSE 1
        END) AS programmati
   FROM (agenda.attivita a
     JOIN matrix.struttura_asl sa ON ((sa.id = a.id_struttura)))
  GROUP BY sa.descrizione_breve, a.id_struttura;


ALTER TABLE agenda.cal_uos_riepilogo OWNER TO postgres;

--
-- Name: cf_allevamenti; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.cf_allevamenti (
    id bigint NOT NULL,
    id_lista bigint NOT NULL,
    attributo character varying,
    cod_allevamento character varying,
    id_linea bigint
);


ALTER TABLE agenda.cf_allevamenti OWNER TO postgres;

--
-- Name: cf_liste_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.cf_liste_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.cf_liste_id_seq OWNER TO postgres;

--
-- Name: cf_liste_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.cf_liste_id_seq OWNED BY agenda.cf_liste.id;


--
-- Name: cf_tipo_lista_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.cf_tipo_lista_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.cf_tipo_lista_id_seq OWNER TO postgres;

--
-- Name: cf_tipo_lista_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.cf_tipo_lista_id_seq OWNED BY agenda.cf_tipo_liste.id;


--
-- Name: config_exp_imp; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.config_exp_imp (
    id bigint NOT NULL,
    cod character varying,
    descr character varying,
    intestazione character varying,
    f_exp character varying,
    f_imp character varying,
    versione character varying,
    intestazione_campi character varying,
    ordine integer,
    livello integer
);


ALTER TABLE agenda.config_exp_imp OWNER TO postgres;

--
-- Name: config_exp_imp_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.config_exp_imp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.config_exp_imp_id_seq OWNER TO postgres;

--
-- Name: config_exp_imp_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.config_exp_imp_id_seq OWNED BY agenda.config_exp_imp.id;


--
-- Name: elab_cal_log_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.elab_cal_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.elab_cal_log_id_seq OWNER TO postgres;

--
-- Name: elab_cal_logs; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.elab_cal_logs (
    id bigint NOT NULL,
    id_elab_cal bigint NOT NULL,
    dt timestamp without time zone NOT NULL,
    value character varying NOT NULL
);


ALTER TABLE agenda.elab_cal_logs OWNER TO postgres;

--
-- Name: elab_cal_param_asl; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.elab_cal_param_asl (
    id bigint NOT NULL,
    id_elab_cal bigint,
    id_asl bigint
);


ALTER TABLE agenda.elab_cal_param_asl OWNER TO postgres;

--
-- Name: elab_cal_param_asl_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.elab_cal_param_asl_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.elab_cal_param_asl_id_seq OWNER TO postgres;

--
-- Name: elab_cal_param_asl_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.elab_cal_param_asl_id_seq OWNED BY agenda.elab_cal_param_asl.id;


--
-- Name: elab_cal_param_ns_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.elab_cal_param_ns_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.elab_cal_param_ns_id_seq OWNER TO postgres;

--
-- Name: elab_cal_param_ns_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.elab_cal_param_ns_id_seq OWNED BY agenda.elab_cal_param_ns.id;


--
-- Name: elab_cal_param_piani_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.elab_cal_param_piani_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.elab_cal_param_piani_id_seq OWNER TO postgres;

--
-- Name: elab_cal_param_piani_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.elab_cal_param_piani_id_seq OWNED BY agenda.elab_cal_param_piani.id;


--
-- Name: elab_cal_params; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.elab_cal_params (
    id bigint NOT NULL,
    id_elab_cal bigint NOT NULL,
    type_param character varying NOT NULL,
    value character varying NOT NULL
);


ALTER TABLE agenda.elab_cal_params OWNER TO postgres;

--
-- Name: festivita; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.festivita (
    dt date
);


ALTER TABLE agenda.festivita OWNER TO postgres;

--
-- Name: import_linea_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.import_linea_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.import_linea_id_seq OWNER TO postgres;

--
-- Name: file_xls_cf; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.file_xls_cf (
    cod_allevamento character varying,
    attributo character varying,
    idlista integer,
    id bigint DEFAULT nextval('agenda.import_linea_id_seq'::regclass) NOT NULL
);


ALTER TABLE agenda.file_xls_cf OWNER TO postgres;

--
-- Name: file_xls_linea; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.file_xls_linea (
    denominazione_sede_operativa character varying,
    piva character varying,
    cod_tipo_linea character varying,
    idlista integer,
    id bigint DEFAULT nextval('agenda.import_linea_id_seq'::regclass) NOT NULL
);


ALTER TABLE agenda.file_xls_linea OWNER TO postgres;

--
-- Name: import_file_xls_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.import_file_xls_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.import_file_xls_id_seq OWNER TO postgres;

--
-- Name: file_xls_profilassi; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.file_xls_profilassi (
    cod_azienda character varying,
    cod_grp_specie character varying,
    idlista integer,
    id character varying DEFAULT nextval('agenda.import_file_xls_id_seq'::regclass) NOT NULL
);


ALTER TABLE agenda.file_xls_profilassi OWNER TO postgres;

--
-- Name: file_xls_sicer; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.file_xls_sicer (
    idua character varying,
    nome character varying,
    codregionale character varying,
    attivitacontrollate character varying,
    comune character varying,
    idlista integer,
    id bigint DEFAULT nextval('agenda.import_linea_id_seq'::regclass) NOT NULL
);


ALTER TABLE agenda.file_xls_sicer OWNER TO postgres;

--
-- Name: import_linea; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.import_linea (
    id bigint DEFAULT nextval('agenda.import_linea_id_seq'::regclass) NOT NULL,
    id_lista bigint NOT NULL,
    piva character varying,
    denominazione_sede_operativa character varying,
    cod_tipo_linea character varying,
    id_linea bigint,
    sd_id integer,
    comune character varying,
    cod_regionale character varying,
    attributo character varying
);


ALTER TABLE agenda.import_linea OWNER TO postgres;

--
-- Name: indirizzi; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.indirizzi (
    id bigint NOT NULL,
    via character varying,
    civico character varying,
    comune character varying,
    prov character varying,
    cap character varying
);


ALTER TABLE agenda.indirizzi OWNER TO postgres;

--
-- Name: indirizzi_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.indirizzi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.indirizzi_id_seq OWNER TO postgres;

--
-- Name: indirizzi_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.indirizzi_id_seq OWNED BY agenda.indirizzi.id;


--
-- Name: j_tree; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.j_tree (
    json_tree json
);


ALTER TABLE agenda.j_tree OWNER TO postgres;

--
-- Name: linea_piani; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.linea_piani (
    id bigint NOT NULL,
    id_linea bigint,
    id_piano bigint
);


ALTER TABLE agenda.linea_piani OWNER TO postgres;

--
-- Name: linea_piani_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.linea_piani_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.linea_piani_id_seq OWNER TO postgres;

--
-- Name: linea_piani_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.linea_piani_id_seq OWNED BY agenda.linea_piani.id;


--
-- Name: linee_principali; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.linee_principali (
    nextval bigint,
    id_az_sede bigint,
    id_linea bigint
);


ALTER TABLE agenda.linee_principali OWNER TO postgres;

--
-- Name: linee_selezionate; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.linee_selezionate (
    id bigint NOT NULL,
    id_elab_cal bigint NOT NULL,
    id_linea bigint NOT NULL,
    id_piano bigint NOT NULL,
    ordine integer
);


ALTER TABLE agenda.linee_selezionate OWNER TO postgres;

--
-- Name: linee_selezionate_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.linee_selezionate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.linee_selezionate_id_seq OWNER TO postgres;

--
-- Name: linee_selezionate_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.linee_selezionate_id_seq OWNED BY agenda.linee_selezionate.id;


--
-- Name: lista_cf_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.lista_cf_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.lista_cf_id_seq OWNER TO postgres;

--
-- Name: lista_cf_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.lista_cf_id_seq OWNED BY agenda.cf_allevamenti.id;


--
-- Name: lista_import_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.lista_import_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.lista_import_id_seq OWNER TO postgres;

--
-- Name: lista_import_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.lista_import_id_seq OWNED BY agenda.lista_import.id;


--
-- Name: max_lev; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.max_lev (
    max integer
);


ALTER TABLE agenda.max_lev OWNER TO postgres;

--
-- Name: n; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.n (
    name_tree character varying,
    id_node bigint,
    id_tree bigint,
    id_node_parent bigint,
    id_node_ref bigint
);


ALTER TABLE agenda.n OWNER TO postgres;

--
-- Name: nominativo_az_sedi; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.nominativo_az_sedi (
    id bigint NOT NULL,
    id_nominativo_struttura bigint,
    id_az_sede bigint
);


ALTER TABLE agenda.nominativo_az_sedi OWNER TO postgres;

--
-- Name: nominativo_az_sedi_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.nominativo_az_sedi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.nominativo_az_sedi_id_seq OWNER TO postgres;

--
-- Name: nominativo_az_sedi_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.nominativo_az_sedi_id_seq OWNED BY agenda.nominativo_az_sedi.id;


--
-- Name: nominativo_comuni; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.nominativo_comuni (
    id bigint NOT NULL,
    id_nominativo_struttura bigint NOT NULL,
    id_struttura_comune bigint NOT NULL
);


ALTER TABLE agenda.nominativo_comuni OWNER TO postgres;

--
-- Name: nominativo_comuni_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.nominativo_comuni_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.nominativo_comuni_id_seq OWNER TO postgres;

--
-- Name: nominativo_comuni_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.nominativo_comuni_id_seq OWNED BY agenda.nominativo_comuni.id;


--
-- Name: nominativo_linee; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.nominativo_linee (
    id bigint NOT NULL,
    id_nominativo_struttura bigint,
    id_linea bigint
);


ALTER TABLE agenda.nominativo_linee OWNER TO postgres;

--
-- Name: nominativo_linee_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.nominativo_linee_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.nominativo_linee_id_seq OWNER TO postgres;

--
-- Name: nominativo_linee_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.nominativo_linee_id_seq OWNED BY agenda.nominativo_linee.id;


--
-- Name: nominativo_piani; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.nominativo_piani (
    id bigint NOT NULL,
    id_nominativo_struttura bigint,
    id_piano bigint
);


ALTER TABLE agenda.nominativo_piani OWNER TO postgres;

--
-- Name: nominativo_piani_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.nominativo_piani_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.nominativo_piani_id_seq OWNER TO postgres;

--
-- Name: nominativo_piani_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.nominativo_piani_id_seq OWNED BY agenda.nominativo_piani.id;


--
-- Name: persone; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.persone (
    id bigint NOT NULL,
    nome character varying,
    cognome character varying,
    dt_nascita date,
    nascita character varying,
    id_comune bigint
);


ALTER TABLE agenda.persone OWNER TO postgres;

--
-- Name: persone_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.persone_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.persone_id_seq OWNER TO postgres;

--
-- Name: persone_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.persone_id_seq OWNED BY agenda.persone.id;


--
-- Name: piano_freq; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.piano_freq (
    id bigint DEFAULT nextval('agenda.agenda_id_seq'::regclass) NOT NULL,
    id_piano bigint,
    livello integer,
    num numeric,
    den numeric
);


ALTER TABLE agenda.piano_freq OWNER TO postgres;

--
-- Name: piano_periodo; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.piano_periodo (
    id bigint NOT NULL,
    id_piano bigint NOT NULL,
    periodo tsrange NOT NULL,
    validita_interna boolean DEFAULT true NOT NULL
);


ALTER TABLE agenda.piano_periodo OWNER TO postgres;

--
-- Name: piano_periodo_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.piano_periodo_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.piano_periodo_id_seq OWNER TO postgres;

--
-- Name: piano_periodo_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.piano_periodo_id_seq OWNED BY agenda.piano_periodo.id;


--
-- Name: piano_tipo_linea; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.piano_tipo_linea (
    id_piano integer,
    id_tipo_linea integer,
    id bigint NOT NULL
);


ALTER TABLE agenda.piano_tipo_linea OWNER TO postgres;

--
-- Name: rt_da_cancellare; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.rt_da_cancellare (
    json_agg json
);


ALTER TABLE agenda.rt_da_cancellare OWNER TO postgres;

--
-- Name: tipo_linee; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.tipo_linee (
    id bigint DEFAULT nextval('agenda.agenda_id_seq'::regclass) NOT NULL,
    cod text,
    descr text
);


ALTER TABLE agenda.tipo_linee OWNER TO postgres;

--
-- Name: tipo_linee_da_cancellare; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.tipo_linee_da_cancellare (
    id bigint DEFAULT nextval('agenda.agenda_id_seq'::regclass) NOT NULL,
    cod text,
    descr text
);


ALTER TABLE agenda.tipo_linee_da_cancellare OWNER TO postgres;

--
-- Name: tipo_lista_piano; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.tipo_lista_piano (
    id_piano integer,
    id_tipo_lista integer,
    id bigint NOT NULL
);


ALTER TABLE agenda.tipo_lista_piano OWNER TO postgres;

--
-- Name: tipoattivita_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.tipoattivita_id_seq
    START WITH 7
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.tipoattivita_id_seq OWNER TO postgres;

--
-- Name: tipologia_controllo_piani; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.tipologia_controllo_piani (
    id bigint NOT NULL,
    id_tipologia_controllo bigint,
    id_piano bigint
);


ALTER TABLE agenda.tipologia_controllo_piani OWNER TO postgres;

--
-- Name: tipologia_controllo_piani_id_seq; Type: SEQUENCE; Schema: agenda; Owner: postgres
--

CREATE SEQUENCE agenda.tipologia_controllo_piani_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agenda.tipologia_controllo_piani_id_seq OWNER TO postgres;

--
-- Name: tipologia_controllo_piani_id_seq; Type: SEQUENCE OWNED BY; Schema: agenda; Owner: postgres
--

ALTER SEQUENCE agenda.tipologia_controllo_piani_id_seq OWNED BY agenda.tipologia_controllo_piani.id;


--
-- Name: clienti; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.clienti (
    id bigint NOT NULL,
    descr character varying,
    id_ref bigint,
    type character varying,
    piva character varying
);


ALTER TABLE trf.clienti OWNER TO postgres;

--
-- Name: tariffari; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.tariffari (
    id bigint NOT NULL,
    asl character varying,
    validita tsrange,
    codice character varying,
    descr character varying
);


ALTER TABLE trf.tariffari OWNER TO postgres;

--
-- Name: tariffe; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.tariffe (
    id bigint NOT NULL,
    id_tariffario bigint,
    sigla character varying,
    descr character varying,
    cod_iva character varying,
    nota character varying,
    visibile_trf boolean DEFAULT true,
    visibile_fatt boolean DEFAULT true,
    id_u_mis bigint,
    visibile_piani boolean,
    visibile_contabilita boolean,
    pdc character varying,
    ordine_tariffa integer,
    validita tsrange,
    livello_asl boolean DEFAULT false NOT NULL,
    cod_conto_iva character varying,
    limiti numrange
);


ALTER TABLE trf.tariffe OWNER TO postgres;

--
-- Name: tariffe_u_mis; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.tariffe_u_mis (
    id bigint NOT NULL,
    descr character varying,
    num numeric,
    den numeric
);


ALTER TABLE trf.tariffe_u_mis OWNER TO postgres;

--
-- Name: trf_fattura_dettagli; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_fattura_dettagli (
    id bigint NOT NULL,
    id_trf_fattura bigint,
    id_tariffa bigint,
    valore numeric,
    costo numeric,
    ordine integer,
    stringa_xml character varying
);


ALTER TABLE trf.trf_fattura_dettagli OWNER TO postgres;

--
-- Name: trf_fatture; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_fatture (
    id bigint NOT NULL,
    id_cliente bigint,
    data_creazione timestamp without time zone,
    id_tariffa bigint,
    id_asl bigint,
    numero_fattura bigint NOT NULL,
    open_amt double precision,
    dt date
);


ALTER TABLE trf.trf_fatture OWNER TO postgres;

--
-- Name: vw_clienti; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_clienti AS
(
         SELECT c.id,
            s.nome AS descr,
            c.id AS id_cliente,
            s.nome AS descr_cliente,
            i.indirizzo,
            (i.comune)::character varying(32) AS comune,
            imp.nome AS rag_soc,
            imp.piva,
            imp.cf AS codfis,
            i.indirizzo AS indirizzo_fatturazione,
            i.comune AS comune_fatturazione,
            (i.cap)::character varying AS cap_fatturazione,
            COALESCE(s.sdi, imp.sdi) AS sdi,
            (COALESCE(s.sdi, imp.sdi) IS NOT NULL) AS inviaresdi,
            ((imp.split_payement)::text = 'S'::text) AS is_split,
            (i.nazione)::character varying AS nazione,
            (i.istat_comune)::text AS comune_istat,
            "left"((i.istat_comune)::text, 3) AS provincia_istat,
            NULL::character varying AS nome,
            NULL::character varying AS cognome,
            (i.istat_comune)::text AS comune_istat_fatturazione,
            s.id AS id_az_sede,
            l.fonte,
            l.id AS id_linea,
            c.type AS tipo_cliente,
            i.indirizzo_completo,
            i.id AS id_impresa
           FROM ((((trf.clienti c
             JOIN cu_anag.linee l ON (((c.id_ref = l.id) AND ((c.type)::text = 'linea'::text))))
             JOIN cu_anag.stabilimenti s ON ((s.id = l.id_stabilimento)))
             JOIN cu_anag.imprese imp ON ((imp.id = s.id_impresa)))
             JOIN cu_anag.vw_indirizzi i ON ((s.id_indirizzo = i.id)))
          WHERE ((c.type)::text = 'linea'::text)
        UNION ALL
         SELECT c.id,
            s.nome AS descr,
            c.id AS id_cliente,
            s.nome AS descr_cliente,
            i.indirizzo,
            (i.comune)::character varying(32) AS comune,
            imp.nome AS rag_soc,
            imp.piva,
            imp.cf AS codfis,
            i.indirizzo AS indirizzo_fatturazione,
            i.comune AS comune_fatturazione,
            (i.cap)::character varying AS cap_fatturazione,
            COALESCE(s.sdi, imp.sdi) AS sdi,
            (COALESCE(s.sdi, imp.sdi) IS NOT NULL) AS inviaresdi,
            ((imp.split_payement)::text = 'S'::text) AS is_split,
            (i.nazione)::character varying AS nazione,
            (i.istat_comune)::text AS comune_istat,
            "left"((i.istat_comune)::text, 3) AS provincia_istat,
            NULL::character varying AS nome,
            NULL::character varying AS cognome,
            (i.istat_comune)::text AS comune_istat_fatturazione,
            s.id AS id_az_sede,
            s.fonte,
            s.id AS id_linea,
            c.type AS tipo_cliente,
            i.indirizzo_completo,
            i.id AS id_impresa
           FROM (((trf.clienti c
             JOIN cu_anag.stabilimenti s ON (((c.id_ref = s.id) AND ((c.type)::text = 'az_sede'::text))))
             JOIN cu_anag.imprese imp ON ((s.id_impresa = imp.id)))
             JOIN cu_anag.vw_indirizzi i ON ((i.id = s.id_indirizzo)))
          WHERE ((c.type)::text = 'az_sede'::text)
        UNION ALL
         SELECT c.id,
            ((COALESCE(sf.nome, ''::character varying))::text || (COALESCE(sf.cognome, ''::character varying))::text) AS descr,
            c.id AS id_cliente,
            (COALESCE(((sf.nome)::text || ' '::text), ''::text) || (sf.cognome)::text) AS descr_cliente,
            sf.indirizzo_luogo AS indirizzo,
            (sf.comune_testo)::character varying(32) AS comune,
            ((COALESCE(sf.nome, ''::character varying))::text || (COALESCE(sf.cognome, ''::character varying))::text) AS rag_soc,
            NULL::character varying AS piva,
            sf.codice_fiscale AS codfis,
            sf.indirizzo_luogo AS indirizzo_fatturazione,
            (sf.comune_testo)::character varying(32) AS comune_fatturazione,
            sf.cap AS cap_fatturazione,
            NULL::character varying AS sdi,
            false AS inviaresdi,
            false AS is_split,
            sf.nazione,
            SUBSTRING(sf.istat_indirizzo FROM 4 FOR 3) AS comune_istat,
            SUBSTRING(sf.istat_indirizzo FROM 1 FOR 3) AS provincia_istat,
            sf.nome,
            sf.cognome,
            sf.istat_indirizzo AS comune_istat_fatturazione,
            NULL::bigint AS id_az_sede,
            sf.fonte,
            NULL::bigint AS id_linea,
            c.type AS tipo_cliente,
            sf.indirizzo_completo,
            NULL::bigint AS id_impresa
           FROM (trf.clienti c
             LEFT JOIN cu_anag.vw_soggetti_fisici sf ON ((((c.piva)::text = (sf.codice_fiscale)::text) AND ((c.type)::text = 'soggetto_fisico'::text))))
          WHERE ((c.type)::text = 'soggetto_fisico'::text)
) UNION
 SELECT c.id,
    c.descr,
    c.id AS id_cliente,
    c.descr AS descr_cliente,
    NULL::character varying AS indirizzo,
    NULL::character varying(32) AS comune,
    c.descr AS rag_soc,
    c.piva,
    NULL::character varying AS codfis,
    NULL::character varying AS indirizzo_fatturazione,
    NULL::character varying AS comune_fatturazione,
    NULL::character varying AS cap_fatturazione,
    NULL::character varying AS sdi,
    NULL::boolean AS inviaresdi,
    true AS is_split,
    'Italia'::character varying AS nazione,
    NULL::text AS comune_istat,
    NULL::text AS provincia_istat,
    NULL::text AS nome,
    NULL::text AS cognome,
    NULL::text AS comune_istat_fatturazione,
    c.id AS id_az_sede,
    'CLIENTI'::text AS fonte,
    NULL::bigint AS id_linea,
    c.type AS tipo_cliente,
    NULL::character varying AS indirizzo_completo,
    NULL::bigint AS id_impresa
   FROM trf.clienti c
  WHERE (c.type IS NULL);


ALTER TABLE trf.vw_clienti OWNER TO postgres;

--
-- Name: vw_tariffari; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_tariffari AS
 SELECT tariffari.id,
    tariffari.asl,
    tariffari.id AS id_tariffario,
    tariffari.validita,
    lower(tariffari.validita) AS valido_da,
    upper(tariffari.validita) AS valido_a
   FROM trf.tariffari;


ALTER TABLE trf.vw_tariffari OWNER TO postgres;

--
-- Name: vw_tariffe__u_mis; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_tariffe__u_mis AS
 SELECT tum.id AS id_u_mis,
    tum.id,
    tum.descr,
    tum.num,
    tum.den,
    (COALESCE(tum.num, (1)::numeric) / COALESCE(tum.den, (1)::numeric)) AS fact_equiv
   FROM trf.tariffe_u_mis tum;


ALTER TABLE trf.vw_tariffe__u_mis OWNER TO postgres;

--
-- Name: trf_ui_righe_fatt; Type: TABLE; Schema: trf_ui; Owner: postgres
--

CREATE TABLE trf_ui.trf_ui_righe_fatt (
    id_tariffa bigint,
    descr_in_fatt character varying
);


ALTER TABLE trf_ui.trf_ui_righe_fatt OWNER TO postgres;

--
-- Name: vw_trf_ui_righe_fatt; Type: VIEW; Schema: trf_ui; Owner: postgres
--

CREATE VIEW trf_ui.vw_trf_ui_righe_fatt AS
 SELECT trf_ui_righe_fatt.id_tariffa,
    trf_ui_righe_fatt.descr_in_fatt
   FROM trf_ui.trf_ui_righe_fatt;


ALTER TABLE trf_ui.vw_trf_ui_righe_fatt OWNER TO postgres;

--
-- Name: vw_tariffe; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_tariffe AS
 SELECT te.id,
    te.id AS id_tariffa,
    te.id_tariffario,
    te.sigla,
    te.descr,
    te.sigla AS sigla_tariffa,
    te.descr AS descr_tariffa,
    ti.asl,
    ti.valido_da,
    ti.valido_a,
    te.visibile_trf,
    te.visibile_fatt,
    te.visibile_piani,
    te.cod_iva,
    te.nota,
    te.id_u_mis,
    n.id_parent,
    te.visibile_contabilita,
    te.pdc,
    ti.validita AS validita_tariffario,
    te.validita AS validita_tariffa,
    lower(te.validita) AS valido_da_tariffa,
    upper(te.validita) AS valido_a_tariffa,
    te.livello_asl,
    te.cod_conto_iva,
    (te.validita @> tsrange(lower(te.validita), NULL::timestamp without time zone, '[)'::text)) AS valida,
    (n.ordinamento)::integer AS ordinamento,
    COALESCE(tu.fact_equiv, (1)::numeric) AS fact_equiv,
    rf.descr_in_fatt,
    te.limiti,
    lower(te.limiti) AS limite_inf,
    upper(te.limiti) AS limite_sup,
    tu.descr AS descr_u_mis,
    ((te.descr)::text || COALESCE(((' ('::text || (tu.descr)::text) || ')'::text), ''::text)) AS descr_con_u_mis
   FROM ((((trf.tariffe te
     JOIN trf.vw_tariffari ti ON ((ti.id_tariffario = te.id_tariffario)))
     JOIN matrix.tree_nodes n ON ((n.id = te.id)))
     LEFT JOIN trf.vw_tariffe__u_mis tu ON ((tu.id_u_mis = te.id_u_mis)))
     LEFT JOIN trf_ui.vw_trf_ui_righe_fatt rf ON ((rf.id_tariffa = te.id)));


ALTER TABLE trf.vw_tariffe OWNER TO postgres;

--
-- Name: vw_trf_fattura_dettagli; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_fattura_dettagli AS
 SELECT tfd.id,
    tfd.id_trf_fattura,
    tfd.id_tariffa,
    tfd.valore,
    tfd.costo,
    tfd.id AS id_fattura_dettaglio,
    tfd.ordine,
    t.visibile_contabilita
   FROM (trf.trf_fattura_dettagli tfd
     LEFT JOIN trf.vw_tariffe t ON ((tfd.id_tariffa = t.id)));


ALTER TABLE trf.vw_trf_fattura_dettagli OWNER TO postgres;

--
-- Name: vw_trf_fatture; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_fatture AS
 SELECT f.id,
    f.id_cliente,
    f.data_creazione,
    c.descr,
    f.id AS id_trf_fattura,
    t.descr AS descr_tariffa,
    c.rag_soc,
    c.piva,
    c.codfis,
    c.indirizzo_fatturazione,
    c.comune_fatturazione,
    c.cap_fatturazione,
    c.inviaresdi,
    c.sdi,
    c.is_split,
    c.nazione,
    f.numero_fattura,
    c.provincia_istat,
    c.nome,
    c.cognome,
    f.id_asl,
    tot.costo,
    c.comune_istat,
    (COALESCE((f.dt)::timestamp without time zone, date_trunc('month'::text, f.data_creazione)))::date AS dt
   FROM (((trf.trf_fatture f
     JOIN trf.vw_clienti c ON ((c.id = f.id_cliente)))
     LEFT JOIN trf.tariffe t ON ((t.id = f.id_tariffa)))
     LEFT JOIN ( SELECT vw_trf_fattura_dettagli.id_trf_fattura,
            sum(COALESCE(vw_trf_fattura_dettagli.costo, (0)::numeric)) AS costo
           FROM trf.vw_trf_fattura_dettagli
          WHERE vw_trf_fattura_dettagli.visibile_contabilita
          GROUP BY vw_trf_fattura_dettagli.id_trf_fattura) tot ON ((tot.id_trf_fattura = f.id)));


ALTER TABLE trf.vw_trf_fatture OWNER TO postgres;

--
-- Name: trf_vw_fatt_forf_riep; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.trf_vw_fatt_forf_riep AS
 SELECT to_char(date_trunc('year'::text, vtf.data_creazione), 'yyyy'::text) AS anno,
    count(*) AS n_fatture,
    sum(COALESCE(vtf.costo, (0)::numeric)) AS tot_fatture
   FROM trf.vw_trf_fatture vtf
  WHERE ((vtf.descr_tariffa)::text = 'Tariffa forfettaria annuale'::text)
  GROUP BY (to_char(date_trunc('year'::text, vtf.data_creazione), 'yyyy'::text));


ALTER TABLE agenda.trf_vw_fatt_forf_riep OWNER TO postgres;

--
-- Name: unita_di_crisi; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.unita_di_crisi (
    id bigint DEFAULT nextval('agenda.agenda_id_seq'::regclass) NOT NULL,
    ruolo character varying,
    responsabile_titolo character varying,
    responsabile_nome character varying,
    responsabile_cognome character varying,
    email character varying,
    telefono character varying,
    cellulare character varying,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL,
    id_asl bigint
);


ALTER TABLE agenda.unita_di_crisi OWNER TO postgres;

--
-- Name: unita_di_crisi_as_fo; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.unita_di_crisi_as_fo (
    id bigint DEFAULT nextval('agenda.agenda_id_seq'::regclass) NOT NULL,
    ruolo character varying,
    responsabile_titolo character varying,
    responsabile_nome character varying,
    responsabile_cognome character varying,
    email character varying,
    telefono character varying,
    cellulare character varying,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL,
    id_asl bigint DEFAULT 205
);


ALTER TABLE agenda.unita_di_crisi_as_fo OWNER TO postgres;

--
-- Name: unita_di_crisi_asu_fc; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.unita_di_crisi_asu_fc (
    id bigint DEFAULT nextval('agenda.agenda_id_seq'::regclass) NOT NULL,
    ruolo character varying,
    responsabile_titolo character varying,
    responsabile_nome character varying,
    responsabile_cognome character varying,
    email character varying,
    telefono character varying,
    cellulare character varying,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL,
    id_asl bigint DEFAULT 206
);


ALTER TABLE agenda.unita_di_crisi_asu_fc OWNER TO postgres;

--
-- Name: unita_di_crisi_asu_gi; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.unita_di_crisi_asu_gi (
    id bigint DEFAULT nextval('agenda.agenda_id_seq'::regclass) NOT NULL,
    ruolo character varying,
    responsabile_titolo character varying,
    responsabile_nome character varying,
    responsabile_cognome character varying,
    email character varying,
    telefono character varying,
    cellulare character varying,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL,
    id_asl bigint DEFAULT 207
);


ALTER TABLE agenda.unita_di_crisi_asu_gi OWNER TO postgres;

--
-- Name: unita_di_crisi_fvg; Type: TABLE; Schema: agenda; Owner: postgres
--

CREATE TABLE agenda.unita_di_crisi_fvg (
    id bigint DEFAULT nextval('agenda.agenda_id_seq'::regclass) NOT NULL,
    ruolo character varying,
    responsabile_titolo character varying,
    responsabile_nome character varying,
    responsabile_cognome character varying,
    email character varying,
    telefono character varying,
    cellulare character varying,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL,
    id_asl bigint DEFAULT '-1'::integer
);


ALTER TABLE agenda.unita_di_crisi_fvg OWNER TO postgres;

--
-- Name: vw_ag_tree_nodes_down; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_ag_tree_nodes_down AS
 WITH RECURSIVE vw_ag_tree_nodes_down(name_tree, id_node, id_tree, id_node_parent, id_node_ref) AS (
         SELECT vw_ag_tree_nodes.name_tree,
            vw_ag_tree_nodes.id_node,
            vw_ag_tree_nodes.id_tree,
            vw_ag_tree_nodes.id_node_parent,
            vw_ag_tree_nodes.id_node AS id_node_ref
           FROM agenda.vw_ag_tree_nodes
        UNION ALL
         SELECT down.name_tree,
            down.id_node,
            down.id_tree,
            down.id_node_parent,
            n.id_parent AS id_node_ref
           FROM (vw_ag_tree_nodes_down down
             JOIN agenda.ag_tree_nodes n ON (((n.id = down.id_node_ref) AND (n.id_parent IS NOT NULL))))
        )
 SELECT vw_ag_tree_nodes_down.name_tree,
    vw_ag_tree_nodes_down.id_node,
    vw_ag_tree_nodes_down.id_tree,
    vw_ag_tree_nodes_down.id_node_parent,
    vw_ag_tree_nodes_down.id_node_ref
   FROM vw_ag_tree_nodes_down;


ALTER TABLE agenda.vw_ag_tree_nodes_down OWNER TO postgres;

--
-- Name: vw_ag_tree_nodes_up_tipo_linee_old; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_ag_tree_nodes_up_tipo_linee_old AS
 SELECT vw_ag_tree_nodes_up.name_tree,
    vw_ag_tree_nodes_up.id_node,
    vw_ag_tree_nodes_up.id_tree,
    vw_ag_tree_nodes_up.id_node_parent,
    vw_ag_tree_nodes_up.path,
    vw_ag_tree_nodes_up.path_ord,
    vw_ag_tree_nodes_up.path_descr,
    tipo_linee_da_cancellare.id,
    tipo_linee_da_cancellare.cod,
    tipo_linee_da_cancellare.descr
   FROM (agenda.vw_ag_tree_nodes_up
     JOIN agenda.tipo_linee_da_cancellare ON ((vw_ag_tree_nodes_up.id_node = tipo_linee_da_cancellare.id)))
  WHERE ((vw_ag_tree_nodes_up.name_tree)::text = 'tipo_linee'::text);


ALTER TABLE agenda.vw_ag_tree_nodes_up_tipo_linee_old OWNER TO postgres;

--
-- Name: vw_eventi_singoli_no_linee; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_eventi_singoli_no_linee AS
 SELECT e.id,
    e.inizio,
    e.fine,
    e.id_nominativo AS id_risorsa,
    n.nominativo AS risorsa,
    t.descr AS descr_tipo_evento,
    t.sigla AS sigla_tipo_evento,
    e.id_attivita AS id_calendario,
    st.descr AS stato,
    date_part('epoch'::text, (e.fine - e.inizio)) AS durata,
    (e.fine - e.inizio) AS durata_int,
    e.effettuata,
    e.valido_da,
    e.valido_a,
    e.id_partner,
    n.id_anagrafica,
    e.id_linea,
    e.id_elab_cal,
    e.id_attivita,
    e.id_tipo_evento,
    e.id_piano,
    e.per_conto AS id_per_conto,
    e.id_cu,
    e.partner_per_conto,
    e.validita_interna,
    t.crea_controllo,
    t.operativa,
    e.id_user_create
   FROM (((agenda.eventi e
     JOIN matrix.nominativi n ON ((e.id_nominativo = n.id)))
     JOIN ag_types.vw_ag_tipo_eventi t ON ((e.id_tipo_evento = t.id)))
     LEFT JOIN ag_types.vw_ag_stato_eventi st ON (((e.id_tipo_evento = st.id_tipo_evento) AND (st.effettuata = e.effettuata) AND (st.scaduta = (date_trunc('day'::text, e.fine) < date_trunc('day'::text, CURRENT_TIMESTAMP))))));


ALTER TABLE agenda.vw_eventi_singoli_no_linee OWNER TO postgres;

--
-- Name: vw_eventi_singoli_p_no_linee; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_eventi_singoli_p_no_linee AS
 SELECT e.id,
    e.inizio,
    e.fine,
    e.id_nominativo AS id_risorsa,
    n.nominativo AS risorsa,
    t.descr AS descr_tipo_evento,
    t.sigla AS sigla_tipo_evento,
    e.id_attivita AS id_calendario,
    st.descr AS stato,
    date_part('epoch'::text, (e.fine - e.inizio)) AS durata,
    (e.fine - e.inizio) AS durata_int,
    e.effettuata,
    e.valido_da,
    e.valido_a,
    e.id_nominativo,
    n.id_anagrafica,
    e.id_linea,
    e.id_elab_cal,
    e.id_attivita,
    e.id_tipo_evento,
    e.id_piano,
    e.partner_per_conto AS id_per_conto,
    e.id_cu,
    e.per_conto AS partner_per_conto,
    e.validita_interna,
    t.crea_controllo,
    t.operativa,
    e.id_user_create
   FROM (((agenda.eventi e
     JOIN matrix.nominativi n ON ((e.id_partner = n.id)))
     JOIN ag_types.vw_ag_tipo_eventi t ON ((e.id_tipo_evento = t.id)))
     LEFT JOIN ag_types.vw_ag_stato_eventi st ON (((e.id_tipo_evento = st.id_tipo_evento) AND (st.effettuata = e.effettuata) AND (st.scaduta = (date_trunc('day'::text, e.fine) < date_trunc('day'::text, CURRENT_TIMESTAMP))))));


ALTER TABLE agenda.vw_eventi_singoli_p_no_linee OWNER TO postgres;

--
-- Name: vw_eventi_no_linee; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_eventi_no_linee AS
 SELECT vw_eventi_singoli_no_linee.id,
    vw_eventi_singoli_no_linee.inizio,
    vw_eventi_singoli_no_linee.fine,
    vw_eventi_singoli_no_linee.id_risorsa,
    vw_eventi_singoli_no_linee.risorsa,
    vw_eventi_singoli_no_linee.descr_tipo_evento,
    vw_eventi_singoli_no_linee.sigla_tipo_evento,
    vw_eventi_singoli_no_linee.id_calendario,
    vw_eventi_singoli_no_linee.stato,
    vw_eventi_singoli_no_linee.durata,
    vw_eventi_singoli_no_linee.durata_int,
    vw_eventi_singoli_no_linee.effettuata,
    vw_eventi_singoli_no_linee.valido_da,
    vw_eventi_singoli_no_linee.valido_a,
    vw_eventi_singoli_no_linee.id_partner,
    vw_eventi_singoli_no_linee.id_anagrafica,
    vw_eventi_singoli_no_linee.id_linea,
    vw_eventi_singoli_no_linee.id_elab_cal,
    vw_eventi_singoli_no_linee.id_attivita,
    vw_eventi_singoli_no_linee.id_tipo_evento,
    vw_eventi_singoli_no_linee.id_piano,
    vw_eventi_singoli_no_linee.id_per_conto,
    vw_eventi_singoli_no_linee.id_cu,
    vw_eventi_singoli_no_linee.partner_per_conto,
    vw_eventi_singoli_no_linee.validita_interna,
    vw_eventi_singoli_no_linee.crea_controllo,
    vw_eventi_singoli_no_linee.operativa
   FROM agenda.vw_eventi_singoli_no_linee
UNION
 SELECT vw_eventi_singoli_p_no_linee.id,
    vw_eventi_singoli_p_no_linee.inizio,
    vw_eventi_singoli_p_no_linee.fine,
    vw_eventi_singoli_p_no_linee.id_risorsa,
    vw_eventi_singoli_p_no_linee.risorsa,
    vw_eventi_singoli_p_no_linee.descr_tipo_evento,
    vw_eventi_singoli_p_no_linee.sigla_tipo_evento,
    vw_eventi_singoli_p_no_linee.id_calendario,
    vw_eventi_singoli_p_no_linee.stato,
    vw_eventi_singoli_p_no_linee.durata,
    vw_eventi_singoli_p_no_linee.durata_int,
    vw_eventi_singoli_p_no_linee.effettuata,
    vw_eventi_singoli_p_no_linee.valido_da,
    vw_eventi_singoli_p_no_linee.valido_a,
    vw_eventi_singoli_p_no_linee.id_nominativo AS id_partner,
    vw_eventi_singoli_p_no_linee.id_anagrafica,
    vw_eventi_singoli_p_no_linee.id_linea,
    vw_eventi_singoli_p_no_linee.id_elab_cal,
    vw_eventi_singoli_p_no_linee.id_attivita,
    vw_eventi_singoli_p_no_linee.id_tipo_evento,
    vw_eventi_singoli_p_no_linee.id_piano,
    vw_eventi_singoli_p_no_linee.id_per_conto,
    vw_eventi_singoli_p_no_linee.id_cu,
    vw_eventi_singoli_p_no_linee.partner_per_conto,
    vw_eventi_singoli_p_no_linee.validita_interna,
    vw_eventi_singoli_p_no_linee.crea_controllo,
    vw_eventi_singoli_p_no_linee.operativa
   FROM agenda.vw_eventi_singoli_p_no_linee;


ALTER TABLE agenda.vw_eventi_no_linee OWNER TO postgres;

--
-- Name: vw_agende; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_agende AS
 SELECT a.id,
    a.risorsa,
    a.eseguite,
    a.pianificate,
    a.eseguite_ratio,
    a.tempo,
    a.eff,
    a.k,
    a.cons,
    a.id_anagrafica,
        CASE
            WHEN ((a.cons * (100)::double precision) > (100)::double precision) THEN (100)::double precision
            ELSE round((a.cons * (100)::double precision))
        END AS cons_perc,
        CASE
            WHEN ((a.tempo * (100)::double precision) > (100)::double precision) THEN (100)::double precision
            ELSE round((a.tempo * (100)::double precision))
        END AS tempo_perc,
        CASE
            WHEN ((a.eff * (100)::double precision) > (100)::double precision) THEN (100)::double precision
            ELSE round((a.eff * (100)::double precision))
        END AS eff_perc
   FROM ( SELECT (n.id_anagrafica)::integer AS id,
            n.nominativo AS risorsa,
            (round(((COALESCE(e.eseguite, ((0)::numeric)::double precision) / ((3600)::numeric)::double precision))::numeric, 2))::double precision AS eseguite,
            (round(((COALESCE(p.pianificate, ((0)::numeric)::double precision) / ((3600)::numeric)::double precision))::numeric, 2))::double precision AS pianificate,
            (round((COALESCE((e.eseguite /
                CASE
                    WHEN (p.pianificate = (0)::double precision) THEN (1)::double precision
                    ELSE p.pianificate
                END), (0)::double precision))::numeric, 2))::double precision AS eseguite_ratio,
            (round((
                CASE
                    WHEN ((CURRENT_TIMESTAMP < p.min_fine) OR (p.min_fine >= p.max_fine) OR (p.min_fine IS NULL) OR (p.max_fine IS NULL)) THEN (0)::double precision
                    ELSE (date_part('epoch'::text, (CURRENT_TIMESTAMP - (p.min_fine)::timestamp with time zone)) / date_part('epoch'::text, (p.max_fine - p.min_fine)))
                END)::numeric, 2))::double precision AS tempo,
            (round((COALESCE(((e.eseguite /
                CASE
                    WHEN (p.pianificate = (0)::double precision) THEN (1)::double precision
                    ELSE p.pianificate
                END) / ((date_part('doy'::text, CURRENT_TIMESTAMP) - (1)::double precision) / (365)::double precision)), (0)::double precision))::numeric, 2))::double precision AS eff,
            (round((COALESCE((e.eseguite /
                CASE
                    WHEN (t.tot_eseguite = (0)::double precision) THEN (1)::double precision
                    ELSE t.tot_eseguite
                END), (0)::double precision))::numeric, 2))::double precision AS k,
            (round((COALESCE((t.tot_eseguite /
                CASE
                    WHEN (tp.tot_pianificate = (0)::double precision) THEN (1)::double precision
                    ELSE tp.tot_pianificate
                END), (0)::double precision))::numeric, 2))::double precision AS cons,
            n.id_anagrafica
           FROM ((((( SELECT nominativi.id_anagrafica,
                    min(nominativi.nominativo) AS nominativo
                   FROM matrix.nominativi
                  GROUP BY nominativi.id_anagrafica) n
             LEFT JOIN ( SELECT vw_eventi_no_linee.id_anagrafica,
                    sum(vw_eventi_no_linee.durata) AS eseguite
                   FROM agenda.vw_eventi_no_linee
                  WHERE (vw_eventi_no_linee.operativa AND vw_eventi_no_linee.effettuata)
                  GROUP BY vw_eventi_no_linee.id_anagrafica) e ON ((n.id_anagrafica = e.id_anagrafica)))
             LEFT JOIN ( SELECT vw_eventi_no_linee.id_anagrafica,
                    sum(vw_eventi_no_linee.durata) AS pianificate,
                    max(vw_eventi_no_linee.fine) AS max_fine,
                    min(vw_eventi_no_linee.fine) AS min_fine
                   FROM agenda.vw_eventi_no_linee
                  WHERE vw_eventi_no_linee.operativa
                  GROUP BY vw_eventi_no_linee.id_anagrafica) p ON ((n.id_anagrafica = p.id_anagrafica)))
             LEFT JOIN ( SELECT e_1.id_anagrafica,
                    sum(e_1.durata) AS tot_eseguite
                   FROM agenda.vw_eventi_no_linee e_1
                  WHERE (e_1.effettuata AND (e_1.fine < CURRENT_TIMESTAMP))
                  GROUP BY e_1.id_anagrafica) t ON ((n.id_anagrafica = t.id_anagrafica)))
             LEFT JOIN ( SELECT e_1.id_anagrafica,
                    sum(e_1.durata) AS tot_pianificate
                   FROM agenda.vw_eventi_no_linee e_1
                  WHERE (e_1.fine < CURRENT_TIMESTAMP)
                  GROUP BY e_1.id_anagrafica) tp ON ((n.id_anagrafica = tp.id_anagrafica)))) a;


ALTER TABLE agenda.vw_agende OWNER TO postgres;

--
-- Name: vw_asl_piani; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_asl_piani AS
 SELECT ap.id,
    ap.id_struttura,
    ap.id_piano,
    ap.id AS id_asl_piani,
    a.descrizione AS descrizione_asl,
    sp.descrizione AS descrizione_piano,
    a.descrizione_breve AS descrizione_breve_asl,
    sp.descrizione_breve AS descrizione_breve_piano,
    a.anno AS anno_asl,
    sp.anno AS anno_piano,
    sp.cod_raggruppamento,
    sp.descrizione_breve,
    sp.alias,
    ((COALESCE(sp.alias, ''::text) || ' - '::text) || sp.descrizione_breve) AS descr_unique
   FROM ((agenda.asl_piani ap
     LEFT JOIN matrix.struttura_asl a ON ((a.id = ap.id_struttura)))
     LEFT JOIN matrix.struttura_piani sp ON ((sp.id = ap.id_piano)));


ALTER TABLE agenda.vw_asl_piani OWNER TO postgres;

--
-- Name: vw_avvisi_validi; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_avvisi_validi AS
 SELECT a.id AS id_avviso,
    a.id,
    a.codice,
    a.sigla,
    a.descrizione,
    a.id_tipo_avviso,
    a.id_livello_avviso,
    a.validita,
    l.descr AS descr_livello,
    l.ordine,
    l.colore,
    t.descr AS descr_tipo,
    lower(a.validita) AS inizio_validita,
    upper(a.validita) AS fine_validita,
    l.icona
   FROM ((agenda.avvisi a
     JOIN ag_types.vw_ag_livelli_avviso l ON ((l.id_livello_avviso = a.id_livello_avviso)))
     JOIN ag_types.vw_ag_tipo_avvisi t ON ((t.id_tipo_avviso = a.id_tipo_avviso)))
  WHERE (a.validita @> (CURRENT_TIMESTAMP)::timestamp without time zone);


ALTER TABLE agenda.vw_avvisi_validi OWNER TO postgres;

--
-- Name: vw_az_sedi_selezionate; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_az_sedi_selezionate AS
 SELECT ss.id,
    ss.id_elab_cal,
    ss.id_az_sede,
    ss.id_piano,
    ss.ordine,
    ss.id AS id_az_sede_selezionata,
    s.denominazione_sede_operativa,
    (COALESCE((p.alias || ' '::text), ''::text) || p.descrizione) AS descrizione,
    p.flag_cf
   FROM ((agenda.az_sedi_selezionate ss
     JOIN agenda.vw_az_sedi s ON ((s.id_az_sede = ss.id_az_sede)))
     JOIN matrix.vw_struttura_piani p ON ((p.id = ss.id_piano)));


ALTER TABLE agenda.vw_az_sedi_selezionate OWNER TO postgres;

--
-- Name: vw_indirizzi; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_indirizzi AS
 SELECT indirizzi.id AS id_indirizzo,
    indirizzi.id,
    indirizzi.via,
    indirizzi.civico,
    indirizzi.comune,
    indirizzi.prov,
    indirizzi.cap
   FROM agenda.indirizzi;


ALTER TABLE agenda.vw_indirizzi OWNER TO postgres;

--
-- Name: vw_azienda_indirizzi; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_azienda_indirizzi AS
 SELECT ai.id AS id_azienda_indirizzo,
    ai.id,
    ai.id_azienda,
    ai.id_tipo_indirizzo,
    ai.id_indirizzo,
    ai.valido,
    a.rag_soc,
    ti.descr AS descr_tipo_indirizzo,
    i.via,
    i.comune,
    i.cap,
    i.civico,
    i.prov
   FROM (((agenda.azienda_indirizzi ai
     JOIN agenda.vw_aziende a ON ((ai.id_azienda = a.id_azienda)))
     JOIN ag_types.vw_tipi_indirizzo ti ON ((ai.id_tipo_indirizzo = ti.id_tipo_indirizzo)))
     JOIN agenda.vw_indirizzi i ON ((ai.id_indirizzo = i.id_indirizzo)));


ALTER TABLE agenda.vw_azienda_indirizzi OWNER TO postgres;

--
-- Name: vw_persone; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_persone AS
 SELECT persone.id AS id_persona,
    persone.id,
    persone.nome,
    persone.cognome,
    persone.dt_nascita,
    persone.nascita
   FROM agenda.persone;


ALTER TABLE agenda.vw_persone OWNER TO postgres;

--
-- Name: vw_azienda_persone; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_azienda_persone AS
 SELECT ap.id AS id_azienda_persone,
    ap.id,
    ap.id_azienda,
    ap.id_tipo_persona,
    ap.id_persona,
    ap.valido,
    a.rag_soc,
    tp.descr AS descr_tipo_persona,
    p.nome,
    p.cognome,
    p.dt_nascita,
    p.nascita
   FROM (((agenda.azienda_persone ap
     JOIN agenda.vw_aziende a ON ((ap.id_azienda = a.id_azienda)))
     JOIN ag_types.vw_tipi_persona tp ON ((ap.id_tipo_persona = tp.id_tipo_persona)))
     JOIN agenda.vw_persone p ON ((ap.id_persona = p.id_persona)));


ALTER TABLE agenda.vw_azienda_persone OWNER TO postgres;

--
-- Name: vw_cal_att_piani; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_cal_att_piani AS
 SELECT att.id_elab_cal,
    ac.descrizione_breve AS asl_c,
    a.descrizione_breve AS asl_d,
    p.descrizione_breve AS piano_d,
    count(*) AS a_cnt,
    att.id_piano,
    att.id_struttura
   FROM ((((agenda.attivita att
     JOIN matrix.struttura_piani p ON ((p.id = att.id_piano)))
     JOIN matrix.struttura_asl a ON ((att.id_struttura = a.id)))
     JOIN matrix.tree_nodes n ON ((n.id = a.id)))
     JOIN matrix.struttura_asl ac ON ((ac.id = n.id_parent)))
  WHERE ((att.id_linea IS NOT NULL) AND (att.id_risorsa IS NOT NULL))
  GROUP BY att.id_elab_cal, ac.descrizione_breve, a.descrizione_breve, p.descrizione_breve, att.id_piano, att.id_struttura;


ALTER TABLE agenda.vw_cal_att_piani OWNER TO postgres;

--
-- Name: vw_cal_linee_piani; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_cal_linee_piani AS
 SELECT ls.id_elab_cal,
    ac.descrizione_breve AS asl_c,
    a.descrizione_breve AS asl_d,
    ((p.alias || ' - '::text) || p.descrizione_breve) AS piano_d,
    count(*) AS cnt,
    ls.id_piano,
    a.id AS id_struttura
   FROM ((((((agenda.linee_selezionate ls
     JOIN matrix.struttura_piani p ON ((p.id = ls.id_piano)))
     JOIN agenda.vw_linee l ON ((ls.id_linea = l.id_linea)))
     JOIN agenda.struttura_comuni sc ON ((sc.id_comune = l.id_comune)))
     JOIN matrix.struttura_asl a ON ((sc.id_struttura = a.id)))
     JOIN matrix.tree_nodes n ON ((n.id = a.id)))
     JOIN matrix.struttura_asl ac ON ((ac.id = n.id_parent)))
  GROUP BY ls.id_elab_cal, ac.descrizione_breve, a.descrizione_breve, ((p.alias || ' - '::text) || p.descrizione_breve), ls.id_piano, a.id;


ALTER TABLE agenda.vw_cal_linee_piani OWNER TO postgres;

--
-- Name: vw_cal_linee_piani_riep; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_cal_linee_piani_riep AS
 SELECT ls.id_elab_cal,
    ls.id_piano,
    ((p.alias || ' '::text) || p.descrizione) AS descrizione,
    count(*) AS selezionate,
    sum(
        CASE
            WHEN ((a.id_linea IS NOT NULL) AND (a.id_risorsa IS NOT NULL)) THEN 1
            ELSE 0
        END) AS programmate
   FROM (((agenda.linee_selezionate ls
     JOIN cu_anag.linee l ON ((ls.id_linea = l.id)))
     JOIN matrix.struttura_piani p ON ((p.id = ls.id_piano)))
     LEFT JOIN agenda.attivita a ON (((a.id_elab_cal = ls.id_elab_cal) AND (a.id_linea = ls.id_linea) AND (a.id_piano = ls.id_piano))))
  GROUP BY ls.id_elab_cal, ls.id_piano, p.alias, p.descrizione;


ALTER TABLE agenda.vw_cal_linee_piani_riep OWNER TO postgres;

--
-- Name: vw_cal_piani_target; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_cal_piani_target AS
 SELECT ac.descrizione_breve AS asl_c,
    a.descrizione_breve AS asl_d,
    ((p.alias || ' - '::text) || p.descrizione_breve) AS piano_d,
    t.target,
    ap.id_piano,
    ap.id_struttura
   FROM (((((agenda.asl_piani ap
     JOIN matrix.struttura_asl a ON ((ap.id_struttura = a.id)))
     JOIN matrix.struttura_piani p ON ((ap.id_piano = p.id)))
     JOIN matrix.tree_nodes n ON ((n.id = a.id)))
     JOIN matrix.struttura_asl ac ON ((ac.id = n.id_parent)))
     JOIN matrix.struttura_piano_target t ON (((t.id_struttura = a.id) AND (t.id_piano = p.id))));


ALTER TABLE agenda.vw_cal_piani_target OWNER TO postgres;

--
-- Name: vw_cal_risorse_riepilogo; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_cal_risorse_riepilogo AS
 SELECT c.nominativo,
    c.id_nominativo AS id_risorsa,
    COALESCE((r.pianificati)::bigint, (0)::bigint) AS pianificati,
    COALESCE((r.programmati)::bigint, (0)::bigint) AS programmati,
    c.id_elab_cal,
    round(COALESCE(c.cap_tot, (0)::numeric)) AS cap_tot,
    round(COALESCE(c.cap_ev, (0)::numeric)) AS cap_ev,
    c.descrizione_breve,
    COALESCE(r.attivita, 0) AS attivita
   FROM (agenda.vw_elab_cal_param_ns c
     LEFT JOIN ( SELECT a.id_risorsa,
            (sum(a.ups))::integer AS pianificati,
            (sum(
                CASE
                    WHEN (a.id_linea IS NULL) THEN (0)::numeric
                    ELSE a.ups
                END))::integer AS programmati,
            (sum(
                CASE
                    WHEN (a.id_linea IS NULL) THEN (0)::numeric
                    ELSE (1)::numeric
                END))::integer AS attivita,
            a.id_elab_cal
           FROM agenda.attivita a
          GROUP BY a.id_risorsa, a.id_elab_cal) r ON (((r.id_risorsa = c.id_nominativo) AND (c.id_elab_cal = r.id_elab_cal))));


ALTER TABLE agenda.vw_cal_risorse_riepilogo OWNER TO postgres;

--
-- Name: vw_cal_uos_riepilogo; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_cal_uos_riepilogo AS
 SELECT sa.descrizione_breve,
    ns.id_struttura,
    count(*) AS pianificati,
    sum(
        CASE
            WHEN ((a.id_linea IS NULL) OR (a.id_risorsa IS NULL)) THEN 0
            ELSE 1
        END) AS programmati,
    ns.id_elab_cal,
    sum(
        CASE
            WHEN (a.id_linea IS NULL) THEN 0
            ELSE 1
        END) AS associati_linee
   FROM ((( SELECT DISTINCT vw_elab_cal_param_ns.id_elab_cal,
            vw_elab_cal_param_ns.id_struttura
           FROM agenda.vw_elab_cal_param_ns) ns
     LEFT JOIN agenda.attivita a ON (((a.id_elab_cal = ns.id_elab_cal) AND (a.id_struttura = ns.id_struttura))))
     JOIN matrix.struttura_asl sa ON ((sa.id = ns.id_struttura)))
  GROUP BY sa.descrizione_breve, ns.id_struttura, ns.id_elab_cal;


ALTER TABLE agenda.vw_cal_uos_riepilogo OWNER TO postgres;

--
-- Name: vw_calendari; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_calendari AS
 SELECT vw_agende.id,
    vw_agende.risorsa,
    vw_agende.eseguite,
    vw_agende.pianificate,
    vw_agende.eseguite_ratio,
    vw_agende.tempo,
    vw_agende.eff,
    vw_agende.k,
    vw_agende.cons,
    vw_agende.id_anagrafica
   FROM agenda.vw_agende;


ALTER TABLE agenda.vw_calendari OWNER TO postgres;

--
-- Name: vw_cf_allevamenti; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_cf_allevamenti AS
 SELECT a.id AS id_cf_allevamento,
    a.id,
    a.id_lista,
    a.attributo,
    a.cod_allevamento,
    a.id_linea,
    l.anno,
    l.dt
   FROM (agenda.cf_allevamenti a
     JOIN agenda.lista_import l ON ((l.id = a.id_lista)));


ALTER TABLE agenda.vw_cf_allevamenti OWNER TO postgres;

--
-- Name: vw_cf_liste_count; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_cf_liste_count AS
 SELECT l.id_lista,
    sum(
        CASE
            WHEN (l.id_linea IS NULL) THEN 1
            ELSE 0
        END) AS non_associati,
    sum(
        CASE
            WHEN (l.id_linea IS NULL) THEN 0
            ELSE 1
        END) AS associati,
    count(*) AS totali
   FROM agenda.vw_cf_allevamenti l
  GROUP BY l.id_lista;


ALTER TABLE agenda.vw_cf_liste_count OWNER TO postgres;

--
-- Name: config; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.config (
    id integer,
    nome character varying(16),
    validita tsrange,
    valore character varying(128)
);


ALTER TABLE config.config OWNER TO postgres;

--
-- Name: vw_comuni1_da_gisa; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_comuni1_da_gisa AS
 SELECT t.id,
    t.cod_comune,
    t.cod_regione,
    t.cod_provincia,
    t.nome,
    t.istat,
    t.codiceistatasl,
    t.codice,
    t.codice_old,
    t.codiceistatasl_old,
    t.cap,
    t.notused,
    t.cod_nazione,
    t.codiceasl_bdn,
    t.codice_nuovo,
    t.codice_nuovo_,
    t.istat_comune_provincia,
    t.cap_,
    t.istat_pre,
    t.note_hd,
    t.reverse_cap,
    t.codice_catastale
   FROM public.dblink((((((('dbname='::text || (( SELECT config.valore
           FROM config.config
          WHERE (((config.nome)::text = 'GISA_DB'::text) AND (config.validita @> (CURRENT_TIMESTAMP)::timestamp without time zone))))::text) || ' port='::text) || (( SELECT config.valore
           FROM config.config
          WHERE (((config.nome)::text = 'GISA_PORT'::text) AND (config.validita @> (CURRENT_TIMESTAMP)::timestamp without time zone))))::text) || ' host='::text) || (( SELECT config.valore
           FROM config.config
          WHERE (((config.nome)::text = 'GISA_ADDRESS'::text) AND (config.validita @> (CURRENT_TIMESTAMP)::timestamp without time zone))))::text) || ' user=postgres'::text), 'select * from public.vw_comuni1'::text) t(id bigint, cod_comune character varying, cod_regione character varying, cod_provincia character varying, nome character varying, istat character varying, codiceistatasl character varying, codice character varying, codice_old character varying, codiceistatasl_old character varying, cap character varying, notused boolean, cod_nazione bigint, codiceasl_bdn character varying, codice_nuovo character varying, codice_nuovo_ character varying, istat_comune_provincia character varying, cap_ character varying, istat_pre character varying, note_hd character varying, reverse_cap character varying, codice_catastale character varying);


ALTER TABLE agenda.vw_comuni1_da_gisa OWNER TO postgres;

--
-- Name: vw_comuni1_used_da_gisa; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_comuni1_used_da_gisa AS
 SELECT t.id,
    t.cod_comune,
    t.cod_regione,
    t.cod_provincia,
    t.nome,
    t.istat,
    t.codiceistatasl,
    t.codice,
    t.codice_old,
    t.codiceistatasl_old,
    t.cap,
    t.notused,
    t.cod_nazione,
    t.codiceasl_bdn,
    t.codice_nuovo,
    t.codice_nuovo_,
    t.istat_comune_provincia,
    t.cap_,
    t.istat_pre,
    t.note_hd,
    t.reverse_cap,
    t.codice_catastale
   FROM public.dblink((((((('dbname='::text || (( SELECT config.valore
           FROM config.config
          WHERE (((config.nome)::text = 'GISA_DB'::text) AND (config.validita @> (CURRENT_TIMESTAMP)::timestamp without time zone))))::text) || ' port='::text) || (( SELECT config.valore
           FROM config.config
          WHERE (((config.nome)::text = 'GISA_PORT'::text) AND (config.validita @> (CURRENT_TIMESTAMP)::timestamp without time zone))))::text) || ' host='::text) || (( SELECT config.valore
           FROM config.config
          WHERE (((config.nome)::text = 'GISA_ADDRESS'::text) AND (config.validita @> (CURRENT_TIMESTAMP)::timestamp without time zone))))::text) || ' user=postgres'::text), 'select * from public.vw_comuni1_used'::text) t(id bigint, cod_comune character varying, cod_regione character varying, cod_provincia character varying, nome character varying, istat character varying, codiceistatasl character varying, codice character varying, codice_old character varying, codiceistatasl_old character varying, cap character varying, notused boolean, cod_nazione bigint, codiceasl_bdn character varying, codice_nuovo character varying, codice_nuovo_ character varying, istat_comune_provincia character varying, cap_ character varying, istat_pre character varying, note_hd character varying, reverse_cap character varying, codice_catastale character varying);


ALTER TABLE agenda.vw_comuni1_used_da_gisa OWNER TO postgres;

--
-- Name: vw_comuni_lookup; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_comuni_lookup AS
 SELECT c.id,
    c.comune,
    lk.com_id
   FROM (agenda.comuni c
     LEFT JOIN ag_types.az_lookup_comuni lk ON ((replace(replace(replace(replace((c.comune)::text, 'AL TORRE - '::text, ''::text), '-CARNICO'::text, ''::text), 'BUJA'::text, 'BUIA'::text), 'ROJALE'::text, 'ROIALE'::text) = (lk.descrizione)::text)));


ALTER TABLE agenda.vw_comuni_lookup OWNER TO postgres;

--
-- Name: vw_config_exp_imp; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_config_exp_imp AS
 SELECT config_exp_imp.id,
    config_exp_imp.cod,
    config_exp_imp.descr,
    config_exp_imp.intestazione,
    config_exp_imp.f_exp,
    config_exp_imp.f_imp,
    config_exp_imp.versione,
    config_exp_imp.intestazione_campi,
    config_exp_imp.ordine,
    config_exp_imp.livello
   FROM agenda.config_exp_imp
  ORDER BY config_exp_imp.ordine;


ALTER TABLE agenda.vw_config_exp_imp OWNER TO postgres;

--
-- Name: vw_elab_cals_params; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_elab_cals_params AS
 SELECT ecp.id,
    ecp.id_elab_cal,
    ecp.type_param,
    ecp.value,
    ec.descr_cal,
    ec.id_user_cal,
    ec.anno
   FROM (agenda.vw_elab_cals ec
     JOIN agenda.elab_cal_params ecp ON ((ec.id = ecp.id_elab_cal)));


ALTER TABLE agenda.vw_elab_cals_params OWNER TO postgres;

--
-- Name: vw_eventi_occupazione; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_eventi_occupazione AS
 SELECT e.inizio,
    e.fine,
    (e.fine - e.inizio) AS durata,
    e.id_nominativo,
    e.per_conto,
    e.id,
    ns.id_anagrafica
   FROM (agenda.eventi e
     JOIN matrix.vw_nominativi_struttura ns ON ((ns.id_nominativo = e.id_nominativo)))
  WHERE ((e.id_nominativo IS NOT NULL) AND (e.inizio IS NOT NULL) AND (e.fine IS NOT NULL) AND (e.fine > e.inizio))
UNION
 SELECT e.inizio,
    e.fine,
    (e.fine - e.inizio) AS durata,
    e.id_partner AS id_nominativo,
    e.partner_per_conto AS per_conto,
    e.id,
    ns.id_anagrafica
   FROM (agenda.eventi e
     JOIN matrix.vw_nominativi_struttura ns ON ((ns.id_nominativo = e.id_partner)))
  WHERE ((e.id_partner IS NOT NULL) AND (e.inizio IS NOT NULL) AND (e.fine IS NOT NULL) AND (e.fine > e.inizio));


ALTER TABLE agenda.vw_eventi_occupazione OWNER TO postgres;

--
-- Name: vw_import_linea; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_import_linea AS
 SELECT a.id,
    a.id_lista,
    a.denominazione_sede_operativa,
    a.piva,
    a.cod_tipo_linea,
    l.anno,
    l.dt,
    a.id_linea,
    a.sd_id,
    a.comune,
    a.cod_regionale,
    l.id_tipo_lista
   FROM (agenda.import_linea a
     JOIN agenda.vw_lista_import l ON ((l.id = a.id_lista)));


ALTER TABLE agenda.vw_import_linea OWNER TO postgres;

--
-- Name: vw_tipo_lista_piani; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_tipo_lista_piani AS
 SELECT tlp.id AS id_tipo_lista_piano,
    tlp.id_piano,
    tlp.id_tipo_lista,
    tlp.id,
    sp.alias
   FROM ((agenda.tipo_lista_piano tlp
     JOIN agenda.vw_tipo_liste tl ON ((tl.id_tipo_lista = tlp.id_tipo_lista)))
     JOIN matrix.struttura_piani sp ON ((tlp.id_piano = sp.id)));


ALTER TABLE agenda.vw_tipo_lista_piani OWNER TO postgres;

--
-- Name: vw_import_linea_piano; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_import_linea_piano AS
 SELECT l.id,
    l.id_lista,
    l.denominazione_sede_operativa,
    l.piva,
    l.cod_tipo_linea,
    l.anno,
    l.dt,
    l.id_linea,
    l.sd_id,
    l.comune,
    l.cod_regionale,
    l.id_tipo_lista,
    (p.id_piano)::bigint AS id_piano,
    p.alias
   FROM (agenda.vw_import_linea l
     JOIN agenda.vw_tipo_lista_piani p ON ((p.id_tipo_lista = l.id_tipo_lista)));


ALTER TABLE agenda.vw_import_linea_piano OWNER TO postgres;

--
-- Name: vw_linea_piani; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_linea_piani AS
 SELECT lp.id,
    lp.id_linea,
    lp.id_piano,
    lp.id AS id_linea_piani,
    l.denominazione,
    sp.descrizione,
    l.id_comune,
    sp.alias
   FROM ((agenda.linea_piani lp
     JOIN agenda.linee l ON ((l.id = lp.id_linea)))
     LEFT JOIN matrix.struttura_piani sp ON ((sp.id = lp.id_piano)));


ALTER TABLE agenda.vw_linea_piani OWNER TO postgres;

--
-- Name: cu; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu (
    id bigint NOT NULL,
    codice character varying NOT NULL,
    dt timestamp without time zone NOT NULL,
    id_tecnica bigint NOT NULL,
    preavviso boolean NOT NULL,
    rilievi boolean NOT NULL,
    id_evento bigint,
    id_az_sede bigint,
    id_responsabile bigint,
    chiuso boolean DEFAULT false NOT NULL,
    dt_chiusura timestamp without time zone,
    pec character varying,
    note_verbale character varying,
    note_generali character varying,
    dt_preavviso timestamp without time zone,
    mezzo_preavviso character varying,
    km_az numeric,
    km_pr numeric,
    id_stato_cu bigint
);


ALTER TABLE cu.cu OWNER TO postgres;

--
-- Name: cu_linee; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_linee (
    id bigint NOT NULL,
    id_cu bigint,
    id_linea bigint NOT NULL,
    ord integer NOT NULL,
    linea_originaria boolean
);


ALTER TABLE cu.cu_linee OWNER TO postgres;

--
-- Name: cu_piani; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_piani (
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_piano bigint NOT NULL,
    ord integer NOT NULL,
    id_perconto_di bigint NOT NULL
);


ALTER TABLE cu.cu_piani OWNER TO postgres;

--
-- Name: cu_tecniche; Type: TABLE; Schema: cu_conf; Owner: postgres
--

CREATE TABLE cu_conf.cu_tecniche (
    id integer NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    cod character varying NOT NULL
);


ALTER TABLE cu_conf.cu_tecniche OWNER TO postgres;

--
-- Name: vw_cu_tecniche; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_tecniche AS
 SELECT cu_tecniche.id AS id_tecnica,
    cu_tecniche.id,
    cu_tecniche.sigla,
    cu_tecniche.descr,
    cu_tecniche.cod
   FROM cu_conf.cu_tecniche;


ALTER TABLE cu_conf.vw_cu_tecniche OWNER TO postgres;

--
-- Name: cu_stati_cu; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.cu_stati_cu (
    id bigint NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    cod character varying NOT NULL,
    ord integer
);


ALTER TABLE cu_types.cu_stati_cu OWNER TO postgres;

--
-- Name: vw_cu_stati_cu; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_cu_stati_cu AS
 SELECT cu_stati_cu.id AS id_stato_cu,
    cu_stati_cu.id,
    cu_stati_cu.sigla,
    cu_stati_cu.descr,
    cu_stati_cu.cod,
    cu_stati_cu.ord
   FROM cu_types.cu_stati_cu;


ALTER TABLE cu_types.vw_cu_stati_cu OWNER TO postgres;

--
-- Name: vw_cu; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu AS
 SELECT c.id AS id_cu,
    c.id,
    c.codice,
    c.dt,
    c.id_tecnica,
    c.preavviso,
    c.rilievi,
    c.id_evento,
    t.sigla AS sigla_tecnica,
    t.descr AS descr_tecnica,
    c.id_az_sede,
    a.nome AS denominazione_sede_operativa,
    (ind.comune)::character varying(32) AS comune,
    c.chiuso,
    c.dt_chiusura,
    COALESCE(c.pec, a.pec) AS pec,
        CASE
            WHEN c.chiuso THEN 'Chiuso'::text
            ELSE 'Aperto'::text
        END AS stato,
    vns.nominativo AS nominativo_responsabile,
    c.note_verbale,
    c.note_generali,
    c.dt_preavviso,
    c.mezzo_preavviso,
    (c.km_az)::character varying AS auto_az,
    (c.km_pr)::character varying AS auto_pr,
    c.km_pr,
    c.km_az,
    vcsc.sigla AS sigla_stato,
    vcsc.descr AS descr_stato,
    c.id_stato_cu,
    t.cod AS cod_tecnica,
    a.pec AS pec_stabilimento,
    NULL::text AS data_chiusura_minima,
    c.id_responsabile,
    a.cod_regionale
   FROM (((((cu.cu c
     JOIN cu_conf.vw_cu_tecniche t ON ((c.id_tecnica = t.id_tecnica)))
     JOIN cu_anag.stabilimenti a ON ((c.id_az_sede = a.id)))
     LEFT JOIN cu_anag.vw_indirizzi ind ON ((ind.id = a.id_indirizzo)))
     LEFT JOIN matrix.vw_nominativi_struttura vns ON ((vns.id_nominativo = c.id_responsabile)))
     LEFT JOIN cu_types.vw_cu_stati_cu vcsc ON ((c.id_stato_cu = vcsc.id_stato_cu)));


ALTER TABLE cu.vw_cu OWNER TO postgres;

--
-- Name: vw_linea_piano_anno_assegnate; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_linea_piano_anno_assegnate AS
 SELECT a.id_linea,
    a.id_piano,
    EXTRACT(year FROM a.inizio) AS anno,
    count(*) AS assegnate
   FROM ( SELECT a_1.id_linea,
            a_1.id_piano,
            a_1.inizio
           FROM agenda.eventi a_1
          WHERE ((a_1.id_linea IS NOT NULL) AND (a_1.id_piano IS NOT NULL) AND (a_1.inizio IS NOT NULL) AND (NOT a_1.effettuata))
        UNION
         SELECT cl.id_linea,
            cp.id_piano,
            c.dt
           FROM ((cu.vw_cu c
             JOIN cu.cu_piani cp ON ((cp.id_cu = c.id)))
             JOIN cu.cu_linee cl ON ((cl.id_cu = c.id)))
          WHERE c.chiuso) a
  GROUP BY a.id_linea, a.id_piano, (EXTRACT(year FROM a.inizio));


ALTER TABLE agenda.vw_linea_piano_anno_assegnate OWNER TO postgres;

--
-- Name: vw_piano_tipo_linea; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_piano_tipo_linea AS
 SELECT pl.id AS id_piano_tipo_linea,
    pl.id_piano,
    pl.id_tipo_linea,
    p.descrizione AS descr_piano,
    p.descrizione_breve AS descr_breve_piano,
    t.cod,
    t.descr AS descr_tipo_linea,
    p.alias AS alias_piano,
    p.flag_cf
   FROM ((agenda.piano_tipo_linea pl
     JOIN matrix.vw_struttura_piani p ON ((pl.id_piano = p.id)))
     JOIN agenda.vw_ag_tree_nodes_up_tipo_linee t ON ((pl.id_tipo_linea = t.id)));


ALTER TABLE agenda.vw_piano_tipo_linea OWNER TO postgres;

--
-- Name: vw_linee_piano_struttura; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_linee_piano_struttura AS
 SELECT l.id,
    l.id_az_sede,
    l.id_azienda,
    l.stato_sede_operativa,
    l.denominazione_sede_operativa,
    l.indirizzo,
    l.id_comune,
    l.id_struttura,
    l.app_number,
    l.rag_soc,
    l.piva,
    l.codfis,
    l.id_linea,
    l.comune,
    l.id_tipo_linea,
    l.cod_tipo_linea,
    l.desc_tipo_linea,
    ptl.id_piano,
    sc.id_struttura AS id_struttura_asl,
    ptl.alias_piano,
    ptl.descr_piano AS descrizione_piano,
    ptl.flag_cf
   FROM (((agenda.vw_linee l
     JOIN agenda.vw_piano_tipo_linea ptl ON ((l.id_attivita = ptl.id_tipo_linea)))
     JOIN agenda.struttura_comuni sc ON ((sc.id_comune = l.id_comune)))
     JOIN agenda.asl_piani ap ON (((ap.id_piano = ptl.id_piano) AND (ap.id_struttura = sc.id_struttura))));


ALTER TABLE agenda.vw_linee_piano_struttura OWNER TO postgres;

--
-- Name: vw_linee_principali; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_linee_principali AS
 SELECT lp.nextval,
    lp.id_az_sede,
    lp.id_linea
   FROM agenda.linee_principali lp;


ALTER TABLE agenda.vw_linee_principali OWNER TO postgres;

--
-- Name: vw_linee_selezionate; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_linee_selezionate AS
 SELECT ls.id,
    ls.id_elab_cal,
    ls.id_linea,
    ls.id_piano,
    ls.ordine,
    ls.id AS id_linea_selezionata,
    l.denominazione_sede_operativa,
    (COALESCE((p.alias || ' '::text), ''::text) || p.descrizione) AS descrizione,
    p.flag_cf,
    l.id_az_sede
   FROM ((agenda.linee_selezionate ls
     JOIN agenda.vw_linee l ON ((l.id_linea = ls.id_linea)))
     JOIN matrix.vw_struttura_piani p ON ((p.id = ls.id_piano)));


ALTER TABLE agenda.vw_linee_selezionate OWNER TO postgres;

--
-- Name: vw_liste_precaricate; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_liste_precaricate AS
 SELECT tlp.id_piano,
    li.anno,
    il.id_linea
   FROM ((agenda.tipo_lista_piano tlp
     JOIN agenda.lista_import li ON ((li.id_tipo_lista = tlp.id_tipo_lista)))
     JOIN agenda.import_linea il ON ((il.id_lista = li.id)))
  WHERE (il.id_linea IS NOT NULL);


ALTER TABLE agenda.vw_liste_precaricate OWNER TO postgres;

--
-- Name: vw_nominativi; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_nominativi AS
 SELECT DISTINCT a.id_anagrafica,
    a.nominativo,
    (a.codice_fiscale)::text AS codice_fiscale,
    (a.qualifica)::text AS qualifica,
    NULL::integer AS role_id,
    a.qualifica AS qualifica_cu
   FROM matrix.nominativi a;


ALTER TABLE agenda.vw_nominativi OWNER TO postgres;

--
-- Name: cu_altri; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_altri (
    id bigint NOT NULL,
    nome character varying,
    cognome character varying,
    comune_nascita character varying,
    dt_nascita date,
    cf character varying
);


ALTER TABLE cu.cu_altri OWNER TO postgres;

--
-- Name: cu_nucleo; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_nucleo (
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_nominativo bigint NOT NULL,
    ord character varying NOT NULL,
    id_tipo_isp bigint,
    id_tipo_nucleo integer DEFAULT 0 NOT NULL,
    ruolo character varying,
    per_conto_di bigint,
    id_tipo_per bigint,
    custode_verbale boolean
);


ALTER TABLE cu.cu_nucleo OWNER TO postgres;

--
-- Name: cu_tipo_isp; Type: TABLE; Schema: cu_conf; Owner: postgres
--

CREATE TABLE cu_conf.cu_tipo_isp (
    id bigint NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    massimo integer DEFAULT 10000 NOT NULL,
    rng numrange
);


ALTER TABLE cu_conf.cu_tipo_isp OWNER TO postgres;

--
-- Name: cu_tipo_per; Type: TABLE; Schema: cu_conf; Owner: postgres
--

CREATE TABLE cu_conf.cu_tipo_per (
    id bigint NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL
);


ALTER TABLE cu_conf.cu_tipo_per OWNER TO postgres;

--
-- Name: vw_cu_tipo_isp; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_tipo_isp AS
 SELECT cu_tipo_isp.id AS id_tipo_isp,
    cu_tipo_isp.id,
    cu_tipo_isp.sigla,
    cu_tipo_isp.descr,
    cu_tipo_isp.massimo,
    cu_tipo_isp.rng,
    lower(cu_tipo_isp.rng) AS numero_minimo,
    upper(cu_tipo_isp.rng) AS numero_massimo
   FROM cu_conf.cu_tipo_isp;


ALTER TABLE cu_conf.vw_cu_tipo_isp OWNER TO postgres;

--
-- Name: vw_cu_tipo_per; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_tipo_per AS
 SELECT cu_tipo_per.id AS id_tipo_per,
    cu_tipo_per.id,
    cu_tipo_per.sigla,
    cu_tipo_per.descr
   FROM cu_conf.cu_tipo_per;


ALTER TABLE cu_conf.vw_cu_tipo_per OWNER TO postgres;

--
-- Name: cu_tipo_nucleo; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.cu_tipo_nucleo (
    id integer NOT NULL,
    sigla character varying NOT NULL,
    descr_tipo_nucleo character varying NOT NULL
);


ALTER TABLE cu_types.cu_tipo_nucleo OWNER TO postgres;

--
-- Name: vw_cu_tipo_nucleo; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_cu_tipo_nucleo AS
 SELECT t.id AS id_tipo_nucleo,
    t.id,
    t.sigla,
    t.descr_tipo_nucleo
   FROM cu_types.cu_tipo_nucleo t;


ALTER TABLE cu_types.vw_cu_tipo_nucleo OWNER TO postgres;

--
-- Name: vw_cu_nucleo; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_nucleo AS
 SELECT n.id AS id_cu_nucleo,
    n.id,
    n.id_cu,
    n.id_nominativo AS id_ns,
    n.ord,
    n.id_tipo_isp,
    ns.nominativo,
    n.id_tipo_nucleo,
    t.sigla AS sigla_tipo_nucleo,
    t.descr_tipo_nucleo,
    ns.descrizione_breve AS ruolo,
    ti.sigla AS sigla_tipo_isp,
    n.id_nominativo,
    n.per_conto_di,
    tp.sigla AS sigla_per,
    tp.descr AS descr_per,
    tp.id_tipo_per,
    NULL::date AS dt_nascita,
    ''::text AS comune_nascita,
    ''::text AS cf,
    n.custode_verbale
   FROM ((((cu.cu_nucleo n
     JOIN matrix.vw_nominativi_struttura ns ON ((ns.id_nominativo = n.id_nominativo)))
     JOIN cu_types.vw_cu_tipo_nucleo t ON ((t.id_tipo_nucleo = n.id_tipo_nucleo)))
     LEFT JOIN cu_conf.vw_cu_tipo_isp ti ON ((ti.id_tipo_isp = n.id_tipo_isp)))
     LEFT JOIN cu_conf.vw_cu_tipo_per tp ON ((tp.id_tipo_per = n.id_tipo_per)))
  WHERE (n.id_tipo_nucleo = 1)
UNION
 SELECT n.id AS id_cu_nucleo,
    n.id,
    n.id_cu,
    n.id_nominativo AS id_ns,
    n.ord,
    n.id_tipo_isp,
    (((a.nome)::text || ' '::text) || (a.cognome)::text) AS nominativo,
    n.id_tipo_nucleo,
    t.sigla AS sigla_tipo_nucleo,
    t.descr_tipo_nucleo,
    n.ruolo,
    ''::character varying AS sigla_tipo_isp,
    n.id_nominativo,
    n.per_conto_di,
    ''::character varying AS sigla_per,
    ''::character varying AS descr_per,
    n.id_tipo_per,
    a.dt_nascita,
    a.comune_nascita,
    a.cf,
    n.custode_verbale
   FROM (((cu.cu_nucleo n
     JOIN cu.vw_cu c ON ((n.id_cu = c.id_cu)))
     JOIN cu.cu_altri a ON ((a.id = n.id_nominativo)))
     JOIN cu_types.vw_cu_tipo_nucleo t ON ((t.id_tipo_nucleo = n.id_tipo_nucleo)))
  WHERE (n.id_tipo_nucleo <> 1);


ALTER TABLE cu.vw_cu_nucleo OWNER TO postgres;

--
-- Name: vw_tree_nodes_up_piani; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_up_piani AS
 SELECT vw_tree_nodes_up.name_tree,
    vw_tree_nodes_up.id_node,
    vw_tree_nodes_up.id_tree,
    vw_tree_nodes_up.id_node_parent,
    vw_tree_nodes_up.path_ord,
    vw_tree_nodes_up.path_descr,
    p.id,
    p.id_gisa,
    p.cod_raggruppamento,
    p.anno,
    p.descrizione,
    (vw_tree_nodes_up.ordinamento)::integer AS ordinamento,
    p.data_scadenza,
    p.stato,
    p.codice_interno,
    p.color,
    p.path,
    (vw_tree_nodes_up.lv)::bigint AS livello,
    p.alias,
    p.id_formula_ups,
    p.id_formula_uba,
    p.descrizione_breve,
    p.codice_interno_univoco,
    p.ha_campioni,
    p.id_tipo_tecnica,
    vw_tree_nodes_up.validita,
    lower(vw_tree_nodes_up.validita) AS inizio_validita,
    upper(vw_tree_nodes_up.validita) AS fine_validita
   FROM (matrix.vw_tree_nodes_up
     JOIN matrix.struttura_piani p ON ((p.id = vw_tree_nodes_up.id_node)));


ALTER TABLE matrix.vw_tree_nodes_up_piani OWNER TO postgres;

--
-- Name: vw_cu_piani; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_piani AS
 SELECT cp.id AS id_cu_piano,
    cp.id,
    cp.id_cu,
    cp.id_piano,
    cp.ord,
    cp.id_perconto_di AS per_conto,
    p.alias,
    a.descrizione_breve AS sigla_asl,
    p.descrizione AS descrizione_piano,
    p.descrizione_breve AS sigla_piano,
    ((p.alias || ' - '::text) || p.descrizione) AS descrizione_completa_piano,
    c.descr_tecnica,
    c.sigla_tecnica,
    c.id_az_sede,
    c.dt,
    c.chiuso,
    c.codice
   FROM (((cu.cu_piani cp
     JOIN cu.vw_cu c ON ((c.id = cp.id_cu)))
     JOIN matrix.vw_tree_nodes_up_piani p ON ((cp.id_piano = p.id)))
     JOIN matrix.vw_tree_nodes_up_asl a ON ((a.id = cp.id_perconto_di)));


ALTER TABLE cu.vw_cu_piani OWNER TO postgres;

--
-- Name: mod4_nominativi; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.mod4_nominativi (
    id bigint NOT NULL,
    id_nominativo_struttura bigint,
    livello_formativo integer,
    carico_annuale integer,
    perc_sottr numeric,
    perc_sottr2 integer,
    fattore1 boolean,
    fattore2 boolean,
    fattore3 boolean,
    uba_ora real,
    fattori_text character varying,
    ups smallint,
    uba smallint,
    entered timestamp without time zone,
    perc_dest_uba numeric
);


ALTER TABLE matrix.mod4_nominativi OWNER TO postgres;

--
-- Name: vw_nominativi; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_nominativi AS
 SELECT (nominativi.id)::integer AS id,
    nominativi.id_nominativo_gisa,
    nominativi.id_anagrafica,
    nominativi.nominativo,
    (nominativi.codice_fiscale)::text AS codice_fiscale,
    (nominativi.qualifica)::text AS qualifica
   FROM matrix.nominativi;


ALTER TABLE matrix.vw_nominativi OWNER TO postgres;

--
-- Name: vw_nominativi_carico; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_nominativi_carico AS
 SELECT b.id_risorsa,
    b.id_nominativo,
    b.nominativo,
    COALESCE(COALESCE(c.anno, a.anno), (b.anno)::numeric) AS anno,
    round((COALESCE(b.uip_potenziali, (0)::bigint))::numeric, 2) AS uip_potenziali,
    round((COALESCE(a.eff_uip, ((0)::numeric)::double precision))::numeric, 2) AS uip_effettuati,
    round((COALESCE(a.eff_cu, (0)::bigint))::numeric, 2) AS cu_effettuati,
    round((COALESCE(c.prog_uip, ((0)::numeric)::double precision))::numeric, 2) AS uip_da_effettuare,
    round((COALESCE(c.prog_cu, (0)::bigint))::numeric, 2) AS cu_da_effettuare,
        CASE
            WHEN ((COALESCE(b.uip_potenziali, (0)::bigint))::double precision = (0)::double precision) THEN (0)::double precision
            ELSE round((((COALESCE(a.eff_uip, (0)::double precision) + COALESCE(c.prog_uip, (0)::double precision)) * (100)::double precision) / (COALESCE(b.uip_potenziali, (1)::bigint))::double precision))
        END AS perc_programmta,
    b.descrizione_breve
   FROM ((( SELECT ns.id_anagrafica AS id_risorsa,
            ns.id_nominativo,
            ns.nominativo,
            sum((round((COALESCE((n.ups)::integer, 0))::double precision))::smallint) AS uip_potenziali,
            ns.descrizione_breve,
            ns.anno
           FROM (matrix.vw_nominativi_struttura ns
             LEFT JOIN matrix.mod4_nominativi n ON ((ns.id = n.id_nominativo_struttura)))
          GROUP BY ns.id_anagrafica, ns.id_nominativo, ns.nominativo, ns.descrizione_breve, ns.anno) b
     LEFT JOIN ( SELECT cn.id_ns AS id_nominativo,
            EXTRACT(year FROM c_1.dt) AS anno,
            sum(COALESCE(p_1.fattore_ups, (0.75)::double precision)) AS eff_uip,
            count(*) AS eff_cu
           FROM (((cu.vw_cu_nucleo cn
             JOIN cu.vw_cu c_1 ON ((cn.id_cu = c_1.id_cu)))
             JOIN cu.vw_cu_piani cp ON ((cp.id_cu = c_1.id_cu)))
             JOIN matrix.vw_struttura_piani p_1 ON ((cp.id_piano = p_1.id)))
          WHERE c_1.chiuso
          GROUP BY cn.id_ns, (EXTRACT(year FROM c_1.dt))) a ON ((a.id_nominativo = b.id_nominativo)))
     LEFT JOIN ( SELECT vn.id AS id_nominativo,
            EXTRACT(year FROM e_1.inizio) AS anno,
            sum(COALESCE(p_1.fattore_ups, (0.75)::double precision)) AS prog_uip,
            count(*) AS prog_cu
           FROM ((agenda.vw_eventi e_1
             JOIN matrix.vw_nominativi vn ON ((e_1.id_risorsa = vn.id)))
             LEFT JOIN matrix.vw_struttura_piani p_1 ON ((e_1.id_piano = p_1.id)))
          WHERE ((e_1.inizio IS NOT NULL) AND (NOT e_1.effettuata) AND e_1.operativa)
          GROUP BY vn.id, (EXTRACT(year FROM e_1.inizio))) c ON (((b.id_nominativo = c.id_nominativo) AND ((b.anno)::numeric = c.anno))));


ALTER TABLE agenda.vw_nominativi_carico OWNER TO postgres;

--
-- Name: vw_nominativi_struttura; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_nominativi_struttura AS
 SELECT (ns.id)::integer AS id,
    n.id_anagrafica AS id_nominativo,
    ns.id_struttura,
    n.nominativo,
    a.descrizione_breve,
    a.id AS id_node_struttura,
    n.id_anagrafica,
    a.anno,
    a.codice_interno_fk,
    a.descrizione
   FROM ((matrix.nominativi_struttura ns
     JOIN matrix.nominativi n ON ((n.id = ns.id_nominativo)))
     JOIN matrix.struttura_asl a ON ((a.id = ns.id_struttura)));


ALTER TABLE agenda.vw_nominativi_struttura OWNER TO postgres;

--
-- Name: vw_nominativo_az_sedi; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_nominativo_az_sedi AS
 SELECT na_s.id,
    na_s.id_nominativo_struttura,
    na_s.id_az_sede,
    a_s.denominazione_sede_operativa,
    ns.nominativo,
    a_s.indirizzo,
    a_s.id_comune,
    a_s.comune,
    ns.id_nominativo,
    ns.descrizione_breve AS descrizione_breve_asl,
    ns.anno AS anno_asl,
    ns.id_anagrafica,
    ns.codice_interno_fk,
    ns.id_struttura,
    ns.descrizione_breve
   FROM ((agenda.nominativo_az_sedi na_s
     JOIN matrix.vw_nominativi_struttura ns ON ((ns.id = na_s.id_nominativo_struttura)))
     JOIN agenda.vw_az_sedi a_s ON ((na_s.id_az_sede = a_s.id)));


ALTER TABLE agenda.vw_nominativo_az_sedi OWNER TO postgres;

--
-- Name: vw_nominativo_carico; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_nominativo_carico AS
 SELECT e.id_anagrafica,
    (e.inizio)::date AS dt,
    sum(e.durata) AS durata,
    ((sum(e.durata) / (36)::double precision) / (8)::double precision) AS durata_perc
   FROM agenda.vw_eventi e
  GROUP BY e.id_anagrafica, ((e.inizio)::date);


ALTER TABLE agenda.vw_nominativo_carico OWNER TO postgres;

--
-- Name: vw_nominativo_comuni; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_nominativo_comuni AS
 SELECT nc.id,
    nc.id_nominativo_struttura,
    nc.id_struttura_comune,
    nc.id AS id_nominativo_comune,
    sa.descrizione,
    n.nominativo,
    sc.id_comune,
    sc.id_struttura,
    sc.comune,
    sc.descrizione_breve,
    sa.descrizione_breve AS descrizione_breve_asl,
    ns.id_nominativo,
    sa.anno AS anno_asl,
    sa.codice_interno_fk,
    n.id_anagrafica
   FROM ((((agenda.nominativo_comuni nc
     JOIN matrix.vw_nominativi_struttura ns ON ((ns.id = nc.id_nominativo_struttura)))
     JOIN matrix.nominativi n ON ((n.id = ns.id_nominativo)))
     JOIN matrix.struttura_asl sa ON ((sa.id = ns.id_node_struttura)))
     JOIN agenda.vw_struttura_comuni sc ON ((nc.id_struttura_comune = sc.id)));


ALTER TABLE agenda.vw_nominativo_comuni OWNER TO postgres;

--
-- Name: vw_nominativo_linee; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_nominativo_linee AS
 SELECT nl.id,
    nl.id_nominativo_struttura,
    nl.id_linea,
    l.denominazione_sede_operativa,
    ns.nominativo,
    l.indirizzo,
    l.id_comune,
    l.comune,
    ns.id_nominativo,
    ns.descrizione_breve AS descrizione_breve_asl,
    ns.anno AS anno_asl,
    ns.id_anagrafica,
    ns.codice_interno_fk,
    ns.id_struttura,
    ns.descrizione_breve
   FROM ((agenda.nominativo_linee nl
     JOIN matrix.vw_nominativi_struttura ns ON ((ns.id = nl.id_nominativo_struttura)))
     JOIN agenda.vw_linee l ON ((nl.id_linea = l.id)));


ALTER TABLE agenda.vw_nominativo_linee OWNER TO postgres;

--
-- Name: vw_nominativo_piani; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_nominativo_piani AS
 SELECT np.id,
    np.id_nominativo_struttura,
    np.id_piano,
    sp.descrizione,
    ns.nominativo,
    sp.descrizione_breve,
    sp.cod_raggruppamento,
    sp.anno AS anno_piano,
    ns.id_nominativo,
    ns.descrizione_breve AS descrizione_breve_asl,
    ns.anno AS anno_asl,
    ns.id_anagrafica,
    ns.codice_interno_fk,
    sp.id_formula_ups,
    sp.id_formula_uba,
    sp.alias,
    ns.id_struttura
   FROM ((agenda.nominativo_piani np
     JOIN matrix.vw_nominativi_struttura ns ON ((ns.id = np.id_nominativo_struttura)))
     JOIN matrix.struttura_piani sp ON ((sp.id = np.id_piano)));


ALTER TABLE agenda.vw_nominativo_piani OWNER TO postgres;

--
-- Name: vw_nominativo_piani_comuni; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_nominativo_piani_comuni AS
 SELECT c.id_comune,
    c.id_nominativo_struttura,
    p.alias,
    p.descrizione_breve,
    p.descrizione,
    c.nominativo
   FROM (agenda.vw_nominativo_comuni c
     JOIN agenda.vw_nominativo_piani p ON ((c.id_nominativo_struttura = p.id_nominativo_struttura)));


ALTER TABLE agenda.vw_nominativo_piani_comuni OWNER TO postgres;

--
-- Name: vw_piani_periodo; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_piani_periodo AS
 SELECT pp.id,
    pp.id_piano,
    pp.periodo,
    lower(pp.periodo) AS da,
    upper(pp.periodo) AS a,
    sp.alias AS alias_piano,
    sp.descrizione_piano,
    pp.validita_interna AS interno
   FROM (agenda.piano_periodo pp
     JOIN matrix.vw_struttura_piani sp ON ((sp.id = pp.id_piano)));


ALTER TABLE agenda.vw_piani_periodo OWNER TO postgres;

--
-- Name: vw_piano_freq; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_piano_freq AS
 SELECT pf.id,
    pf.id AS id_piano_freq,
    pf.livello,
    pf.num,
    pf.den,
    sp.descrizione,
    sp.descrizione_breve,
    pf.id_piano,
    (
        CASE
            WHEN (pf.num = (0)::numeric) THEN (1)::numeric
            ELSE pf.num
        END /
        CASE
            WHEN (pf.den = (0)::numeric) THEN (1)::numeric
            ELSE pf.den
        END) AS freq,
    sp.alias AS alias_piano
   FROM (agenda.piano_freq pf
     JOIN matrix.vw_struttura_piani sp ON ((sp.id = pf.id_piano)));


ALTER TABLE agenda.vw_piano_freq OWNER TO postgres;

--
-- Name: vw_piano_freq_all; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_piano_freq_all AS
 SELECT sp.id,
    pf.id AS id_piano_freq,
    c.idx AS livello,
    COALESCE(pf.num, (1)::numeric) AS num,
    COALESCE(pf.den, ((c.value)::integer)::numeric) AS den,
    sp.descrizione,
    sp.descrizione_breve,
    sp.id AS id_piano,
    (
        CASE
            WHEN (COALESCE(pf.num, (1)::numeric) = (0)::numeric) THEN (1)::numeric
            ELSE COALESCE(pf.num, (1)::numeric)
        END /
        CASE
            WHEN (COALESCE(pf.den, ((c.value)::integer)::numeric) = (0)::numeric) THEN (1)::numeric
            ELSE COALESCE(pf.den, ((c.value)::integer)::numeric)
        END) AS freq,
    sp.alias AS alias_piano
   FROM ((matrix.vw_struttura_piani sp
     JOIN ag_conf.ag_conf c ON (((c.cod)::text = 'freq_rischio'::text)))
     LEFT JOIN agenda.piano_freq pf ON (((sp.id = pf.id_piano) AND (pf.livello = c.idx))));


ALTER TABLE agenda.vw_piano_freq_all OWNER TO postgres;

--
-- Name: vw_prova; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_prova AS
 SELECT a.id,
    a.risorsa,
    a.eseguite,
    a.pianificate,
    a.eseguite_ratio,
    a.tempo,
    a.eff,
    a.k,
    a.cons,
    a.id_anagrafica,
        CASE
            WHEN ((a.cons * (100)::double precision) > (100)::double precision) THEN (100)::double precision
            ELSE (a.cons * (100)::double precision)
        END AS cons_perc,
        CASE
            WHEN ((a.tempo * (100)::double precision) > (100)::double precision) THEN (100)::double precision
            ELSE (a.tempo * (100)::double precision)
        END AS tempo_perc,
        CASE
            WHEN ((a.eff * (100)::double precision) > (100)::double precision) THEN (100)::double precision
            ELSE (a.eff * (100)::double precision)
        END AS eff_perc
   FROM ( SELECT (n.id_anagrafica)::integer AS id,
            n.nominativo AS risorsa,
            (round(((COALESCE(e.eseguite, ((0)::numeric)::double precision) / ((3600)::numeric)::double precision))::numeric, 2))::double precision AS eseguite,
            (round(((COALESCE(p.pianificate, ((0)::numeric)::double precision) / ((3600)::numeric)::double precision))::numeric, 2))::double precision AS pianificate,
            (round((COALESCE((e.eseguite /
                CASE
                    WHEN (p.pianificate = (0)::double precision) THEN (1)::double precision
                    ELSE p.pianificate
                END), (0)::double precision))::numeric, 2))::double precision AS eseguite_ratio,
            (round((
                CASE
                    WHEN ((CURRENT_TIMESTAMP < p.min_fine) OR (p.min_fine >= p.max_fine) OR (p.min_fine IS NULL) OR (p.max_fine IS NULL)) THEN (0)::double precision
                    ELSE (date_part('epoch'::text, (CURRENT_TIMESTAMP - (p.min_fine)::timestamp with time zone)) / date_part('epoch'::text, (p.max_fine - p.min_fine)))
                END)::numeric, 2))::double precision AS tempo,
            (round((COALESCE(((e.eseguite /
                CASE
                    WHEN (p.pianificate = (0)::double precision) THEN (1)::double precision
                    ELSE p.pianificate
                END) / ((date_part('doy'::text, CURRENT_TIMESTAMP) - (1)::double precision) / (365)::double precision)), (0)::double precision))::numeric, 2))::double precision AS eff,
            (round((COALESCE((e.eseguite /
                CASE
                    WHEN (t.tot_eseguite = (0)::double precision) THEN (1)::double precision
                    ELSE t.tot_eseguite
                END), (0)::double precision))::numeric, 2))::double precision AS k,
            (round((COALESCE((t.tot_eseguite /
                CASE
                    WHEN (tp.tot_pianificate = (0)::double precision) THEN (1)::double precision
                    ELSE tp.tot_pianificate
                END), (0)::double precision))::numeric, 2))::double precision AS cons,
            n.id_anagrafica
           FROM ((((( SELECT nominativi.id_anagrafica,
                    min(nominativi.nominativo) AS nominativo
                   FROM matrix.nominativi
                  GROUP BY nominativi.id_anagrafica) n
             LEFT JOIN ( SELECT vw_eventi_no_linee.id_anagrafica,
                    sum(vw_eventi_no_linee.durata) AS eseguite
                   FROM agenda.vw_eventi_no_linee
                  WHERE (vw_eventi_no_linee.operativa AND vw_eventi_no_linee.effettuata)
                  GROUP BY vw_eventi_no_linee.id_anagrafica) e ON ((n.id_anagrafica = e.id_anagrafica)))
             LEFT JOIN ( SELECT vw_eventi_no_linee.id_anagrafica,
                    sum(vw_eventi_no_linee.durata) AS pianificate,
                    max(vw_eventi_no_linee.fine) AS max_fine,
                    min(vw_eventi_no_linee.fine) AS min_fine
                   FROM agenda.vw_eventi_no_linee
                  WHERE vw_eventi_no_linee.operativa
                  GROUP BY vw_eventi_no_linee.id_anagrafica) p ON ((n.id_anagrafica = p.id_anagrafica)))
             LEFT JOIN ( SELECT e_1.id_anagrafica,
                    sum(e_1.durata) AS tot_eseguite
                   FROM agenda.vw_eventi_no_linee e_1
                  WHERE (e_1.effettuata AND (e_1.fine < CURRENT_TIMESTAMP))
                  GROUP BY e_1.id_anagrafica) t ON ((n.id_anagrafica = t.id_anagrafica)))
             LEFT JOIN ( SELECT e_1.id_anagrafica,
                    sum(e_1.durata) AS tot_pianificate
                   FROM agenda.vw_eventi_no_linee e_1
                  WHERE (e_1.fine < CURRENT_TIMESTAMP)
                  GROUP BY e_1.id_anagrafica) tp ON ((n.id_anagrafica = tp.id_anagrafica)))) a;


ALTER TABLE agenda.vw_prova OWNER TO postgres;

--
-- Name: vw_tree_nodes; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_tree_nodes AS
 SELECT t.name AS name_tree,
    n.id AS id_node,
    n.id_tree,
    n.id_parent AS id_node_parent,
    n.ordinamento,
    n.node_descr
   FROM (agenda.ag_tree_nodes n
     JOIN agenda.ag_trees t ON ((n.id_tree = t.id)));


ALTER TABLE agenda.vw_tree_nodes OWNER TO postgres;

--
-- Name: vw_tree_nodes_up; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_tree_nodes_up AS
 WITH RECURSIVE vw_tree_nodes_up(name_tree, id_node, id_tree, id_node_parent, path) AS (
         SELECT vw_tree_nodes.name_tree,
            vw_tree_nodes.id_node,
            vw_tree_nodes.id_tree,
            vw_tree_nodes.id_node_parent,
            (vw_tree_nodes.id_node)::text AS path,
            vw_tree_nodes.ordinamento AS path_ord,
            vw_tree_nodes.node_descr AS path_descr,
            0 AS lv,
            vw_tree_nodes.ordinamento
           FROM agenda.vw_tree_nodes
          WHERE (vw_tree_nodes.id_node_parent IS NULL)
        UNION ALL
         SELECT n.name_tree,
            n.id_node,
            n.id_tree,
            n.id_node_parent,
            ((up.path || '/'::text) || n.id_node),
            (((up.path_ord)::text || '/'::text) || (n.ordinamento)::text),
            (((up.path_descr)::text || '/'::text) || (n.node_descr)::text),
            (up.lv + 1) AS lv,
            n.ordinamento
           FROM (vw_tree_nodes_up up
             JOIN agenda.vw_tree_nodes n ON ((up.id_node = n.id_node_parent)))
        )
 SELECT vw_tree_nodes_up.name_tree,
    vw_tree_nodes_up.id_node,
    vw_tree_nodes_up.id_tree,
    vw_tree_nodes_up.id_node_parent,
    vw_tree_nodes_up.path,
    vw_tree_nodes_up.path_ord,
    vw_tree_nodes_up.path_descr,
    vw_tree_nodes_up.lv,
    vw_tree_nodes_up.ordinamento
   FROM vw_tree_nodes_up
  ORDER BY vw_tree_nodes_up.path;


ALTER TABLE agenda.vw_tree_nodes_up OWNER TO postgres;

--
-- Name: vw_unita_di_crisi; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_unita_di_crisi AS
 SELECT udcf.id,
    udcf.ruolo,
    udcf.responsabile_titolo,
    udcf.responsabile_nome,
    udcf.responsabile_cognome,
    udcf.email,
    udcf.telefono,
    udcf.cellulare,
    udcf.validita,
    (COALESCE(((udcf.responsabile_cognome)::text || ' '::text), ''::text) || (udcf.responsabile_nome)::text) AS responsabile,
    udcf.id_asl
   FROM agenda.unita_di_crisi udcf
  WHERE (udcf.validita && tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));


ALTER TABLE agenda.vw_unita_di_crisi OWNER TO postgres;

--
-- Name: vw_unita_di_crisi_as_fo; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_unita_di_crisi_as_fo AS
 SELECT udcaf.id,
    udcaf.ruolo,
    udcaf.responsabile_titolo,
    udcaf.responsabile_nome,
    udcaf.responsabile_cognome,
    udcaf.email,
    udcaf.telefono,
    udcaf.cellulare,
    udcaf.validita,
    (COALESCE(((udcaf.responsabile_cognome)::text || ' '::text), ''::text) || (udcaf.responsabile_nome)::text) AS responsabile,
    udcaf.id_asl
   FROM agenda.unita_di_crisi_as_fo udcaf
  WHERE (udcaf.validita && tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));


ALTER TABLE agenda.vw_unita_di_crisi_as_fo OWNER TO postgres;

--
-- Name: vw_unita_di_crisi_asu_fc; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_unita_di_crisi_asu_fc AS
 SELECT udcaf.id,
    udcaf.ruolo,
    udcaf.responsabile_titolo,
    udcaf.responsabile_nome,
    udcaf.responsabile_cognome,
    udcaf.email,
    udcaf.telefono,
    udcaf.cellulare,
    udcaf.validita,
    (COALESCE(((udcaf.responsabile_cognome)::text || ' '::text), ''::text) || (udcaf.responsabile_nome)::text) AS responsabile,
    udcaf.id_asl
   FROM agenda.unita_di_crisi_asu_fc udcaf
  WHERE (udcaf.validita && tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));


ALTER TABLE agenda.vw_unita_di_crisi_asu_fc OWNER TO postgres;

--
-- Name: vw_unita_di_crisi_asu_gi; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_unita_di_crisi_asu_gi AS
 SELECT udcag.id,
    udcag.ruolo,
    udcag.responsabile_titolo,
    udcag.responsabile_nome,
    udcag.responsabile_cognome,
    udcag.email,
    udcag.telefono,
    udcag.cellulare,
    udcag.validita,
    (COALESCE(((udcag.responsabile_nome)::text || ' '::text), ''::text) || (udcag.responsabile_cognome)::text) AS responsabile,
    udcag.id_asl
   FROM agenda.unita_di_crisi_asu_gi udcag
  WHERE (udcag.validita && tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));


ALTER TABLE agenda.vw_unita_di_crisi_asu_gi OWNER TO postgres;

--
-- Name: vw_unita_di_crisi_fvg; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_unita_di_crisi_fvg AS
 SELECT udcf.id,
    udcf.ruolo,
    udcf.responsabile_titolo,
    udcf.responsabile_nome,
    udcf.responsabile_cognome,
    udcf.email,
    udcf.telefono,
    udcf.cellulare,
    udcf.validita,
    (COALESCE(((udcf.responsabile_cognome)::text || ' '::text), ''::text) || (udcf.responsabile_nome)::text) AS responsabile,
    udcf.id_asl
   FROM agenda.unita_di_crisi_fvg udcf
  WHERE (udcf.validita && tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));


ALTER TABLE agenda.vw_unita_di_crisi_fvg OWNER TO postgres;

--
-- Name: vw_utente_strutture; Type: VIEW; Schema: agenda; Owner: postgres
--

CREATE VIEW agenda.vw_utente_strutture AS
 SELECT us.id AS id_utente_struttura,
    us.id_utente,
    us.id_struttura,
    lower(us.validita) AS inizio_validita,
    upper(us.validita) AS fine_validita,
    t.id_asl,
    t.descrizione,
    t.descrizione_breve,
    u.nome,
    u.cognome,
    u.cf,
    u.descr_qualifica,
    u.sigla_qualifica,
    us.validita,
    u.id_qualifica
   FROM ((rbac.utente_strutture us
     JOIN matrix.vw_tree_nodes_up_asl t ON ((t.id_node = us.id_struttura)))
     JOIN rbac.vw_utenti u ON ((u.id_utente = us.id_utente)))
  WHERE (us.validita && tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));


ALTER TABLE agenda.vw_utente_strutture OWNER TO postgres;

--
-- Name: ag_conf_2024_01_11; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.ag_conf_2024_01_11 (
    id bigint,
    area character varying,
    cod character varying,
    descr character varying,
    value character varying,
    tipo character varying,
    validita tsrange,
    idx integer
);


ALTER TABLE bck.ag_conf_2024_01_11 OWNER TO postgres;

--
-- Name: ag_tree_nodes_20230919; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.ag_tree_nodes_20230919 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying,
    id_node_parent integer
);


ALTER TABLE bck.ag_tree_nodes_20230919 OWNER TO postgres;

--
-- Name: ag_tree_nodes_20231010; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.ag_tree_nodes_20231010 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying,
    id_node_parent integer
);


ALTER TABLE bck.ag_tree_nodes_20231010 OWNER TO postgres;

--
-- Name: ag_tree_nodes_20240321; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.ag_tree_nodes_20240321 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying,
    id_node_parent integer
);


ALTER TABLE bck.ag_tree_nodes_20240321 OWNER TO postgres;

--
-- Name: ag_tree_nodes_2024_07_04; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.ag_tree_nodes_2024_07_04 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying,
    id_node_parent integer
);


ALTER TABLE bck.ag_tree_nodes_2024_07_04 OWNER TO postgres;

--
-- Name: clienti_2024_01_11; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.clienti_2024_01_11 (
    id bigint,
    descr character varying,
    id_ref bigint,
    type character varying,
    piva character varying
);


ALTER TABLE bck.clienti_2024_01_11 OWNER TO postgres;

--
-- Name: clienti_2024_07_16; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.clienti_2024_07_16 (
    id bigint,
    descr character varying,
    id_ref bigint,
    type character varying,
    piva character varying
);


ALTER TABLE bck.clienti_2024_07_16 OWNER TO postgres;

--
-- Name: cu_2024_04_15; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.cu_2024_04_15 (
    id bigint,
    codice character varying,
    dt timestamp without time zone,
    id_tecnica bigint,
    preavviso boolean,
    rilievi boolean,
    id_evento bigint,
    id_az_sede bigint,
    id_responsabile bigint,
    chiuso boolean,
    dt_chiusura timestamp without time zone,
    pec character varying,
    note_verbale character varying,
    note_generali character varying,
    dt_preavviso timestamp without time zone,
    mezzo_preavviso character varying,
    km_az numeric,
    km_pr numeric,
    id_stato_cu bigint
);


ALTER TABLE bck.cu_2024_04_15 OWNER TO postgres;

--
-- Name: cu_2024_05_06; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.cu_2024_05_06 (
    id bigint,
    codice character varying,
    dt timestamp without time zone,
    id_tecnica bigint,
    preavviso boolean,
    rilievi boolean,
    id_evento bigint,
    id_az_sede bigint,
    id_responsabile bigint,
    chiuso boolean,
    dt_chiusura timestamp without time zone,
    pec character varying,
    note_verbale character varying,
    note_generali character varying,
    dt_preavviso timestamp without time zone,
    mezzo_preavviso character varying,
    km_az numeric,
    km_pr numeric,
    id_stato_cu bigint
);


ALTER TABLE bck.cu_2024_05_06 OWNER TO postgres;

--
-- Name: cu_anag_imprese_bdnupd_27_06_2024; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.cu_anag_imprese_bdnupd_27_06_2024 (
    id bigint,
    nome character varying,
    cf character varying,
    piva character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    az_id bigint,
    az_cod_aziendale character varying,
    az_cod_regionale character varying,
    sd_id bigint,
    verificato boolean,
    fonte character varying,
    validita tsrange,
    tipo_soggetto character varying
);


ALTER TABLE bck.cu_anag_imprese_bdnupd_27_06_2024 OWNER TO postgres;

--
-- Name: cu_anag_indirizzi_bdnupd_27_06_2024; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.cu_anag_indirizzi_bdnupd_27_06_2024 (
    id bigint,
    toponimo character varying,
    indirizzo character varying,
    cap text,
    stato_prov character varying,
    nazione text,
    istat_comune character varying,
    comune character varying,
    localita text,
    civico character varying,
    latitudine character varying,
    longitudine character varying,
    verificato boolean,
    fonte text
);


ALTER TABLE bck.cu_anag_indirizzi_bdnupd_27_06_2024 OWNER TO postgres;

--
-- Name: cu_anag_linee_bdnupd_27_06_2024; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.cu_anag_linee_bdnupd_27_06_2024 (
    id bigint,
    id_stabilimento bigint,
    id_tipo_linea integer,
    validita tsrange,
    attivita_fissa boolean,
    linea_principale boolean,
    verificato boolean,
    fonte text,
    data_ultima_visita timestamp without time zone,
    id_esterno character varying
);


ALTER TABLE bck.cu_anag_linee_bdnupd_27_06_2024 OWNER TO postgres;

--
-- Name: cu_anag_soggetti_fisici_bdnupd_27_06_2024; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.cu_anag_soggetti_fisici_bdnupd_27_06_2024 (
    id bigint,
    titolo character varying,
    cognome character varying,
    nome character varying,
    comune_nascita character varying,
    codice_fiscale character varying,
    sesso character varying,
    telefono character varying,
    email character varying,
    pec character varying,
    telefono2 character varying,
    data_nascita date,
    documento_identita character varying,
    indirizzo_id bigint,
    verificato boolean,
    fonte character varying
);


ALTER TABLE bck.cu_anag_soggetti_fisici_bdnupd_27_06_2024 OWNER TO postgres;

--
-- Name: cu_anag_stabilimenti_bdnupd_27_06_2024; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.cu_anag_stabilimenti_bdnupd_27_06_2024 (
    id bigint,
    id_impresa bigint,
    nome character varying,
    sd_id numeric(12,0),
    id_indirizzo bigint,
    cod_regionale character varying,
    verificato boolean,
    fonte character varying,
    categoria_rischio numeric,
    validita tsrange,
    cod_nazionale character varying,
    id_tipologia_struttura bigint,
    pec character varying,
    telefono character varying,
    sdi character varying
);


ALTER TABLE bck.cu_anag_stabilimenti_bdnupd_27_06_2024 OWNER TO postgres;

--
-- Name: cu_anag_stabilimento_figure_bdnupd_27_06_2024; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.cu_anag_stabilimento_figure_bdnupd_27_06_2024 (
    id bigint,
    id_stabilimento bigint,
    id_soggetto bigint,
    id_tipo_figura bigint,
    id_indirizzo bigint,
    old_id bigint,
    fonte text,
    descr character varying,
    validita tsrange
);


ALTER TABLE bck.cu_anag_stabilimento_figure_bdnupd_27_06_2024 OWNER TO postgres;

--
-- Name: cu_anag_stabilimento_sedi_bdnupd_27_06_2024; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.cu_anag_stabilimento_sedi_bdnupd_27_06_2024 (
    id bigint,
    id_stabilimento bigint,
    id_tipo_sede bigint,
    id_indirizzo bigint,
    pec character varying,
    email character varying,
    old_id bigint,
    fonte text,
    validita tsrange
);


ALTER TABLE bck.cu_anag_stabilimento_sedi_bdnupd_27_06_2024 OWNER TO postgres;

--
-- Name: eventi_2024_06_05; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.eventi_2024_06_05 (
    id bigint,
    id_nominativo bigint,
    id_tipo_evento bigint,
    inizio timestamp without time zone,
    fine timestamp without time zone,
    id_linea bigint,
    id_attivita bigint,
    id_piano bigint,
    effettuata boolean,
    id_partner bigint,
    valido_da timestamp without time zone,
    valido_a timestamp without time zone,
    per_conto bigint,
    id_elab_cal bigint,
    id_cu bigint,
    partner_per_conto bigint,
    validita_interna boolean,
    quantita numeric,
    id_user_create bigint,
    ts_create timestamp without time zone
);


ALTER TABLE bck.eventi_2024_06_05 OWNER TO postgres;

--
-- Name: get_info_masterlist_202301010; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.get_info_masterlist_202301010 (
    codice_univoco text,
    id_norma integer,
    codice_norma text,
    id_macroarea integer,
    macroarea text,
    codice_macroarea text,
    id_aggregazione integer,
    aggregazione text,
    codice_aggregazione text,
    id_linea integer,
    attivita text,
    codice_attivita text,
    mobile boolean,
    fisso boolean,
    apicoltura boolean,
    registrabili boolean,
    riconoscibili boolean,
    sintesis boolean,
    bdu boolean,
    vam boolean,
    no_scia boolean,
    categorizzabili boolean,
    rev integer,
    categoria_rischio_default integer
);


ALTER TABLE bck.get_info_masterlist_202301010 OWNER TO postgres;

--
-- Name: get_info_masterlist_202309019; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.get_info_masterlist_202309019 (
    codice_univoco text,
    id_norma integer,
    codice_norma text,
    id_macroarea integer,
    macroarea text,
    codice_macroarea text,
    id_aggregazione integer,
    aggregazione text,
    codice_aggregazione text,
    id_linea integer,
    attivita text,
    codice_attivita text,
    mobile boolean,
    fisso boolean,
    apicoltura boolean,
    registrabili boolean,
    riconoscibili boolean,
    sintesis boolean,
    bdu boolean,
    vam boolean,
    no_scia boolean,
    categorizzabili boolean,
    rev integer,
    categoria_rischio_default integer
);


ALTER TABLE bck.get_info_masterlist_202309019 OWNER TO postgres;

--
-- Name: get_info_masterlist_2024_07_04; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.get_info_masterlist_2024_07_04 (
    codice_univoco text,
    id_norma integer,
    codice_norma text,
    id_macroarea integer,
    macroarea text,
    codice_macroarea text,
    id_aggregazione integer,
    aggregazione text,
    codice_aggregazione text,
    id_linea integer,
    attivita text,
    codice_attivita text,
    mobile boolean,
    fisso boolean,
    apicoltura boolean,
    registrabili boolean,
    riconoscibili boolean,
    sintesis boolean,
    bdu boolean,
    vam boolean,
    no_scia boolean,
    categorizzabili boolean,
    rev integer,
    categoria_rischio_default integer
);


ALTER TABLE bck.get_info_masterlist_2024_07_04 OWNER TO postgres;

--
-- Name: grid_definition_20240411; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.grid_definition_20240411 (
    id bigint,
    funct character varying,
    id_user bigint,
    type_user character varying,
    str_conf character varying,
    note character varying
);


ALTER TABLE bck.grid_definition_20240411 OWNER TO postgres;

--
-- Name: impresa_sedi_2024_09_30; Type: TABLE; Schema: bck; Owner: gisa_fvg
--

CREATE TABLE bck.impresa_sedi_2024_09_30 (
    id bigint,
    id_impresa bigint,
    id_tipo_sede bigint,
    id_indirizzo bigint,
    pec character varying,
    email character varying,
    old_id bigint,
    fonte text,
    validita tsrange
);


ALTER TABLE bck.impresa_sedi_2024_09_30 OWNER TO gisa_fvg;

--
-- Name: imprese_2024_03_29; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.imprese_2024_03_29 (
    id bigint,
    nome character varying,
    cf character varying,
    piva character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    az_id bigint,
    az_cod_aziendale character varying,
    az_cod_regionale character varying,
    sd_id bigint,
    verificato boolean,
    fonte character varying,
    validita tsrange,
    tipo_soggetto character varying
);


ALTER TABLE bck.imprese_2024_03_29 OWNER TO postgres;

--
-- Name: imprese_2024_07_04; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.imprese_2024_07_04 (
    id bigint,
    nome character varying,
    cf character varying,
    piva character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    az_id bigint,
    az_cod_aziendale character varying,
    az_cod_regionale character varying,
    sd_id bigint,
    verificato boolean,
    fonte character varying,
    validita tsrange,
    tipo_soggetto character varying
);


ALTER TABLE bck.imprese_2024_07_04 OWNER TO postgres;

--
-- Name: imprese_2024_07_08; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.imprese_2024_07_08 (
    id bigint,
    nome character varying,
    cf character varying,
    piva character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    az_id bigint,
    az_cod_aziendale character varying,
    az_cod_regionale character varying,
    sd_id bigint,
    verificato boolean,
    fonte character varying,
    validita tsrange,
    tipo_soggetto character varying
);


ALTER TABLE bck.imprese_2024_07_08 OWNER TO postgres;

--
-- Name: imprese_2024_09_30; Type: TABLE; Schema: bck; Owner: gisa_fvg
--

CREATE TABLE bck.imprese_2024_09_30 (
    id bigint,
    nome character varying,
    cf character varying,
    piva character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    az_id bigint,
    az_cod_aziendale character varying,
    az_cod_regionale character varying,
    sd_id bigint,
    verificato boolean,
    fonte character varying,
    validita tsrange,
    tipo_soggetto character varying
);


ALTER TABLE bck.imprese_2024_09_30 OWNER TO gisa_fvg;

--
-- Name: indirizzi_2024_03_25; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.indirizzi_2024_03_25 (
    id bigint,
    toponimo character varying,
    indirizzo character varying,
    cap text,
    stato_prov character varying,
    nazione text,
    istat_comune character varying,
    comune character varying,
    localita text,
    civico character varying,
    latitudine character varying,
    longitudine character varying,
    verificato boolean,
    fonte text
);


ALTER TABLE bck.indirizzi_2024_03_25 OWNER TO postgres;

--
-- Name: indirizzi_2024_04_05; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.indirizzi_2024_04_05 (
    id bigint,
    toponimo character varying,
    indirizzo character varying,
    cap text,
    stato_prov character varying,
    nazione text,
    istat_comune character varying,
    comune character varying,
    localita text,
    civico character varying,
    latitudine character varying,
    longitudine character varying,
    verificato boolean,
    fonte text
);


ALTER TABLE bck.indirizzi_2024_04_05 OWNER TO postgres;

--
-- Name: indirizzi_2024_07_05; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.indirizzi_2024_07_05 (
    id bigint,
    toponimo character varying,
    indirizzo character varying,
    cap text,
    stato_prov character varying,
    nazione text,
    istat_comune character varying,
    comune character varying,
    localita text,
    civico character varying,
    latitudine character varying,
    longitudine character varying,
    verificato boolean,
    fonte text
);


ALTER TABLE bck.indirizzi_2024_07_05 OWNER TO postgres;

--
-- Name: indirizzi_2024_07_08; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.indirizzi_2024_07_08 (
    id bigint,
    toponimo character varying,
    indirizzo character varying,
    cap text,
    stato_prov character varying,
    nazione text,
    istat_comune character varying,
    comune character varying,
    localita text,
    civico character varying,
    latitudine character varying,
    longitudine character varying,
    verificato boolean,
    fonte text
);


ALTER TABLE bck.indirizzi_2024_07_08 OWNER TO postgres;

--
-- Name: indirizzi_2024_09_30; Type: TABLE; Schema: bck; Owner: gisa_fvg
--

CREATE TABLE bck.indirizzi_2024_09_30 (
    id bigint,
    toponimo character varying,
    indirizzo character varying,
    cap text,
    stato_prov character varying,
    nazione text,
    istat_comune character varying,
    comune character varying,
    localita text,
    civico character varying,
    latitudine character varying,
    longitudine character varying,
    verificato boolean,
    fonte text
);


ALTER TABLE bck.indirizzi_2024_09_30 OWNER TO gisa_fvg;

--
-- Name: linee_2024_07_04; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.linee_2024_07_04 (
    id bigint,
    id_stabilimento bigint,
    id_tipo_linea integer,
    validita tsrange,
    attivita_fissa boolean,
    linea_principale boolean,
    verificato boolean,
    fonte text,
    data_ultima_visita timestamp without time zone,
    id_esterno character varying
);


ALTER TABLE bck.linee_2024_07_04 OWNER TO postgres;

--
-- Name: linee_2024_07_08; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.linee_2024_07_08 (
    id bigint,
    id_stabilimento bigint,
    id_tipo_linea integer,
    validita tsrange,
    attivita_fissa boolean,
    linea_principale boolean,
    verificato boolean,
    fonte text,
    data_ultima_visita timestamp without time zone,
    id_esterno character varying
);


ALTER TABLE bck.linee_2024_07_08 OWNER TO postgres;

--
-- Name: linee_2024_07_26; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.linee_2024_07_26 (
    id bigint,
    id_stabilimento bigint,
    id_tipo_linea integer,
    validita tsrange,
    attivita_fissa boolean,
    linea_principale boolean,
    verificato boolean,
    fonte text,
    data_ultima_visita timestamp without time zone,
    id_esterno character varying
);


ALTER TABLE bck.linee_2024_07_26 OWNER TO postgres;

--
-- Name: linee_2024_08_05; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.linee_2024_08_05 (
    id bigint,
    id_stabilimento bigint,
    id_tipo_linea integer,
    validita tsrange,
    attivita_fissa boolean,
    linea_principale boolean,
    verificato boolean,
    fonte text,
    data_ultima_visita timestamp without time zone,
    id_esterno character varying
);


ALTER TABLE bck.linee_2024_08_05 OWNER TO postgres;

--
-- Name: nominativi_2024_09_30; Type: TABLE; Schema: bck; Owner: gisa_fvg
--

CREATE TABLE bck.nominativi_2024_09_30 (
    id integer,
    id_nominativo_gisa bigint,
    id_anagrafica bigint,
    nominativo text,
    codice_fiscale text,
    qualifica text
);


ALTER TABLE bck.nominativi_2024_09_30 OWNER TO gisa_fvg;

--
-- Name: nominativi_struttura_2024_09_30; Type: TABLE; Schema: bck; Owner: gisa_fvg
--

CREATE TABLE bck.nominativi_struttura_2024_09_30 (
    id integer,
    id_nominativo bigint,
    id_struttura bigint
);


ALTER TABLE bck.nominativi_struttura_2024_09_30 OWNER TO gisa_fvg;

--
-- Name: nominativo_linee_2024_04_30_2; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.nominativo_linee_2024_04_30_2 (
    id bigint,
    id_nominativo_struttura bigint,
    id_linea bigint
);


ALTER TABLE bck.nominativo_linee_2024_04_30_2 OWNER TO postgres;

--
-- Name: nominativo_linee_2024_05_06; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.nominativo_linee_2024_05_06 (
    id bigint,
    id_nominativo_struttura bigint,
    id_linea bigint
);


ALTER TABLE bck.nominativo_linee_2024_05_06 OWNER TO postgres;

--
-- Name: nominativo_linee_2024_05_15; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.nominativo_linee_2024_05_15 (
    id bigint,
    id_nominativo_struttura bigint,
    id_linea bigint
);


ALTER TABLE bck.nominativo_linee_2024_05_15 OWNER TO postgres;

--
-- Name: nominativo_linee_2024_05_17; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.nominativo_linee_2024_05_17 (
    id bigint,
    id_nominativo_struttura bigint,
    id_linea bigint
);


ALTER TABLE bck.nominativo_linee_2024_05_17 OWNER TO postgres;

--
-- Name: piano_tipo_linea_20231012; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.piano_tipo_linea_20231012 (
    id_piano integer,
    id_tipo_linea integer,
    id bigint
);


ALTER TABLE bck.piano_tipo_linea_20231012 OWNER TO postgres;

--
-- Name: piano_tipo_linea_20231023; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.piano_tipo_linea_20231023 (
    id_piano integer,
    id_tipo_linea integer,
    id bigint
);


ALTER TABLE bck.piano_tipo_linea_20231023 OWNER TO postgres;

--
-- Name: provincie_2024_01_11; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.provincie_2024_01_11 (
    idprovinciaistat integer,
    siglaprovincia character varying(50)
);


ALTER TABLE bck.provincie_2024_01_11 OWNER TO postgres;

--
-- Name: role_info; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.role_info (
    role_id integer,
    role_descr character varying,
    responsabile boolean,
    livello integer,
    qualifica character varying
);


ALTER TABLE bck.role_info OWNER TO postgres;

--
-- Name: stabilimenti_2024_07_04; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.stabilimenti_2024_07_04 (
    id bigint,
    id_impresa bigint,
    nome character varying,
    sd_id numeric(12,0),
    id_indirizzo bigint,
    cod_regionale character varying,
    verificato boolean,
    fonte character varying,
    categoria_rischio numeric,
    validita tsrange,
    cod_nazionale character varying,
    id_tipologia_struttura bigint,
    pec character varying,
    telefono character varying,
    sdi character varying
);


ALTER TABLE bck.stabilimenti_2024_07_04 OWNER TO postgres;

--
-- Name: stabilimenti_2024_07_05; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.stabilimenti_2024_07_05 (
    id bigint,
    id_impresa bigint,
    nome character varying,
    sd_id numeric(12,0),
    id_indirizzo bigint,
    cod_regionale character varying,
    verificato boolean,
    fonte character varying,
    categoria_rischio numeric,
    validita tsrange,
    cod_nazionale character varying,
    id_tipologia_struttura bigint,
    pec character varying,
    telefono character varying,
    sdi character varying
);


ALTER TABLE bck.stabilimenti_2024_07_05 OWNER TO postgres;

--
-- Name: stabilimenti_2024_07_08; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.stabilimenti_2024_07_08 (
    id bigint,
    id_impresa bigint,
    nome character varying,
    sd_id numeric(12,0),
    id_indirizzo bigint,
    cod_regionale character varying,
    verificato boolean,
    fonte character varying,
    categoria_rischio numeric,
    validita tsrange,
    cod_nazionale character varying,
    id_tipologia_struttura bigint,
    pec character varying,
    telefono character varying,
    sdi character varying
);


ALTER TABLE bck.stabilimenti_2024_07_08 OWNER TO postgres;

--
-- Name: stabilimenti_2024_07_26; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.stabilimenti_2024_07_26 (
    id bigint,
    id_impresa bigint,
    nome character varying,
    sd_id numeric(12,0),
    id_indirizzo bigint,
    cod_regionale character varying,
    verificato boolean,
    fonte character varying,
    categoria_rischio numeric,
    validita tsrange,
    cod_nazionale character varying,
    id_tipologia_struttura bigint,
    pec character varying,
    telefono character varying,
    sdi character varying
);


ALTER TABLE bck.stabilimenti_2024_07_26 OWNER TO postgres;

--
-- Name: stabilimenti_2024_08_05; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.stabilimenti_2024_08_05 (
    id bigint,
    id_impresa bigint,
    nome character varying,
    sd_id numeric(12,0),
    id_indirizzo bigint,
    cod_regionale character varying,
    verificato boolean,
    fonte character varying,
    categoria_rischio numeric,
    validita tsrange,
    cod_nazionale character varying,
    id_tipologia_struttura bigint,
    pec character varying,
    telefono character varying,
    sdi character varying
);


ALTER TABLE bck.stabilimenti_2024_08_05 OWNER TO postgres;

--
-- Name: stabilimenti_2024_09_30; Type: TABLE; Schema: bck; Owner: gisa_fvg
--

CREATE TABLE bck.stabilimenti_2024_09_30 (
    id bigint,
    id_impresa bigint,
    nome character varying,
    sd_id numeric(12,0),
    id_indirizzo bigint,
    cod_regionale character varying,
    verificato boolean,
    fonte character varying,
    categoria_rischio numeric,
    validita tsrange,
    cod_nazionale character varying,
    id_tipologia_struttura bigint,
    pec character varying,
    telefono character varying,
    sdi character varying
);


ALTER TABLE bck.stabilimenti_2024_09_30 OWNER TO gisa_fvg;

--
-- Name: stabilimenti_storico_2024_05_07; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.stabilimenti_storico_2024_05_07 (
    id integer,
    id_stabilimento bigint,
    id_impresa bigint,
    validita tsrange,
    note text
);


ALTER TABLE bck.stabilimenti_storico_2024_05_07 OWNER TO postgres;

--
-- Name: stabilimento_sedi_2024_09_30; Type: TABLE; Schema: bck; Owner: gisa_fvg
--

CREATE TABLE bck.stabilimento_sedi_2024_09_30 (
    id bigint,
    id_stabilimento bigint,
    id_tipo_sede bigint,
    id_indirizzo bigint,
    pec character varying,
    email character varying,
    old_id bigint,
    fonte text,
    validita tsrange
);


ALTER TABLE bck.stabilimento_sedi_2024_09_30 OWNER TO gisa_fvg;

--
-- Name: struttura_piano_target_2024_03_27; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.struttura_piano_target_2024_03_27 (
    id integer,
    id_struttura integer,
    id_piano integer,
    target double precision
);


ALTER TABLE bck.struttura_piano_target_2024_03_27 OWNER TO postgres;

--
-- Name: struttura_piano_target_2024_09_02; Type: TABLE; Schema: bck; Owner: gisa_fvg
--

CREATE TABLE bck.struttura_piano_target_2024_09_02 (
    id integer,
    id_struttura integer,
    id_piano integer,
    target double precision
);


ALTER TABLE bck.struttura_piano_target_2024_09_02 OWNER TO gisa_fvg;

--
-- Name: tariffa_strutture_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.tariffa_strutture_20230907 (
    id bigint,
    id_tariffa bigint,
    id_asl bigint,
    validita tsrange
);


ALTER TABLE bck.tariffa_strutture_20230907 OWNER TO postgres;

--
-- Name: tariffa_voci_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.tariffa_voci_20230907 (
    id bigint,
    id_tariffa_struttura bigint,
    scaglione numrange,
    ordine integer
);


ALTER TABLE bck.tariffa_voci_20230907 OWNER TO postgres;

--
-- Name: tariffa_voci_calcolo_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.tariffa_voci_calcolo_20230907 (
    id_tariffa_voce bigint,
    valore numeric,
    tipo integer
);


ALTER TABLE bck.tariffa_voci_calcolo_20230907 OWNER TO postgres;

--
-- Name: tariffari_2024_01_11; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.tariffari_2024_01_11 (
    id bigint,
    asl character varying,
    validita tsrange,
    codice character varying,
    descr character varying
);


ALTER TABLE bck.tariffari_2024_01_11 OWNER TO postgres;

--
-- Name: tariffe_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.tariffe_20230907 (
    id bigint,
    id_tariffario bigint,
    sigla character varying,
    descr character varying,
    cod_iva character varying,
    nota character varying,
    visibile_trf boolean,
    visibile_fatt boolean,
    id_u_mis bigint,
    visibile_piani boolean,
    visibile_contabilita boolean,
    pdc character varying,
    ordine_tariffa integer,
    validita tsrange,
    livello_asl boolean,
    cod_conto_iva character varying
);


ALTER TABLE bck.tariffe_20230907 OWNER TO postgres;

--
-- Name: tariffe_2024_01_11; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.tariffe_2024_01_11 (
    id bigint,
    id_tariffario bigint,
    sigla character varying,
    descr character varying,
    cod_iva character varying,
    nota character varying,
    visibile_trf boolean,
    visibile_fatt boolean,
    id_u_mis bigint,
    visibile_piani boolean,
    visibile_contabilita boolean,
    pdc character varying,
    ordine_tariffa integer,
    validita tsrange,
    livello_asl boolean,
    cod_conto_iva character varying,
    limiti numrange
);


ALTER TABLE bck.tariffe_2024_01_11 OWNER TO postgres;

--
-- Name: tariffe_u_mis_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.tariffe_u_mis_20230907 (
    id bigint,
    descr character varying
);


ALTER TABLE bck.tariffe_u_mis_20230907 OWNER TO postgres;

--
-- Name: tariffe_u_mis_2024_01_11; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.tariffe_u_mis_2024_01_11 (
    id bigint,
    descr character varying,
    num numeric,
    den numeric
);


ALTER TABLE bck.tariffe_u_mis_2024_01_11 OWNER TO postgres;

--
-- Name: tree_nodes_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.tree_nodes_20230907 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE bck.tree_nodes_20230907 OWNER TO postgres;

--
-- Name: tree_nodes_20230908; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.tree_nodes_20230908 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE bck.tree_nodes_20230908 OWNER TO postgres;

--
-- Name: tree_nodes_20230921; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.tree_nodes_20230921 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE bck.tree_nodes_20230921 OWNER TO postgres;

--
-- Name: tree_nodes_20231114; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.tree_nodes_20231114 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE bck.tree_nodes_20231114 OWNER TO postgres;

--
-- Name: tree_nodes_20231207; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.tree_nodes_20231207 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE bck.tree_nodes_20231207 OWNER TO postgres;

--
-- Name: trf_att_inviate_2024_05_22; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_att_inviate_2024_05_22 (
    id bigint,
    id_trf_attivita bigint,
    tm_invio timestamp without time zone,
    str_j json
);


ALTER TABLE bck.trf_att_inviate_2024_05_22 OWNER TO postgres;

--
-- Name: trf_att_inviate_stati_2024_05_22; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_att_inviate_stati_2024_05_22 (
    id bigint,
    id_att_inviata bigint,
    ret character varying,
    id_trf_att_inviate_tipo_stati bigint,
    ts timestamp without time zone
);


ALTER TABLE bck.trf_att_inviate_stati_2024_05_22 OWNER TO postgres;

--
-- Name: trf_attivita_2024_05_30; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_attivita_2024_05_30 (
    id bigint,
    id_cliente bigint,
    id_servizio bigint,
    data_da timestamp without time zone,
    data_a timestamp without time zone,
    id_trf_operatore bigint,
    note character varying,
    imponibile character varying,
    id_tariffa bigint,
    per_conto_di bigint,
    id_ref_attivita bigint,
    id_type_attivita character varying,
    closed boolean,
    data_closed timestamp without time zone,
    id_fattura bigint,
    conto_addebito character varying,
    per_conto_di_struttura bigint
);


ALTER TABLE bck.trf_attivita_2024_05_30 OWNER TO postgres;

--
-- Name: trf_attivita_2024_07_16; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_attivita_2024_07_16 (
    id bigint,
    id_cliente bigint,
    id_servizio bigint,
    data_da timestamp without time zone,
    data_a timestamp without time zone,
    id_trf_operatore bigint,
    note character varying,
    imponibile character varying,
    id_tariffa bigint,
    per_conto_di bigint,
    id_ref_attivita bigint,
    id_type_attivita character varying,
    closed boolean,
    data_closed timestamp without time zone,
    id_fattura bigint,
    conto_addebito character varying,
    per_conto_di_struttura bigint
);


ALTER TABLE bck.trf_attivita_2024_07_16 OWNER TO postgres;

--
-- Name: trf_attivita_dettagli_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_attivita_dettagli_20230907 (
    id bigint,
    id_trf_attivita bigint,
    id_tariffa bigint,
    valore character varying,
    costo numeric
);


ALTER TABLE bck.trf_attivita_dettagli_20230907 OWNER TO postgres;

--
-- Name: trf_attivita_dettagli_2024_05_22; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_attivita_dettagli_2024_05_22 (
    id bigint,
    id_trf_attivita bigint,
    id_tariffa bigint,
    valore character varying,
    costo numeric
);


ALTER TABLE bck.trf_attivita_dettagli_2024_05_22 OWNER TO postgres;

--
-- Name: trf_attivita_dettagli_forfet_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_attivita_dettagli_forfet_20230907 (
    id bigint,
    id_trf_attivita bigint,
    id_tariffa bigint,
    valore character varying,
    costo numeric
);


ALTER TABLE bck.trf_attivita_dettagli_forfet_20230907 OWNER TO postgres;

--
-- Name: trf_attivita_forfet_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_attivita_forfet_20230907 (
    id bigint,
    id_cliente bigint,
    id_servizio bigint,
    data_da timestamp without time zone,
    data_a timestamp without time zone,
    id_trf_operatore bigint,
    note character varying,
    imponibile character varying,
    id_tariffa bigint,
    per_conto_di bigint,
    id_ref_attivita bigint,
    id_type_attivita character varying,
    closed boolean,
    data_closed timestamp without time zone,
    id_fattura bigint,
    id_stato bigint
);


ALTER TABLE bck.trf_attivita_forfet_20230907 OWNER TO postgres;

--
-- Name: trf_fattura_dettagli_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_fattura_dettagli_20230907 (
    id bigint,
    id_trf_fattura bigint,
    id_tariffa bigint,
    valore numeric,
    costo numeric,
    ordine integer,
    stringa_xml character varying
);


ALTER TABLE bck.trf_fattura_dettagli_20230907 OWNER TO postgres;

--
-- Name: trf_fattura_dettagli_2024_01_11; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_fattura_dettagli_2024_01_11 (
    id bigint,
    id_trf_fattura bigint,
    id_tariffa bigint,
    valore numeric,
    costo numeric,
    ordine integer,
    stringa_xml character varying
);


ALTER TABLE bck.trf_fattura_dettagli_2024_01_11 OWNER TO postgres;

--
-- Name: trf_fattura_stati_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_fattura_stati_20230907 (
    id bigint,
    id_trf_fattura bigint,
    ret character varying,
    id_trf_stato bigint,
    ts timestamp without time zone
);


ALTER TABLE bck.trf_fattura_stati_20230907 OWNER TO postgres;

--
-- Name: trf_fatture_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_fatture_20230907 (
    id bigint,
    id_cliente bigint,
    data_creazione timestamp without time zone,
    id_tariffa bigint,
    id_asl bigint,
    numero_fattura bigint
);


ALTER TABLE bck.trf_fatture_20230907 OWNER TO postgres;

--
-- Name: trf_fatture_2024_01_11; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_fatture_2024_01_11 (
    id bigint,
    id_cliente bigint,
    data_creazione timestamp without time zone,
    id_tariffa bigint,
    id_asl bigint,
    numero_fattura bigint,
    open_amt double precision,
    dt date
);


ALTER TABLE bck.trf_fatture_2024_01_11 OWNER TO postgres;

--
-- Name: trf_regole_fatt_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_regole_fatt_20230907 (
    id bigint,
    op character varying,
    val numeric,
    id_tariffa bigint,
    ord_exec integer
);


ALTER TABLE bck.trf_regole_fatt_20230907 OWNER TO postgres;

--
-- Name: trf_regole_fatt_dett_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_regole_fatt_dett_20230907 (
    id bigint,
    id_regola_fatt bigint,
    id_tariffa bigint
);


ALTER TABLE bck.trf_regole_fatt_dett_20230907 OWNER TO postgres;

--
-- Name: trf_trf_fattura_dettagli_20230907; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_trf_fattura_dettagli_20230907 (
    id bigint,
    id_trf_fattura bigint,
    id_tariffa bigint,
    valore numeric,
    costo numeric,
    ordine integer,
    stringa_xml character varying
);


ALTER TABLE bck.trf_trf_fattura_dettagli_20230907 OWNER TO postgres;

--
-- Name: trf_ui_2024_05_20; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_ui_2024_05_20 (
    id_tariffa bigint,
    ui_info character varying,
    ui_info_fatt character varying
);


ALTER TABLE bck.trf_ui_2024_05_20 OWNER TO postgres;

--
-- Name: trf_ui_righe_fatt_2024_01_11; Type: TABLE; Schema: bck; Owner: postgres
--

CREATE TABLE bck.trf_ui_righe_fatt_2024_01_11 (
    id_tariffa bigint,
    descr_in_fatt character varying
);


ALTER TABLE bck.trf_ui_righe_fatt_2024_01_11 OWNER TO postgres;

--
-- Name: anpr_archivio_comuni_31_01; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.anpr_archivio_comuni_31_01 (
    id integer,
    dataistituzione character varying(50),
    datacessazione character varying(50),
    codistat integer,
    codcatastale character varying(50),
    denominazione_it character varying(50),
    denomtraslitterata character varying(50),
    altradenominazione character varying(50),
    altradenomtraslitterata character varying(50),
    id_provincia integer,
    idprovinciaistat integer,
    idregione character varying(50),
    idprefettura character varying(50),
    stato character varying(50),
    siglaprovincia character varying(50),
    fonte character varying(50),
    dataultimoagg character varying(50),
    cod_denom integer
);


ALTER TABLE conf_ext.anpr_archivio_comuni_31_01 OWNER TO postgres;

--
-- Name: as_fo_piscine; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.as_fo_piscine (
    distretto character varying,
    comune character varying,
    denominazione character varying,
    indirizzo character varying,
    destinazione character varying,
    impianto_coperto integer,
    impianto_scoperto integer,
    n_vasche_coperte integer,
    n_vasche_scoperte integer
);


ALTER TABLE conf_ext.as_fo_piscine OWNER TO postgres;

--
-- Name: as_fo_programmazione_853; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.as_fo_programmazione_853 (
    id integer,
    id_ua integer,
    azienda character varying,
    comune character varying,
    codice_struttura character varying,
    nome character varying,
    controllore character varying,
    indirizzo_azienda character varying,
    tipologia_struttura character varying
);


ALTER TABLE conf_ext.as_fo_programmazione_853 OWNER TO postgres;

--
-- Name: asu_fc_programmazione_853; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.asu_fc_programmazione_853 (
    id integer,
    id_ua integer,
    comune character varying,
    codice_struttura character varying,
    nome character varying,
    controllore character varying,
    anno_assegnazione_stabilimento character varying,
    indirizz_azienda character varying,
    attivita_prevalente character varying
);


ALTER TABLE conf_ext.asu_fc_programmazione_853 OWNER TO postgres;

--
-- Name: asufcpoolsian2022; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.asufcpoolsian2022 (
    idua integer,
    codiceregionale character varying,
    comune character varying,
    azienda character varying,
    distretto character varying,
    nome character varying,
    indirizzoazienda character varying,
    attivitaprevalente character varying
);


ALTER TABLE conf_ext.asufcpoolsian2022 OWNER TO postgres;

--
-- Name: bonifica_imprese; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.bonifica_imprese (
    id bigint,
    piva character varying,
    cf character varying,
    nome character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    tipo_impresa character varying,
    inizio_validita date,
    fine_validita date,
    figura_codice_fiscale character varying,
    figura_tipo character varying,
    figura_inizio_validita character varying,
    figura_fine_validita character varying,
    sede_toponimo character varying,
    sede_civico character varying,
    sede_indirizzo character varying,
    sede_cap character varying,
    sede_nazione character varying,
    sede_istat_comune character varying,
    sede_comune character varying,
    sede_pec character varying,
    fonte character varying
);


ALTER TABLE conf_ext.bonifica_imprese OWNER TO postgres;

--
-- Name: bonifica_soggetti_fisici; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.bonifica_soggetti_fisici (
    id integer NOT NULL,
    codice_fiscale character varying,
    cognome character varying,
    nome character varying,
    comune_nascita character varying,
    data_nascita date,
    sesso character varying,
    telefono character varying,
    email character varying,
    pec character varying,
    telefono2 character varying,
    documento_identita character varying,
    toponimo character varying,
    civico character varying,
    indirizzo character varying,
    cap text,
    stato_prov character varying,
    nazione text,
    istat_comune character varying,
    comune character varying,
    localita text,
    fonte character varying,
    codice_at character varying
);


ALTER TABLE conf_ext.bonifica_soggetti_fisici OWNER TO postgres;

--
-- Name: bonifica_soggetti_fisici_id_seq; Type: SEQUENCE; Schema: conf_ext; Owner: postgres
--

CREATE SEQUENCE conf_ext.bonifica_soggetti_fisici_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE conf_ext.bonifica_soggetti_fisici_id_seq OWNER TO postgres;

--
-- Name: bonifica_soggetti_fisici_id_seq; Type: SEQUENCE OWNED BY; Schema: conf_ext; Owner: postgres
--

ALTER SEQUENCE conf_ext.bonifica_soggetti_fisici_id_seq OWNED BY conf_ext.bonifica_soggetti_fisici.id;


--
-- Name: cap; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.cap (
    codice_istat integer,
    cap integer
);


ALTER TABLE conf_ext.cap OWNER TO postgres;

--
-- Name: cf_da_bonificare; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.cf_da_bonificare (
    codice_fiscale character varying
);


ALTER TABLE conf_ext.cf_da_bonificare OWNER TO postgres;

--
-- Name: codiciateco; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.codiciateco (
    codice character varying,
    titolo character varying
);


ALTER TABLE conf_ext.codiciateco OWNER TO postgres;

--
-- Name: com_vie_fvg; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.com_vie_fvg (
    istat integer,
    cod_ministero character varying,
    cod_catasto character varying,
    cap integer,
    inizio_validita character varying,
    data_variazione character varying,
    descrizione_comune character varying,
    descrizione_comune_1 character varying,
    inizio_validita_1 character varying,
    toponimo character varying,
    toponimo_snd character varying,
    descrizione_indirizzo character varying,
    descrizione_snd_2 character varying,
    cod_istat character varying
);


ALTER TABLE conf_ext.com_vie_fvg OWNER TO postgres;

--
-- Name: comuni1; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.comuni1 (
    id integer,
    cod_comune integer,
    cod_regione integer,
    cod_provincia integer,
    nome character varying,
    istat integer,
    codiceistatasl integer,
    codice character varying,
    codice_old character varying,
    codiceistatasl_old bit varying,
    cap integer,
    notused character varying,
    cod_nazione integer,
    codiceasl_bdn integer,
    codice_nuovo character varying,
    codice_nuovo_ character varying,
    istat_comune_provincia integer,
    cap_ integer,
    istat_pre integer,
    note_hd character varying,
    reverse_cap integer,
    codice_catastale character varying
);


ALTER TABLE conf_ext.comuni1 OWNER TO postgres;

--
-- Name: comuni_friuli; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.comuni_friuli (
    prog character varying,
    cf character varying,
    nome character varying,
    indirizzo character varying,
    localita character varying
);


ALTER TABLE conf_ext.comuni_friuli OWNER TO postgres;

--
-- Name: comuni_stab; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.comuni_stab (
    ufficio character varying,
    sdi character varying,
    cf character varying,
    nome character varying,
    note character varying
);


ALTER TABLE conf_ext.comuni_stab OWNER TO postgres;

--
-- Name: dpar_gisa_fvg; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.dpar_gisa_fvg (
    alias_sotto_piano character varying(50),
    as_fo_amm character varying(50),
    as_fo_isp character varying(50),
    as_fo_isp_at character varying(50),
    as_fo_sian character varying(50),
    as_fo_sian_at character varying(50),
    as_fo_svet_at character varying(50),
    as_fo_vet_a character varying(50),
    as_fo_vet_b character varying(50),
    as_fo_vet_c character varying(50),
    asu_fc_isp character varying(50),
    asu_fc_svet character varying(50),
    asu_fc_tdp_sian character varying(50),
    asu_fc_vet_a character varying(50),
    asu_fc_vet_b character varying(50),
    asu_fc_vet_c character varying(50),
    asu_gi_isp character varying(50),
    asu_gi_sian character varying(50),
    asu_gi_vet_ac character varying(50),
    asu_gi_vet_b character varying(50)
);


ALTER TABLE conf_ext.dpar_gisa_fvg OWNER TO postgres;

--
-- Name: dpar_piani_tipo_linee; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.dpar_piani_tipo_linee (
    id integer,
    alias_sotto_piano character varying,
    descrizione_sotto_piano character varying,
    tipo_linea character varying,
    tipo_linea_mod character varying
);


ALTER TABLE conf_ext.dpar_piani_tipo_linee OWNER TO postgres;

--
-- Name: dpar_piani_tipolinea_frequenze; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.dpar_piani_tipolinea_frequenze (
    alias_indicatore character varying,
    tipo_linea character varying,
    anno_alto integer,
    volte_alto integer,
    anno_medio integer,
    volte_medio integer,
    anno_basso integer,
    volte_basso integer
);


ALTER TABLE conf_ext.dpar_piani_tipolinea_frequenze OWNER TO postgres;

--
-- Name: fvg_gisa_imprese; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.fvg_gisa_imprese (
    id numeric(12,0),
    az_id numeric(12,0),
    az_data_inizio date,
    az_data_fine date,
    az_cod_aziendale character varying,
    az_bdn_id character varying,
    az_latitudine character varying,
    az_longitudine character varying,
    az_tipo_impresa character varying,
    az_id_anagrafica numeric(12,0),
    az_denominazione character varying,
    az_an_dato_fiscale character varying,
    az_an_cf character varying,
    az_an_iva character varying,
    az_an_pec character varying,
    az_an_email character varying,
    az_an_sdi character varying,
    az_an_split_payment numeric(1,0),
    az_an_data_nascita date,
    az_an_tipo character varying,
    az_an_tipo_descr character varying,
    az_an_tipo_persona character varying,
    az_an_tipo_pers_descr character varying,
    az_an_data_fine date,
    az_an_data_decesso date,
    az_an_provincia character varying,
    az_an_istat character varying,
    az_an_cap character varying,
    az_an_comune character varying,
    az_an_toponimo character varying,
    az_an_indirizzo character varying,
    az_an_civico character varying,
    az_di_cod_asl character varying,
    az_di_descr_asl character varying,
    sede_operativa character varying,
    sd_id numeric(12,0),
    sd_bdn_id character varying,
    sd_bdn_specie character varying,
    sd_specie_descr character varying,
    sd_cod_tipologia_struttura character varying,
    sd_tipologia_struttura character varying,
    sd_cod_regionale character varying,
    sd_cod_struttura character varying,
    sd_data_inizio date,
    sd_data_fine date,
    sd_vet_id numeric(12,0),
    sd_vet_cf character varying,
    sd_vet_cognome character varying,
    sd_vet_nome character varying,
    sd_an_id numeric(12,0),
    sd_an_nome character varying,
    sd_an_dato_fiscale character varying,
    sd_an_cf character varying,
    sd_an_iva character varying,
    sd_an_pec character varying,
    sd_an_email character varying,
    sd_an_sdi character varying,
    sd_an_split_payment numeric(1,0),
    sd_an_data_nascita date,
    sd_an_tipo character varying,
    sd_an_tipo_descr character varying,
    sd_an_tipo_persona character varying,
    sd_an_tipo_pers_descr character varying,
    sd_an_data_fine date,
    sd_an_data_decesso date,
    sd_an_res_provincia character varying,
    sd_an_res_istat character varying,
    sd_an_res_cap character varying,
    sd_an_res_comune character varying,
    sd_an_res_toponimo character varying,
    sd_an_res_indirizzo character varying,
    sd_an_res_civico character varying,
    sd_an_dom_provincia character varying,
    sd_an_dom_istat character varying,
    sd_an_dom_cap character varying,
    sd_an_dom_comune character varying,
    sd_an_dom_toponimo character varying,
    sd_an_dom_indirizzo character varying,
    sd_an_dom_civico character varying,
    figura_aziendale character varying,
    fg_id numeric(12,0),
    fg_data_inizio date,
    fg_data_fine date,
    fg_cod_tipo_figura character varying,
    fg_tipo_figura_descr character varying,
    fg_id_anagrafica numeric(12,0),
    fg_an_nome character varying,
    fg_an_dato_fiscale character varying,
    fg_an_cf character varying,
    fg_an_iva character varying,
    fg_an_pec character varying,
    fg_an_email character varying,
    fg_an_sdi character varying,
    fg_an_split_payment numeric(1,0),
    fg_an_data_nascita date,
    fg_an_tipo character varying,
    fg_an_tipo_descr character varying,
    fg_an_tipo_persona character varying,
    fg_an_tipo_pers_descr character varying,
    fg_an_data_fine date,
    fg_an_res_provincia character varying,
    fg_an_res_istat character varying,
    fg_an_res_cap character varying,
    fg_an_res_comune character varying,
    fg_an_res_toponimo character varying,
    fg_an_res_indirizzo character varying,
    fg_an_res_civico character varying,
    fg_an_dom_provincia character varying,
    fg_an_dom_istat character varying,
    fg_an_dom_cap character varying,
    fg_an_dom_comune character varying,
    fg_an_dom_toponimo character varying,
    fg_an_dom_indirizzo character varying,
    fg_an_dom_civico character varying,
    controlli character varying,
    azienda_anagr numeric(1,0),
    sedeop numeric(1,0),
    sedeop_anag numeric(1,0),
    figura_sede numeric(1,0),
    figura_anag numeric(1,0),
    errori character varying,
    score numeric(3,0)
);


ALTER TABLE conf_ext.fvg_gisa_imprese OWNER TO postgres;

--
-- Name: fvg_gisa_imprese_cuf_motivo_ultimo; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.fvg_gisa_imprese_cuf_motivo_ultimo (
    sd_id numeric(12,0),
    cod_motivo character varying,
    descr_motivo character varying,
    data_sopralluogo date
);


ALTER TABLE conf_ext.fvg_gisa_imprese_cuf_motivo_ultimo OWNER TO postgres;

--
-- Name: fvg_gisa_imprese_cuf_motivo_ultimo_old; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.fvg_gisa_imprese_cuf_motivo_ultimo_old (
    sd_id numeric(12,0),
    cod_motivo character varying,
    descr_motivo character varying,
    data_sopralluogo date
);


ALTER TABLE conf_ext.fvg_gisa_imprese_cuf_motivo_ultimo_old OWNER TO postgres;

--
-- Name: fvg_gisa_imprese_indice; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.fvg_gisa_imprese_indice (
    sed_operativa character varying,
    indice numeric(12,0),
    rischio_gruppo numeric(12,0),
    richio_cod numeric(12,0),
    sede_operativa character varying,
    gi_az_id numeric(12,0),
    gi_az_cod_aziendale character varying,
    gi_az_denominazione character varying,
    gi_az_an_tipo character varying,
    gi_sd_id numeric(12,0),
    gi_sd_tipologia_struttura character varying,
    gi_sd_specie_descr character varying,
    gi_sd_an_nome character varying,
    gi_sd_an_tipo_descr character varying,
    gi_sd_an_tipo_pers_descr character varying,
    ind_indice_rischio character varying,
    ind_id_sede_operativa numeric(12,0),
    ind_ultimo_rilevamento date,
    ind_valore_rischio character varying,
    ind_gruppo_rischio_codice character varying,
    ind_gruppo_rischio character varying,
    ind_rischio_codice character varying,
    ind_rischio_descrizione character varying,
    peso_rischio character varying,
    valore_rischio character varying
);


ALTER TABLE conf_ext.fvg_gisa_imprese_indice OWNER TO postgres;

--
-- Name: fvg_gisa_imprese_indice_old; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.fvg_gisa_imprese_indice_old (
    sed_operativa character varying,
    indice numeric(12,0),
    rischio_gruppo numeric(12,0),
    richio_cod numeric(12,0),
    sede_operativa character varying,
    gi_az_id numeric(12,0),
    gi_az_cod_aziendale character varying,
    gi_az_denominazione character varying,
    gi_az_an_tipo character varying,
    gi_sd_id numeric(12,0),
    gi_sd_tipologia_struttura character varying,
    gi_sd_specie_descr character varying,
    gi_sd_an_nome character varying,
    gi_sd_an_tipo_descr character varying,
    gi_sd_an_tipo_pers_descr character varying,
    ind_indice_rischio character varying,
    ind_id_sede_operativa numeric(12,0),
    ind_ultimo_rilevamento date,
    ind_valore_rischio character varying,
    ind_gruppo_rischio_codice character varying,
    ind_gruppo_rischio character varying,
    ind_rischio_codice character varying,
    ind_rischio_descrizione character varying,
    peso_rischio character varying,
    valore_rischio character varying
);


ALTER TABLE conf_ext.fvg_gisa_imprese_indice_old OWNER TO postgres;

--
-- Name: fvg_gisa_imprese_old; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.fvg_gisa_imprese_old (
    id numeric(12,0),
    az_id numeric(12,0),
    az_data_inizio date,
    az_data_fine date,
    az_cod_aziendale character varying,
    az_bdn_id character varying,
    az_latitudine character varying,
    az_longitudine character varying,
    az_tipo_impresa character varying,
    az_id_anagrafica numeric(12,0),
    az_denominazione character varying,
    az_an_dato_fiscale character varying,
    az_an_cf character varying,
    az_an_iva character varying,
    az_an_pec character varying,
    az_an_email character varying,
    az_an_sdi character varying,
    az_an_split_payment numeric(1,0),
    az_an_data_nascita date,
    az_an_tipo character varying,
    az_an_tipo_descr character varying,
    az_an_tipo_persona character varying,
    az_an_tipo_pers_descr character varying,
    az_an_data_fine date,
    az_an_data_decesso date,
    az_an_provincia character varying,
    az_an_istat character varying,
    az_an_cap character varying,
    az_an_comune character varying,
    az_an_toponimo character varying,
    az_an_indirizzo character varying,
    az_an_civico character varying,
    az_di_cod_asl character varying,
    az_di_descr_asl character varying,
    sede_operativa character varying,
    sd_id numeric(12,0),
    sd_bdn_id character varying,
    sd_bdn_specie character varying,
    sd_specie_descr character varying,
    sd_cod_tipologia_struttura character varying,
    sd_tipologia_struttura character varying,
    sd_cod_regionale character varying,
    sd_cod_struttura character varying,
    sd_data_inizio date,
    sd_data_fine date,
    sd_vet_id numeric(12,0),
    sd_vet_cf character varying,
    sd_vet_cognome character varying,
    sd_vet_nome character varying,
    sd_an_id numeric(12,0),
    sd_an_nome character varying,
    sd_an_dato_fiscale character varying,
    sd_an_cf character varying,
    sd_an_iva character varying,
    sd_an_pec character varying,
    sd_an_email character varying,
    sd_an_sdi character varying,
    sd_an_split_payment numeric(1,0),
    sd_an_data_nascita date,
    sd_an_tipo character varying,
    sd_an_tipo_descr character varying,
    sd_an_tipo_persona character varying,
    sd_an_tipo_pers_descr character varying,
    sd_an_data_fine date,
    sd_an_data_decesso date,
    sd_an_res_provincia character varying,
    sd_an_res_istat character varying,
    sd_an_res_cap character varying,
    sd_an_res_comune character varying,
    sd_an_res_toponimo character varying,
    sd_an_res_indirizzo character varying,
    sd_an_res_civico character varying,
    sd_an_dom_provincia character varying,
    sd_an_dom_istat character varying,
    sd_an_dom_cap character varying,
    sd_an_dom_comune character varying,
    sd_an_dom_toponimo character varying,
    sd_an_dom_indirizzo character varying,
    sd_an_dom_civico character varying,
    figura_aziendale character varying,
    fg_id numeric(12,0),
    fg_data_inizio date,
    fg_data_fine date,
    fg_cod_tipo_figura character varying,
    fg_tipo_figura_descr character varying,
    fg_id_anagrafica numeric(12,0),
    fg_an_nome character varying,
    fg_an_dato_fiscale character varying,
    fg_an_cf character varying,
    fg_an_iva character varying,
    fg_an_pec character varying,
    fg_an_email character varying,
    fg_an_sdi character varying,
    fg_an_split_payment numeric(1,0),
    fg_an_data_nascita date,
    fg_an_tipo character varying,
    fg_an_tipo_descr character varying,
    fg_an_tipo_persona character varying,
    fg_an_tipo_pers_descr character varying,
    fg_an_data_fine date,
    fg_an_res_provincia character varying,
    fg_an_res_istat character varying,
    fg_an_res_cap character varying,
    fg_an_res_comune character varying,
    fg_an_res_toponimo character varying,
    fg_an_res_indirizzo character varying,
    fg_an_res_civico character varying,
    fg_an_dom_provincia character varying,
    fg_an_dom_istat character varying,
    fg_an_dom_cap character varying,
    fg_an_dom_comune character varying,
    fg_an_dom_toponimo character varying,
    fg_an_dom_indirizzo character varying,
    fg_an_dom_civico character varying,
    controlli character varying,
    azienda_anagr numeric(1,0),
    sedeop numeric(1,0),
    sedeop_anag numeric(1,0),
    figura_sede numeric(1,0),
    figura_anag numeric(1,0),
    errori character varying,
    score numeric(3,0)
);


ALTER TABLE conf_ext.fvg_gisa_imprese_old OWNER TO postgres;

--
-- Name: fvg_gisa_imprese_produzione; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.fvg_gisa_imprese_produzione (
    gisa_imprese numeric(12,0),
    produzione numeric(12,0),
    attivita numeric(12,0),
    tipologia_struttura numeric(12,0),
    sinvsa_norma numeric(12,0),
    sinvsa_sezione numeric(12,0),
    sinvsa_attivita numeric(12,0),
    sinvsa_prodotto numeric(12,0),
    sinvsa_remark numeric(12,0),
    gi_gisa_imprese character varying,
    gi_sd_id numeric(12,0),
    pr_produzione character varying,
    pr_id numeric(12,0),
    pr_id_unita_aziendale numeric(12,0),
    pr_cod_attivita character varying,
    pr_data_inizio date,
    pr_data_fine date,
    pr_inattivo numeric(12,0),
    pr_ts_ultima_modifica date,
    pr_id_operatore numeric(12,0),
    pr_principale numeric(12,0),
    pr_note character varying,
    pr_cessata_attivita numeric(12,0),
    pr_data_presunta_fine date,
    pr_data_upload_tablet date,
    pr_data_creazione_tablet date,
    at_attivita character varying,
    at_codice character varying,
    at_descrizione character varying,
    at_cod_tipologia_struttura character varying,
    at_cod_organizzazione character varying,
    at_cod_prodotto character varying,
    at_cod_orientamento_produttivo character varying,
    at_cod_specie character varying,
    at_attivo numeric(12,0),
    at_cod_ateco character varying,
    at_cod_sinvsa character varying,
    at_cod_attivita_istat character varying,
    at_riconosciuta numeric(12,0),
    at_attivita_dipartimento character varying,
    at_orientamento_bdn character varying,
    at_flag_codice_regionale numeric(12,0),
    at_cod_tipo_sede_teseo character varying,
    at_flag_macellazione numeric(12,0),
    at_id_esterno_ch character varying,
    ts_tipologia_struttura character varying,
    ts_codice character varying,
    ts_descrizione character varying,
    ts_flag_risanamento numeric(12,0),
    ts_codice_bdn character varying,
    ts_settore_bdn character varying,
    ts_obbliga_mezzo numeric(12,0),
    ts_obbliga_autorizza numeric(12,0),
    ts_obbliga_caratteristica numeric(12,0),
    ts_data_futura numeric(12,0),
    sc_specie character varying,
    sc_codice character varying,
    sc_descrizione character varying,
    sc_cod_gruppo_specie character varying,
    sc_categoria_prodotto numeric(12,0),
    sc_interparto numeric(12,0),
    sc_gestazione numeric(12,0),
    sc_codice_bdn character varying,
    ab_attivita_bdn character varying,
    ab_id numeric(12,0),
    ab_bdn_specie character varying,
    ab_bdn_tipo_attivita character varying,
    ab_bdn_orientamento_prod character varying,
    ab_bdn_tipo_produzione character varying,
    ab_bdn_mod_allevamento character varying,
    ab_web_serv character varying,
    ab_cod_attivita character varying,
    ab_cod_caratteristica_rischio character varying,
    ab_val_caratteristica_rischio character varying,
    ab_bdn_tipologia_produttiva character varying,
    ab_bdn_flag_riproduzione character varying,
    ab_bdn_flag_ciclo_riproduzione character varying,
    ab_bdn_flag_svezzamento character varying,
    ab_id_sinvsa_norma numeric(12,0),
    ab_id_sinvsa_sezione numeric(12,0),
    ab_id_sinvsa_attivita numeric(12,0),
    ab_id_sinvsa_prodotto numeric(12,0),
    ab_id_sinvsa_remark numeric(12,0),
    ab_tipologia_sinvsa_norma character varying,
    ab_api_tipo_attivita character varying,
    ab_acq_gruppo_specie character varying,
    ab_acq_tipol_produttive character varying,
    ab_acq_tipol_allevamenti character varying,
    ab_acq_tipol_acque character varying,
    ab_bdn_flag_fase_produttiva character varying,
    ab_bdn_flag_finissaggio character varying,
    ab_bdn_flag_magronaggio character varying,
    ab_bdn_flag_cinghiale character varying,
    ab_api_classificazione character varying,
    sn_sinvsa_norma character varying,
    sn_id numeric(12,0),
    sn_codice character varying,
    sn_descrizione character varying,
    ss_sinvsa_sezione character varying,
    ss_id numeric(12,0),
    ss_codice character varying,
    ss_descrizione character varying,
    ss_id_sinvsa_norma numeric(12,0),
    sa_sinvsa_attivita character varying,
    sa_id numeric(12,0),
    sa_codice character varying,
    sa_descrizione character varying,
    sa_id_sinvsa_sezione numeric(12,0),
    sp_sinvsa_prodotto character varying,
    sp_id numeric(12,0),
    sp_codice character varying,
    sp_descrizione character varying,
    sp_id_sinvsa_attivita numeric(12,0),
    sr_sinvsa_remark character varying,
    sr_id numeric(12,0),
    sr_codice character varying,
    sr_descrizione character varying,
    sr_id_sinvsa_attivita numeric(12,0),
    sr_id_sinvsa_prodotto numeric(12,0)
);


ALTER TABLE conf_ext.fvg_gisa_imprese_produzione OWNER TO postgres;

--
-- Name: fvg_gisa_imprese_produzione_old; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.fvg_gisa_imprese_produzione_old (
    gisa_imprese numeric(12,0),
    produzione numeric(12,0),
    attivita numeric(12,0),
    tipologia_struttura numeric(12,0),
    sinvsa_norma numeric(12,0),
    sinvsa_sezione numeric(12,0),
    sinvsa_attivita numeric(12,0),
    sinvsa_prodotto numeric(12,0),
    sinvsa_remark numeric(12,0),
    gi_gisa_imprese character varying,
    gi_sd_id numeric(12,0),
    pr_produzione character varying,
    pr_id numeric(12,0),
    pr_id_unita_aziendale numeric(12,0),
    pr_cod_attivita character varying,
    pr_data_inizio date,
    pr_data_fine date,
    pr_inattivo numeric(12,0),
    pr_ts_ultima_modifica date,
    pr_id_operatore numeric(12,0),
    pr_principale numeric(12,0),
    pr_note character varying,
    pr_cessata_attivita numeric(12,0),
    pr_data_presunta_fine date,
    pr_data_upload_tablet date,
    pr_data_creazione_tablet date,
    at_attivita character varying,
    at_codice character varying,
    at_descrizione character varying,
    at_cod_tipologia_struttura character varying,
    at_cod_organizzazione character varying,
    at_cod_prodotto character varying,
    at_cod_orientamento_produttivo character varying,
    at_cod_specie character varying,
    at_attivo numeric(12,0),
    at_cod_ateco character varying,
    at_cod_sinvsa character varying,
    at_cod_attivita_istat character varying,
    at_riconosciuta numeric(12,0),
    at_attivita_dipartimento character varying,
    at_orientamento_bdn character varying,
    at_flag_codice_regionale numeric(12,0),
    at_cod_tipo_sede_teseo character varying,
    at_flag_macellazione numeric(12,0),
    at_id_esterno_ch character varying,
    ts_tipologia_struttura character varying,
    ts_codice character varying,
    ts_descrizione character varying,
    ts_flag_risanamento numeric(12,0),
    ts_codice_bdn character varying,
    ts_settore_bdn character varying,
    ts_obbliga_mezzo numeric(12,0),
    ts_obbliga_autorizza numeric(12,0),
    ts_obbliga_caratteristica numeric(12,0),
    ts_data_futura numeric(12,0),
    sc_specie character varying,
    sc_codice character varying,
    sc_descrizione character varying,
    sc_cod_gruppo_specie character varying,
    sc_categoria_prodotto numeric(12,0),
    sc_interparto numeric(12,0),
    sc_gestazione numeric(12,0),
    sc_codice_bdn character varying,
    ab_attivita_bdn character varying,
    ab_id numeric(12,0),
    ab_bdn_specie character varying,
    ab_bdn_tipo_attivita character varying,
    ab_bdn_orientamento_prod character varying,
    ab_bdn_tipo_produzione character varying,
    ab_bdn_mod_allevamento character varying,
    ab_web_serv character varying,
    ab_cod_attivita character varying,
    ab_cod_caratteristica_rischio character varying,
    ab_val_caratteristica_rischio character varying,
    ab_bdn_tipologia_produttiva character varying,
    ab_bdn_flag_riproduzione character varying,
    ab_bdn_flag_ciclo_riproduzione character varying,
    ab_bdn_flag_svezzamento character varying,
    ab_id_sinvsa_norma numeric(12,0),
    ab_id_sinvsa_sezione numeric(12,0),
    ab_id_sinvsa_attivita numeric(12,0),
    ab_id_sinvsa_prodotto numeric(12,0),
    ab_id_sinvsa_remark numeric(12,0),
    ab_tipologia_sinvsa_norma character varying,
    ab_api_tipo_attivita character varying,
    ab_acq_gruppo_specie character varying,
    ab_acq_tipol_produttive character varying,
    ab_acq_tipol_allevamenti character varying,
    ab_acq_tipol_acque character varying,
    ab_bdn_flag_fase_produttiva character varying,
    ab_bdn_flag_finissaggio character varying,
    ab_bdn_flag_magronaggio character varying,
    ab_bdn_flag_cinghiale character varying,
    ab_api_classificazione character varying,
    sn_sinvsa_norma character varying,
    sn_id numeric(12,0),
    sn_codice character varying,
    sn_descrizione character varying,
    ss_sinvsa_sezione character varying,
    ss_id numeric(12,0),
    ss_codice character varying,
    ss_descrizione character varying,
    ss_id_sinvsa_norma numeric(12,0),
    sa_sinvsa_attivita character varying,
    sa_id numeric(12,0),
    sa_codice character varying,
    sa_descrizione character varying,
    sa_id_sinvsa_sezione numeric(12,0),
    sp_sinvsa_prodotto character varying,
    sp_id numeric(12,0),
    sp_codice character varying,
    sp_descrizione character varying,
    sp_id_sinvsa_attivita numeric(12,0),
    sr_sinvsa_remark character varying,
    sr_id numeric(12,0),
    sr_codice character varying,
    sr_descrizione character varying,
    sr_id_sinvsa_attivita numeric(12,0),
    sr_id_sinvsa_prodotto numeric(12,0)
);


ALTER TABLE conf_ext.fvg_gisa_imprese_produzione_old OWNER TO postgres;

--
-- Name: fvg_gisa_privati; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.fvg_gisa_privati (
    id numeric(12,0),
    sicer_id numeric(12,0),
    nome_completo character varying,
    nome character varying,
    cognome character varying,
    sesso character varying,
    comune_nascita character varying,
    data_nascita date,
    data_decesso date,
    codice_fiscale character varying,
    tipo character varying,
    tipo_persona character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payment numeric(1,0),
    telefono character varying,
    documento character varying,
    nazione character varying,
    res_provincia character varying,
    res_istat character varying,
    res_comune character varying,
    res_toponimo character varying,
    res_indirizzo character varying,
    res_civico character varying,
    res_cap character varying,
    dom_provincia character varying,
    dom_istat character varying,
    dom_comune character varying,
    dom_toponimo character varying,
    dom_indirizzo character varying,
    dom_civico character varying,
    dom_cap character varying,
    latitudine character varying,
    longitudine character varying,
    errori character varying,
    score numeric(3,0),
    inviare numeric(1,0),
    codice_catastale_nascita character varying,
    data_nascita_fiscale character varying
);


ALTER TABLE conf_ext.fvg_gisa_privati OWNER TO postgres;

--
-- Name: fvg_gisa_privati_old; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.fvg_gisa_privati_old (
    id numeric(12,0),
    sicer_id numeric(12,0),
    nome_completo character varying,
    nome character varying,
    cognome character varying,
    sesso character varying,
    comune_nascita character varying,
    data_nascita date,
    data_decesso date,
    codice_fiscale character varying,
    tipo character varying,
    tipo_persona character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payment numeric(1,0),
    telefono character varying,
    documento character varying,
    nazione character varying,
    res_provincia character varying,
    res_istat character varying,
    res_comune character varying,
    res_toponimo character varying,
    res_indirizzo character varying,
    res_civico character varying,
    res_cap character varying,
    dom_provincia character varying,
    dom_istat character varying,
    dom_comune character varying,
    dom_toponimo character varying,
    dom_indirizzo character varying,
    dom_civico character varying,
    dom_cap character varying,
    latitudine character varying,
    longitudine character varying,
    errori character varying,
    score numeric(3,0),
    inviare numeric(1,0),
    codice_catastale_nascita character varying,
    data_nascita_fiscale character varying
);


ALTER TABLE conf_ext.fvg_gisa_privati_old OWNER TO postgres;

--
-- Name: gi_cap; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.gi_cap (
    codice_istat integer,
    cap integer
);


ALTER TABLE conf_ext.gi_cap OWNER TO postgres;

--
-- Name: gisa_imprese_fvg; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.gisa_imprese_fvg (
    id numeric(12,0),
    az_id numeric(12,0),
    az_data_inizio date,
    az_data_fine date,
    az_cod_aziendale character varying,
    az_bdn_id character varying,
    az_latitudine character varying,
    az_longitudine character varying,
    az_tipo_impresa character varying,
    az_id_anagrafica numeric(12,0),
    az_denominazione character varying,
    az_an_dato_fiscale character varying,
    az_an_cf character varying,
    az_an_iva character varying,
    az_an_pec character varying,
    az_an_email character varying,
    az_an_sdi character varying,
    az_an_split_payment numeric(1,0),
    az_an_data_nascita date,
    az_an_tipo character varying,
    az_an_tipo_descr character varying,
    az_an_tipo_persona character varying,
    az_an_tipo_pers_descr character varying,
    az_an_data_fine date,
    az_an_data_decesso date,
    az_an_provincia character varying,
    az_an_istat character varying,
    az_an_cap character varying,
    az_an_comune character varying,
    az_an_toponimo character varying,
    az_an_indirizzo character varying,
    az_an_civico character varying,
    az_di_cod_asl character varying,
    az_di_descr_asl character varying,
    sede_operativa character varying,
    sd_id numeric(12,0),
    sd_bdn_id character varying,
    sd_bdn_specie character varying,
    sd_specie_descr character varying,
    sd_cod_tipologia_struttura character varying,
    sd_tipologia_struttura character varying,
    sd_cod_regionale character varying,
    sd_cod_struttura character varying,
    sd_data_inizio date,
    sd_data_fine date,
    sd_vet_id numeric(12,0),
    sd_vet_cf character varying,
    sd_vet_cognome character varying,
    sd_vet_nome character varying,
    sd_an_id numeric(12,0),
    sd_an_nome character varying,
    sd_an_dato_fiscale character varying,
    sd_an_cf character varying,
    sd_an_iva character varying,
    sd_an_pec character varying,
    sd_an_email character varying,
    sd_an_sdi character varying,
    sd_an_split_payment numeric(1,0),
    sd_an_data_nascita date,
    sd_an_tipo character varying,
    sd_an_tipo_descr character varying,
    sd_an_tipo_persona character varying,
    sd_an_tipo_pers_descr character varying,
    sd_an_data_fine date,
    sd_an_data_decesso date,
    sd_an_res_provincia character varying,
    sd_an_res_istat character varying,
    sd_an_res_cap character varying,
    sd_an_res_comune character varying,
    sd_an_res_toponimo character varying,
    sd_an_res_indirizzo character varying,
    sd_an_res_civico character varying,
    sd_an_dom_provincia character varying,
    sd_an_dom_istat character varying,
    sd_an_dom_cap character varying,
    sd_an_dom_comune character varying,
    sd_an_dom_toponimo character varying,
    sd_an_dom_indirizzo character varying,
    sd_an_dom_civico character varying,
    figura_aziendale character varying,
    fg_id numeric(12,0),
    fg_data_inizio date,
    fg_data_fine date,
    fg_cod_tipo_figura character varying,
    fg_tipo_figura_descr character varying,
    fg_id_anagrafica numeric(12,0),
    fg_an_nome character varying,
    fg_an_dato_fiscale character varying,
    fg_an_cf character varying,
    fg_an_iva character varying,
    fg_an_pec character varying,
    fg_an_email character varying,
    fg_an_sdi character varying,
    fg_an_split_payment numeric(1,0),
    fg_an_data_nascita date,
    fg_an_tipo character varying,
    fg_an_tipo_descr character varying,
    fg_an_tipo_persona character varying,
    fg_an_tipo_pers_descr character varying,
    fg_an_data_fine date,
    fg_an_res_provincia character varying,
    fg_an_res_istat character varying,
    fg_an_res_cap character varying,
    fg_an_res_comune character varying,
    fg_an_res_toponimo character varying,
    fg_an_res_indirizzo character varying,
    fg_an_res_civico character varying,
    fg_an_dom_provincia character varying,
    fg_an_dom_istat character varying,
    fg_an_dom_cap character varying,
    fg_an_dom_comune character varying,
    fg_an_dom_toponimo character varying,
    fg_an_dom_indirizzo character varying,
    fg_an_dom_civico character varying,
    controlli character varying,
    azienda_anagr numeric(1,0),
    sedeop numeric(1,0),
    sedeop_anag numeric(1,0),
    figura_sede numeric(1,0),
    figura_anag numeric(1,0),
    errori character varying,
    score numeric(3,0),
    sl_fg_tipo_figura_descr character varying,
    sl_fg_an_nome character varying,
    sl_fg_an_cf character varying,
    sl_fg_an_iva character varying,
    sl_fg_an_pec character varying,
    sl_fg_an_email character varying,
    sl_fg_data_fine date,
    sl_fg_an_res_provincia character varying,
    sl_fg_an_res_istat character varying,
    sl_fg_an_res_comune character varying,
    sl_fg_an_res_toponimo character varying,
    sl_fg_an_res_indirizzo character varying,
    sl_fg_an_res_civico character varying,
    sl_fg_an_tipo_persona character varying,
    sl_fg_an_tipo_pers_descr character varying,
    sl_sd_cod_tipologia_struttura character varying,
    sl_sd_tipologia_struttura character varying,
    sl_az_cod_aziendale character varying,
    sl_sd_cod_regionale character varying,
    sl_fg_an_split_payment numeric(1,0),
    sl_fg_an_sdi character varying
);


ALTER TABLE conf_ext.gisa_imprese_fvg OWNER TO postgres;

--
-- Name: gisa_imprese_fvg_scarto; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.gisa_imprese_fvg_scarto (
    id numeric(12,0),
    az_id numeric(12,0),
    az_data_inizio date,
    az_data_fine date,
    az_cod_aziendale character varying,
    az_bdn_id character varying,
    az_latitudine character varying,
    az_longitudine character varying,
    az_tipo_impresa character varying,
    az_id_anagrafica numeric(12,0),
    az_denominazione character varying,
    az_an_dato_fiscale character varying,
    az_an_cf character varying,
    az_an_iva character varying,
    az_an_pec character varying,
    az_an_email character varying,
    az_an_sdi character varying,
    az_an_split_payment numeric(1,0),
    az_an_data_nascita date,
    az_an_tipo character varying,
    az_an_tipo_descr character varying,
    az_an_tipo_persona character varying,
    az_an_tipo_pers_descr character varying,
    az_an_data_fine date,
    az_an_data_decesso date,
    az_an_provincia character varying,
    az_an_istat character varying,
    az_an_cap character varying,
    az_an_comune character varying,
    az_an_toponimo character varying,
    az_an_indirizzo character varying,
    az_an_civico character varying,
    az_di_cod_asl character varying,
    az_di_descr_asl character varying,
    sede_operativa character varying,
    sd_id numeric(12,0),
    sd_bdn_id character varying,
    sd_bdn_specie character varying,
    sd_specie_descr character varying,
    sd_cod_tipologia_struttura character varying,
    sd_tipologia_struttura character varying,
    sd_cod_regionale character varying,
    sd_cod_struttura character varying,
    sd_data_inizio date,
    sd_data_fine date,
    sd_vet_id numeric(12,0),
    sd_vet_cf character varying,
    sd_vet_cognome character varying,
    sd_vet_nome character varying,
    sd_an_id numeric(12,0),
    sd_an_nome character varying,
    sd_an_dato_fiscale character varying,
    sd_an_cf character varying,
    sd_an_iva character varying,
    sd_an_pec character varying,
    sd_an_email character varying,
    sd_an_sdi character varying,
    sd_an_split_payment numeric(1,0),
    sd_an_data_nascita date,
    sd_an_tipo character varying,
    sd_an_tipo_descr character varying,
    sd_an_tipo_persona character varying,
    sd_an_tipo_pers_descr character varying,
    sd_an_data_fine date,
    sd_an_data_decesso date,
    sd_an_res_provincia character varying,
    sd_an_res_istat character varying,
    sd_an_res_cap character varying,
    sd_an_res_comune character varying,
    sd_an_res_toponimo character varying,
    sd_an_res_indirizzo character varying,
    sd_an_res_civico character varying,
    sd_an_dom_provincia character varying,
    sd_an_dom_istat character varying,
    sd_an_dom_cap character varying,
    sd_an_dom_comune character varying,
    sd_an_dom_toponimo character varying,
    sd_an_dom_indirizzo character varying,
    sd_an_dom_civico character varying,
    figura_aziendale character varying,
    fg_id numeric(12,0),
    fg_data_inizio date,
    fg_data_fine date,
    fg_cod_tipo_figura character varying,
    fg_tipo_figura_descr character varying,
    fg_id_anagrafica numeric(12,0),
    fg_an_nome character varying,
    fg_an_dato_fiscale character varying,
    fg_an_cf character varying,
    fg_an_iva character varying,
    fg_an_pec character varying,
    fg_an_email character varying,
    fg_an_sdi character varying,
    fg_an_split_payment numeric(1,0),
    fg_an_data_nascita date,
    fg_an_tipo character varying,
    fg_an_tipo_descr character varying,
    fg_an_tipo_persona character varying,
    fg_an_tipo_pers_descr character varying,
    fg_an_data_fine date,
    fg_an_res_provincia character varying,
    fg_an_res_istat character varying,
    fg_an_res_cap character varying,
    fg_an_res_comune character varying,
    fg_an_res_toponimo character varying,
    fg_an_res_indirizzo character varying,
    fg_an_res_civico character varying,
    fg_an_dom_provincia character varying,
    fg_an_dom_istat character varying,
    fg_an_dom_cap character varying,
    fg_an_dom_comune character varying,
    fg_an_dom_toponimo character varying,
    fg_an_dom_indirizzo character varying,
    fg_an_dom_civico character varying,
    controlli character varying,
    azienda_anagr numeric(1,0),
    sedeop numeric(1,0),
    sedeop_anag numeric(1,0),
    figura_sede numeric(1,0),
    figura_anag numeric(1,0),
    errori character varying,
    score numeric(3,0),
    sl_fg_tipo_figura_descr character varying,
    sl_fg_an_nome character varying,
    sl_fg_an_cf character varying,
    sl_fg_an_iva character varying,
    sl_fg_an_pec character varying,
    sl_fg_an_email character varying,
    sl_fg_an_data_fine date,
    sl_fg_an_res_provincia character varying,
    sl_fg_an_res_istat character varying,
    sl_fg_an_res_comune character varying,
    sl_fg_an_res_toponimo character varying,
    sl_fg_an_res_indirizzo character varying,
    sl_fg_an_res_civico character varying,
    sl_fg_an_tipo_persona character varying,
    sl_fg_an_tipo_pers_descr character varying,
    sl_sd_cod_tipologia_struttura character varying,
    sl_sd_tipologia_struttura character varying,
    sl_az_cod_aziendale character varying,
    sl_sd_cod_regionale character varying,
    sl_fg_an_split_payment numeric(1,0),
    sl_fg_an_sdi character varying,
    motivo text
);


ALTER TABLE conf_ext.gisa_imprese_fvg_scarto OWNER TO postgres;

--
-- Name: istat_cap; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.istat_cap (
    istat text,
    cap text
);


ALTER TABLE conf_ext.istat_cap OWNER TO postgres;

--
-- Name: j_tree; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.j_tree (
    json_tree json
);


ALTER TABLE conf_ext.j_tree OWNER TO postgres;

--
-- Name: lineefo; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.lineefo (
    idua character varying,
    codiceregionale character varying,
    comune character varying,
    nome character varying,
    "Indirizzo " character varying,
    attivitaprevalente character varying,
    rischio character varying,
    "Attribuitaa " character varying
);


ALTER TABLE conf_ext.lineefo OWNER TO postgres;

--
-- Name: log_bonifica_imprese; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.log_bonifica_imprese (
    id integer NOT NULL,
    piva character varying,
    esito character varying,
    errore character varying,
    chiamata character varying,
    params character varying,
    chiamata_completa character varying
);


ALTER TABLE conf_ext.log_bonifica_imprese OWNER TO postgres;

--
-- Name: log_bonifica_imprese_id_seq; Type: SEQUENCE; Schema: conf_ext; Owner: postgres
--

CREATE SEQUENCE conf_ext.log_bonifica_imprese_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE conf_ext.log_bonifica_imprese_id_seq OWNER TO postgres;

--
-- Name: log_bonifica_imprese_id_seq; Type: SEQUENCE OWNED BY; Schema: conf_ext; Owner: postgres
--

ALTER SEQUENCE conf_ext.log_bonifica_imprese_id_seq OWNED BY conf_ext.log_bonifica_imprese.id;


--
-- Name: lookup_nazioni_; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.lookup_nazioni_ (
    code integer NOT NULL,
    description text NOT NULL,
    default_item boolean,
    level integer,
    enabled boolean,
    short_desc text
);


ALTER TABLE conf_ext.lookup_nazioni_ OWNER TO postgres;

--
-- Name: master_list_1069_da_caricare; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.master_list_1069_da_caricare (
    codice_univoco character varying(50),
    id_norma integer,
    codice_norma character varying(50),
    id_macroarea integer,
    macroarea character varying(128),
    codice_macroarea character varying(50),
    id_aggregazione integer,
    aggregazione character varying(128),
    codice_aggregazione character varying(50),
    id_linea integer,
    attivita character varying(128),
    codice_attivita character varying(50),
    mobile boolean,
    fisso boolean,
    apicoltura boolean,
    registrabili boolean,
    riconoscibili boolean,
    sintesis boolean,
    bdu boolean,
    vam boolean,
    no_scia boolean,
    categorizzabili boolean,
    rev integer,
    categoria_rischio_default integer,
    stato character varying(50)
);


ALTER TABLE conf_ext.master_list_1069_da_caricare OWNER TO postgres;

--
-- Name: master_list_1069_old; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.master_list_1069_old (
    codice_norma character varying(50),
    macroarea character varying(128),
    codice_macroarea character varying(50),
    aggregazione character varying(128),
    codice_aggregazione character varying(50),
    attivita character varying(128),
    codice_attivita character varying(50),
    stato character varying(50)
);


ALTER TABLE conf_ext.master_list_1069_old OWNER TO postgres;

--
-- Name: max_lev; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.max_lev (
    max integer
);


ALTER TABLE conf_ext.max_lev OWNER TO postgres;

--
-- Name: nazioni; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.nazioni (
    sigla_estesa character varying(4),
    descrizione character varying(64),
    sigla character varying(2)
);


ALTER TABLE conf_ext.nazioni OWNER TO postgres;

--
-- Name: new_gisa_imprese_fvg; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.new_gisa_imprese_fvg (
    id numeric(12,0),
    az_id numeric(12,0),
    az_data_inizio date,
    az_data_fine date,
    az_cod_aziendale character varying,
    az_bdn_id character varying,
    az_latitudine character varying,
    az_longitudine character varying,
    az_tipo_impresa character varying,
    az_id_anagrafica numeric(12,0),
    az_denominazione character varying,
    az_an_dato_fiscale character varying,
    az_an_cf character varying,
    az_an_iva character varying,
    az_an_pec character varying,
    az_an_email character varying,
    az_an_sdi character varying,
    az_an_split_payment numeric(1,0),
    az_an_data_nascita date,
    az_an_tipo character varying,
    az_an_tipo_descr character varying,
    az_an_tipo_persona character varying,
    az_an_tipo_pers_descr character varying,
    az_an_data_fine date,
    az_an_data_decesso date,
    az_an_provincia character varying,
    az_an_istat character varying,
    az_an_cap character varying,
    az_an_comune character varying,
    az_an_toponimo character varying,
    az_an_indirizzo character varying,
    az_an_civico character varying,
    az_di_cod_asl character varying,
    az_di_descr_asl character varying,
    sede_operativa character varying,
    sd_id numeric(12,0),
    sd_bdn_id character varying,
    sd_bdn_specie character varying,
    sd_specie_descr character varying,
    sd_cod_tipologia_struttura character varying,
    sd_tipologia_struttura character varying,
    sd_cod_regionale character varying,
    sd_cod_struttura character varying,
    sd_data_inizio date,
    sd_data_fine date,
    sd_vet_id numeric(12,0),
    sd_vet_cf character varying,
    sd_vet_cognome character varying,
    sd_vet_nome character varying,
    sd_an_id numeric(12,0),
    sd_an_nome character varying,
    sd_an_dato_fiscale character varying,
    sd_an_cf character varying,
    sd_an_iva character varying,
    sd_an_pec character varying,
    sd_an_email character varying,
    sd_an_sdi character varying,
    sd_an_split_payment numeric(1,0),
    sd_an_data_nascita date,
    sd_an_tipo character varying,
    sd_an_tipo_descr character varying,
    sd_an_tipo_persona character varying,
    sd_an_tipo_pers_descr character varying,
    sd_an_data_fine date,
    sd_an_data_decesso date,
    sd_an_res_provincia character varying,
    sd_an_res_istat character varying,
    sd_an_res_cap character varying,
    sd_an_res_comune character varying,
    sd_an_res_toponimo character varying,
    sd_an_res_indirizzo character varying,
    sd_an_res_civico character varying,
    sd_an_dom_provincia character varying,
    sd_an_dom_istat character varying,
    sd_an_dom_cap character varying,
    sd_an_dom_comune character varying,
    sd_an_dom_toponimo character varying,
    sd_an_dom_indirizzo character varying,
    sd_an_dom_civico character varying,
    figura_aziendale character varying,
    fg_id numeric(12,0),
    fg_data_inizio date,
    fg_data_fine date,
    fg_cod_tipo_figura character varying,
    fg_tipo_figura_descr character varying,
    fg_id_anagrafica numeric(12,0),
    fg_an_nome character varying,
    fg_an_dato_fiscale character varying,
    fg_an_cf character varying,
    fg_an_iva character varying,
    fg_an_pec character varying,
    fg_an_email character varying,
    fg_an_sdi character varying,
    fg_an_split_payment numeric(1,0),
    fg_an_data_nascita date,
    fg_an_tipo character varying,
    fg_an_tipo_descr character varying,
    fg_an_tipo_persona character varying,
    fg_an_tipo_pers_descr character varying,
    fg_an_data_fine date,
    fg_an_res_provincia character varying,
    fg_an_res_istat character varying,
    fg_an_res_cap character varying,
    fg_an_res_comune character varying,
    fg_an_res_toponimo character varying,
    fg_an_res_indirizzo character varying,
    fg_an_res_civico character varying,
    fg_an_dom_provincia character varying,
    fg_an_dom_istat character varying,
    fg_an_dom_cap character varying,
    fg_an_dom_comune character varying,
    fg_an_dom_toponimo character varying,
    fg_an_dom_indirizzo character varying,
    fg_an_dom_civico character varying,
    controlli character varying,
    azienda_anagr numeric(1,0),
    sedeop numeric(1,0),
    sedeop_anag numeric(1,0),
    figura_sede numeric(1,0),
    figura_anag numeric(1,0),
    errori character varying,
    score numeric(3,0),
    sl_fg_tipo_figura_descr character varying,
    sl_fg_an_nome character varying,
    sl_fg_an_cf character varying,
    sl_fg_an_iva character varying,
    sl_fg_an_pec character varying,
    sl_fg_an_email character varying,
    sl_fg_data_fine date,
    sl_fg_an_res_provincia character varying,
    sl_fg_an_res_istat character varying,
    sl_fg_an_res_comune character varying,
    sl_fg_an_res_toponimo character varying,
    sl_fg_an_res_indirizzo character varying,
    sl_fg_an_res_civico character varying,
    sl_fg_an_tipo_persona character varying,
    sl_fg_an_tipo_pers_descr character varying,
    sl_sd_cod_tipologia_struttura character varying,
    sl_sd_tipologia_struttura character varying,
    sl_az_cod_aziendale character varying,
    sl_sd_cod_regionale character varying,
    sl_fg_an_split_payment numeric(1,0),
    sl_fg_an_sdi character varying
);


ALTER TABLE conf_ext.new_gisa_imprese_fvg OWNER TO postgres;

--
-- Name: new_gisa_imprese_fvg_scarto; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.new_gisa_imprese_fvg_scarto (
    id numeric(12,0),
    az_id numeric(12,0),
    az_data_inizio date,
    az_data_fine date,
    az_cod_aziendale character varying,
    az_bdn_id character varying,
    az_latitudine character varying,
    az_longitudine character varying,
    az_tipo_impresa character varying,
    az_id_anagrafica numeric(12,0),
    az_denominazione character varying,
    az_an_dato_fiscale character varying,
    az_an_cf character varying,
    az_an_iva character varying,
    az_an_pec character varying,
    az_an_email character varying,
    az_an_sdi character varying,
    az_an_split_payment numeric(1,0),
    az_an_data_nascita date,
    az_an_tipo character varying,
    az_an_tipo_descr character varying,
    az_an_tipo_persona character varying,
    az_an_tipo_pers_descr character varying,
    az_an_data_fine date,
    az_an_data_decesso date,
    az_an_provincia character varying,
    az_an_istat character varying,
    az_an_cap character varying,
    az_an_comune character varying,
    az_an_toponimo character varying,
    az_an_indirizzo character varying,
    az_an_civico character varying,
    az_di_cod_asl character varying,
    az_di_descr_asl character varying,
    sede_operativa character varying,
    sd_id numeric(12,0),
    sd_bdn_id character varying,
    sd_bdn_specie character varying,
    sd_specie_descr character varying,
    sd_cod_tipologia_struttura character varying,
    sd_tipologia_struttura character varying,
    sd_cod_regionale character varying,
    sd_cod_struttura character varying,
    sd_data_inizio date,
    sd_data_fine date,
    sd_vet_id numeric(12,0),
    sd_vet_cf character varying,
    sd_vet_cognome character varying,
    sd_vet_nome character varying,
    sd_an_id numeric(12,0),
    sd_an_nome character varying,
    sd_an_dato_fiscale character varying,
    sd_an_cf character varying,
    sd_an_iva character varying,
    sd_an_pec character varying,
    sd_an_email character varying,
    sd_an_sdi character varying,
    sd_an_split_payment numeric(1,0),
    sd_an_data_nascita date,
    sd_an_tipo character varying,
    sd_an_tipo_descr character varying,
    sd_an_tipo_persona character varying,
    sd_an_tipo_pers_descr character varying,
    sd_an_data_fine date,
    sd_an_data_decesso date,
    sd_an_res_provincia character varying,
    sd_an_res_istat character varying,
    sd_an_res_cap character varying,
    sd_an_res_comune character varying,
    sd_an_res_toponimo character varying,
    sd_an_res_indirizzo character varying,
    sd_an_res_civico character varying,
    sd_an_dom_provincia character varying,
    sd_an_dom_istat character varying,
    sd_an_dom_cap character varying,
    sd_an_dom_comune character varying,
    sd_an_dom_toponimo character varying,
    sd_an_dom_indirizzo character varying,
    sd_an_dom_civico character varying,
    figura_aziendale character varying,
    fg_id numeric(12,0),
    fg_data_inizio date,
    fg_data_fine date,
    fg_cod_tipo_figura character varying,
    fg_tipo_figura_descr character varying,
    fg_id_anagrafica numeric(12,0),
    fg_an_nome character varying,
    fg_an_dato_fiscale character varying,
    fg_an_cf character varying,
    fg_an_iva character varying,
    fg_an_pec character varying,
    fg_an_email character varying,
    fg_an_sdi character varying,
    fg_an_split_payment numeric(1,0),
    fg_an_data_nascita date,
    fg_an_tipo character varying,
    fg_an_tipo_descr character varying,
    fg_an_tipo_persona character varying,
    fg_an_tipo_pers_descr character varying,
    fg_an_data_fine date,
    fg_an_res_provincia character varying,
    fg_an_res_istat character varying,
    fg_an_res_cap character varying,
    fg_an_res_comune character varying,
    fg_an_res_toponimo character varying,
    fg_an_res_indirizzo character varying,
    fg_an_res_civico character varying,
    fg_an_dom_provincia character varying,
    fg_an_dom_istat character varying,
    fg_an_dom_cap character varying,
    fg_an_dom_comune character varying,
    fg_an_dom_toponimo character varying,
    fg_an_dom_indirizzo character varying,
    fg_an_dom_civico character varying,
    controlli character varying,
    azienda_anagr numeric(1,0),
    sedeop numeric(1,0),
    sedeop_anag numeric(1,0),
    figura_sede numeric(1,0),
    figura_anag numeric(1,0),
    errori character varying,
    score numeric(3,0),
    sl_fg_tipo_figura_descr character varying,
    sl_fg_an_nome character varying,
    sl_fg_an_cf character varying,
    sl_fg_an_iva character varying,
    sl_fg_an_pec character varying,
    sl_fg_an_email character varying,
    sl_fg_an_data_fine date,
    sl_fg_an_res_provincia character varying,
    sl_fg_an_res_istat character varying,
    sl_fg_an_res_comune character varying,
    sl_fg_an_res_toponimo character varying,
    sl_fg_an_res_indirizzo character varying,
    sl_fg_an_res_civico character varying,
    sl_fg_an_tipo_persona character varying,
    sl_fg_an_tipo_pers_descr character varying,
    sl_sd_cod_tipologia_struttura character varying,
    sl_sd_tipologia_struttura character varying,
    sl_az_cod_aziendale character varying,
    sl_sd_cod_regionale character varying,
    sl_fg_an_split_payment numeric(1,0),
    sl_fg_an_sdi character varying,
    motivo text
);


ALTER TABLE conf_ext.new_gisa_imprese_fvg_scarto OWNER TO postgres;

--
-- Name: piano_strutture; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.piano_strutture (
    alias_sotto_piano character varying(50),
    descrizione_breve text
);


ALTER TABLE conf_ext.piano_strutture OWNER TO postgres;

--
-- Name: piano_strutture_old; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.piano_strutture_old (
    alias_sotto_piano character varying(16),
    descrizione_breve character varying(32)
);


ALTER TABLE conf_ext.piano_strutture_old OWNER TO postgres;

--
-- Name: piva_da_bonificare; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.piva_da_bonificare (
    piva character varying,
    check_piva boolean,
    fonte character varying
);


ALTER TABLE conf_ext.piva_da_bonificare OWNER TO postgres;

--
-- Name: soggetti_fisici_fvg; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.soggetti_fisici_fvg (
    id numeric(12,0),
    sicer_id numeric(12,0),
    nome_completo character varying,
    nome character varying,
    cognome character varying,
    sesso character varying,
    comune_nascita character varying,
    data_nascita date,
    data_decesso date,
    codice_fiscale character varying,
    tipo character varying,
    tipo_persona character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payment numeric(1,0),
    telefono character varying,
    documento character varying,
    nazione character varying,
    res_provincia character varying,
    res_istat character varying,
    res_comune character varying,
    res_toponimo character varying,
    res_indirizzo character varying,
    res_civico character varying,
    res_cap character varying,
    dom_provincia character varying,
    dom_istat character varying,
    dom_comune character varying,
    dom_toponimo character varying,
    dom_indirizzo character varying,
    dom_civico character varying,
    dom_cap character varying,
    latitudine character varying,
    longitudine character varying,
    errori character varying,
    score numeric(3,0),
    inviare numeric(1,0),
    codice_catastale_nascita text,
    data_nascita_fiscale text
);


ALTER TABLE conf_ext.soggetti_fisici_fvg OWNER TO postgres;

--
-- Name: soggetti_fisici_fvg_modificati; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.soggetti_fisici_fvg_modificati (
    id numeric(12,0),
    sicer_id numeric(12,0),
    nome_completo character varying,
    nome character varying,
    cognome character varying,
    sesso character varying,
    comune_nascita character varying,
    data_nascita date,
    data_decesso date,
    codice_fiscale character varying,
    tipo character varying,
    tipo_persona character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payment numeric(1,0),
    telefono character varying,
    documento character varying,
    nazione character varying,
    res_provincia character varying,
    res_istat character varying,
    res_comune character varying,
    res_toponimo character varying,
    res_indirizzo character varying,
    res_civico character varying,
    res_cap character varying,
    dom_provincia character varying,
    dom_istat character varying,
    dom_comune character varying,
    dom_toponimo character varying,
    dom_indirizzo character varying,
    dom_civico character varying,
    dom_cap character varying,
    latitudine character varying,
    longitudine character varying,
    errori character varying,
    score numeric(3,0),
    inviare numeric(1,0),
    codice_catastale_nascita text,
    data_nascita_fiscale text,
    motivo text
);


ALTER TABLE conf_ext.soggetti_fisici_fvg_modificati OWNER TO postgres;

--
-- Name: soggetti_fisici_fvg_scarto; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.soggetti_fisici_fvg_scarto (
    id numeric(12,0),
    sicer_id numeric(12,0),
    nome_completo character varying,
    nome character varying,
    cognome character varying,
    sesso character varying,
    comune_nascita character varying,
    data_nascita date,
    data_decesso date,
    codice_fiscale character varying,
    tipo character varying,
    tipo_persona character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payment numeric(1,0),
    telefono character varying,
    documento character varying,
    nazione character varying,
    res_provincia character varying,
    res_istat character varying,
    res_comune character varying,
    res_toponimo character varying,
    res_indirizzo character varying,
    res_civico character varying,
    res_cap character varying,
    dom_provincia character varying,
    dom_istat character varying,
    dom_comune character varying,
    dom_toponimo character varying,
    dom_indirizzo character varying,
    dom_civico character varying,
    dom_cap character varying,
    latitudine character varying,
    longitudine character varying,
    errori character varying,
    score numeric(3,0),
    inviare numeric(1,0),
    codice_catastale_nascita text,
    data_nascita_fiscale text,
    motivo text
);


ALTER TABLE conf_ext.soggetti_fisici_fvg_scarto OWNER TO postgres;

--
-- Name: tmp_gisa_imprese_fvg_a; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.tmp_gisa_imprese_fvg_a (
    id numeric(12,0),
    az_id numeric(12,0),
    az_data_inizio date,
    az_data_fine date,
    az_cod_aziendale character varying,
    az_bdn_id character varying,
    az_latitudine character varying,
    az_longitudine character varying,
    az_tipo_impresa character varying,
    az_id_anagrafica numeric(12,0),
    az_denominazione character varying,
    az_an_dato_fiscale character varying,
    az_an_cf character varying,
    az_an_iva character varying,
    az_an_pec character varying,
    az_an_email character varying,
    az_an_sdi character varying,
    az_an_split_payment numeric(1,0),
    az_an_data_nascita date,
    az_an_tipo character varying,
    az_an_tipo_descr character varying,
    az_an_tipo_persona character varying,
    az_an_tipo_pers_descr character varying,
    az_an_data_fine date,
    az_an_data_decesso date,
    az_an_provincia character varying,
    az_an_istat character varying,
    az_an_cap character varying,
    az_an_comune character varying,
    az_an_toponimo character varying,
    az_an_indirizzo character varying,
    az_an_civico character varying,
    az_di_cod_asl character varying,
    az_di_descr_asl character varying,
    sede_operativa character varying,
    sd_id numeric(12,0),
    sd_bdn_id character varying,
    sd_bdn_specie character varying,
    sd_specie_descr character varying,
    sd_cod_tipologia_struttura character varying,
    sd_tipologia_struttura character varying,
    sd_cod_regionale character varying,
    sd_cod_struttura character varying,
    sd_data_inizio date,
    sd_data_fine date,
    sd_vet_id numeric(12,0),
    sd_vet_cf character varying,
    sd_vet_cognome character varying,
    sd_vet_nome character varying,
    sd_an_id numeric(12,0),
    sd_an_nome character varying,
    sd_an_dato_fiscale character varying,
    sd_an_cf character varying,
    sd_an_iva character varying,
    sd_an_pec character varying,
    sd_an_email character varying,
    sd_an_sdi character varying,
    sd_an_split_payment numeric(1,0),
    sd_an_data_nascita date,
    sd_an_tipo character varying,
    sd_an_tipo_descr character varying,
    sd_an_tipo_persona character varying,
    sd_an_tipo_pers_descr character varying,
    sd_an_data_fine date,
    sd_an_data_decesso date,
    sd_an_res_provincia character varying,
    sd_an_res_istat character varying,
    sd_an_res_cap character varying,
    sd_an_res_comune character varying,
    sd_an_res_toponimo character varying,
    sd_an_res_indirizzo character varying,
    sd_an_res_civico character varying,
    sd_an_dom_provincia character varying,
    sd_an_dom_istat character varying,
    sd_an_dom_cap character varying,
    sd_an_dom_comune character varying,
    sd_an_dom_toponimo character varying,
    sd_an_dom_indirizzo character varying,
    sd_an_dom_civico character varying,
    figura_aziendale character varying,
    fg_id numeric(12,0),
    fg_data_inizio date,
    fg_data_fine date,
    fg_cod_tipo_figura character varying,
    fg_tipo_figura_descr character varying,
    fg_id_anagrafica numeric(12,0),
    fg_an_nome character varying,
    fg_an_dato_fiscale character varying,
    fg_an_cf character varying,
    fg_an_iva character varying,
    fg_an_pec character varying,
    fg_an_email character varying,
    fg_an_sdi character varying,
    fg_an_split_payment numeric(1,0),
    fg_an_data_nascita date,
    fg_an_tipo character varying,
    fg_an_tipo_descr character varying,
    fg_an_tipo_persona character varying,
    fg_an_tipo_pers_descr character varying,
    fg_an_data_fine date,
    fg_an_res_provincia character varying,
    fg_an_res_istat character varying,
    fg_an_res_cap character varying,
    fg_an_res_comune character varying,
    fg_an_res_toponimo character varying,
    fg_an_res_indirizzo character varying,
    fg_an_res_civico character varying,
    fg_an_dom_provincia character varying,
    fg_an_dom_istat character varying,
    fg_an_dom_cap character varying,
    fg_an_dom_comune character varying,
    fg_an_dom_toponimo character varying,
    fg_an_dom_indirizzo character varying,
    fg_an_dom_civico character varying,
    controlli character varying,
    azienda_anagr numeric(1,0),
    sedeop numeric(1,0),
    sedeop_anag numeric(1,0),
    figura_sede numeric(1,0),
    figura_anag numeric(1,0),
    errori character varying,
    score numeric(3,0),
    sl_fg_tipo_figura_descr character varying,
    sl_fg_an_nome character varying,
    sl_fg_an_cf character varying,
    sl_fg_an_iva character varying,
    sl_fg_an_pec character varying,
    sl_fg_an_email character varying,
    sl_fg_data_fine date,
    sl_fg_an_res_provincia character varying,
    sl_fg_an_res_istat character varying,
    sl_fg_an_res_comune character varying,
    sl_fg_an_res_toponimo character varying,
    sl_fg_an_res_indirizzo character varying,
    sl_fg_an_res_civico character varying,
    sl_fg_an_tipo_persona character varying,
    sl_fg_an_tipo_pers_descr character varying,
    sl_sd_cod_tipologia_struttura character varying,
    sl_sd_tipologia_struttura character varying,
    sl_az_cod_aziendale character varying,
    sl_sd_cod_regionale character varying,
    sl_fg_an_split_payment numeric(1,0),
    sl_fg_an_sdi character varying
);


ALTER TABLE conf_ext.tmp_gisa_imprese_fvg_a OWNER TO postgres;

--
-- Name: tmp_gisa_imprese_fvg_b; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.tmp_gisa_imprese_fvg_b (
    id numeric(12,0),
    az_id numeric(12,0),
    az_data_inizio date,
    az_data_fine date,
    az_cod_aziendale character varying,
    az_bdn_id character varying,
    az_latitudine character varying,
    az_longitudine character varying,
    az_tipo_impresa character varying,
    az_id_anagrafica numeric(12,0),
    az_denominazione character varying,
    az_an_dato_fiscale character varying,
    az_an_cf character varying,
    az_an_iva character varying,
    az_an_pec character varying,
    az_an_email character varying,
    az_an_sdi character varying,
    az_an_split_payment numeric(1,0),
    az_an_data_nascita date,
    az_an_tipo character varying,
    az_an_tipo_descr character varying,
    az_an_tipo_persona character varying,
    az_an_tipo_pers_descr character varying,
    az_an_data_fine date,
    az_an_data_decesso date,
    az_an_provincia character varying,
    az_an_istat character varying,
    az_an_cap character varying,
    az_an_comune character varying,
    az_an_toponimo character varying,
    az_an_indirizzo character varying,
    az_an_civico character varying,
    az_di_cod_asl character varying,
    az_di_descr_asl character varying,
    sede_operativa character varying,
    sd_id numeric(12,0),
    sd_bdn_id character varying,
    sd_bdn_specie character varying,
    sd_specie_descr character varying,
    sd_cod_tipologia_struttura character varying,
    sd_tipologia_struttura character varying,
    sd_cod_regionale character varying,
    sd_cod_struttura character varying,
    sd_data_inizio date,
    sd_data_fine date,
    sd_vet_id numeric(12,0),
    sd_vet_cf character varying,
    sd_vet_cognome character varying,
    sd_vet_nome character varying,
    sd_an_id numeric(12,0),
    sd_an_nome character varying,
    sd_an_dato_fiscale character varying,
    sd_an_cf character varying,
    sd_an_iva character varying,
    sd_an_pec character varying,
    sd_an_email character varying,
    sd_an_sdi character varying,
    sd_an_split_payment numeric(1,0),
    sd_an_data_nascita date,
    sd_an_tipo character varying,
    sd_an_tipo_descr character varying,
    sd_an_tipo_persona character varying,
    sd_an_tipo_pers_descr character varying,
    sd_an_data_fine date,
    sd_an_data_decesso date,
    sd_an_res_provincia character varying,
    sd_an_res_istat character varying,
    sd_an_res_cap character varying,
    sd_an_res_comune character varying,
    sd_an_res_toponimo character varying,
    sd_an_res_indirizzo character varying,
    sd_an_res_civico character varying,
    sd_an_dom_provincia character varying,
    sd_an_dom_istat character varying,
    sd_an_dom_cap character varying,
    sd_an_dom_comune character varying,
    sd_an_dom_toponimo character varying,
    sd_an_dom_indirizzo character varying,
    sd_an_dom_civico character varying,
    figura_aziendale character varying,
    fg_id numeric(12,0),
    fg_data_inizio date,
    fg_data_fine date,
    fg_cod_tipo_figura character varying,
    fg_tipo_figura_descr character varying,
    fg_id_anagrafica numeric(12,0),
    fg_an_nome character varying,
    fg_an_dato_fiscale character varying,
    fg_an_cf character varying,
    fg_an_iva character varying,
    fg_an_pec character varying,
    fg_an_email character varying,
    fg_an_sdi character varying,
    fg_an_split_payment numeric(1,0),
    fg_an_data_nascita date,
    fg_an_tipo character varying,
    fg_an_tipo_descr character varying,
    fg_an_tipo_persona character varying,
    fg_an_tipo_pers_descr character varying,
    fg_an_data_fine date,
    fg_an_res_provincia character varying,
    fg_an_res_istat character varying,
    fg_an_res_cap character varying,
    fg_an_res_comune character varying,
    fg_an_res_toponimo character varying,
    fg_an_res_indirizzo character varying,
    fg_an_res_civico character varying,
    fg_an_dom_provincia character varying,
    fg_an_dom_istat character varying,
    fg_an_dom_cap character varying,
    fg_an_dom_comune character varying,
    fg_an_dom_toponimo character varying,
    fg_an_dom_indirizzo character varying,
    fg_an_dom_civico character varying,
    controlli character varying,
    azienda_anagr numeric(1,0),
    sedeop numeric(1,0),
    sedeop_anag numeric(1,0),
    figura_sede numeric(1,0),
    figura_anag numeric(1,0),
    errori character varying,
    score numeric(3,0),
    sl_fg_tipo_figura_descr character varying,
    sl_fg_an_nome character varying,
    sl_fg_an_cf character varying,
    sl_fg_an_iva character varying,
    sl_fg_an_pec character varying,
    sl_fg_an_email character varying,
    sl_fg_an_data_fine date,
    sl_fg_an_res_provincia character varying,
    sl_fg_an_res_istat character varying,
    sl_fg_an_res_comune character varying,
    sl_fg_an_res_toponimo character varying,
    sl_fg_an_res_indirizzo character varying,
    sl_fg_an_res_civico character varying,
    sl_fg_an_tipo_persona character varying,
    sl_fg_an_tipo_pers_descr character varying,
    sl_sd_cod_tipologia_struttura character varying,
    sl_sd_tipologia_struttura character varying,
    sl_az_cod_aziendale character varying,
    sl_sd_cod_regionale character varying,
    sl_fg_an_split_payment numeric(1,0),
    sl_fg_an_sdi character varying,
    motivo text
);


ALTER TABLE conf_ext.tmp_gisa_imprese_fvg_b OWNER TO postgres;

--
-- Name: tmp_gisa_imprese_fvg_b_mod; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.tmp_gisa_imprese_fvg_b_mod (
    id numeric(12,0),
    az_id numeric(12,0),
    az_data_inizio date,
    az_data_fine date,
    az_cod_aziendale character varying,
    az_bdn_id character varying,
    az_latitudine character varying,
    az_longitudine character varying,
    az_tipo_impresa character varying,
    az_id_anagrafica numeric(12,0),
    az_denominazione character varying,
    az_an_dato_fiscale character varying,
    az_an_cf character varying,
    az_an_iva character varying,
    az_an_pec character varying,
    az_an_email character varying,
    az_an_sdi character varying,
    az_an_split_payment numeric(1,0),
    az_an_data_nascita date,
    az_an_tipo character varying,
    az_an_tipo_descr character varying,
    az_an_tipo_persona character varying,
    az_an_tipo_pers_descr character varying,
    az_an_data_fine date,
    az_an_data_decesso date,
    az_an_provincia character varying,
    az_an_istat character varying,
    az_an_cap character varying,
    az_an_comune character varying,
    az_an_toponimo character varying,
    az_an_indirizzo character varying,
    az_an_civico character varying,
    az_di_cod_asl character varying,
    az_di_descr_asl character varying,
    sede_operativa character varying,
    sd_id numeric(12,0),
    sd_bdn_id character varying,
    sd_bdn_specie character varying,
    sd_specie_descr character varying,
    sd_cod_tipologia_struttura character varying,
    sd_tipologia_struttura character varying,
    sd_cod_regionale character varying,
    sd_cod_struttura character varying,
    sd_data_inizio date,
    sd_data_fine date,
    sd_vet_id numeric(12,0),
    sd_vet_cf character varying,
    sd_vet_cognome character varying,
    sd_vet_nome character varying,
    sd_an_id numeric(12,0),
    sd_an_nome character varying,
    sd_an_dato_fiscale character varying,
    sd_an_cf character varying,
    sd_an_iva character varying,
    sd_an_pec character varying,
    sd_an_email character varying,
    sd_an_sdi character varying,
    sd_an_split_payment numeric(1,0),
    sd_an_data_nascita date,
    sd_an_tipo character varying,
    sd_an_tipo_descr character varying,
    sd_an_tipo_persona character varying,
    sd_an_tipo_pers_descr character varying,
    sd_an_data_fine date,
    sd_an_data_decesso date,
    sd_an_res_provincia character varying,
    sd_an_res_istat character varying,
    sd_an_res_cap character varying,
    sd_an_res_comune character varying,
    sd_an_res_toponimo character varying,
    sd_an_res_indirizzo character varying,
    sd_an_res_civico character varying,
    sd_an_dom_provincia character varying,
    sd_an_dom_istat character varying,
    sd_an_dom_cap character varying,
    sd_an_dom_comune character varying,
    sd_an_dom_toponimo character varying,
    sd_an_dom_indirizzo character varying,
    sd_an_dom_civico character varying,
    figura_aziendale character varying,
    fg_id numeric(12,0),
    fg_data_inizio date,
    fg_data_fine date,
    fg_cod_tipo_figura character varying,
    fg_tipo_figura_descr character varying,
    fg_id_anagrafica numeric(12,0),
    fg_an_nome character varying,
    fg_an_dato_fiscale character varying,
    fg_an_cf character varying,
    fg_an_iva character varying,
    fg_an_pec character varying,
    fg_an_email character varying,
    fg_an_sdi character varying,
    fg_an_split_payment numeric(1,0),
    fg_an_data_nascita date,
    fg_an_tipo character varying,
    fg_an_tipo_descr character varying,
    fg_an_tipo_persona character varying,
    fg_an_tipo_pers_descr character varying,
    fg_an_data_fine date,
    fg_an_res_provincia character varying,
    fg_an_res_istat character varying,
    fg_an_res_cap character varying,
    fg_an_res_comune character varying,
    fg_an_res_toponimo character varying,
    fg_an_res_indirizzo character varying,
    fg_an_res_civico character varying,
    fg_an_dom_provincia character varying,
    fg_an_dom_istat character varying,
    fg_an_dom_cap character varying,
    fg_an_dom_comune character varying,
    fg_an_dom_toponimo character varying,
    fg_an_dom_indirizzo character varying,
    fg_an_dom_civico character varying,
    controlli character varying,
    azienda_anagr numeric(1,0),
    sedeop numeric(1,0),
    sedeop_anag numeric(1,0),
    figura_sede numeric(1,0),
    figura_anag numeric(1,0),
    errori character varying,
    score numeric(3,0),
    sl_fg_tipo_figura_descr character varying,
    sl_fg_an_nome character varying,
    sl_fg_an_cf character varying,
    sl_fg_an_iva character varying,
    sl_fg_an_pec character varying,
    sl_fg_an_email character varying,
    sl_fg_an_data_fine date,
    sl_fg_an_res_provincia character varying,
    sl_fg_an_res_istat character varying,
    sl_fg_an_res_comune character varying,
    sl_fg_an_res_toponimo character varying,
    sl_fg_an_res_indirizzo character varying,
    sl_fg_an_res_civico character varying,
    sl_fg_an_tipo_persona character varying,
    sl_fg_an_tipo_pers_descr character varying,
    sl_sd_cod_tipologia_struttura character varying,
    sl_sd_tipologia_struttura character varying,
    sl_az_cod_aziendale character varying,
    sl_sd_cod_regionale character varying,
    sl_fg_an_split_payment numeric(1,0),
    sl_fg_an_sdi character varying,
    motivo text,
    pr_id numeric(12,0),
    gi_sd_id numeric(12,0),
    pr_data_inizio date,
    pr_data_fine date,
    sn_codice character varying,
    ss_codice character varying,
    sa_codice character varying,
    sp_codice character varying,
    pr_cod_attivita character varying,
    pr_principale numeric(12,0)
);


ALTER TABLE conf_ext.tmp_gisa_imprese_fvg_b_mod OWNER TO postgres;

--
-- Name: tmp_new_gisa_imprese_fvg_c1; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.tmp_new_gisa_imprese_fvg_c1 (
    id numeric(12,0),
    az_id numeric(12,0),
    az_data_inizio date,
    az_data_fine date,
    az_cod_aziendale character varying,
    az_bdn_id character varying,
    az_latitudine character varying,
    az_longitudine character varying,
    az_tipo_impresa character varying,
    az_id_anagrafica numeric(12,0),
    az_denominazione character varying,
    az_an_dato_fiscale character varying,
    az_an_cf character varying,
    az_an_iva character varying,
    az_an_pec character varying,
    az_an_email character varying,
    az_an_sdi character varying,
    az_an_split_payment numeric(1,0),
    az_an_data_nascita date,
    az_an_tipo character varying,
    az_an_tipo_descr character varying,
    az_an_tipo_persona character varying,
    az_an_tipo_pers_descr character varying,
    az_an_data_fine date,
    az_an_data_decesso date,
    az_an_provincia character varying,
    az_an_istat character varying,
    az_an_cap character varying,
    az_an_comune character varying,
    az_an_toponimo character varying,
    az_an_indirizzo character varying,
    az_an_civico character varying,
    az_di_cod_asl character varying,
    az_di_descr_asl character varying,
    sede_operativa character varying,
    sd_id numeric(12,0),
    sd_bdn_id character varying,
    sd_bdn_specie character varying,
    sd_specie_descr character varying,
    sd_cod_tipologia_struttura character varying,
    sd_tipologia_struttura character varying,
    sd_cod_regionale character varying,
    sd_cod_struttura character varying,
    sd_data_inizio date,
    sd_data_fine date,
    sd_vet_id numeric(12,0),
    sd_vet_cf character varying,
    sd_vet_cognome character varying,
    sd_vet_nome character varying,
    sd_an_id numeric(12,0),
    sd_an_nome character varying,
    sd_an_dato_fiscale character varying,
    sd_an_cf character varying,
    sd_an_iva character varying,
    sd_an_pec character varying,
    sd_an_email character varying,
    sd_an_sdi character varying,
    sd_an_split_payment numeric(1,0),
    sd_an_data_nascita date,
    sd_an_tipo character varying,
    sd_an_tipo_descr character varying,
    sd_an_tipo_persona character varying,
    sd_an_tipo_pers_descr character varying,
    sd_an_data_fine date,
    sd_an_data_decesso date,
    sd_an_res_provincia character varying,
    sd_an_res_istat character varying,
    sd_an_res_cap character varying,
    sd_an_res_comune character varying,
    sd_an_res_toponimo character varying,
    sd_an_res_indirizzo character varying,
    sd_an_res_civico character varying,
    sd_an_dom_provincia character varying,
    sd_an_dom_istat character varying,
    sd_an_dom_cap character varying,
    sd_an_dom_comune character varying,
    sd_an_dom_toponimo character varying,
    sd_an_dom_indirizzo character varying,
    sd_an_dom_civico character varying,
    figura_aziendale character varying,
    fg_id numeric(12,0),
    fg_data_inizio date,
    fg_data_fine date,
    fg_cod_tipo_figura character varying,
    fg_tipo_figura_descr character varying,
    fg_id_anagrafica numeric(12,0),
    fg_an_nome character varying,
    fg_an_dato_fiscale character varying,
    fg_an_cf character varying,
    fg_an_iva character varying,
    fg_an_pec character varying,
    fg_an_email character varying,
    fg_an_sdi character varying,
    fg_an_split_payment numeric(1,0),
    fg_an_data_nascita date,
    fg_an_tipo character varying,
    fg_an_tipo_descr character varying,
    fg_an_tipo_persona character varying,
    fg_an_tipo_pers_descr character varying,
    fg_an_data_fine date,
    fg_an_res_provincia character varying,
    fg_an_res_istat character varying,
    fg_an_res_cap character varying,
    fg_an_res_comune character varying,
    fg_an_res_toponimo character varying,
    fg_an_res_indirizzo character varying,
    fg_an_res_civico character varying,
    fg_an_dom_provincia character varying,
    fg_an_dom_istat character varying,
    fg_an_dom_cap character varying,
    fg_an_dom_comune character varying,
    fg_an_dom_toponimo character varying,
    fg_an_dom_indirizzo character varying,
    fg_an_dom_civico character varying,
    controlli character varying,
    azienda_anagr numeric(1,0),
    sedeop numeric(1,0),
    sedeop_anag numeric(1,0),
    figura_sede numeric(1,0),
    figura_anag numeric(1,0),
    errori character varying,
    score numeric(3,0),
    sl_fg_tipo_figura_descr character varying,
    sl_fg_an_nome character varying,
    sl_fg_an_cf character varying,
    sl_fg_an_iva character varying,
    sl_fg_an_pec character varying,
    sl_fg_an_email character varying,
    sl_fg_data_fine date,
    sl_fg_an_res_provincia character varying,
    sl_fg_an_res_istat character varying,
    sl_fg_an_res_comune character varying,
    sl_fg_an_res_toponimo character varying,
    sl_fg_an_res_indirizzo character varying,
    sl_fg_an_res_civico character varying,
    sl_fg_an_tipo_persona character varying,
    sl_fg_an_tipo_pers_descr character varying,
    sl_sd_cod_tipologia_struttura character varying,
    sl_sd_tipologia_struttura character varying,
    sl_az_cod_aziendale character varying,
    sl_sd_cod_regionale character varying,
    sl_fg_an_split_payment numeric(1,0),
    sl_fg_an_sdi character varying
);


ALTER TABLE conf_ext.tmp_new_gisa_imprese_fvg_c1 OWNER TO postgres;

--
-- Name: tmp_new_gisa_imprese_fvg_c2; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.tmp_new_gisa_imprese_fvg_c2 (
    id numeric(12,0),
    az_id numeric(12,0),
    az_data_inizio date,
    az_data_fine date,
    az_cod_aziendale character varying,
    az_bdn_id character varying,
    az_latitudine character varying,
    az_longitudine character varying,
    az_tipo_impresa character varying,
    az_id_anagrafica numeric(12,0),
    az_denominazione character varying,
    az_an_dato_fiscale character varying,
    az_an_cf character varying,
    az_an_iva character varying,
    az_an_pec character varying,
    az_an_email character varying,
    az_an_sdi character varying,
    az_an_split_payment numeric(1,0),
    az_an_data_nascita date,
    az_an_tipo character varying,
    az_an_tipo_descr character varying,
    az_an_tipo_persona character varying,
    az_an_tipo_pers_descr character varying,
    az_an_data_fine date,
    az_an_data_decesso date,
    az_an_provincia character varying,
    az_an_istat character varying,
    az_an_cap character varying,
    az_an_comune character varying,
    az_an_toponimo character varying,
    az_an_indirizzo character varying,
    az_an_civico character varying,
    az_di_cod_asl character varying,
    az_di_descr_asl character varying,
    sede_operativa character varying,
    sd_id numeric(12,0),
    sd_bdn_id character varying,
    sd_bdn_specie character varying,
    sd_specie_descr character varying,
    sd_cod_tipologia_struttura character varying,
    sd_tipologia_struttura character varying,
    sd_cod_regionale character varying,
    sd_cod_struttura character varying,
    sd_data_inizio date,
    sd_data_fine date,
    sd_vet_id numeric(12,0),
    sd_vet_cf character varying,
    sd_vet_cognome character varying,
    sd_vet_nome character varying,
    sd_an_id numeric(12,0),
    sd_an_nome character varying,
    sd_an_dato_fiscale character varying,
    sd_an_cf character varying,
    sd_an_iva character varying,
    sd_an_pec character varying,
    sd_an_email character varying,
    sd_an_sdi character varying,
    sd_an_split_payment numeric(1,0),
    sd_an_data_nascita date,
    sd_an_tipo character varying,
    sd_an_tipo_descr character varying,
    sd_an_tipo_persona character varying,
    sd_an_tipo_pers_descr character varying,
    sd_an_data_fine date,
    sd_an_data_decesso date,
    sd_an_res_provincia character varying,
    sd_an_res_istat character varying,
    sd_an_res_cap character varying,
    sd_an_res_comune character varying,
    sd_an_res_toponimo character varying,
    sd_an_res_indirizzo character varying,
    sd_an_res_civico character varying,
    sd_an_dom_provincia character varying,
    sd_an_dom_istat character varying,
    sd_an_dom_cap character varying,
    sd_an_dom_comune character varying,
    sd_an_dom_toponimo character varying,
    sd_an_dom_indirizzo character varying,
    sd_an_dom_civico character varying,
    figura_aziendale character varying,
    fg_id numeric(12,0),
    fg_data_inizio date,
    fg_data_fine date,
    fg_cod_tipo_figura character varying,
    fg_tipo_figura_descr character varying,
    fg_id_anagrafica numeric(12,0),
    fg_an_nome character varying,
    fg_an_dato_fiscale character varying,
    fg_an_cf character varying,
    fg_an_iva character varying,
    fg_an_pec character varying,
    fg_an_email character varying,
    fg_an_sdi character varying,
    fg_an_split_payment numeric(1,0),
    fg_an_data_nascita date,
    fg_an_tipo character varying,
    fg_an_tipo_descr character varying,
    fg_an_tipo_persona character varying,
    fg_an_tipo_pers_descr character varying,
    fg_an_data_fine date,
    fg_an_res_provincia character varying,
    fg_an_res_istat character varying,
    fg_an_res_cap character varying,
    fg_an_res_comune character varying,
    fg_an_res_toponimo character varying,
    fg_an_res_indirizzo character varying,
    fg_an_res_civico character varying,
    fg_an_dom_provincia character varying,
    fg_an_dom_istat character varying,
    fg_an_dom_cap character varying,
    fg_an_dom_comune character varying,
    fg_an_dom_toponimo character varying,
    fg_an_dom_indirizzo character varying,
    fg_an_dom_civico character varying,
    controlli character varying,
    azienda_anagr numeric(1,0),
    sedeop numeric(1,0),
    sedeop_anag numeric(1,0),
    figura_sede numeric(1,0),
    figura_anag numeric(1,0),
    errori character varying,
    score numeric(3,0),
    sl_fg_tipo_figura_descr character varying,
    sl_fg_an_nome character varying,
    sl_fg_an_cf character varying,
    sl_fg_an_iva character varying,
    sl_fg_an_pec character varying,
    sl_fg_an_email character varying,
    sl_fg_an_data_fine date,
    sl_fg_an_res_provincia character varying,
    sl_fg_an_res_istat character varying,
    sl_fg_an_res_comune character varying,
    sl_fg_an_res_toponimo character varying,
    sl_fg_an_res_indirizzo character varying,
    sl_fg_an_res_civico character varying,
    sl_fg_an_tipo_persona character varying,
    sl_fg_an_tipo_pers_descr character varying,
    sl_sd_cod_tipologia_struttura character varying,
    sl_sd_tipologia_struttura character varying,
    sl_az_cod_aziendale character varying,
    sl_sd_cod_regionale character varying,
    sl_fg_an_split_payment numeric(1,0),
    sl_fg_an_sdi character varying,
    motivo text
);


ALTER TABLE conf_ext.tmp_new_gisa_imprese_fvg_c2 OWNER TO postgres;

--
-- Name: tmp_new_gisa_imprese_fvg_c2_mod; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.tmp_new_gisa_imprese_fvg_c2_mod (
    id numeric(12,0),
    az_id numeric(12,0),
    az_data_inizio date,
    az_data_fine date,
    az_cod_aziendale character varying,
    az_bdn_id character varying,
    az_latitudine character varying,
    az_longitudine character varying,
    az_tipo_impresa character varying,
    az_id_anagrafica numeric(12,0),
    az_denominazione character varying,
    az_an_dato_fiscale character varying,
    az_an_cf character varying,
    az_an_iva character varying,
    az_an_pec character varying,
    az_an_email character varying,
    az_an_sdi character varying,
    az_an_split_payment numeric(1,0),
    az_an_data_nascita date,
    az_an_tipo character varying,
    az_an_tipo_descr character varying,
    az_an_tipo_persona character varying,
    az_an_tipo_pers_descr character varying,
    az_an_data_fine date,
    az_an_data_decesso date,
    az_an_provincia character varying,
    az_an_istat character varying,
    az_an_cap character varying,
    az_an_comune character varying,
    az_an_toponimo character varying,
    az_an_indirizzo character varying,
    az_an_civico character varying,
    az_di_cod_asl character varying,
    az_di_descr_asl character varying,
    sede_operativa character varying,
    sd_id numeric(12,0),
    sd_bdn_id character varying,
    sd_bdn_specie character varying,
    sd_specie_descr character varying,
    sd_cod_tipologia_struttura character varying,
    sd_tipologia_struttura character varying,
    sd_cod_regionale character varying,
    sd_cod_struttura character varying,
    sd_data_inizio date,
    sd_data_fine date,
    sd_vet_id numeric(12,0),
    sd_vet_cf character varying,
    sd_vet_cognome character varying,
    sd_vet_nome character varying,
    sd_an_id numeric(12,0),
    sd_an_nome character varying,
    sd_an_dato_fiscale character varying,
    sd_an_cf character varying,
    sd_an_iva character varying,
    sd_an_pec character varying,
    sd_an_email character varying,
    sd_an_sdi character varying,
    sd_an_split_payment numeric(1,0),
    sd_an_data_nascita date,
    sd_an_tipo character varying,
    sd_an_tipo_descr character varying,
    sd_an_tipo_persona character varying,
    sd_an_tipo_pers_descr character varying,
    sd_an_data_fine date,
    sd_an_data_decesso date,
    sd_an_res_provincia character varying,
    sd_an_res_istat character varying,
    sd_an_res_cap character varying,
    sd_an_res_comune character varying,
    sd_an_res_toponimo character varying,
    sd_an_res_indirizzo character varying,
    sd_an_res_civico character varying,
    sd_an_dom_provincia character varying,
    sd_an_dom_istat character varying,
    sd_an_dom_cap character varying,
    sd_an_dom_comune character varying,
    sd_an_dom_toponimo character varying,
    sd_an_dom_indirizzo character varying,
    sd_an_dom_civico character varying,
    figura_aziendale character varying,
    fg_id numeric(12,0),
    fg_data_inizio date,
    fg_data_fine date,
    fg_cod_tipo_figura character varying,
    fg_tipo_figura_descr character varying,
    fg_id_anagrafica numeric(12,0),
    fg_an_nome character varying,
    fg_an_dato_fiscale character varying,
    fg_an_cf character varying,
    fg_an_iva character varying,
    fg_an_pec character varying,
    fg_an_email character varying,
    fg_an_sdi character varying,
    fg_an_split_payment numeric(1,0),
    fg_an_data_nascita date,
    fg_an_tipo character varying,
    fg_an_tipo_descr character varying,
    fg_an_tipo_persona character varying,
    fg_an_tipo_pers_descr character varying,
    fg_an_data_fine date,
    fg_an_res_provincia character varying,
    fg_an_res_istat character varying,
    fg_an_res_cap character varying,
    fg_an_res_comune character varying,
    fg_an_res_toponimo character varying,
    fg_an_res_indirizzo character varying,
    fg_an_res_civico character varying,
    fg_an_dom_provincia character varying,
    fg_an_dom_istat character varying,
    fg_an_dom_cap character varying,
    fg_an_dom_comune character varying,
    fg_an_dom_toponimo character varying,
    fg_an_dom_indirizzo character varying,
    fg_an_dom_civico character varying,
    controlli character varying,
    azienda_anagr numeric(1,0),
    sedeop numeric(1,0),
    sedeop_anag numeric(1,0),
    figura_sede numeric(1,0),
    figura_anag numeric(1,0),
    errori character varying,
    score numeric(3,0),
    sl_fg_tipo_figura_descr character varying,
    sl_fg_an_nome character varying,
    sl_fg_an_cf character varying,
    sl_fg_an_iva character varying,
    sl_fg_an_pec character varying,
    sl_fg_an_email character varying,
    sl_fg_an_data_fine date,
    sl_fg_an_res_provincia character varying,
    sl_fg_an_res_istat character varying,
    sl_fg_an_res_comune character varying,
    sl_fg_an_res_toponimo character varying,
    sl_fg_an_res_indirizzo character varying,
    sl_fg_an_res_civico character varying,
    sl_fg_an_tipo_persona character varying,
    sl_fg_an_tipo_pers_descr character varying,
    sl_sd_cod_tipologia_struttura character varying,
    sl_sd_tipologia_struttura character varying,
    sl_az_cod_aziendale character varying,
    sl_sd_cod_regionale character varying,
    sl_fg_an_split_payment numeric(1,0),
    sl_fg_an_sdi character varying,
    motivo text
);


ALTER TABLE conf_ext.tmp_new_gisa_imprese_fvg_c2_mod OWNER TO postgres;

--
-- Name: toponimi; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.toponimi (
    sigla character varying(50),
    descrizione character varying(50),
    id bigint
);


ALTER TABLE conf_ext.toponimi OWNER TO postgres;

--
-- Name: us_stabilimenti; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.us_stabilimenti (
    id_impresa integer,
    nome character varying,
    sd_id integer,
    cod_regionale character varying,
    categoria_rischio character varying,
    cod_nazionale character varying,
    tipologia_struttura character varying,
    pec character varying,
    telefono character varying,
    sdi character varying,
    inizio_validita character varying,
    fine_validita character varying,
    toponimo character varying,
    indirizzo character varying,
    civico character varying,
    cap character varying,
    stato_prov character varying,
    nazione character varying,
    istat_comune character varying,
    comune character varying,
    localita character varying,
    latitudine character varying,
    longitudine character varying
);


ALTER TABLE conf_ext.us_stabilimenti OWNER TO postgres;

--
-- Name: utenti_fvg_bonifica_soggetti_fisici; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.utenti_fvg_bonifica_soggetti_fisici (
    id integer NOT NULL,
    codice_fiscale character varying,
    cognome character varying,
    nome character varying,
    comune_nascita character varying,
    data_nascita date,
    sesso character varying,
    telefono character varying,
    email character varying,
    pec character varying,
    telefono2 character varying,
    documento_identita character varying,
    toponimo character varying,
    civico character varying,
    indirizzo character varying,
    cap text,
    stato_prov character varying,
    nazione text,
    istat_comune character varying,
    comune character varying,
    localita text,
    fonte character varying,
    codice_at character varying
);


ALTER TABLE conf_ext.utenti_fvg_bonifica_soggetti_fisici OWNER TO postgres;

--
-- Name: utenti_fvg_bonifica_soggetti_fisici_id_seq; Type: SEQUENCE; Schema: conf_ext; Owner: postgres
--

CREATE SEQUENCE conf_ext.utenti_fvg_bonifica_soggetti_fisici_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE conf_ext.utenti_fvg_bonifica_soggetti_fisici_id_seq OWNER TO postgres;

--
-- Name: utenti_fvg_bonifica_soggetti_fisici_id_seq; Type: SEQUENCE OWNED BY; Schema: conf_ext; Owner: postgres
--

ALTER SEQUENCE conf_ext.utenti_fvg_bonifica_soggetti_fisici_id_seq OWNED BY conf_ext.utenti_fvg_bonifica_soggetti_fisici.id;


--
-- Name: utenti_fvg_soggetti_fisici; Type: TABLE; Schema: conf_ext; Owner: postgres
--

CREATE TABLE conf_ext.utenti_fvg_soggetti_fisici (
    codice_fiscale character varying,
    nominativo character varying,
    cognome character varying,
    nome character varying,
    qualifica character varying,
    fonte character varying
);


ALTER TABLE conf_ext.utenti_fvg_soggetti_fisici OWNER TO postgres;

--
-- Name: vw_cap; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_cap AS
 SELECT cap.codice_istat,
    cap.cap,
    to_char(cap.codice_istat, '000000'::text) AS istat_char,
    to_char(cap.cap, '00000'::text) AS cap_char
   FROM conf_ext.cap;


ALTER TABLE conf_ext.vw_cap OWNER TO postgres;

--
-- Name: vw_cf_da_bonificare; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_cf_da_bonificare AS
 SELECT cdb.codice_fiscale,
        CASE
            WHEN ((cdb.codice_fiscale)::text = (bsf.codice_fiscale)::text) THEN 'SI'::text
            ELSE 'NO'::text
        END AS cf_verificato
   FROM (conf_ext.cf_da_bonificare cdb
     JOIN conf_ext.bonifica_soggetti_fisici bsf ON (((cdb.codice_fiscale)::text = (bsf.codice_fiscale)::text)))
  WHERE ((bsf.fonte)::text = 'PARIX'::text);


ALTER TABLE conf_ext.vw_cf_da_bonificare OWNER TO postgres;

--
-- Name: vw_codicicatastali_vigenti; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_codicicatastali_vigenti AS
 SELECT vw_comuni_vigenti_catastali.codcatastale,
    (upper((vw_comuni_vigenti_catastali.denominazione_it)::text))::character varying AS denominazione_it,
    vw_comuni_vigenti_catastali.denomtraslitterata,
    vw_comuni_vigenti_catastali.denominazione_it AS deonminazione_en,
    lpad(((vw_comuni_vigenti_catastali.codistat)::character varying)::text, 6, '0'::text) AS codistat
   FROM conf_ext.vw_comuni_vigenti_catastali
UNION
 SELECT se.codice_at AS codcatastale,
    (upper((se.denom_it)::text))::character varying AS denominazione_it,
    se.denom_it AS denomtraslitterata,
    se.denom_en AS deonminazione_en,
    lpad(((se.cod_istat)::character varying)::text, 6, '0'::text) AS codistat
   FROM conf_ext.stati_esteri se;


ALTER TABLE conf_ext.vw_codicicatastali_vigenti OWNER TO postgres;

--
-- Name: vw_dettaglio_scarto_aziende; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_dettaglio_scarto_aziende AS
 SELECT t.motivo,
    t.az_denominazione,
    t.sd_an_nome,
    t.sd_an_iva
   FROM public.dblink((((((('dbname='::text || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_DB'::text)))::text) || ' port='::text) || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_PORT'::text)))::text) || ' host='::text) || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_ADDRESS'::text)))::text) || ' user=postgres'::text), 'select
    motivo,az_denominazione ,sd_an_nome, sd_an_iva   from (    
    select s.* from   conf_ext.gisa_imprese_fvg_scarto  s
			inner join (
			select distinct  az_id cod_azienda ,sd_id  cod_stab from conf_ext.gisa_imprese_fvg_scarto    
			except 
			select distinct  impresa_id cod_azienda ,stabilimento_id  cod_stab from import_dati.vw_gisa_imprese_completa_b
			) a on a.cod_azienda =s.az_id and a.cod_stab =s.sd_id  
			order by motivo


	)risultato
   '::text) t(motivo text, az_denominazione character varying, sd_an_nome character varying, sd_an_iva character varying);


ALTER TABLE conf_ext.vw_dettaglio_scarto_aziende OWNER TO postgres;

--
-- Name: vw_dettaglio_scarto_aziende_importate; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_dettaglio_scarto_aziende_importate AS
 SELECT t.motivo,
    t.az_denominazione,
    t.sd_an_nome,
    t.sd_an_iva
   FROM public.dblink((((((('dbname='::text || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_DB'::text)))::text) || ' port='::text) || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_PORT'::text)))::text) || ' host='::text) || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_ADDRESS'::text)))::text) || ' user=postgres'::text), 'select  motivo,az_denominazione ,sd_an_nome, sd_an_iva  from (
    select motivo, az_denominazione ,sd_an_nome, sd_an_iva  
	from import_dati.vw_gisa_imprese_completa_b b
	inner join import_dati.tmp_gisa_imprese_fvg_b_mod b_motivi on b_motivi.az_id = b.impresa_id and b.stabilimento_id =b_motivi.sd_id 
	order by motivo
)risultato	
 '::text) t(motivo text, az_denominazione character varying, sd_an_nome character varying, sd_an_iva character varying);


ALTER TABLE conf_ext.vw_dettaglio_scarto_aziende_importate OWNER TO postgres;

--
-- Name: vw_dettaglio_scarto_persone; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_dettaglio_scarto_persone AS
 SELECT t.nome,
    t.cognome,
    t.sesso,
    t.comune_nascita,
    t.data_nascita,
    t.codice_fiscale,
    t.motivo
   FROM public.dblink((((((('dbname='::text || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_DB'::text)))::text) || ' port='::text) || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_PORT'::text)))::text) || ' host='::text) || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_ADDRESS'::text)))::text) || ' user=postgres'::text), '        
   select pers.nome ,pers.cognome ,pers.sesso ,pers.comune_nascita ,pers.data_nascita ,pers.codice_fiscale , b.motivo 
         from conf_ext.fvg_gisa_privati pers 
      inner join  conf_ext.soggetti_fisici_fvg_scarto b on b.codice_fiscale=pers.codice_fiscale
   where pers.codice_fiscale in(
    	  select codice_fiscale from conf_ext.fvg_gisa_privati pers
    	  except
    	 select codice_fiscale  from public.opu_soggetto_fisico persCar where import_fvg is true) 
 '::text) t(nome character varying, cognome character varying, sesso character varying, comune_nascita character varying, data_nascita date, codice_fiscale character varying, motivo character varying);


ALTER TABLE conf_ext.vw_dettaglio_scarto_persone OWNER TO postgres;

--
-- Name: vw_gisa_imprese_completa; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_gisa_imprese_completa AS
 SELECT i.az_id AS impresa_id,
    i.sl_fg_an_nome AS impresa_ragione_sociale,
    COALESCE(i.sl_fg_an_iva, i.sd_an_iva) AS impresa_piva,
    COALESCE(i.sl_fg_an_cf, i.sd_an_cf) AS impresa_cf,
    i.az_cod_aziendale AS impresa_cod_aziendale,
    i.sl_fg_an_res_toponimo AS impresa_indirizzo_toponimo,
    i.sl_fg_an_res_indirizzo AS impresa_indirizzo,
    i.sl_fg_an_res_civico AS impresa_indirizzo_civico,
    i.sl_fg_an_res_istat AS impresa_indirizzo_istat_comune,
    i.sl_fg_an_res_provincia AS impresa_indirizzo_provincia,
    i.sl_fg_an_pec AS impresa_pec,
    i.sl_fg_an_email AS impresa_email,
    i.sl_fg_an_split_payment AS impresa_split_payment,
    i.sl_fg_an_sdi AS impresa_sdi,
    i.sl_fg_tipo_figura_descr AS impresa_tipo_figura_descr,
    i.fg_an_tipo_persona AS impresa_tipo_persona,
    i.fg_an_tipo_pers_descr AS impresa_tipo_pers_descr,
    i.sd_cod_tipologia_struttura AS stabilimento_cod_tipologia_struttura,
    i.sd_tipologia_struttura AS impresa_tipologia_struttura,
    i.sl_az_cod_aziendale AS impresa_codice_aziendale,
    i.sd_id AS stabilimento_id,
    i.sd_an_nome AS stabilimento_denominazione,
    i.sl_sd_cod_regionale AS stabilimento_codice_regionale,
    i.sd_an_res_toponimo AS stabilimento_indirizzo_toponimo,
    i.sd_an_res_indirizzo AS stabilimento_indirizzo,
    i.sd_an_res_civico AS stabilimento_indirizzo_civico,
    i.sd_an_res_istat AS stabilimento_indirizzo_istat_comune,
    i.sd_an_res_provincia AS stabilimento_indirizzo_provincia,
    i.az_latitudine AS stabilimento_latitudine,
    i.az_longitudine AS stabilimento_longitudine,
    s.id AS soggetto_id,
    s.nome AS soggetto_nome,
    s.cognome AS soggetto_cognome,
    s.sesso AS soggetto_sesso,
    s.codice_catastale_nascita AS soggetto_codice_catastale_comune_nascita,
    s.data_nascita AS soggetto_data_nascita,
    s.codice_fiscale AS soggetto_codice_fiscale,
    s.email AS soggetto_email,
    s.telefono AS soggetto_telefono,
    s.res_toponimo AS soggetto_indirizzo_toponimo,
    s.res_indirizzo AS soggetto_indirizzo,
    s.res_civico AS soggetto_indirizzo_civico,
    s.res_istat AS soggetto_indirizzo_istat_comune,
    s.res_provincia AS soggetto_indirizzo_provincia,
    p.pr_id AS linea_id,
    p.pr_data_inizio AS linea_data_inizio,
    p.pr_data_fine AS linea_data_fine,
    p.sn_codice AS linea_norma_codice,
    p.ss_codice AS linea_macroarea_codice,
    p.sa_codice AS linea_aggregazione_codice,
    p.sp_codice AS linea_attivita_codice,
    p.pr_cod_attivita AS linea_ateco,
        CASE
            WHEN (((i.az_denominazione)::text ~~* '%trasport%'::text) OR ((i.sd_an_nome)::text ~~* '%trasport%'::text)) THEN false
            ELSE true
        END AS attivita_fissa,
    p.pr_principale AS linea_principale
   FROM ((conf_ext.gisa_imprese_fvg i
     JOIN conf_ext.soggetti_fisici_fvg s ON (((i.fg_an_cf)::text = (s.codice_fiscale)::text)))
     JOIN ( SELECT DISTINCT ON (fvg_gisa_imprese_produzione.pr_id) fvg_gisa_imprese_produzione.pr_id,
            fvg_gisa_imprese_produzione.gi_sd_id,
            fvg_gisa_imprese_produzione.pr_data_inizio,
            fvg_gisa_imprese_produzione.pr_data_fine,
            fvg_gisa_imprese_produzione.sn_codice,
            fvg_gisa_imprese_produzione.ss_codice,
            fvg_gisa_imprese_produzione.sa_codice,
            fvg_gisa_imprese_produzione.sp_codice,
            fvg_gisa_imprese_produzione.pr_cod_attivita,
            fvg_gisa_imprese_produzione.pr_principale
           FROM conf_ext.fvg_gisa_imprese_produzione
          WHERE (fvg_gisa_imprese_produzione.pr_principale = (1)::numeric)
          ORDER BY fvg_gisa_imprese_produzione.pr_id, fvg_gisa_imprese_produzione.gi_sd_id, fvg_gisa_imprese_produzione.pr_data_inizio DESC) p ON ((i.sd_id = p.gi_sd_id)))
  WHERE (p.pr_principale IS NOT NULL)
  ORDER BY i.az_id, i.sd_id;


ALTER TABLE conf_ext.vw_gisa_imprese_completa OWNER TO postgres;

--
-- Name: vw_gisa_imprese_categoria_rischio; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_gisa_imprese_categoria_rischio AS
 SELECT g.impresa_id,
    g.impresa_ragione_sociale,
    g.impresa_piva,
    g.stabilimento_id,
    g.stabilimento_denominazione,
    i.data_ril AS categoria_rischio_data_controllo,
    i.valore_rischio AS categoria_rischio_valore,
    g.stabilimento_id AS sd_id
   FROM (conf_ext.vw_gisa_imprese_completa g
     LEFT JOIN ( SELECT DISTINCT a.gi_sd_id,
            max(a.ind_ultimo_rilevamento) AS data_ril,
            a.valore_rischio
           FROM conf_ext.fvg_gisa_imprese_indice a
          GROUP BY a.gi_sd_id, a.ind_valore_rischio, a.valore_rischio
         HAVING (count(a.gi_sd_id) = 1)) i ON ((g.stabilimento_id = i.gi_sd_id)))
  ORDER BY g.stabilimento_id;


ALTER TABLE conf_ext.vw_gisa_imprese_categoria_rischio OWNER TO postgres;

--
-- Name: vw_soggetti_fisici_fvg; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_soggetti_fisici_fvg AS
 SELECT soggetti_fisici_fvg.id,
    soggetti_fisici_fvg.sicer_id,
    soggetti_fisici_fvg.nome_completo,
    soggetti_fisici_fvg.nome,
    soggetti_fisici_fvg.cognome,
    soggetti_fisici_fvg.sesso,
    soggetti_fisici_fvg.comune_nascita,
    soggetti_fisici_fvg.data_nascita,
    soggetti_fisici_fvg.data_decesso,
    soggetti_fisici_fvg.codice_fiscale,
    soggetti_fisici_fvg.tipo,
    soggetti_fisici_fvg.tipo_persona,
    soggetti_fisici_fvg.pec,
    soggetti_fisici_fvg.email,
    soggetti_fisici_fvg.sdi,
    soggetti_fisici_fvg.split_payment,
    soggetti_fisici_fvg.telefono,
    soggetti_fisici_fvg.documento,
    soggetti_fisici_fvg.nazione,
    soggetti_fisici_fvg.res_provincia,
    soggetti_fisici_fvg.res_istat,
    soggetti_fisici_fvg.res_comune,
    soggetti_fisici_fvg.res_toponimo,
    soggetti_fisici_fvg.res_indirizzo,
    soggetti_fisici_fvg.res_civico,
    soggetti_fisici_fvg.res_cap,
    soggetti_fisici_fvg.dom_provincia,
    soggetti_fisici_fvg.dom_istat,
    soggetti_fisici_fvg.dom_comune,
    soggetti_fisici_fvg.dom_toponimo,
    soggetti_fisici_fvg.dom_indirizzo,
    soggetti_fisici_fvg.dom_civico,
    soggetti_fisici_fvg.dom_cap,
    soggetti_fisici_fvg.latitudine,
    soggetti_fisici_fvg.longitudine,
    soggetti_fisici_fvg.errori,
    soggetti_fisici_fvg.score,
    soggetti_fisici_fvg.inviare,
    soggetti_fisici_fvg.codice_catastale_nascita,
    soggetti_fisici_fvg.data_nascita_fiscale
   FROM conf_ext.soggetti_fisici_fvg
UNION
 SELECT soggetti_fisici_fvg_modificati.id,
    soggetti_fisici_fvg_modificati.sicer_id,
    soggetti_fisici_fvg_modificati.nome_completo,
    soggetti_fisici_fvg_modificati.nome,
    soggetti_fisici_fvg_modificati.cognome,
    soggetti_fisici_fvg_modificati.sesso,
    soggetti_fisici_fvg_modificati.comune_nascita,
    soggetti_fisici_fvg_modificati.data_nascita,
    soggetti_fisici_fvg_modificati.data_decesso,
    soggetti_fisici_fvg_modificati.codice_fiscale,
    soggetti_fisici_fvg_modificati.tipo,
    soggetti_fisici_fvg_modificati.tipo_persona,
    soggetti_fisici_fvg_modificati.pec,
    soggetti_fisici_fvg_modificati.email,
    soggetti_fisici_fvg_modificati.sdi,
    soggetti_fisici_fvg_modificati.split_payment,
    soggetti_fisici_fvg_modificati.telefono,
    soggetti_fisici_fvg_modificati.documento,
    soggetti_fisici_fvg_modificati.nazione,
    soggetti_fisici_fvg_modificati.res_provincia,
    soggetti_fisici_fvg_modificati.res_istat,
    soggetti_fisici_fvg_modificati.res_comune,
    soggetti_fisici_fvg_modificati.res_toponimo,
    soggetti_fisici_fvg_modificati.res_indirizzo,
    soggetti_fisici_fvg_modificati.res_civico,
    soggetti_fisici_fvg_modificati.res_cap,
    soggetti_fisici_fvg_modificati.dom_provincia,
    soggetti_fisici_fvg_modificati.dom_istat,
    soggetti_fisici_fvg_modificati.dom_comune,
    soggetti_fisici_fvg_modificati.dom_toponimo,
    soggetti_fisici_fvg_modificati.dom_indirizzo,
    soggetti_fisici_fvg_modificati.dom_civico,
    soggetti_fisici_fvg_modificati.dom_cap,
    soggetti_fisici_fvg_modificati.latitudine,
    soggetti_fisici_fvg_modificati.longitudine,
    soggetti_fisici_fvg_modificati.errori,
    soggetti_fisici_fvg_modificati.score,
    soggetti_fisici_fvg_modificati.inviare,
    soggetti_fisici_fvg_modificati.codice_catastale_nascita,
    soggetti_fisici_fvg_modificati.data_nascita_fiscale
   FROM conf_ext.soggetti_fisici_fvg_modificati
  WHERE (NOT ((soggetti_fisici_fvg_modificati.codice_fiscale)::text IN ( SELECT soggetti_fisici_fvg.codice_fiscale
           FROM conf_ext.soggetti_fisici_fvg)));


ALTER TABLE conf_ext.vw_soggetti_fisici_fvg OWNER TO postgres;

--
-- Name: vw_gisa_imprese_completa_a; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_gisa_imprese_completa_a AS
 SELECT i.az_id AS impresa_id,
    i.sl_fg_an_nome AS impresa_ragione_sociale,
    COALESCE(i.sl_fg_an_iva, i.sd_an_iva) AS impresa_piva,
    COALESCE(i.sl_fg_an_cf, i.sd_an_cf) AS impresa_cf,
    i.az_cod_aziendale AS impresa_cod_aziendale,
    i.sl_fg_an_res_toponimo AS impresa_indirizzo_toponimo,
    i.sl_fg_an_res_indirizzo AS impresa_indirizzo,
    i.sl_fg_an_res_civico AS impresa_indirizzo_civico,
    i.sl_fg_an_res_istat AS impresa_indirizzo_istat_comune,
    i.sl_fg_an_res_provincia AS impresa_indirizzo_provincia,
    i.sl_fg_an_pec AS impresa_pec,
    i.sl_fg_an_email AS impresa_email,
    i.sl_fg_an_split_payment AS impresa_split_payment,
    i.sl_fg_an_sdi AS impresa_sdi,
    i.sl_fg_tipo_figura_descr AS impresa_tipo_figura_descr,
    i.sl_fg_an_tipo_persona AS impresa_tipo_persona,
    i.sl_fg_an_tipo_pers_descr AS impresa_tipo_pers_descr,
    i.sl_sd_cod_tipologia_struttura AS stabilimento_cod_tipologia_struttura,
    i.sl_sd_tipologia_struttura AS impresa_tipologia_struttura,
    i.sl_az_cod_aziendale AS impresa_codice_aziendale,
    i.sd_id AS stabilimento_id,
    i.sd_an_nome AS stabilimento_denominazione,
    i.sl_sd_cod_regionale AS stabilimento_codice_regionale,
    i.sd_an_res_toponimo AS stabilimento_indirizzo_toponimo,
    i.sd_an_res_indirizzo AS stabilimento_indirizzo,
    i.sd_an_res_civico AS stabilimento_indirizzo_civico,
    i.sd_an_res_istat AS stabilimento_indirizzo_istat_comune,
    i.sd_an_res_provincia AS stabilimento_indirizzo_provincia,
    i.sd_an_res_cap AS stabilimento_indirizzo_cap,
    i.az_latitudine AS stabilimento_latitudine,
    i.az_longitudine AS stabilimento_longitudine,
    s.id AS soggetto_id,
    s.nome AS soggetto_nome,
    s.cognome AS soggetto_cognome,
    s.sesso AS soggetto_sesso,
    s.codice_catastale_nascita AS soggetto_codice_catastale_comune_nascita,
    s.data_nascita AS soggetto_data_nascita,
    s.codice_fiscale AS soggetto_codice_fiscale,
    s.email AS soggetto_email,
    s.telefono AS soggetto_telefono,
    s.res_toponimo AS soggetto_indirizzo_toponimo,
    s.res_indirizzo AS soggetto_indirizzo,
    s.res_civico AS soggetto_indirizzo_civico,
    s.res_istat AS soggetto_indirizzo_istat_comune,
    s.res_provincia AS soggetto_indirizzo_provincia,
    p.pr_id AS linea_id,
    p.pr_data_inizio AS linea_data_inizio,
    p.pr_data_fine AS linea_data_fine,
    p.sn_codice AS linea_norma_codice,
    p.ss_codice AS linea_macroarea_codice,
    p.sa_codice AS linea_aggregazione_codice,
    p.sp_codice AS linea_attivita_codice,
    p.pr_cod_attivita AS linea_ateco,
        CASE
            WHEN (((i.az_denominazione)::text ~~* '%trasport%'::text) OR ((i.sd_an_nome)::text ~~* '%trasport%'::text)) THEN false
            ELSE true
        END AS attivita_fissa,
    p.pr_principale AS linea_principale
   FROM ((conf_ext.tmp_gisa_imprese_fvg_a i
     JOIN conf_ext.vw_soggetti_fisici_fvg s ON (((i.fg_an_cf)::text = (s.codice_fiscale)::text)))
     JOIN ( SELECT DISTINCT ON (fvg_gisa_imprese_produzione.pr_id) fvg_gisa_imprese_produzione.pr_id,
            fvg_gisa_imprese_produzione.gi_sd_id,
            fvg_gisa_imprese_produzione.pr_data_inizio,
            fvg_gisa_imprese_produzione.pr_data_fine,
            fvg_gisa_imprese_produzione.sn_codice,
            fvg_gisa_imprese_produzione.ss_codice,
            fvg_gisa_imprese_produzione.sa_codice,
            fvg_gisa_imprese_produzione.sp_codice,
            fvg_gisa_imprese_produzione.pr_cod_attivita,
            fvg_gisa_imprese_produzione.pr_principale
           FROM conf_ext.fvg_gisa_imprese_produzione
          WHERE (fvg_gisa_imprese_produzione.pr_principale = (1)::numeric)
          ORDER BY fvg_gisa_imprese_produzione.pr_id, fvg_gisa_imprese_produzione.gi_sd_id, fvg_gisa_imprese_produzione.pr_data_inizio DESC) p ON ((i.sd_id = p.gi_sd_id)))
  WHERE (p.pr_principale IS NOT NULL)
  ORDER BY i.az_id, i.sd_id;


ALTER TABLE conf_ext.vw_gisa_imprese_completa_a OWNER TO postgres;

--
-- Name: vw_gisa_imprese_completa_b; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_gisa_imprese_completa_b AS
 SELECT DISTINCT i.az_id AS impresa_id,
    i.sl_fg_an_nome AS impresa_ragione_sociale,
    COALESCE(i.sl_fg_an_iva, i.sd_an_iva) AS impresa_piva,
    COALESCE(i.sl_fg_an_cf, i.sd_an_cf) AS impresa_cf,
    i.az_cod_aziendale AS impresa_cod_aziendale,
    i.sl_fg_an_res_toponimo AS impresa_indirizzo_toponimo,
    i.sl_fg_an_res_indirizzo AS impresa_indirizzo,
    i.sl_fg_an_res_civico AS impresa_indirizzo_civico,
    i.sl_fg_an_res_istat AS impresa_indirizzo_istat_comune,
    i.sl_fg_an_res_provincia AS impresa_indirizzo_provincia,
    i.sl_fg_an_pec AS impresa_pec,
    i.sl_fg_an_email AS impresa_email,
    i.sl_fg_an_split_payment AS impresa_split_payment,
    i.sl_fg_an_sdi AS impresa_sdi,
    i.sl_fg_tipo_figura_descr AS impresa_tipo_figura_descr,
    i.fg_an_tipo_persona AS impresa_tipo_persona,
    i.fg_an_tipo_pers_descr AS impresa_tipo_pers_descr,
    i.sd_cod_tipologia_struttura AS stabilimento_cod_tipologia_struttura,
    i.sd_tipologia_struttura AS impresa_tipologia_struttura,
    i.sl_az_cod_aziendale AS impresa_codice_aziendale,
    i.sd_id AS stabilimento_id,
    i.sd_an_nome AS stabilimento_denominazione,
    i.sl_sd_cod_regionale AS stabilimento_codice_regionale,
    i.sd_an_res_toponimo AS stabilimento_indirizzo_toponimo,
    i.sd_an_res_indirizzo AS stabilimento_indirizzo,
    i.sd_an_res_civico AS stabilimento_indirizzo_civico,
    i.sd_an_res_istat AS stabilimento_indirizzo_istat_comune,
    i.sd_an_res_provincia AS stabilimento_indirizzo_provincia,
    i.sd_an_res_cap AS stabilimento_indirizzo_cap,
    i.az_latitudine AS stabilimento_latitudine,
    i.az_longitudine AS stabilimento_longitudine,
    s.id AS soggetto_id,
    s.nome AS soggetto_nome,
    s.cognome AS soggetto_cognome,
    s.sesso AS soggetto_sesso,
    s.codice_catastale_nascita AS soggetto_codice_catastale_comune_nascita,
    s.data_nascita AS soggetto_data_nascita,
    s.codice_fiscale AS soggetto_codice_fiscale,
    s.email AS soggetto_email,
    s.telefono AS soggetto_telefono,
    s.res_toponimo AS soggetto_indirizzo_toponimo,
    s.res_indirizzo AS soggetto_indirizzo,
    s.res_civico AS soggetto_indirizzo_civico,
    s.res_istat AS soggetto_indirizzo_istat_comune,
    s.res_provincia AS soggetto_indirizzo_provincia,
    i.pr_id AS linea_id,
    i.pr_data_inizio AS linea_data_inizio,
    i.pr_data_fine AS linea_data_fine,
    i.sn_codice AS linea_norma_codice,
    i.ss_codice AS linea_macroarea_codice,
    i.sa_codice AS linea_aggregazione_codice,
    i.sp_codice AS linea_attivita_codice,
    i.pr_cod_attivita AS linea_ateco,
        CASE
            WHEN (((i.az_denominazione)::text ~~* '%trasport%'::text) OR ((i.sd_an_nome)::text ~~* '%trasport%'::text)) THEN false
            ELSE true
        END AS attivita_fissa,
    i.pr_principale AS linea_principale
   FROM (conf_ext.tmp_gisa_imprese_fvg_b_mod i
     LEFT JOIN conf_ext.vw_soggetti_fisici_fvg s ON (((i.fg_an_cf)::text = (s.codice_fiscale)::text)))
  ORDER BY i.az_id, i.sd_id;


ALTER TABLE conf_ext.vw_gisa_imprese_completa_b OWNER TO postgres;

--
-- Name: vw_gisa_imprese_completa_c1; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_gisa_imprese_completa_c1 AS
 SELECT i.az_id AS impresa_id,
    i.sl_fg_an_nome AS impresa_ragione_sociale,
    COALESCE(i.sl_fg_an_iva, i.sd_an_iva) AS impresa_piva,
    COALESCE(i.sl_fg_an_cf, i.sd_an_cf) AS impresa_cf,
    i.az_cod_aziendale AS impresa_cod_aziendale,
    i.sl_fg_an_res_toponimo AS impresa_indirizzo_toponimo,
    i.sl_fg_an_res_indirizzo AS impresa_indirizzo,
    i.sl_fg_an_res_civico AS impresa_indirizzo_civico,
    i.sl_fg_an_res_istat AS impresa_indirizzo_istat_comune,
    i.sl_fg_an_res_provincia AS impresa_indirizzo_provincia,
    i.sl_fg_an_pec AS impresa_pec,
    i.sl_fg_an_email AS impresa_email,
    i.sl_fg_an_split_payment AS impresa_split_payment,
    i.sl_fg_an_sdi AS impresa_sdi,
    i.sl_fg_tipo_figura_descr AS impresa_tipo_figura_descr,
    i.sl_fg_an_tipo_persona AS impresa_cod_tipo_persona,
    i.sl_fg_an_tipo_pers_descr AS impresa_tipo_persona,
    i.az_data_inizio AS impresa_data_inizio,
    i.az_data_fine AS impresa_data_fine,
    i.sd_id AS stabilimento_id,
    i.sd_an_nome AS stabilimento_denominazione,
    i.sl_sd_cod_regionale AS stabilimento_codice_regionale,
    i.sl_sd_cod_tipologia_struttura AS stabilimento_cod_tipologia_struttura,
    i.sl_sd_tipologia_struttura AS stabilimento_tipologia_struttura,
    i.sd_an_res_toponimo AS stabilimento_indirizzo_toponimo,
    i.sd_an_res_indirizzo AS stabilimento_indirizzo,
    i.sd_an_res_civico AS stabilimento_indirizzo_civico,
    i.sd_an_res_istat AS stabilimento_indirizzo_istat_comune,
    i.sd_an_res_provincia AS stabilimento_indirizzo_provincia,
    i.sd_an_res_cap AS stabilimento_indirizzo_cap,
    i.az_latitudine AS stabilimento_latitudine,
    i.az_longitudine AS stabilimento_longitudine,
    i.sd_data_inizio AS stabilimento_data_inizio,
    i.sd_data_fine AS stabilimento_data_fine,
    s.codice_fiscale AS soggetto_codice_fiscale,
    i.fg_data_inizio AS soggetto_data_inizio,
    i.fg_data_fine AS soggetto_data_fine
   FROM (conf_ext.tmp_new_gisa_imprese_fvg_c1 i
     LEFT JOIN conf_ext.vw_soggetti_fisici_fvg s ON (((i.fg_an_cf)::text = (s.codice_fiscale)::text)))
  ORDER BY i.az_id, i.sd_id;


ALTER TABLE conf_ext.vw_gisa_imprese_completa_c1 OWNER TO postgres;

--
-- Name: vw_gisa_imprese_completa_c2; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_gisa_imprese_completa_c2 AS
 SELECT DISTINCT i.az_id AS impresa_id,
    i.sl_fg_an_nome AS impresa_ragione_sociale,
    COALESCE(i.sl_fg_an_iva, i.sd_an_iva) AS impresa_piva,
    COALESCE(i.sl_fg_an_cf, i.sd_an_cf) AS impresa_cf,
    i.az_cod_aziendale AS impresa_cod_aziendale,
    i.sl_fg_an_res_toponimo AS impresa_indirizzo_toponimo,
    i.sl_fg_an_res_indirizzo AS impresa_indirizzo,
    i.sl_fg_an_res_civico AS impresa_indirizzo_civico,
    i.sl_fg_an_res_istat AS impresa_indirizzo_istat_comune,
    i.sl_fg_an_res_provincia AS impresa_indirizzo_provincia,
    i.sl_fg_an_pec AS impresa_pec,
    i.sl_fg_an_email AS impresa_email,
    i.sl_fg_an_split_payment AS impresa_split_payment,
    i.sl_fg_an_sdi AS impresa_sdi,
    i.sl_fg_tipo_figura_descr AS impresa_tipo_figura_descr,
    i.sl_fg_an_tipo_persona AS impresa_cod_tipo_persona,
    i.sl_fg_an_tipo_pers_descr AS impresa_tipo_persona,
    i.az_data_inizio AS impresa_data_inizio,
    i.az_data_fine AS impresa_data_fine,
    i.sd_id AS stabilimento_id,
    i.sd_an_nome AS stabilimento_denominazione,
    i.sl_sd_cod_regionale AS stabilimento_codice_regionale,
    i.sl_sd_cod_tipologia_struttura AS stabilimento_cod_tipologia_struttura,
    i.sl_sd_tipologia_struttura AS stabilimento_tipologia_struttura,
    i.sd_an_res_toponimo AS stabilimento_indirizzo_toponimo,
    i.sd_an_res_indirizzo AS stabilimento_indirizzo,
    i.sd_an_res_civico AS stabilimento_indirizzo_civico,
    i.sd_an_res_istat AS stabilimento_indirizzo_istat_comune,
    i.sd_an_res_provincia AS stabilimento_indirizzo_provincia,
    i.sd_an_res_cap AS stabilimento_indirizzo_cap,
    i.az_latitudine AS stabilimento_latitudine,
    i.az_longitudine AS stabilimento_longitudine,
    i.sd_data_inizio AS stabilimento_data_inizio,
    i.sd_data_fine AS stabilimento_data_fine,
    s.codice_fiscale AS soggetto_codice_fiscale,
    i.fg_data_inizio AS soggetto_data_inizio,
    i.fg_data_fine AS soggetto_data_fine
   FROM (conf_ext.tmp_new_gisa_imprese_fvg_c2_mod i
     LEFT JOIN conf_ext.vw_soggetti_fisici_fvg s ON (((i.fg_an_cf)::text = (s.codice_fiscale)::text)))
  ORDER BY i.az_id, i.sd_id;


ALTER TABLE conf_ext.vw_gisa_imprese_completa_c2 OWNER TO postgres;

--
-- Name: vw_gisa_imprese_completa_c; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_gisa_imprese_completa_c AS
 SELECT 'C_1'::text AS tipo_c,
    vw_gisa_imprese_completa_c1.impresa_id,
    vw_gisa_imprese_completa_c1.impresa_ragione_sociale,
    vw_gisa_imprese_completa_c1.impresa_piva,
    vw_gisa_imprese_completa_c1.impresa_cf,
    vw_gisa_imprese_completa_c1.impresa_cod_aziendale,
    vw_gisa_imprese_completa_c1.impresa_indirizzo_toponimo,
    vw_gisa_imprese_completa_c1.impresa_indirizzo,
    vw_gisa_imprese_completa_c1.impresa_indirizzo_civico,
    vw_gisa_imprese_completa_c1.impresa_indirizzo_istat_comune,
    vw_gisa_imprese_completa_c1.impresa_indirizzo_provincia,
    vw_gisa_imprese_completa_c1.impresa_pec,
    vw_gisa_imprese_completa_c1.impresa_email,
    vw_gisa_imprese_completa_c1.impresa_split_payment,
    vw_gisa_imprese_completa_c1.impresa_sdi,
    vw_gisa_imprese_completa_c1.impresa_tipo_figura_descr,
    vw_gisa_imprese_completa_c1.impresa_cod_tipo_persona,
    vw_gisa_imprese_completa_c1.impresa_tipo_persona,
    vw_gisa_imprese_completa_c1.impresa_data_inizio,
    vw_gisa_imprese_completa_c1.impresa_data_fine,
    vw_gisa_imprese_completa_c1.stabilimento_id,
    vw_gisa_imprese_completa_c1.stabilimento_denominazione,
    vw_gisa_imprese_completa_c1.stabilimento_codice_regionale,
    vw_gisa_imprese_completa_c1.stabilimento_cod_tipologia_struttura,
    vw_gisa_imprese_completa_c1.stabilimento_tipologia_struttura,
    vw_gisa_imprese_completa_c1.stabilimento_indirizzo_toponimo,
    vw_gisa_imprese_completa_c1.stabilimento_indirizzo,
    vw_gisa_imprese_completa_c1.stabilimento_indirizzo_civico,
    vw_gisa_imprese_completa_c1.stabilimento_indirizzo_istat_comune,
    vw_gisa_imprese_completa_c1.stabilimento_indirizzo_provincia,
    vw_gisa_imprese_completa_c1.stabilimento_indirizzo_cap,
    vw_gisa_imprese_completa_c1.stabilimento_latitudine,
    vw_gisa_imprese_completa_c1.stabilimento_longitudine,
    vw_gisa_imprese_completa_c1.stabilimento_data_inizio,
    vw_gisa_imprese_completa_c1.stabilimento_data_fine,
    vw_gisa_imprese_completa_c1.soggetto_codice_fiscale,
    vw_gisa_imprese_completa_c1.soggetto_data_inizio,
    vw_gisa_imprese_completa_c1.soggetto_data_fine
   FROM conf_ext.vw_gisa_imprese_completa_c1
UNION
 SELECT 'C_2'::text AS tipo_c,
    vw_gisa_imprese_completa_c2.impresa_id,
    vw_gisa_imprese_completa_c2.impresa_ragione_sociale,
    vw_gisa_imprese_completa_c2.impresa_piva,
    vw_gisa_imprese_completa_c2.impresa_cf,
    vw_gisa_imprese_completa_c2.impresa_cod_aziendale,
    vw_gisa_imprese_completa_c2.impresa_indirizzo_toponimo,
    vw_gisa_imprese_completa_c2.impresa_indirizzo,
    vw_gisa_imprese_completa_c2.impresa_indirizzo_civico,
    vw_gisa_imprese_completa_c2.impresa_indirizzo_istat_comune,
    vw_gisa_imprese_completa_c2.impresa_indirizzo_provincia,
    vw_gisa_imprese_completa_c2.impresa_pec,
    vw_gisa_imprese_completa_c2.impresa_email,
    vw_gisa_imprese_completa_c2.impresa_split_payment,
    vw_gisa_imprese_completa_c2.impresa_sdi,
    vw_gisa_imprese_completa_c2.impresa_tipo_figura_descr,
    vw_gisa_imprese_completa_c2.impresa_cod_tipo_persona,
    vw_gisa_imprese_completa_c2.impresa_tipo_persona,
    vw_gisa_imprese_completa_c2.impresa_data_inizio,
    vw_gisa_imprese_completa_c2.impresa_data_fine,
    vw_gisa_imprese_completa_c2.stabilimento_id,
    vw_gisa_imprese_completa_c2.stabilimento_denominazione,
    vw_gisa_imprese_completa_c2.stabilimento_codice_regionale,
    vw_gisa_imprese_completa_c2.stabilimento_cod_tipologia_struttura,
    vw_gisa_imprese_completa_c2.stabilimento_tipologia_struttura,
    vw_gisa_imprese_completa_c2.stabilimento_indirizzo_toponimo,
    vw_gisa_imprese_completa_c2.stabilimento_indirizzo,
    vw_gisa_imprese_completa_c2.stabilimento_indirizzo_civico,
    vw_gisa_imprese_completa_c2.stabilimento_indirizzo_istat_comune,
    vw_gisa_imprese_completa_c2.stabilimento_indirizzo_provincia,
    vw_gisa_imprese_completa_c2.stabilimento_indirizzo_cap,
    vw_gisa_imprese_completa_c2.stabilimento_latitudine,
    vw_gisa_imprese_completa_c2.stabilimento_longitudine,
    vw_gisa_imprese_completa_c2.stabilimento_data_inizio,
    vw_gisa_imprese_completa_c2.stabilimento_data_fine,
    vw_gisa_imprese_completa_c2.soggetto_codice_fiscale,
    vw_gisa_imprese_completa_c2.soggetto_data_inizio,
    vw_gisa_imprese_completa_c2.soggetto_data_fine
   FROM conf_ext.vw_gisa_imprese_completa_c2;


ALTER TABLE conf_ext.vw_gisa_imprese_completa_c OWNER TO postgres;

--
-- Name: vw_gisa_imprese_completa_c_new; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_gisa_imprese_completa_c_new AS
 SELECT DISTINCT ON (vw_gisa_imprese_completa_c.stabilimento_codice_regionale) vw_gisa_imprese_completa_c.stabilimento_codice_regionale AS cod_reg,
    vw_gisa_imprese_completa_c.tipo_c,
    vw_gisa_imprese_completa_c.impresa_id,
    vw_gisa_imprese_completa_c.impresa_ragione_sociale,
    vw_gisa_imprese_completa_c.impresa_piva,
    vw_gisa_imprese_completa_c.impresa_cf,
    vw_gisa_imprese_completa_c.impresa_cod_aziendale,
    vw_gisa_imprese_completa_c.impresa_indirizzo_toponimo,
    vw_gisa_imprese_completa_c.impresa_indirizzo,
    vw_gisa_imprese_completa_c.impresa_indirizzo_civico,
    vw_gisa_imprese_completa_c.impresa_indirizzo_istat_comune,
    vw_gisa_imprese_completa_c.impresa_indirizzo_provincia,
    vw_gisa_imprese_completa_c.impresa_pec,
    vw_gisa_imprese_completa_c.impresa_email,
    vw_gisa_imprese_completa_c.impresa_split_payment,
    vw_gisa_imprese_completa_c.impresa_sdi,
    vw_gisa_imprese_completa_c.impresa_tipo_figura_descr,
    vw_gisa_imprese_completa_c.impresa_cod_tipo_persona,
    vw_gisa_imprese_completa_c.impresa_tipo_persona,
    vw_gisa_imprese_completa_c.impresa_data_inizio,
    vw_gisa_imprese_completa_c.impresa_data_fine,
    vw_gisa_imprese_completa_c.stabilimento_id,
    vw_gisa_imprese_completa_c.stabilimento_denominazione,
    vw_gisa_imprese_completa_c.stabilimento_codice_regionale,
    vw_gisa_imprese_completa_c.stabilimento_cod_tipologia_struttura,
    vw_gisa_imprese_completa_c.stabilimento_tipologia_struttura,
    vw_gisa_imprese_completa_c.stabilimento_indirizzo_toponimo,
    vw_gisa_imprese_completa_c.stabilimento_indirizzo,
    vw_gisa_imprese_completa_c.stabilimento_indirizzo_civico,
    vw_gisa_imprese_completa_c.stabilimento_indirizzo_istat_comune,
    vw_gisa_imprese_completa_c.stabilimento_indirizzo_provincia,
    vw_gisa_imprese_completa_c.stabilimento_indirizzo_cap,
    vw_gisa_imprese_completa_c.stabilimento_latitudine,
    vw_gisa_imprese_completa_c.stabilimento_longitudine,
    vw_gisa_imprese_completa_c.stabilimento_data_inizio,
    vw_gisa_imprese_completa_c.stabilimento_data_fine,
    vw_gisa_imprese_completa_c.soggetto_codice_fiscale,
    vw_gisa_imprese_completa_c.soggetto_data_inizio,
    vw_gisa_imprese_completa_c.soggetto_data_fine
   FROM conf_ext.vw_gisa_imprese_completa_c
  ORDER BY vw_gisa_imprese_completa_c.stabilimento_codice_regionale, vw_gisa_imprese_completa_c.soggetto_codice_fiscale;


ALTER TABLE conf_ext.vw_gisa_imprese_completa_c_new OWNER TO postgres;

--
-- Name: vw_gisa_imprese_linee_c; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_gisa_imprese_linee_c AS
 SELECT i.impresa_id,
    i.stabilimento_id,
    i.impresa_ragione_sociale,
    i.stabilimento_denominazione,
    p.pr_id AS linea_id,
    p.pr_data_inizio AS linea_data_inizio,
    p.pr_data_fine AS linea_data_fine,
    p.sn_codice AS linea_norma_codice,
    p.ss_codice AS linea_macroarea_codice,
    p.sa_codice AS linea_aggregazione_codice,
    p.sp_codice AS linea_attivita_codice,
    p.pr_cod_attivita AS linea_ateco,
    p.pr_principale AS linea_principale
   FROM (conf_ext.vw_gisa_imprese_completa_c_new i
     JOIN ( SELECT DISTINCT ON (fvg_gisa_imprese_produzione.pr_id) fvg_gisa_imprese_produzione.pr_id,
            fvg_gisa_imprese_produzione.gi_sd_id,
            fvg_gisa_imprese_produzione.pr_data_inizio,
            fvg_gisa_imprese_produzione.pr_data_fine,
            fvg_gisa_imprese_produzione.sn_codice,
            fvg_gisa_imprese_produzione.ss_codice,
            fvg_gisa_imprese_produzione.sa_codice,
            fvg_gisa_imprese_produzione.sp_codice,
            fvg_gisa_imprese_produzione.pr_cod_attivita,
            fvg_gisa_imprese_produzione.pr_principale
           FROM conf_ext.fvg_gisa_imprese_produzione
          WHERE ((fvg_gisa_imprese_produzione.pr_cod_attivita)::text IN ( SELECT vw_ag_tree_nodes_up_tipo_linee.cod_mod
                   FROM agenda.vw_ag_tree_nodes_up_tipo_linee))
          ORDER BY fvg_gisa_imprese_produzione.pr_id, fvg_gisa_imprese_produzione.gi_sd_id, fvg_gisa_imprese_produzione.pr_data_inizio DESC) p ON ((i.stabilimento_id = p.gi_sd_id)))
  WHERE (p.pr_data_fine IS NULL);


ALTER TABLE conf_ext.vw_gisa_imprese_linee_c OWNER TO postgres;

--
-- Name: vw_gisa_imprese_linee_secondarie_a; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_gisa_imprese_linee_secondarie_a AS
 SELECT i.impresa_id,
    i.stabilimento_id,
    i.impresa_ragione_sociale,
    i.stabilimento_denominazione,
    p.pr_id AS linea_id,
    p.pr_data_inizio AS linea_data_inizio,
    p.pr_data_fine AS linea_data_fine,
    p.sn_codice AS linea_norma_codice,
    p.ss_codice AS linea_macroarea_codice,
    p.sa_codice AS linea_aggregazione_codice,
    p.sp_codice AS linea_attivita_codice,
    p.pr_cod_attivita AS linea_ateco,
    p.pr_principale AS linea_principale
   FROM (conf_ext.vw_gisa_imprese_completa_a i
     JOIN ( SELECT DISTINCT ON (fvg_gisa_imprese_produzione.pr_id) fvg_gisa_imprese_produzione.pr_id,
            fvg_gisa_imprese_produzione.gi_sd_id,
            fvg_gisa_imprese_produzione.pr_data_inizio,
            fvg_gisa_imprese_produzione.pr_data_fine,
            fvg_gisa_imprese_produzione.sn_codice,
            fvg_gisa_imprese_produzione.ss_codice,
            fvg_gisa_imprese_produzione.sa_codice,
            fvg_gisa_imprese_produzione.sp_codice,
            fvg_gisa_imprese_produzione.pr_cod_attivita,
            fvg_gisa_imprese_produzione.pr_principale
           FROM conf_ext.fvg_gisa_imprese_produzione
          WHERE (((fvg_gisa_imprese_produzione.pr_cod_attivita)::text IN ( SELECT vw_ag_tree_nodes_up_tipo_linee.cod_mod
                   FROM agenda.vw_ag_tree_nodes_up_tipo_linee)) AND ((fvg_gisa_imprese_produzione.pr_principale = (0)::numeric) OR (fvg_gisa_imprese_produzione.pr_principale IS NULL)) AND (NOT (fvg_gisa_imprese_produzione.pr_id IN ( SELECT vw_gisa_imprese_completa_a.linea_id
                   FROM conf_ext.vw_gisa_imprese_completa_a))))
          ORDER BY fvg_gisa_imprese_produzione.pr_id, fvg_gisa_imprese_produzione.gi_sd_id, fvg_gisa_imprese_produzione.pr_data_inizio DESC) p ON ((i.stabilimento_id = p.gi_sd_id)))
  WHERE (p.pr_data_fine IS NULL);


ALTER TABLE conf_ext.vw_gisa_imprese_linee_secondarie_a OWNER TO postgres;

--
-- Name: vw_gisa_imprese_minimale; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_gisa_imprese_minimale AS
 SELECT i.az_id,
    i.az_denominazione,
    i.sd_an_cf,
    i.sd_an_iva,
    i.az_an_indirizzo,
    i.az_an_civico,
    i.az_an_istat,
    i.az_an_provincia,
    i.sd_an_res_indirizzo,
    i.sd_an_res_civico,
    i.sd_an_res_istat,
    i.sd_an_res_provincia,
    i.fg_an_cf,
    p.pr_data_inizio,
    p.sn_codice,
    p.ss_codice,
    p.sa_codice,
    p.sp_codice,
    p.pr_cod_attivita,
        CASE
            WHEN ((i.az_denominazione)::text ~~* '%trasport%'::text) THEN false
            ELSE true
        END AS fissa
   FROM (conf_ext.gisa_imprese_fvg i
     LEFT JOIN ( SELECT DISTINCT ON (fvg_gisa_imprese_produzione.gi_sd_id) fvg_gisa_imprese_produzione.gi_sd_id,
            fvg_gisa_imprese_produzione.pr_id,
            fvg_gisa_imprese_produzione.pr_data_inizio,
            fvg_gisa_imprese_produzione.pr_data_fine,
            fvg_gisa_imprese_produzione.sn_codice,
            fvg_gisa_imprese_produzione.ss_codice,
            fvg_gisa_imprese_produzione.sa_codice,
            fvg_gisa_imprese_produzione.sp_codice,
            fvg_gisa_imprese_produzione.pr_cod_attivita
           FROM conf_ext.fvg_gisa_imprese_produzione
          ORDER BY fvg_gisa_imprese_produzione.gi_sd_id, fvg_gisa_imprese_produzione.pr_data_inizio DESC) p ON ((i.az_id = p.gi_sd_id)))
  WHERE ((p.sn_codice IS NOT NULL) AND (p.pr_data_inizio IS NOT NULL))
  ORDER BY i.az_id;


ALTER TABLE conf_ext.vw_gisa_imprese_minimale OWNER TO postgres;

--
-- Name: vw_gisa_imprese_partenza; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_gisa_imprese_partenza AS
 SELECT DISTINCT i.id,
    i.az_id,
    i.az_data_inizio,
    i.az_data_fine,
    i.az_cod_aziendale,
    i.az_bdn_id,
    i.az_latitudine,
    i.az_longitudine,
    i.az_tipo_impresa,
    i.az_id_anagrafica,
    i.az_denominazione,
    i.az_an_dato_fiscale,
    i.az_an_cf,
    i.az_an_iva,
    i.az_an_pec,
    i.az_an_email,
    i.az_an_sdi,
    i.az_an_split_payment,
    i.az_an_data_nascita,
    i.az_an_tipo,
    i.az_an_tipo_descr,
    i.az_an_tipo_persona,
    i.az_an_tipo_pers_descr,
    i.az_an_data_fine,
    i.az_an_data_decesso,
    i.az_an_provincia,
    i.az_an_istat,
    i.az_an_cap,
    i.az_an_comune,
    i.az_an_toponimo,
    i.az_an_indirizzo,
    i.az_an_civico,
    i.az_di_cod_asl,
    i.az_di_descr_asl,
    i.sede_operativa,
    i.sd_id,
    i.sd_bdn_id,
    i.sd_bdn_specie,
    i.sd_specie_descr,
    i.sd_cod_tipologia_struttura,
    i.sd_tipologia_struttura,
    i.sd_cod_regionale,
    i.sd_cod_struttura,
    i.sd_data_inizio,
    i.sd_data_fine,
    i.sd_vet_id,
    i.sd_vet_cf,
    i.sd_vet_cognome,
    i.sd_vet_nome,
    i.sd_an_id,
    i.sd_an_nome,
    i.sd_an_dato_fiscale,
    i.sd_an_cf,
    i.sd_an_iva,
    i.sd_an_pec,
    i.sd_an_email,
    i.sd_an_sdi,
    i.sd_an_split_payment,
    i.sd_an_data_nascita,
    i.sd_an_tipo,
    i.sd_an_tipo_descr,
    i.sd_an_tipo_persona,
    i.sd_an_tipo_pers_descr,
    i.sd_an_data_fine,
    i.sd_an_data_decesso,
    i.sd_an_res_provincia,
    i.sd_an_res_istat,
    i.sd_an_res_cap,
    i.sd_an_res_comune,
    i.sd_an_res_toponimo,
    i.sd_an_res_indirizzo,
    i.sd_an_res_civico,
    i.sd_an_dom_provincia,
    i.sd_an_dom_istat,
    i.sd_an_dom_cap,
    i.sd_an_dom_comune,
    i.sd_an_dom_toponimo,
    i.sd_an_dom_indirizzo,
    i.sd_an_dom_civico,
    i.figura_aziendale,
    i.fg_id,
    i.fg_data_inizio,
    i.fg_data_fine,
    i.fg_cod_tipo_figura,
    i.fg_tipo_figura_descr,
    i.fg_id_anagrafica,
    i.fg_an_nome,
    i.fg_an_dato_fiscale,
    i.fg_an_cf,
    i.fg_an_iva,
    i.fg_an_pec,
    i.fg_an_email,
    i.fg_an_sdi,
    i.fg_an_split_payment,
    i.fg_an_data_nascita,
    i.fg_an_tipo,
    i.fg_an_tipo_descr,
    i.fg_an_tipo_persona,
    i.fg_an_tipo_pers_descr,
    i.fg_an_data_fine,
    i.fg_an_res_provincia,
    i.fg_an_res_istat,
    i.fg_an_res_cap,
    i.fg_an_res_comune,
    i.fg_an_res_toponimo,
    i.fg_an_res_indirizzo,
    i.fg_an_res_civico,
    i.fg_an_dom_provincia,
    i.fg_an_dom_istat,
    i.fg_an_dom_cap,
    i.fg_an_dom_comune,
    i.fg_an_dom_toponimo,
    i.fg_an_dom_indirizzo,
    i.fg_an_dom_civico,
    i.controlli,
    i.azienda_anagr,
    i.sedeop,
    i.sedeop_anag,
    i.figura_sede,
    i.figura_anag,
    i.errori,
    i.score,
    sl.fg_tipo_figura_descr AS sl_fg_tipo_figura_descr,
    sl.fg_an_nome AS sl_fg_an_nome,
    sl.fg_an_cf AS sl_fg_an_cf,
    sl.fg_an_iva AS sl_fg_an_iva,
    sl.fg_an_pec AS sl_fg_an_pec,
    sl.fg_an_email AS sl_fg_an_email,
    sl.fg_data_fine AS sl_fg_data_fine,
    sl.fg_an_res_provincia AS sl_fg_an_res_provincia,
    sl.fg_an_res_istat AS sl_fg_an_res_istat,
    sl.fg_an_res_comune AS sl_fg_an_res_comune,
    sl.fg_an_res_toponimo AS sl_fg_an_res_toponimo,
    sl.fg_an_res_indirizzo AS sl_fg_an_res_indirizzo,
    sl.fg_an_res_civico AS sl_fg_an_res_civico,
    sl.fg_an_tipo_persona AS sl_fg_an_tipo_persona,
    sl.fg_an_tipo_pers_descr AS sl_fg_an_tipo_pers_descr,
    sl.sd_cod_tipologia_struttura AS sl_sd_cod_tipologia_struttura,
    sl.sd_tipologia_struttura AS sl_sd_tipologia_struttura,
    sl.az_cod_aziendale AS sl_az_cod_aziendale,
    sl.sd_cod_regionale AS sl_sd_cod_regionale,
    sl.fg_an_split_payment AS sl_fg_an_split_payment,
    sl.fg_an_sdi AS sl_fg_an_sdi
   FROM (conf_ext.fvg_gisa_imprese i
     JOIN conf_ext.fvg_gisa_imprese sl ON (((i.sd_id = sl.sd_id) AND ((sl.fg_tipo_figura_descr)::text ~~* '%Sede%Legale%'::text))))
  WHERE ((NOT ((i.sd_cod_regionale)::text IN ( SELECT stabilimenti.cod_regionale
           FROM cu_anag.stabilimenti
          WHERE (stabilimenti.cod_regionale IS NOT NULL)))) AND (NOT (i.sd_id IN ( SELECT stabilimenti.sd_id
           FROM cu_anag.stabilimenti
          WHERE (stabilimenti.sd_id IS NOT NULL)))) AND ((i.az_cod_aziendale)::text !~ '^[0-9]{3}[A-Z]{2}[0-9]{3}'::text) AND ((i.fg_tipo_figura_descr)::text ~~* '%Legale%Rappresentante%'::text) AND ((i.fg_data_fine IS NULL) OR (i.fg_data_fine > '2022-01-01'::date)) AND ((i.az_data_fine IS NULL) OR (i.az_data_fine > '2022-01-01'::date)) AND ((i.sd_data_fine IS NULL) OR (i.sd_data_fine > '2022-01-01'::date)) AND ((sl.fg_data_fine IS NULL) OR (sl.fg_data_fine > '2022-01-01'::date)) AND ((i.sd_cod_tipologia_struttura)::text = ANY (ARRAY[('852'::character varying)::text, ('99907'::character varying)::text, ('CG'::character varying)::text, ('FI'::character varying)::text, ('FIE'::character varying)::text, ('MOCA'::character varying)::text, ('PS'::character varying)::text, ('RSP'::character varying)::text, ('ST'::character varying)::text, ('STA'::character varying)::text, ('T11'::character varying)::text, ('Z01'::character varying)::text])));


ALTER TABLE conf_ext.vw_gisa_imprese_partenza OWNER TO postgres;

--
-- Name: vw_gisa_imprese_partenza_c; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_gisa_imprese_partenza_c AS
 SELECT DISTINCT i.id,
    i.az_id,
    i.az_data_inizio,
    i.az_data_fine,
    i.az_cod_aziendale,
    i.az_bdn_id,
    i.az_latitudine,
    i.az_longitudine,
    i.az_tipo_impresa,
    i.az_id_anagrafica,
    i.az_denominazione,
    i.az_an_dato_fiscale,
    i.az_an_cf,
    i.az_an_iva,
    i.az_an_pec,
    i.az_an_email,
    i.az_an_sdi,
    i.az_an_split_payment,
    i.az_an_data_nascita,
    i.az_an_tipo,
    i.az_an_tipo_descr,
    i.az_an_tipo_persona,
    i.az_an_tipo_pers_descr,
    i.az_an_data_fine,
    i.az_an_data_decesso,
    i.az_an_provincia,
    i.az_an_istat,
    i.az_an_cap,
    i.az_an_comune,
    i.az_an_toponimo,
    i.az_an_indirizzo,
    i.az_an_civico,
    i.az_di_cod_asl,
    i.az_di_descr_asl,
    i.sede_operativa,
    i.sd_id,
    i.sd_bdn_id,
    i.sd_bdn_specie,
    i.sd_specie_descr,
    i.sd_cod_tipologia_struttura,
    i.sd_tipologia_struttura,
    i.sd_cod_regionale,
    i.sd_cod_struttura,
    i.sd_data_inizio,
    i.sd_data_fine,
    i.sd_vet_id,
    i.sd_vet_cf,
    i.sd_vet_cognome,
    i.sd_vet_nome,
    i.sd_an_id,
    i.sd_an_nome,
    i.sd_an_dato_fiscale,
    i.sd_an_cf,
    i.sd_an_iva,
    i.sd_an_pec,
    i.sd_an_email,
    i.sd_an_sdi,
    i.sd_an_split_payment,
    i.sd_an_data_nascita,
    i.sd_an_tipo,
    i.sd_an_tipo_descr,
    i.sd_an_tipo_persona,
    i.sd_an_tipo_pers_descr,
    i.sd_an_data_fine,
    i.sd_an_data_decesso,
    i.sd_an_res_provincia,
    i.sd_an_res_istat,
    i.sd_an_res_cap,
    i.sd_an_res_comune,
    i.sd_an_res_toponimo,
    i.sd_an_res_indirizzo,
    i.sd_an_res_civico,
    i.sd_an_dom_provincia,
    i.sd_an_dom_istat,
    i.sd_an_dom_cap,
    i.sd_an_dom_comune,
    i.sd_an_dom_toponimo,
    i.sd_an_dom_indirizzo,
    i.sd_an_dom_civico,
    i.figura_aziendale,
    i.fg_id,
    i.fg_data_inizio,
    i.fg_data_fine,
    i.fg_cod_tipo_figura,
    i.fg_tipo_figura_descr,
    i.fg_id_anagrafica,
    i.fg_an_nome,
    i.fg_an_dato_fiscale,
    i.fg_an_cf,
    i.fg_an_iva,
    i.fg_an_pec,
    i.fg_an_email,
    i.fg_an_sdi,
    i.fg_an_split_payment,
    i.fg_an_data_nascita,
    i.fg_an_tipo,
    i.fg_an_tipo_descr,
    i.fg_an_tipo_persona,
    i.fg_an_tipo_pers_descr,
    i.fg_an_data_fine,
    i.fg_an_res_provincia,
    i.fg_an_res_istat,
    i.fg_an_res_cap,
    i.fg_an_res_comune,
    i.fg_an_res_toponimo,
    i.fg_an_res_indirizzo,
    i.fg_an_res_civico,
    i.fg_an_dom_provincia,
    i.fg_an_dom_istat,
    i.fg_an_dom_cap,
    i.fg_an_dom_comune,
    i.fg_an_dom_toponimo,
    i.fg_an_dom_indirizzo,
    i.fg_an_dom_civico,
    i.controlli,
    i.azienda_anagr,
    i.sedeop,
    i.sedeop_anag,
    i.figura_sede,
    i.figura_anag,
    i.errori,
    i.score,
    sl.fg_tipo_figura_descr AS sl_fg_tipo_figura_descr,
    sl.fg_an_nome AS sl_fg_an_nome,
    sl.fg_an_cf AS sl_fg_an_cf,
    sl.fg_an_iva AS sl_fg_an_iva,
    sl.fg_an_pec AS sl_fg_an_pec,
    sl.fg_an_email AS sl_fg_an_email,
    sl.fg_data_fine AS sl_fg_data_fine,
    sl.fg_an_res_provincia AS sl_fg_an_res_provincia,
    sl.fg_an_res_istat AS sl_fg_an_res_istat,
    sl.fg_an_res_comune AS sl_fg_an_res_comune,
    sl.fg_an_res_toponimo AS sl_fg_an_res_toponimo,
    sl.fg_an_res_indirizzo AS sl_fg_an_res_indirizzo,
    sl.fg_an_res_civico AS sl_fg_an_res_civico,
    sl.fg_an_tipo_persona AS sl_fg_an_tipo_persona,
    sl.fg_an_tipo_pers_descr AS sl_fg_an_tipo_pers_descr,
    sl.sd_cod_tipologia_struttura AS sl_sd_cod_tipologia_struttura,
    sl.sd_tipologia_struttura AS sl_sd_tipologia_struttura,
    sl.az_cod_aziendale AS sl_az_cod_aziendale,
    sl.sd_cod_regionale AS sl_sd_cod_regionale,
    sl.fg_an_split_payment AS sl_fg_an_split_payment,
    sl.fg_an_sdi AS sl_fg_an_sdi
   FROM (conf_ext.fvg_gisa_imprese i
     JOIN conf_ext.fvg_gisa_imprese sl ON (((i.sd_id = sl.sd_id) AND ((sl.fg_tipo_figura_descr)::text ~~* '%Sede%Legale%'::text))))
  WHERE ((NOT ((i.sd_cod_regionale)::text IN ( SELECT stabilimenti.cod_regionale
           FROM cu_anag.stabilimenti
          WHERE (stabilimenti.cod_regionale IS NOT NULL)))) AND (NOT (i.sd_id IN ( SELECT stabilimenti.sd_id
           FROM cu_anag.stabilimenti
          WHERE (stabilimenti.sd_id IS NOT NULL)))) AND ((i.az_cod_aziendale)::text !~ '^[0-9]{3}[A-Z]{2}[0-9]{3}'::text) AND ((i.fg_tipo_figura_descr)::text ~~* '%Legale%Rappresentante%'::text) AND ((i.fg_data_fine IS NULL) OR (i.fg_data_fine > '2022-01-01'::date)) AND ((i.az_data_fine IS NULL) OR (i.az_data_fine > '2022-01-01'::date)) AND ((i.sd_data_fine IS NULL) OR (i.sd_data_fine > '2022-01-01'::date)) AND ((sl.fg_data_fine IS NULL) OR (sl.fg_data_fine > '2022-01-01'::date)) AND ((i.sd_cod_tipologia_struttura)::text = ANY (ARRAY[('852'::character varying)::text, ('99907'::character varying)::text, ('CG'::character varying)::text, ('FI'::character varying)::text, ('FIE'::character varying)::text, ('MOCA'::character varying)::text, ('PS'::character varying)::text, ('RSP'::character varying)::text, ('ST'::character varying)::text, ('STA'::character varying)::text, ('T11'::character varying)::text, ('Z01'::character varying)::text])));


ALTER TABLE conf_ext.vw_gisa_imprese_partenza_c OWNER TO postgres;

--
-- Name: vw_import_imprese; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_import_imprese AS
 SELECT gisa_imprese_fvg.id,
    gisa_imprese_fvg.az_id,
    gisa_imprese_fvg.az_data_inizio,
    gisa_imprese_fvg.az_data_fine,
    gisa_imprese_fvg.az_cod_aziendale,
    gisa_imprese_fvg.az_bdn_id,
    gisa_imprese_fvg.az_latitudine,
    gisa_imprese_fvg.az_longitudine,
    gisa_imprese_fvg.az_tipo_impresa,
    gisa_imprese_fvg.az_id_anagrafica,
    gisa_imprese_fvg.az_denominazione,
    gisa_imprese_fvg.az_an_dato_fiscale,
    gisa_imprese_fvg.az_an_cf,
    gisa_imprese_fvg.az_an_iva,
    gisa_imprese_fvg.az_an_pec,
    gisa_imprese_fvg.az_an_email,
    gisa_imprese_fvg.az_an_sdi,
    gisa_imprese_fvg.az_an_split_payment,
    gisa_imprese_fvg.az_an_data_nascita,
    gisa_imprese_fvg.az_an_tipo,
    gisa_imprese_fvg.az_an_tipo_descr,
    gisa_imprese_fvg.az_an_tipo_persona,
    gisa_imprese_fvg.az_an_tipo_pers_descr,
    gisa_imprese_fvg.az_an_data_fine,
    gisa_imprese_fvg.az_an_data_decesso,
    gisa_imprese_fvg.az_an_provincia,
    gisa_imprese_fvg.az_an_istat,
    gisa_imprese_fvg.az_an_cap,
    gisa_imprese_fvg.az_an_comune,
    gisa_imprese_fvg.az_an_toponimo,
    gisa_imprese_fvg.az_an_indirizzo,
    gisa_imprese_fvg.az_an_civico,
    gisa_imprese_fvg.az_di_cod_asl,
    gisa_imprese_fvg.az_di_descr_asl,
    gisa_imprese_fvg.sede_operativa,
    gisa_imprese_fvg.sd_id,
    gisa_imprese_fvg.sd_bdn_id,
    gisa_imprese_fvg.sd_bdn_specie,
    gisa_imprese_fvg.sd_specie_descr,
    gisa_imprese_fvg.sd_cod_tipologia_struttura,
    gisa_imprese_fvg.sd_tipologia_struttura,
    gisa_imprese_fvg.sd_cod_regionale,
    gisa_imprese_fvg.sd_cod_struttura,
    gisa_imprese_fvg.sd_data_inizio,
    gisa_imprese_fvg.sd_data_fine,
    gisa_imprese_fvg.sd_vet_id,
    gisa_imprese_fvg.sd_vet_cf,
    gisa_imprese_fvg.sd_vet_cognome,
    gisa_imprese_fvg.sd_vet_nome,
    gisa_imprese_fvg.sd_an_id,
    gisa_imprese_fvg.sd_an_nome,
    gisa_imprese_fvg.sd_an_dato_fiscale,
    gisa_imprese_fvg.sd_an_cf,
    gisa_imprese_fvg.sd_an_iva,
    gisa_imprese_fvg.sd_an_pec,
    gisa_imprese_fvg.sd_an_email,
    gisa_imprese_fvg.sd_an_sdi,
    gisa_imprese_fvg.sd_an_split_payment,
    gisa_imprese_fvg.sd_an_data_nascita,
    gisa_imprese_fvg.sd_an_tipo,
    gisa_imprese_fvg.sd_an_tipo_descr,
    gisa_imprese_fvg.sd_an_tipo_persona,
    gisa_imprese_fvg.sd_an_tipo_pers_descr,
    gisa_imprese_fvg.sd_an_data_fine,
    gisa_imprese_fvg.sd_an_data_decesso,
    gisa_imprese_fvg.sd_an_res_provincia,
    gisa_imprese_fvg.sd_an_res_istat,
    gisa_imprese_fvg.sd_an_res_cap,
    gisa_imprese_fvg.sd_an_res_comune,
    gisa_imprese_fvg.sd_an_res_toponimo,
    gisa_imprese_fvg.sd_an_res_indirizzo,
    gisa_imprese_fvg.sd_an_res_civico,
    gisa_imprese_fvg.sd_an_dom_provincia,
    gisa_imprese_fvg.sd_an_dom_istat,
    gisa_imprese_fvg.sd_an_dom_cap,
    gisa_imprese_fvg.sd_an_dom_comune,
    gisa_imprese_fvg.sd_an_dom_toponimo,
    gisa_imprese_fvg.sd_an_dom_indirizzo,
    gisa_imprese_fvg.sd_an_dom_civico,
    gisa_imprese_fvg.figura_aziendale,
    gisa_imprese_fvg.fg_id,
    gisa_imprese_fvg.fg_data_inizio,
    gisa_imprese_fvg.fg_data_fine,
    gisa_imprese_fvg.fg_cod_tipo_figura,
    gisa_imprese_fvg.fg_tipo_figura_descr,
    gisa_imprese_fvg.fg_id_anagrafica,
    gisa_imprese_fvg.fg_an_nome,
    gisa_imprese_fvg.fg_an_dato_fiscale,
    gisa_imprese_fvg.fg_an_cf,
    gisa_imprese_fvg.fg_an_iva,
    gisa_imprese_fvg.fg_an_pec,
    gisa_imprese_fvg.fg_an_email,
    gisa_imprese_fvg.fg_an_sdi,
    gisa_imprese_fvg.fg_an_split_payment,
    gisa_imprese_fvg.fg_an_data_nascita,
    gisa_imprese_fvg.fg_an_tipo,
    gisa_imprese_fvg.fg_an_tipo_descr,
    gisa_imprese_fvg.fg_an_tipo_persona,
    gisa_imprese_fvg.fg_an_tipo_pers_descr,
    gisa_imprese_fvg.fg_an_data_fine,
    gisa_imprese_fvg.fg_an_res_provincia,
    gisa_imprese_fvg.fg_an_res_istat,
    gisa_imprese_fvg.fg_an_res_cap,
    gisa_imprese_fvg.fg_an_res_comune,
    gisa_imprese_fvg.fg_an_res_toponimo,
    gisa_imprese_fvg.fg_an_res_indirizzo,
    gisa_imprese_fvg.fg_an_res_civico,
    gisa_imprese_fvg.fg_an_dom_provincia,
    gisa_imprese_fvg.fg_an_dom_istat,
    gisa_imprese_fvg.fg_an_dom_cap,
    gisa_imprese_fvg.fg_an_dom_comune,
    gisa_imprese_fvg.fg_an_dom_toponimo,
    gisa_imprese_fvg.fg_an_dom_indirizzo,
    gisa_imprese_fvg.fg_an_dom_civico,
    gisa_imprese_fvg.controlli,
    gisa_imprese_fvg.azienda_anagr,
    gisa_imprese_fvg.sedeop,
    gisa_imprese_fvg.sedeop_anag,
    gisa_imprese_fvg.figura_sede,
    gisa_imprese_fvg.figura_anag,
    gisa_imprese_fvg.errori,
    gisa_imprese_fvg.score,
    gisa_imprese_fvg.sl_fg_tipo_figura_descr,
    gisa_imprese_fvg.sl_fg_an_nome,
    gisa_imprese_fvg.sl_fg_an_cf,
    gisa_imprese_fvg.sl_fg_an_iva,
    gisa_imprese_fvg.sl_fg_an_pec,
    gisa_imprese_fvg.sl_fg_an_email,
    gisa_imprese_fvg.sl_fg_data_fine,
    gisa_imprese_fvg.sl_fg_an_res_provincia,
    gisa_imprese_fvg.sl_fg_an_res_istat,
    gisa_imprese_fvg.sl_fg_an_res_comune,
    gisa_imprese_fvg.sl_fg_an_res_toponimo,
    gisa_imprese_fvg.sl_fg_an_res_indirizzo,
    gisa_imprese_fvg.sl_fg_an_res_civico,
    gisa_imprese_fvg.sl_fg_an_tipo_persona,
    gisa_imprese_fvg.sl_fg_an_tipo_pers_descr,
    gisa_imprese_fvg.sl_sd_cod_tipologia_struttura,
    gisa_imprese_fvg.sl_sd_tipologia_struttura,
    gisa_imprese_fvg.sl_az_cod_aziendale,
    gisa_imprese_fvg.sl_sd_cod_regionale,
    gisa_imprese_fvg.sl_fg_an_split_payment,
    gisa_imprese_fvg.sl_fg_an_sdi
   FROM conf_ext.gisa_imprese_fvg;


ALTER TABLE conf_ext.vw_import_imprese OWNER TO postgres;

--
-- Name: vw_imprese_fvg_scarto_motivi; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_imprese_fvg_scarto_motivi AS
 SELECT regexp_match(gifs.motivo, '^[^:]*'::text) AS motivo,
    count(*) AS count
   FROM conf_ext.gisa_imprese_fvg_scarto gifs
  GROUP BY (regexp_match(gifs.motivo, '^[^:]*'::text))
  ORDER BY (count(*)) DESC;


ALTER TABLE conf_ext.vw_imprese_fvg_scarto_motivi OWNER TO postgres;

--
-- Name: vw_istat_cap; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_istat_cap AS
 SELECT lpad(((gi_cap.codice_istat)::character varying)::text, 6, '0'::text) AS istat,
    lpad(((gi_cap.cap)::character varying)::text, 5, '0'::text) AS cap
   FROM conf_ext.gi_cap;


ALTER TABLE conf_ext.vw_istat_cap OWNER TO postgres;

--
-- Name: vw_istat_lista_cap; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_istat_lista_cap AS
 SELECT vw_istat_cap.istat,
    json_agg(vw_istat_cap.cap) AS caps
   FROM conf_ext.vw_istat_cap
  GROUP BY vw_istat_cap.istat;


ALTER TABLE conf_ext.vw_istat_lista_cap OWNER TO postgres;

--
-- Name: vw_ml_allevamenti_lev_da_gisa; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_ml_allevamenti_lev_da_gisa AS
 SELECT t.id,
    t.descr,
    t.cod,
    t.path_ord,
    t.path_descr,
    t.id_node_parent,
    t.lev,
    t.ordinamento
   FROM public.dblink((((((('dbname='::text || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_DB'::text)))::text) || ' port='::text) || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_PORT'::text)))::text) || ' host='::text) || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_ADDRESS'::text)))::text) || ' user=postgres'::text), 'select * from conf_public.vw_ml_allevamenti_lev'::text) t(id bigint, descr text, cod text, path_ord text, path_descr text, id_node_parent bigint, lev integer, ordinamento text);


ALTER TABLE conf_ext.vw_ml_allevamenti_lev_da_gisa OWNER TO postgres;

--
-- Name: vw_monitoraggio_flusso_import_gisa; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_monitoraggio_flusso_import_gisa AS
 SELECT t.flusso,
    t.totali,
    t.scarti
   FROM public.dblink((((((('dbname='::text || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_DB'::text)))::text) || ' port='::text) || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_PORT'::text)))::text) || ' host='::text) || (( SELECT config.valore
           FROM config.config
          WHERE ((config.nome)::text = 'GISA_ADDRESS'::text)))::text) || ' user=postgres'::text), '
select flusso    ,totali  ,scarti   from 

(select ''Persone'' as flusso,a.*,b.*, 1 ordine from
  ( select count(*) totali from conf_ext.fvg_gisa_privati) a,
  ( select count(*) scarti from (
     select codice_fiscale from conf_ext.fvg_gisa_privati pers
     except
    select codice_fiscale  from public.opu_soggetto_fisico persCar where import_fvg is true
   ) scar 
  )b
  
 union
 
 select ''Persone Caricate'' as flusso, a.*,null scarti, 2 ordine  from
 (  select count(*) totali from public.opu_soggetto_fisico where import_fvg is true )a
 
 union

select null flusso,null totali,null scarti,3 ordine

union

 select ''Aziende'' as flusso,a.*,b.scarti, 4 ordine  from
 (select count(*) totali from ( 
   select   az_id  ,sd_id from  conf_ext.vw_gisa_imprese_partenza
   union
   select   impresa_id ,stabilimento_id  from import_dati.vw_gisa_imprese_completa_b	
 )aa)a,
 (select count(*) scarti from (
  select    az_id ,sd_id   from conf_ext.gisa_imprese_fvg_scarto    
  except 
  select    impresa_id ,stabilimento_id   from import_dati.vw_gisa_imprese_completa_b
  )
  bb)b
  
  union
   select ''Aziende Importate'' as flusso,a.*,b.*, 5 ordine  from
    (select count(*) totali from (
      select   impresa_id ,stabilimento_id from import_dati.vw_gisa_imprese_completa_a 
      union
      select   impresa_id ,stabilimento_id  from import_dati.vw_gisa_imprese_completa_b	
     )aa)a,
   (select  count(*) scarti from (
    select    impresa_id ,stabilimento_id from import_dati.vw_gisa_imprese_completa_b
    )bb)b
   
   union
	select ''Aziende Serie A'' as flusso,count(*) totali,null  scarti, 6 ordine from(
	select   impresa_id ,stabilimento_id  from import_dati.vw_gisa_imprese_completa_a
	)a
)t
order by ordine
'::text) t(flusso character varying, totali bigint, scarti bigint);


ALTER TABLE conf_ext.vw_monitoraggio_flusso_import_gisa OWNER TO postgres;

--
-- Name: vw_nazioni; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_nazioni AS
 SELECT n.sigla_estesa,
    n.descrizione,
    n.sigla,
    upper((n.descrizione)::text) AS descrizione_upper
   FROM conf_ext.nazioni n;


ALTER TABLE conf_ext.vw_nazioni OWNER TO postgres;

--
-- Name: vw_new_imprese_fvg_scarto_motivi; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_new_imprese_fvg_scarto_motivi AS
 SELECT regexp_match(gifs.motivo, '^[^:]*'::text) AS motivo,
    count(*) AS count
   FROM conf_ext.new_gisa_imprese_fvg_scarto gifs
  GROUP BY (regexp_match(gifs.motivo, '^[^:]*'::text))
  ORDER BY (count(*)) DESC;


ALTER TABLE conf_ext.vw_new_imprese_fvg_scarto_motivi OWNER TO postgres;

--
-- Name: vw_piano_strutture; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_piano_strutture AS
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'AS FO - AMM'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.as_fo_amm)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'AS FO - ISP'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.as_fo_isp)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'AS FO - ISP AT'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.as_fo_isp_at)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'AS FO - SIAN'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.as_fo_sian)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'AS FO - SIAN AT'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.as_fo_sian_at)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'AS FO - SVET AT'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.as_fo_svet_at)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'AS FO - VET A'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.as_fo_vet_a)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'AS FO - VET B'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.as_fo_vet_b)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'AS FO - VET C'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.as_fo_vet_c)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'ASU FC - ISP'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.asu_fc_isp)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'ASU FC - SVET'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.asu_fc_svet)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'ASU FC - TDP SIAN'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.asu_fc_tdp_sian)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'ASU FC - VET A'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.asu_fc_vet_a)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'ASU FC - VET B'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.asu_fc_vet_b)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'ASU FC - VET C'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.asu_fc_vet_c)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'ASU GI - ISP'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.asu_gi_isp)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'ASU GI - SIAN'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.asu_gi_sian)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'ASU GI - VET A/C'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.asu_gi_vet_ac)::text ~~* 'x'::text)
UNION
 SELECT dpar_gisa_fvg.alias_sotto_piano,
    'ASU GI - VET B'::text AS descrizione_breve
   FROM conf_ext.dpar_gisa_fvg
  WHERE ((dpar_gisa_fvg.asu_gi_vet_b)::text ~~* 'x'::text);


ALTER TABLE conf_ext.vw_piano_strutture OWNER TO postgres;

--
-- Name: vw_soggetti_fisici_fvg_scarto_motivi; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_soggetti_fisici_fvg_scarto_motivi AS
 SELECT regexp_match(gifs.motivo, '^[^:]*'::text) AS motivo,
    count(*) AS count
   FROM conf_ext.soggetti_fisici_fvg_scarto gifs
  GROUP BY (regexp_match(gifs.motivo, '^[^:]*'::text))
  ORDER BY (count(*)) DESC;


ALTER TABLE conf_ext.vw_soggetti_fisici_fvg_scarto_motivi OWNER TO postgres;

--
-- Name: vw_toponimi; Type: VIEW; Schema: conf_ext; Owner: postgres
--

CREATE VIEW conf_ext.vw_toponimi AS
 SELECT t.sigla,
    t.descrizione,
    t.id
   FROM conf_ext.toponimi t;


ALTER TABLE conf_ext.vw_toponimi OWNER TO postgres;

--
-- Name: vwm_bonifica_soggetti_fisici_validi; Type: MATERIALIZED VIEW; Schema: conf_ext; Owner: gisa_fvg
--

CREATE MATERIALIZED VIEW conf_ext.vwm_bonifica_soggetti_fisici_validi AS
 SELECT cu_anag.split_check_cf_bool(bonifica_soggetti_fisici.codice_fiscale, bonifica_soggetti_fisici.nome, bonifica_soggetti_fisici.cognome, bonifica_soggetti_fisici.data_nascita, bonifica_soggetti_fisici.sesso, bonifica_soggetti_fisici.istat_comune) AS split_check_cf_bool,
    bonifica_soggetti_fisici.id,
    bonifica_soggetti_fisici.codice_fiscale,
    bonifica_soggetti_fisici.cognome,
    bonifica_soggetti_fisici.nome,
    bonifica_soggetti_fisici.comune_nascita,
    bonifica_soggetti_fisici.data_nascita,
    bonifica_soggetti_fisici.sesso,
    bonifica_soggetti_fisici.telefono,
    bonifica_soggetti_fisici.email,
    bonifica_soggetti_fisici.pec,
    bonifica_soggetti_fisici.telefono2,
    bonifica_soggetti_fisici.documento_identita,
    bonifica_soggetti_fisici.toponimo,
    bonifica_soggetti_fisici.civico,
    bonifica_soggetti_fisici.indirizzo,
    bonifica_soggetti_fisici.cap,
    bonifica_soggetti_fisici.stato_prov,
    bonifica_soggetti_fisici.nazione,
    bonifica_soggetti_fisici.istat_comune,
    bonifica_soggetti_fisici.comune,
    bonifica_soggetti_fisici.localita,
    bonifica_soggetti_fisici.fonte,
    bonifica_soggetti_fisici.codice_at
   FROM conf_ext.bonifica_soggetti_fisici
  WHERE ((bonifica_soggetti_fisici.codice_fiscale)::text IN ( SELECT bonifica_soggetti_fisici_1.codice_fiscale
           FROM conf_ext.bonifica_soggetti_fisici bonifica_soggetti_fisici_1
          WHERE (cu_anag.split_check_cf_bool(bonifica_soggetti_fisici_1.codice_fiscale, bonifica_soggetti_fisici_1.nome, bonifica_soggetti_fisici_1.cognome, bonifica_soggetti_fisici_1.data_nascita, bonifica_soggetti_fisici_1.sesso, bonifica_soggetti_fisici_1.istat_comune) IS FALSE)))
  WITH NO DATA;


ALTER TABLE conf_ext.vwm_bonifica_soggetti_fisici_validi OWNER TO gisa_fvg;

--
-- Name: az_1069; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.az_1069 (
    "Stato sede operativa" character varying,
    "Approval Number" character varying,
    "Denominazione sede operativa" character varying,
    "Ragione Sociale Impresa" character varying,
    "Partita Iva" character varying,
    "Codice Fiscale" character varying,
    indirizzo character varying,
    comune character varying,
    "Sigla provincia" character varying,
    provincia character varying,
    regione character varying,
    "Cod. Ufficio Veterinario" integer,
    "Ufficio Veterinario" character varying,
    "attività" character varying,
    "Stato Attività" character varying,
    "Descrizione Sezione" character varying,
    "Data inizio attività" character varying,
    "Data fine attività" character varying,
    "Tipo autorizzazione" character varying,
    imballaggio character varying,
    "Paesi abilitati export" character varying,
    remark character varying,
    species character varying,
    "Informazioni Aggiuntive" character varying
);


ALTER TABLE config.az_1069 OWNER TO postgres;

--
-- Name: az_853; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.az_853 (
    "Stato sede operativa" character varying,
    "Approval Number" character varying,
    "Denominazione sede operativa" character varying,
    "Ragione Sociale Impresa" character varying,
    "Partita Iva" character varying,
    "Codice Fiscale" character varying,
    indirizzo character varying,
    comune character varying,
    "Sigla provincia" character varying,
    provincia character varying,
    regione character varying,
    "Cod. Ufficio Veterinario" integer,
    "Ufficio Veterinario" character varying,
    "attività" character varying,
    "Stato Attività" character varying,
    "Descrizione Sezione" character varying,
    "Data inizio attività" character varying,
    "Data fine attività" character varying,
    "Tipo autorizzazione" character varying,
    imballaggio character varying,
    "Paesi abilitati export" character varying,
    remark character varying,
    species character varying,
    "Informazioni Aggiuntive" character varying
);


ALTER TABLE config.az_853 OWNER TO postgres;

--
-- Name: az_aromi; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.az_aromi (
    "Stato sede operativa" character varying,
    "Approval Number" character varying,
    "Denominazione sede operativa" character varying,
    "Ragione Sociale Impresa" character varying,
    "Partita Iva" character varying,
    "Codice Fiscale" character varying,
    indirizzo character varying,
    comune character varying,
    "Sigla provincia" character varying,
    provincia character varying,
    regione character varying,
    "Cod. Ufficio Veterinario" integer,
    "Ufficio Veterinario" character varying,
    "attività" character varying,
    "Stato Attività" character varying,
    "Descrizione Sezione" character varying,
    "Data inizio attività" character varying,
    "Data fine attività" character varying,
    "Tipo autorizzazione" character varying,
    imballaggio character varying,
    "Paesi abilitati export" character varying,
    remark character varying,
    species character varying,
    "Informazioni Aggiuntive" character varying
);


ALTER TABLE config.az_aromi OWNER TO postgres;

--
-- Name: az_particolari; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.az_particolari (
    "Stato sede operativa" character varying,
    "Approval Number" character varying,
    "Denominazione sede operativa" character varying,
    "Ragione Sociale Impresa" character varying,
    "Partita Iva" character varying,
    "Codice Fiscale" character varying,
    indirizzo character varying,
    comune character varying,
    "Sigla provincia" character varying,
    provincia character varying,
    regione character varying,
    "Cod. Ufficio Veterinario" integer,
    "Ufficio Veterinario" character varying,
    "attività" character varying,
    "Stato Attività" character varying,
    "Descrizione Sezione" character varying,
    "Data inizio attività" character varying,
    "Data fine attività" character varying,
    "Tipo autorizzazione" character varying,
    imballaggio character varying,
    "Paesi abilitati export" character varying,
    remark character varying,
    species character varying,
    "Informazioni Aggiuntive" character varying
);


ALTER TABLE config.az_particolari OWNER TO postgres;

--
-- Name: az_struttura_piani; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.az_struttura_piani (
    id integer,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione character varying(512),
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(8),
    path character varying(1),
    livello integer,
    alias character varying(1),
    id_formula_ups integer,
    id_formula_uba integer,
    descrizione_breve character varying(512),
    codice_interno_univoco character varying(1),
    ha_campioni boolean,
    id_tipo_tecnica integer
);


ALTER TABLE config.az_struttura_piani OWNER TO postgres;

--
-- Name: az_tree_nodes; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.az_tree_nodes (
    id integer,
    id_tree integer,
    id_parent integer,
    ordinamento integer,
    node_descr character varying(512)
);


ALTER TABLE config.az_tree_nodes OWNER TO postgres;

--
-- Name: distretti_personale_fvg_comuni; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.distretti_personale_fvg_comuni (
    comune character varying(32),
    distretto_da_atto character varying(32),
    distretto_operativo character varying(32),
    svet character varying(16),
    veta character varying(64),
    vetb character varying(32),
    vetc character varying(32),
    sian character varying(16)
);


ALTER TABLE config.distretti_personale_fvg_comuni OWNER TO postgres;

--
-- Name: festivita; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.festivita (
    id bigint NOT NULL,
    data date
);


ALTER TABLE config.festivita OWNER TO postgres;

--
-- Name: festivita_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE config.festivita_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.festivita_id_seq OWNER TO postgres;

--
-- Name: festivita_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE config.festivita_id_seq OWNED BY config.festivita.id;


--
-- Name: nom_strutt_fvg; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.nom_strutt_fvg (
    nominativo character varying,
    struttura character varying
);


ALTER TABLE config.nom_strutt_fvg OWNER TO postgres;

--
-- Name: nuovo_tariffario_in_sicer_con_indicazioni_operative; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.nuovo_tariffario_in_sicer_con_indicazioni_operative (
    codice character varying,
    descrizione character varying,
    "codice iva" integer,
    "Tempistiche minime concordate in Regione FVG" character varying,
    "Tipologia Tariffa" character varying,
    "unita misura" character varying,
    note character varying,
    legenda character varying,
    column9 character varying
);


ALTER TABLE config.nuovo_tariffario_in_sicer_con_indicazioni_operative OWNER TO postgres;

--
-- Name: stabfc852; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.stabfc852 (
    comune character varying,
    linea character varying,
    indirizzo character varying
);


ALTER TABLE config.stabfc852 OWNER TO postgres;

--
-- Name: stabfc853; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.stabfc853 (
    comune character varying,
    linea character varying,
    indirizzo character varying
);


ALTER TABLE config.stabfc853 OWNER TO postgres;

--
-- Name: tariffario_sicer; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.tariffario_sicer (
    macroarea character varying,
    codice character varying,
    descrizione character varying,
    codiceiva integer,
    tempisticheminime character varying,
    tipologiatariffa character varying,
    unitamisura character varying,
    note character varying,
    a character varying,
    b integer,
    legenda character varying,
    column12 character varying
);


ALTER TABLE config.tariffario_sicer OWNER TO postgres;

--
-- Name: tariffe; Type: TABLE; Schema: config; Owner: postgres
--

CREATE TABLE config.tariffe (
    descr character varying,
    sigla character varying
);


ALTER TABLE config.tariffe OWNER TO postgres;

--
-- Name: categorizzazione_rischio_tipo_stabilimento; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.categorizzazione_rischio_tipo_stabilimento (
    id bigint NOT NULL,
    id_categorizzazione_rischio bigint,
    id_tipo_stabilimento bigint
);


ALTER TABLE cu.categorizzazione_rischio_tipo_stabilimento OWNER TO postgres;

--
-- Name: categorizzazione_rischio_tipo_stabilimento_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.categorizzazione_rischio_tipo_stabilimento_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.categorizzazione_rischio_tipo_stabilimento_id_seq OWNER TO postgres;

--
-- Name: categorizzazione_rischio_tipo_stabilimento_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.categorizzazione_rischio_tipo_stabilimento_id_seq OWNED BY cu.categorizzazione_rischio_tipo_stabilimento.id;


--
-- Name: cu_altri_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_altri_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_altri_id_seq OWNER TO postgres;

--
-- Name: cu_altri_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_altri_id_seq OWNED BY cu.cu_altri.id;


--
-- Name: cu_automezzi; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_automezzi (
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_automezzo bigint NOT NULL
);


ALTER TABLE cu.cu_automezzi OWNER TO postgres;

--
-- Name: cu_categ_evals; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_categ_evals (
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_categ bigint NOT NULL,
    valore numeric NOT NULL
);


ALTER TABLE cu.cu_categ_evals OWNER TO postgres;

--
-- Name: cu_categ_eval_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_categ_eval_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_categ_eval_id_seq OWNER TO postgres;

--
-- Name: cu_categ_eval_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_categ_eval_id_seq OWNED BY cu.cu_categ_evals.id;


--
-- Name: cu_categ_evals_storico_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_categ_evals_storico_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_categ_evals_storico_id_seq OWNER TO postgres;

--
-- Name: cu_categ_evals_storico_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_categ_evals_storico_id_seq OWNED BY cu.cu_categ_evals_storico.id;


--
-- Name: cu_codice_cu; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_codice_cu
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_codice_cu OWNER TO postgres;

--
-- Name: cu_dichiarazioni; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_dichiarazioni (
    id bigint NOT NULL,
    id_cu_nucleo bigint NOT NULL,
    dichiarazione character varying NOT NULL
);


ALTER TABLE cu.cu_dichiarazioni OWNER TO postgres;

--
-- Name: cu_dichiarazioni_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_dichiarazioni_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_dichiarazioni_id_seq OWNER TO postgres;

--
-- Name: cu_dichiarazioni_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_dichiarazioni_id_seq OWNED BY cu.cu_dichiarazioni.id;


--
-- Name: cu_evidenza_linee; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_evidenza_linee (
    id bigint NOT NULL,
    id_evidenza bigint NOT NULL,
    id_cu_linea bigint NOT NULL,
    chiuso boolean DEFAULT false NOT NULL,
    id_fu bigint
);


ALTER TABLE cu.cu_evidenza_linee OWNER TO postgres;

--
-- Name: cu_evidenza_linee_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_evidenza_linee_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_evidenza_linee_id_seq OWNER TO postgres;

--
-- Name: cu_evidenza_linee_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_evidenza_linee_id_seq OWNED BY cu.cu_evidenza_linee.id;


--
-- Name: cu_evidenze; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_evidenze (
    id bigint NOT NULL,
    id_cu_oggetto_cl bigint NOT NULL,
    id_cu_grado_evidenza bigint,
    evidenza character varying,
    risultanza character varying,
    id_cu_classe_evidenza bigint NOT NULL,
    ord integer
);


ALTER TABLE cu.cu_evidenze OWNER TO postgres;

--
-- Name: cu_evidenze_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_evidenze_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_evidenze_id_seq OWNER TO postgres;

--
-- Name: cu_evidenze_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_evidenze_id_seq OWNED BY cu.cu_evidenze.id;


--
-- Name: cu_evidenze_sp; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_evidenze_sp (
    id bigint NOT NULL,
    id_cu bigint,
    id_cu_evidenza bigint,
    id_cu_grado_evidenza bigint,
    evidenza character varying,
    risultanza character varying,
    id_cu_classe_evidenza bigint NOT NULL,
    ord integer
);


ALTER TABLE cu.cu_evidenze_sp OWNER TO postgres;

--
-- Name: cu_evidenze_sosp_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_evidenze_sosp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_evidenze_sosp_id_seq OWNER TO postgres;

--
-- Name: cu_evidenze_sosp_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_evidenze_sosp_id_seq OWNED BY cu.cu_evidenze_sp.id;


--
-- Name: cu_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_id_seq OWNER TO postgres;

--
-- Name: cu_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_id_seq OWNED BY cu.cu.id;


--
-- Name: cu_indirizzi; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_indirizzi (
    id integer NOT NULL,
    id_cu bigint NOT NULL,
    id_indirizzo bigint NOT NULL
);


ALTER TABLE cu.cu_indirizzi OWNER TO postgres;

--
-- Name: cu_indirizzi_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_indirizzi_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_indirizzi_id_seq OWNER TO postgres;

--
-- Name: cu_indirizzi_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_indirizzi_id_seq OWNED BY cu.cu_indirizzi.id;


--
-- Name: cu_linee_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_linee_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_linee_id_seq OWNER TO postgres;

--
-- Name: cu_linee_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_linee_id_seq OWNED BY cu.cu_linee.id;


--
-- Name: cu_nominativo_provv; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_nominativo_provv (
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_nominativo bigint NOT NULL
);


ALTER TABLE cu.cu_nominativo_provv OWNER TO postgres;

--
-- Name: cu_nominativo_provv_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_nominativo_provv_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_nominativo_provv_id_seq OWNER TO postgres;

--
-- Name: cu_nominativo_provv_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_nominativo_provv_id_seq OWNED BY cu.cu_nominativo_provv.id;


--
-- Name: cu_norme_violate; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_norme_violate (
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_norma bigint NOT NULL
);


ALTER TABLE cu.cu_norme_violate OWNER TO postgres;

--
-- Name: cu_norme_violate_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_norme_violate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_norme_violate_id_seq OWNER TO postgres;

--
-- Name: cu_norme_violate_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_norme_violate_id_seq OWNED BY cu.cu_norme_violate.id;


--
-- Name: cu_nucleo_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_nucleo_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_nucleo_id_seq OWNER TO postgres;

--
-- Name: cu_nucleo_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_nucleo_id_seq OWNED BY cu.cu_nucleo.id;


--
-- Name: cu_nucleo_periodi; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_nucleo_periodi (
    id bigint NOT NULL,
    id_cu_nucleo bigint NOT NULL,
    periodo tsrange NOT NULL,
    id_cu_piano bigint
);


ALTER TABLE cu.cu_nucleo_periodi OWNER TO postgres;

--
-- Name: cu_nucleo_periodi_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_nucleo_periodi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_nucleo_periodi_id_seq OWNER TO postgres;

--
-- Name: cu_nucleo_periodi_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_nucleo_periodi_id_seq OWNED BY cu.cu_nucleo_periodi.id;


--
-- Name: cu_oggetti; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_oggetti (
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    ord integer NOT NULL,
    id_tipo_oggetto bigint NOT NULL,
    chiuso boolean DEFAULT false NOT NULL,
    id_stato_oggetto bigint
);


ALTER TABLE cu.cu_oggetti OWNER TO postgres;

--
-- Name: cu_oggetti_cl; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_oggetti_cl (
    id bigint NOT NULL,
    id_cu_oggetto bigint NOT NULL,
    id_requisito bigint NOT NULL,
    id_stato_cl bigint,
    chiuso boolean DEFAULT false NOT NULL
);


ALTER TABLE cu.cu_oggetti_cl OWNER TO postgres;

--
-- Name: cu_oggetti_cl_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_oggetti_cl_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_oggetti_cl_id_seq OWNER TO postgres;

--
-- Name: cu_oggetti_cl_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_oggetti_cl_id_seq OWNED BY cu.cu_oggetti_cl.id;


--
-- Name: cu_oggetti_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_oggetti_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_oggetti_id_seq OWNER TO postgres;

--
-- Name: cu_oggetti_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_oggetti_id_seq OWNED BY cu.cu_oggetti.id;


--
-- Name: cu_piani_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_piani_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_piani_id_seq OWNER TO postgres;

--
-- Name: cu_piani_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_piani_id_seq OWNED BY cu.cu_piani.id;


--
-- Name: cu_provv; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_provv (
    id bigint NOT NULL,
    id_norma_violata bigint NOT NULL,
    ord integer NOT NULL,
    id_tipo_provv bigint NOT NULL,
    azione character varying,
    dt date,
    chiuso boolean DEFAULT false NOT NULL,
    id_fu bigint
);


ALTER TABLE cu.cu_provv OWNER TO postgres;

--
-- Name: cu_provv_fu; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_provv_fu (
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_provv bigint NOT NULL,
    ord integer,
    risolta boolean
);


ALTER TABLE cu.cu_provv_fu OWNER TO postgres;

--
-- Name: cu_provv_fu_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_provv_fu_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_provv_fu_id_seq OWNER TO postgres;

--
-- Name: cu_provv_fu_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_provv_fu_id_seq OWNED BY cu.cu_provv_fu.id;


--
-- Name: cu_provv_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_provv_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_provv_id_seq OWNER TO postgres;

--
-- Name: cu_provv_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_provv_id_seq OWNED BY cu.cu_provv.id;


--
-- Name: cu_provv_sopralluogo; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_provv_sopralluogo (
    id integer NOT NULL,
    id_cu bigint,
    id_cu_grado_evidenza bigint,
    id_cu_classe_evidenza bigint NOT NULL,
    evidenza character varying,
    id_tipo_provv bigint NOT NULL,
    dt date,
    id_cu_linea bigint NOT NULL,
    id_piano bigint NOT NULL,
    id_nominativo bigint NOT NULL
);


ALTER TABLE cu.cu_provv_sopralluogo OWNER TO postgres;

--
-- Name: cu_provv_sopralluogo_fu; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.cu_provv_sopralluogo_fu (
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_provv bigint NOT NULL,
    ord integer,
    risolta boolean
);


ALTER TABLE cu.cu_provv_sopralluogo_fu OWNER TO postgres;

--
-- Name: cu_provv_sopralluogo_fu_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_provv_sopralluogo_fu_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_provv_sopralluogo_fu_id_seq OWNER TO postgres;

--
-- Name: cu_provv_sopralluogo_fu_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_provv_sopralluogo_fu_id_seq OWNED BY cu.cu_provv_sopralluogo_fu.id;


--
-- Name: cu_provv_sopralluogo_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.cu_provv_sopralluogo_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.cu_provv_sopralluogo_id_seq OWNER TO postgres;

--
-- Name: cu_provv_sopralluogo_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.cu_provv_sopralluogo_id_seq OWNED BY cu.cu_provv_sopralluogo.id;


--
-- Name: cu_stati_cl; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.cu_stati_cl (
    id bigint NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    cod character varying NOT NULL,
    ord integer,
    evidenze integer DEFAULT 1 NOT NULL
);


ALTER TABLE cu_types.cu_stati_cl OWNER TO postgres;

--
-- Name: cu_types_vw_cu_stati_cl; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.cu_types_vw_cu_stati_cl AS
 SELECT cu_stati_cl.id AS id_stato_cl,
    cu_stati_cl.id,
    cu_stati_cl.sigla,
    cu_stati_cl.descr,
    cu_stati_cl.cod,
    cu_stati_cl.ord
   FROM cu_types.cu_stati_cl;


ALTER TABLE cu.cu_types_vw_cu_stati_cl OWNER TO postgres;

--
-- Name: n; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.n (
    count bigint
);


ALTER TABLE cu.n OWNER TO postgres;

--
-- Name: nomi_file_pdf_controlli; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.nomi_file_pdf_controlli (
    id integer NOT NULL,
    nome character varying NOT NULL,
    id_cu bigint NOT NULL,
    validita tsrange DEFAULT tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL
);


ALTER TABLE cu.nomi_file_pdf_controlli OWNER TO postgres;

--
-- Name: nomi_file_pdf_controlli_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.nomi_file_pdf_controlli_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.nomi_file_pdf_controlli_id_seq OWNER TO postgres;

--
-- Name: nomi_file_pdf_controlli_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.nomi_file_pdf_controlli_id_seq OWNED BY cu.nomi_file_pdf_controlli.id;


--
-- Name: nomi_file_pdf_evidenze; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.nomi_file_pdf_evidenze (
    id integer NOT NULL,
    nome character varying NOT NULL,
    id_evidenza bigint NOT NULL,
    validita tsrange DEFAULT tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL
);


ALTER TABLE cu.nomi_file_pdf_evidenze OWNER TO postgres;

--
-- Name: nomi_file_pdf_evidenze_id_seq; Type: SEQUENCE; Schema: cu; Owner: postgres
--

CREATE SEQUENCE cu.nomi_file_pdf_evidenze_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu.nomi_file_pdf_evidenze_id_seq OWNER TO postgres;

--
-- Name: nomi_file_pdf_evidenze_id_seq; Type: SEQUENCE OWNED BY; Schema: cu; Owner: postgres
--

ALTER SEQUENCE cu.nomi_file_pdf_evidenze_id_seq OWNED BY cu.nomi_file_pdf_evidenze.id;


--
-- Name: r1; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.r1 (
    indirizzo_azienda character varying,
    cap_azienda character varying,
    codice_istat character varying,
    latitudine double precision,
    longitudine double precision
);


ALTER TABLE cu.r1 OWNER TO postgres;

--
-- Name: r5; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.r5 (
    id bigint,
    id_fiscale_prop character varying,
    cf character varying,
    piva character varying,
    cod_timpo_impresa text,
    sdi bigint,
    fonte text,
    dat_apertura_azienda timestamp without time zone,
    data_chius_azienda timestamp without time zone
);


ALTER TABLE cu.r5 OWNER TO postgres;

--
-- Name: rec; Type: TABLE; Schema: cu; Owner: postgres
--

CREATE TABLE cu.rec (
    minval timestamp without time zone,
    min timestamp without time zone,
    maxval timestamp without time zone
);


ALTER TABLE cu.rec OWNER TO postgres;

--
-- Name: cu_categ; Type: TABLE; Schema: cu_conf; Owner: postgres
--

CREATE TABLE cu_conf.cu_categ (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    fattore numeric,
    peso numeric,
    validita tsrange
);


ALTER TABLE cu_conf.cu_categ OWNER TO postgres;

--
-- Name: cu_categ_nodes; Type: TABLE; Schema: cu_conf; Owner: postgres
--

CREATE TABLE cu_conf.cu_categ_nodes (
    id bigint DEFAULT nextval('cu.cu_id_seq'::regclass),
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying,
    id_node_parent integer
);


ALTER TABLE cu_conf.cu_categ_nodes OWNER TO postgres;

--
-- Name: vw_cu_categ_nodes; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_categ_nodes AS
 SELECT n.id AS id_node,
    n.id_parent AS id_node_parent,
    n.ordinamento,
    n.node_descr
   FROM cu_conf.cu_categ_nodes n;


ALTER TABLE cu_conf.vw_cu_categ_nodes OWNER TO postgres;

--
-- Name: vw_cu_categ_nodes_up; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_categ_nodes_up AS
 WITH RECURSIVE vw_cu_categ_nodes_up(id_node, id_node_parent, path) AS (
         SELECT vw_cu_categ_nodes.id_node,
            vw_cu_categ_nodes.id_node_parent,
            (vw_cu_categ_nodes.id_node)::text AS path,
            vw_cu_categ_nodes.ordinamento AS path_ord,
            vw_cu_categ_nodes.node_descr AS path_descr,
            0 AS lv,
            vw_cu_categ_nodes.node_descr,
            vw_cu_categ_nodes.ordinamento
           FROM cu_conf.vw_cu_categ_nodes
          WHERE (vw_cu_categ_nodes.id_node_parent IS NULL)
        UNION ALL
         SELECT n.id_node,
            n.id_node_parent,
            ((up.path || '/'::text) || n.id_node),
            (((up.path_ord)::text || '/'::text) || (n.ordinamento)::text),
            (((up.path_descr)::text || '/'::text) || (n.node_descr)::text),
            (up.lv + 1) AS lv,
            (n.node_descr)::text AS node_descr,
            up.ordinamento
           FROM (vw_cu_categ_nodes_up up
             JOIN cu_conf.vw_cu_categ_nodes n ON ((up.id_node = n.id_node_parent)))
        )
 SELECT vw_cu_categ_nodes_up.id_node,
    vw_cu_categ_nodes_up.id_node_parent,
    vw_cu_categ_nodes_up.path,
    vw_cu_categ_nodes_up.path_ord,
    vw_cu_categ_nodes_up.path_descr,
    vw_cu_categ_nodes_up.lv,
    vw_cu_categ_nodes_up.node_descr,
    vw_cu_categ_nodes_up.ordinamento
   FROM vw_cu_categ_nodes_up
  ORDER BY vw_cu_categ_nodes_up.path;


ALTER TABLE cu_conf.vw_cu_categ_nodes_up OWNER TO postgres;

--
-- Name: vw_cu_categ_nodes_up_descr; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_categ_nodes_up_descr AS
 SELECT c.id,
    c.cod,
    c.sigla,
    c.descr,
    c.fattore,
    c.peso,
    c.validita,
    cn.id_node,
    cn.id_node_parent,
    cn.path,
    cn.path_ord,
    cn.path_descr,
    cn.lv,
    cn.node_descr,
    cn.ordinamento
   FROM (cu_conf.vw_cu_categ_nodes_up cn
     JOIN cu_conf.cu_categ c ON ((cn.id_node = c.id)));


ALTER TABLE cu_conf.vw_cu_categ_nodes_up_descr OWNER TO postgres;

--
-- Name: vw_cu_categ_evals; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_categ_evals AS
 SELECT e.id AS id_categ_eval,
    e.id,
    e.id_cu,
    e.id_categ,
    e.valore,
    n.descr,
    n.id_node_parent AS id_nodo_padre
   FROM (cu.cu_categ_evals e
     JOIN cu_conf.vw_cu_categ_nodes_up_descr n ON ((e.id_categ = n.id_node)));


ALTER TABLE cu.vw_cu_categ_evals OWNER TO postgres;

--
-- Name: vw_cu_categ_evals_storico; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_categ_evals_storico AS
 SELECT cs.id AS id_categ_storico,
    cs.id_cu,
    cs.id_stabilimento,
    cs.valore,
    e.descr,
    cs.dt_storico
   FROM (cu.cu_categ_evals_storico cs
     JOIN cu_conf.vw_cu_categ_esiti e ON ((e.rng @> cs.valore)));


ALTER TABLE cu.vw_cu_categ_evals_storico OWNER TO postgres;

--
-- Name: vw_cu_periodo; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_periodo AS
 SELECT cn.id_cu,
    min(lower(cnp.periodo)) AS cu_inizio,
    max(upper(cnp.periodo)) AS cu_fine
   FROM (cu.cu_nucleo_periodi cnp
     JOIN cu.cu_nucleo cn ON ((cnp.id_cu_nucleo = cn.id)))
  GROUP BY cn.id_cu;


ALTER TABLE cu.vw_cu_periodo OWNER TO postgres;

--
-- Name: vw_cu_con_periodo; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_con_periodo AS
 SELECT c.id_cu,
    c.id,
    c.codice,
    c.dt,
    c.id_tecnica,
    c.preavviso,
    c.rilievi,
    c.id_evento,
    c.sigla_tecnica,
    c.descr_tecnica,
    c.id_az_sede,
    p.cu_inizio,
    p.cu_fine,
    c.denominazione_sede_operativa,
    c.chiuso,
    c.stato,
    c.dt_chiusura,
    c.pec,
    c.id_responsabile,
    c.nominativo_responsabile,
    c.cod_regionale
   FROM (cu.vw_cu c
     LEFT JOIN cu.vw_cu_periodo p ON ((c.id_cu = p.id_cu)));


ALTER TABLE cu.vw_cu_con_periodo OWNER TO postgres;

--
-- Name: vw_cu_dichiarazioni; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_dichiarazioni AS
 SELECT d.id AS id_dichiarazione,
    d.id,
    d.id_cu_nucleo,
    d.dichiarazione,
    n.id_cu,
    n.nominativo
   FROM (cu.cu_dichiarazioni d
     JOIN cu.vw_cu_nucleo n ON ((n.id_cu_nucleo = d.id_cu_nucleo)));


ALTER TABLE cu.vw_cu_dichiarazioni OWNER TO postgres;

--
-- Name: cu_tipo_oggetti; Type: TABLE; Schema: cu_conf; Owner: postgres
--

CREATE TABLE cu_conf.cu_tipo_oggetti (
    id bigint NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    cod character varying,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '[)'::text) NOT NULL,
    ord integer DEFAULT 1 NOT NULL
);


ALTER TABLE cu_conf.cu_tipo_oggetti OWNER TO postgres;

--
-- Name: cu_tipo_oggetto_piani; Type: TABLE; Schema: cu_conf; Owner: postgres
--

CREATE TABLE cu_conf.cu_tipo_oggetto_piani (
    id bigint NOT NULL,
    id_tipo_oggetto bigint NOT NULL,
    id_piano bigint NOT NULL
);


ALTER TABLE cu_conf.cu_tipo_oggetto_piani OWNER TO postgres;

--
-- Name: vw_cu_tipo_oggetti; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_tipo_oggetti AS
 SELECT cto.id AS id_tipo_oggetto,
    cto.id,
    cto.sigla,
    cto.descr,
    cto.cod,
    cto.validita,
    cto.ord
   FROM cu_conf.cu_tipo_oggetti cto
  ORDER BY cto.ord;


ALTER TABLE cu_conf.vw_cu_tipo_oggetti OWNER TO postgres;

--
-- Name: vw_cu_tipo_oggetto_piani; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_tipo_oggetto_piani AS
 SELECT tp.id AS id_tipo_oggetto_piani,
    tp.id,
    tp.id_tipo_oggetto,
    tp.id_piano,
    t.descr AS descr_tipo_oggetto,
    p.alias AS alias_paino,
    p.descrizione AS descr_piano,
    t.sigla AS sigla_oggetto,
    p.alias AS alias_piano,
    t.validita
   FROM ((cu_conf.cu_tipo_oggetto_piani tp
     JOIN cu_conf.vw_cu_tipo_oggetti t ON ((tp.id_tipo_oggetto = t.id_tipo_oggetto)))
     JOIN matrix.vw_struttura_piani p ON ((p.id = tp.id_piano)));


ALTER TABLE cu_conf.vw_cu_tipo_oggetto_piani OWNER TO postgres;

--
-- Name: vw_tipo_oggetti_obbl; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_tipo_oggetti_obbl AS
 SELECT DISTINCT cp.id_cu,
    op.id_tipo_oggetto
   FROM (cu.vw_cu_piani cp
     JOIN cu_conf.vw_cu_tipo_oggetto_piani op ON ((cp.id_piano = op.id_piano)));


ALTER TABLE cu.vw_tipo_oggetti_obbl OWNER TO postgres;

--
-- Name: cu_stati_oggetto; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.cu_stati_oggetto (
    id bigint NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    cod character varying NOT NULL,
    ord integer,
    evidenze integer DEFAULT 1 NOT NULL,
    tooltip character varying
);


ALTER TABLE cu_types.cu_stati_oggetto OWNER TO postgres;

--
-- Name: vw_cu_oggetti; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_oggetti AS
 SELECT o.id AS id_cu_oggetto,
    o.id,
    o.id_cu,
    o.ord,
    o.id_tipo_oggetto,
    t.sigla AS sigla_oggetto,
    t.descr AS descr_oggetto,
    t.cod AS cod_oggetto,
    c.id_az_sede,
    s.nome AS denominazione_sede_operativa,
    (ob.id_cu IS NULL) AS obbligatorio,
    (ob.id_cu IS NULL) AS selezionabile,
    o.id_stato_oggetto,
    o.chiuso,
    cso.descr AS descr_stato,
    cso.sigla AS sigla_stato,
    c.dt AS dt_cu
   FROM (((((cu.cu_oggetti o
     JOIN cu.cu c ON ((o.id_cu = c.id)))
     JOIN cu_anag.stabilimenti s ON ((c.id_az_sede = s.id)))
     JOIN cu_conf.vw_cu_tipo_oggetti t ON ((t.id_tipo_oggetto = o.id_tipo_oggetto)))
     LEFT JOIN cu.vw_tipo_oggetti_obbl ob ON (((ob.id_cu = o.id_cu) AND (ob.id_tipo_oggetto = o.id_tipo_oggetto))))
     LEFT JOIN cu_types.cu_stati_oggetto cso ON ((o.id_stato_oggetto = cso.id)));


ALTER TABLE cu.vw_cu_oggetti OWNER TO postgres;

--
-- Name: cu_norme; Type: TABLE; Schema: cu_conf; Owner: postgres
--

CREATE TABLE cu_conf.cu_norme (
    id bigint NOT NULL,
    norma character varying,
    regolamento character varying
);


ALTER TABLE cu_conf.cu_norme OWNER TO postgres;

--
-- Name: cu_requisiti; Type: TABLE; Schema: cu_conf; Owner: postgres
--

CREATE TABLE cu_conf.cu_requisiti (
    id bigint NOT NULL,
    id_tipo_oggetto bigint NOT NULL,
    ord integer NOT NULL,
    norma character varying NOT NULL,
    descr character varying NOT NULL,
    cl character varying NOT NULL,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '[)'::text) NOT NULL,
    id_norma bigint,
    enum_list json,
    tabella json
);


ALTER TABLE cu_conf.cu_requisiti OWNER TO postgres;

--
-- Name: vw_cu_norme; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_norme AS
 SELECT cu_norme.id AS id_norma,
    cu_norme.id,
    cu_norme.norma,
    cu_norme.regolamento
   FROM cu_conf.cu_norme;


ALTER TABLE cu_conf.vw_cu_norme OWNER TO postgres;

--
-- Name: vw_cu_requisiti; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_requisiti AS
 SELECT r.id AS id_requisito,
    r.id,
    r.id_tipo_oggetto,
    r.ord,
    n.norma,
    r.descr,
    r.cl,
    t.sigla AS tipo_oggetto_sigla,
    t.cod AS tipo_oggetto_cod,
    t.descr AS tipo_oggetto_descr,
    n.id_norma,
    r.enum_list,
    r.tabella
   FROM ((cu_conf.cu_requisiti r
     JOIN cu_conf.vw_cu_tipo_oggetti t ON ((t.id_tipo_oggetto = r.id_tipo_oggetto)))
     JOIN cu_conf.vw_cu_norme n ON ((n.id_norma = r.id_norma)))
  ORDER BY t.ord, r.ord;


ALTER TABLE cu_conf.vw_cu_requisiti OWNER TO postgres;

--
-- Name: vw_cu_stati_cl; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_cu_stati_cl AS
 SELECT cu_stati_cl.id AS id_stato_cl,
    cu_stati_cl.id,
    cu_stati_cl.sigla,
    cu_stati_cl.descr,
    cu_stati_cl.cod,
    cu_stati_cl.ord,
    cu_stati_cl.evidenze
   FROM cu_types.cu_stati_cl;


ALTER TABLE cu_types.vw_cu_stati_cl OWNER TO postgres;

--
-- Name: vw_cu_oggetti_cl; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_oggetti_cl AS
 SELECT cl.id AS id_cu_oggetto_cl,
    cl.id,
    cl.id_cu_oggetto,
    cl.id_requisito,
    o.sigla_oggetto,
    o.descr_oggetto,
    r.descr AS descr_requisito,
    cl.chiuso,
    cl.id_stato_cl,
    s.sigla AS sigla_stato,
    s.descr AS descr_stato,
    o.id_cu,
    o.id_az_sede,
    o.denominazione_sede_operativa,
    r.ord,
    r.norma,
    r.id_norma,
    o.dt_cu,
    o.id_tipo_oggetto,
    r.enum_list,
    r.tabella
   FROM (((cu.cu_oggetti_cl cl
     JOIN cu_conf.vw_cu_requisiti r ON ((r.id_requisito = cl.id_requisito)))
     JOIN cu.vw_cu_oggetti o ON ((o.id_cu_oggetto = cl.id_cu_oggetto)))
     LEFT JOIN cu_types.vw_cu_stati_cl s ON ((s.id_stato_cl = cl.id_stato_cl)));


ALTER TABLE cu.vw_cu_oggetti_cl OWNER TO postgres;

--
-- Name: cu_classe_evidenze; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.cu_classe_evidenze (
    id bigint NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    cod character varying NOT NULL,
    ord integer
);


ALTER TABLE cu_types.cu_classe_evidenze OWNER TO postgres;

--
-- Name: cu_grado_evidenze; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.cu_grado_evidenze (
    id bigint NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    cod character varying
);


ALTER TABLE cu_types.cu_grado_evidenze OWNER TO postgres;

--
-- Name: vw_cu_classe_evidenze; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_cu_classe_evidenze AS
 SELECT g.id AS id_cu_classe_evidenza,
    g.id,
    g.sigla,
    g.descr,
    g.cod
   FROM cu_types.cu_classe_evidenze g;


ALTER TABLE cu_types.vw_cu_classe_evidenze OWNER TO postgres;

--
-- Name: vw_cu_grado_evidenze; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_cu_grado_evidenze AS
 SELECT g.id AS id_cu_grado_evidenza,
    g.id,
    g.sigla,
    g.descr,
    g.cod
   FROM cu_types.cu_grado_evidenze g;


ALTER TABLE cu_types.vw_cu_grado_evidenze OWNER TO postgres;

--
-- Name: vw_cu_evidenze; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_evidenze AS
 SELECT e.id AS id_evidenza,
    e.id,
    e.id_cu_oggetto_cl,
    e.id_cu_grado_evidenza,
    e.evidenza,
    e.risultanza,
    e.id_cu_classe_evidenza,
    g.sigla AS sigla_grado_evidenza,
    c.sigla AS sigla_classe_evidenza,
    g.descr AS descr_grado_evidenza,
    c.descr AS descr_classe_evidenza,
    cl.descr_oggetto,
    cl.descr_requisito,
    cl.id_cu,
    cl.id_cu_oggetto,
    cl.id_az_sede,
    cl.denominazione_sede_operativa,
    cl.norma,
    cl.id_norma,
    e.ord,
    cl.id_tipo_oggetto
   FROM (((cu.cu_evidenze e
     JOIN cu.vw_cu_oggetti_cl cl ON ((cl.id_cu_oggetto_cl = e.id_cu_oggetto_cl)))
     LEFT JOIN cu_types.vw_cu_grado_evidenze g ON ((g.id_cu_grado_evidenza = e.id_cu_grado_evidenza)))
     JOIN cu_types.vw_cu_classe_evidenze c ON ((c.id_cu_classe_evidenza = e.id_cu_classe_evidenza)));


ALTER TABLE cu.vw_cu_evidenze OWNER TO postgres;

--
-- Name: vw_cu_evidenza_linee; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_evidenza_linee AS
 SELECT el.id AS id_evidenza_linea,
    el.id,
    el.id_evidenza,
    el.id_cu_linea,
    e.id_cu_oggetto_cl,
    e.id_cu_oggetto,
    e.id_cu,
    e.id_norma,
    e.norma,
    e.evidenza,
    e.sigla_grado_evidenza,
    e.sigla_classe_evidenza,
    e.descr_grado_evidenza,
    e.descr_classe_evidenza
   FROM (cu.cu_evidenza_linee el
     JOIN cu.vw_cu_evidenze e ON ((e.id_evidenza = el.id_evidenza)));


ALTER TABLE cu.vw_cu_evidenza_linee OWNER TO postgres;

--
-- Name: vw_cu_info_reportistica; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_info_reportistica AS
 SELECT cp.codice,
    cp.id_piano,
    cp.per_conto,
    cp.dt,
    cp.id_az_sede AS id_stabilimento,
    s.cod_tipologia_struttura,
    s.piva_impresa,
    s.cf_impresa,
    cp.chiuso
   FROM (cu.vw_cu_piani cp
     JOIN cu_anag.vw_stabilimenti_all s ON ((cp.id_az_sede = s.id)));


ALTER TABLE cu.vw_cu_info_reportistica OWNER TO postgres;

--
-- Name: vw_cu_linee; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_linee AS
 SELECT l.id AS id_cu_linea,
    l.id,
    l.id_cu,
    l.id_linea,
    l.ord,
    al.denominazione_sede_operativa,
    al.comune,
    al.desc_tipo_linea,
    c.id_az_sede,
    l.linea_originaria
   FROM ((cu.cu_linee l
     JOIN cu.cu c ON ((l.id_cu = c.id)))
     JOIN agenda.vw_linee al ON ((al.id_linea = l.id_linea)));


ALTER TABLE cu.vw_cu_linee OWNER TO postgres;

--
-- Name: vw_cu_nominativo_provv; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_nominativo_provv AS
 SELECT c.id_cu,
    c.codice,
    vns.id_nominativo,
    vns.nominativo,
    vns.id_struttura,
    vns.descrizione_breve,
    np.id AS id_nominativo_provv
   FROM ((cu.cu_nominativo_provv np
     JOIN cu.vw_cu c ON ((c.id_cu = np.id_cu)))
     LEFT JOIN matrix.vw_nominativi_struttura vns ON ((vns.id_nominativo = np.id_nominativo)));


ALTER TABLE cu.vw_cu_nominativo_provv OWNER TO postgres;

--
-- Name: vw_cu_norme_violate; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_norme_violate AS
 SELECT nv.id AS id_norma_violata,
    nv.id,
    nv.id_cu,
    nv.id_norma,
    n.norma,
    c.chiuso AS cu_chiuso
   FROM ((cu.cu_norme_violate nv
     JOIN cu.cu c ON ((c.id = nv.id_cu)))
     JOIN cu_conf.vw_cu_norme n ON ((n.id_norma = nv.id_norma)));


ALTER TABLE cu.vw_cu_norme_violate OWNER TO postgres;

--
-- Name: vw_cu_nucleo_e; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_nucleo_e AS
 SELECT vw_cu_nucleo.id_cu_nucleo,
    vw_cu_nucleo.id,
    vw_cu_nucleo.id_cu,
    vw_cu_nucleo.id_ns,
    vw_cu_nucleo.ord,
    vw_cu_nucleo.id_tipo_isp,
    vw_cu_nucleo.nominativo,
    vw_cu_nucleo.id_tipo_nucleo,
    vw_cu_nucleo.sigla_tipo_nucleo,
    vw_cu_nucleo.descr_tipo_nucleo,
    vw_cu_nucleo.ruolo
   FROM cu.vw_cu_nucleo
  WHERE ((vw_cu_nucleo.sigla_tipo_nucleo)::text = 'E'::text);


ALTER TABLE cu.vw_cu_nucleo_e OWNER TO postgres;

--
-- Name: vw_cu_nucleo_ni; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_nucleo_ni AS
 SELECT vw_cu_nucleo.id_cu_nucleo,
    vw_cu_nucleo.id,
    vw_cu_nucleo.id_cu,
    vw_cu_nucleo.id_ns,
    vw_cu_nucleo.ord,
    vw_cu_nucleo.id_tipo_isp,
    vw_cu_nucleo.nominativo,
    vw_cu_nucleo.id_tipo_nucleo,
    vw_cu_nucleo.sigla_tipo_nucleo,
    vw_cu_nucleo.descr_tipo_nucleo,
    vw_cu_nucleo.ruolo,
    vw_cu_nucleo.id_nominativo,
    vw_cu_nucleo.sigla_tipo_isp
   FROM cu.vw_cu_nucleo
  WHERE ((vw_cu_nucleo.sigla_tipo_nucleo)::text = 'NI'::text);


ALTER TABLE cu.vw_cu_nucleo_ni OWNER TO postgres;

--
-- Name: vw_cu_nucleo_p; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_nucleo_p AS
 SELECT vw_cu_nucleo.id_cu_nucleo,
    vw_cu_nucleo.id,
    vw_cu_nucleo.id_cu,
    vw_cu_nucleo.id_ns,
    vw_cu_nucleo.ord,
    vw_cu_nucleo.id_tipo_isp,
    vw_cu_nucleo.nominativo,
    vw_cu_nucleo.id_tipo_nucleo,
    vw_cu_nucleo.sigla_tipo_nucleo,
    vw_cu_nucleo.descr_tipo_nucleo,
    vw_cu_nucleo.ruolo,
    vw_cu_nucleo.custode_verbale
   FROM cu.vw_cu_nucleo
  WHERE ((vw_cu_nucleo.sigla_tipo_nucleo)::text = 'P'::text);


ALTER TABLE cu.vw_cu_nucleo_p OWNER TO postgres;

--
-- Name: vw_cu_nucleo_periodi; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_nucleo_periodi AS
 SELECT p.id AS id_nucleo_periodo,
    p.id,
    n.id AS id_cu_nucleo,
    p.periodo AS "interval",
    n.sigla_tipo_nucleo,
    n.nominativo,
    n.id_cu,
    lower(p.periodo) AS inizio,
    upper(p.periodo) AS fine,
    (n.ruolo)::character varying AS ruolo,
    cp.sigla_piano,
    cp.descrizione_piano,
    p.id_cu_piano,
    ns.descrizione_breve AS descrizione_struttura,
    ti.sigla AS sigla_isp,
    ti.descr AS descr_isp,
    n.id_tipo_nucleo,
    a.nome,
    a.cognome,
    (((a.nome)::text || ' '::text) || (a.cognome)::text) AS nominativo_altri,
    tp.sigla AS sigla_per,
    tp.descr AS descr_per,
    tp.id_tipo_per,
    an.qualifica_cu,
    ns.id_nominativo,
    ns.id_anagrafica,
    n.dt_nascita,
    n.comune_nascita,
    n.cf,
    n.custode_verbale
   FROM (((((((cu.vw_cu_nucleo n
     LEFT JOIN matrix.vw_nominativi_struttura ns ON ((ns.id_nominativo = n.id_nominativo)))
     LEFT JOIN agenda.vw_nominativi an ON ((an.id_anagrafica = ns.id_anagrafica)))
     LEFT JOIN cu.cu_nucleo_periodi p ON ((p.id_cu_nucleo = n.id)))
     LEFT JOIN cu.vw_cu_piani cp ON ((p.id_cu_piano = cp.id)))
     LEFT JOIN cu_conf.vw_cu_tipo_isp ti ON ((ti.id_tipo_isp = n.id_tipo_isp)))
     LEFT JOIN cu_conf.vw_cu_tipo_per tp ON ((tp.id_tipo_per = n.id_tipo_per)))
     LEFT JOIN cu.cu_altri a ON ((a.id = n.id_nominativo)));


ALTER TABLE cu.vw_cu_nucleo_periodi OWNER TO postgres;

--
-- Name: vw_cu_nucleo_periodi_e; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_nucleo_periodi_e AS
 SELECT vw_cu_nucleo_periodi.id_nucleo_periodo,
    vw_cu_nucleo_periodi.id,
    vw_cu_nucleo_periodi.id_cu_nucleo,
    vw_cu_nucleo_periodi."interval",
    vw_cu_nucleo_periodi.sigla_tipo_nucleo,
    vw_cu_nucleo_periodi.nominativo,
    vw_cu_nucleo_periodi.id_cu,
    vw_cu_nucleo_periodi.inizio,
    vw_cu_nucleo_periodi.fine,
    vw_cu_nucleo_periodi.ruolo
   FROM cu.vw_cu_nucleo_periodi
  WHERE ((vw_cu_nucleo_periodi.sigla_tipo_nucleo)::text = 'E'::text);


ALTER TABLE cu.vw_cu_nucleo_periodi_e OWNER TO postgres;

--
-- Name: vw_cu_nucleo_periodi_ni; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_nucleo_periodi_ni AS
 SELECT vw_cu_nucleo_periodi.id_nucleo_periodo,
    vw_cu_nucleo_periodi.id,
    vw_cu_nucleo_periodi.id_cu_nucleo,
    vw_cu_nucleo_periodi."interval",
    vw_cu_nucleo_periodi.sigla_tipo_nucleo,
    vw_cu_nucleo_periodi.nominativo,
    vw_cu_nucleo_periodi.id_cu,
    vw_cu_nucleo_periodi.inizio,
    vw_cu_nucleo_periodi.fine,
    vw_cu_nucleo_periodi.ruolo
   FROM cu.vw_cu_nucleo_periodi
  WHERE ((vw_cu_nucleo_periodi.sigla_tipo_nucleo)::text = 'NI'::text);


ALTER TABLE cu.vw_cu_nucleo_periodi_ni OWNER TO postgres;

--
-- Name: vw_cu_nucleo_periodi_p; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_nucleo_periodi_p AS
 SELECT vw_cu_nucleo_periodi.id_nucleo_periodo,
    vw_cu_nucleo_periodi.id,
    vw_cu_nucleo_periodi.id_cu_nucleo,
    vw_cu_nucleo_periodi."interval",
    vw_cu_nucleo_periodi.sigla_tipo_nucleo,
    vw_cu_nucleo_periodi.nominativo,
    vw_cu_nucleo_periodi.id_cu,
    vw_cu_nucleo_periodi.inizio,
    vw_cu_nucleo_periodi.fine,
    vw_cu_nucleo_periodi.ruolo
   FROM cu.vw_cu_nucleo_periodi
  WHERE ((vw_cu_nucleo_periodi.sigla_tipo_nucleo)::text = 'E'::text);


ALTER TABLE cu.vw_cu_nucleo_periodi_p OWNER TO postgres;

--
-- Name: cu_tipi_provv; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.cu_tipi_provv (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    data_richiesta boolean NOT NULL,
    fu_richiesto boolean DEFAULT false NOT NULL,
    durata numeric,
    tempo character varying,
    unit character varying,
    ord integer
);


ALTER TABLE cu_types.cu_tipi_provv OWNER TO postgres;

--
-- Name: vw_cu_tipi_provv; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_cu_tipi_provv AS
 SELECT cu_tipi_provv.id AS id_tipo_provv,
    cu_tipi_provv.id,
    cu_tipi_provv.cod,
    cu_tipi_provv.sigla,
    cu_tipi_provv.descr,
    cu_tipi_provv.data_richiesta,
    cu_tipi_provv.fu_richiesto,
    cu_tipi_provv.ord
   FROM cu_types.cu_tipi_provv;


ALTER TABLE cu_types.vw_cu_tipi_provv OWNER TO postgres;

--
-- Name: vw_cu_provv; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_provv AS
 SELECT p.id AS id_provv,
    p.id,
    p.id_norma_violata AS id_evidenza,
    p.ord,
    p.id_tipo_provv,
    p.azione,
    p.dt,
    t.sigla AS sigla_tipo_provv,
    t.descr AS descr_tipo_provv,
    ((t.descr)::text || COALESCE((' '::text || to_char((p.dt)::timestamp with time zone, 'DD/MM/YYYY'::text)), ''::text)) AS descr_provv,
    t.fu_richiesto,
    nv.id_cu,
    c.id_az_sede,
    p.chiuso,
    p.id_fu,
    nv.id_norma,
    nv.norma
   FROM (((cu.cu_provv p
     JOIN cu_types.vw_cu_tipi_provv t ON ((t.id_tipo_provv = p.id_tipo_provv)))
     JOIN cu.vw_cu_norme_violate nv ON ((nv.id_norma_violata = p.id_norma_violata)))
     JOIN cu.cu c ON ((c.id = nv.id_cu)));


ALTER TABLE cu.vw_cu_provv OWNER TO postgres;

--
-- Name: vw_cu_provv_fu; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_provv_fu AS
 SELECT p.id AS id_provv_fu,
    cp.id_provv,
    cp.id_evidenza,
    cp.ord,
    cp.id_tipo_provv,
    cp.azione,
    cp.dt,
    t.sigla AS sigla_tipo_provv,
    t.descr AS descr_tipo_provv,
    ((t.descr)::text || COALESCE((' '::text || to_char((cp.dt)::timestamp with time zone, 'DD/MM/YYYY'::text)), ''::text)) AS descr_provv,
    t.fu_richiesto,
    p.id_cu,
    c.id_az_sede,
    p.risolta,
        CASE
            WHEN p.risolta THEN 'Risolto'::text
            WHEN (NOT p.risolta) THEN 'Non Risolto'::text
            WHEN (p.risolta IS NULL) THEN ''::text
            ELSE NULL::text
        END AS risolta_descr,
    cp.id_norma,
    cp.norma
   FROM (((cu.cu_provv_fu p
     JOIN cu.vw_cu_provv cp ON ((cp.id_provv = p.id_provv)))
     JOIN cu_types.vw_cu_tipi_provv t ON ((t.id_tipo_provv = cp.id_tipo_provv)))
     JOIN cu.cu c ON ((c.id = p.id_cu)));


ALTER TABLE cu.vw_cu_provv_fu OWNER TO postgres;

--
-- Name: vw_cu_provv_sopralluogo; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_provv_sopralluogo AS
 SELECT p.id,
    p.id_cu,
    p.id_cu_grado_evidenza,
    p.id_cu_classe_evidenza,
    p.evidenza,
    p.id_tipo_provv,
    p.dt,
    t.sigla AS sigla_tipo_provv,
    t.descr AS descr_tipo_provv,
    ((t.descr)::text || COALESCE((' '::text || to_char((p.dt)::timestamp with time zone, 'DD/MM/YYYY'::text)), ''::text)) AS descr_provv,
    g.sigla AS sigla_grado_evidenza,
    c.sigla AS sigla_classe_evidenza,
    g.descr AS descr_grado_evidenza,
    c.descr AS descr_classe_evidenza,
    l.desc_tipo_linea AS descr_linee,
    pp.id AS id_piano,
    ((pp.alias || ' - '::text) || pp.descrizione) AS descrizione_completa_piano,
    pp.descrizione_breve AS sigla_piano,
    pp.alias,
    vns.nominativo AS nominativo_vet,
    p.id_nominativo
   FROM ((((((cu.cu_provv_sopralluogo p
     JOIN cu_types.vw_cu_tipi_provv t ON ((t.id_tipo_provv = p.id_tipo_provv)))
     LEFT JOIN cu_types.vw_cu_grado_evidenze g ON ((g.id_cu_grado_evidenza = p.id_cu_grado_evidenza)))
     JOIN cu_types.vw_cu_classe_evidenze c ON ((c.id_cu_classe_evidenza = p.id_cu_classe_evidenza)))
     JOIN cu.vw_cu_linee l ON ((l.id_cu_linea = p.id_cu_linea)))
     JOIN matrix.vw_tree_nodes_up_piani pp ON ((pp.id = p.id_piano)))
     LEFT JOIN matrix.vw_nominativi_struttura vns ON ((vns.id_nominativo = p.id_nominativo)));


ALTER TABLE cu.vw_cu_provv_sopralluogo OWNER TO postgres;

--
-- Name: vw_cu_provv_sopralluogo_fu; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_cu_provv_sopralluogo_fu AS
 SELECT pf.id,
    pf.id_cu,
    p.id_cu AS id_cu_org,
    p.id_cu_grado_evidenza,
    p.id_cu_classe_evidenza,
    p.evidenza,
    p.id_tipo_provv,
    p.dt,
    p.sigla_tipo_provv,
    p.descr_tipo_provv,
    p.descr_provv,
    p.sigla_grado_evidenza,
    p.sigla_classe_evidenza,
    p.descr_grado_evidenza,
    p.descr_classe_evidenza,
    p.descr_linee,
    p.id_piano,
    p.descrizione_completa_piano,
    p.sigla_piano,
    p.alias,
    p.nominativo_vet,
    p.id_nominativo,
    pf.risolta,
        CASE
            WHEN pf.risolta THEN 'Risolto'::text
            WHEN (NOT pf.risolta) THEN 'Non Risolto'::text
            WHEN (pf.risolta IS NULL) THEN ''::text
            ELSE NULL::text
        END AS risolta_descr
   FROM (cu.cu_provv_sopralluogo_fu pf
     JOIN cu.vw_cu_provv_sopralluogo p ON ((pf.id_provv = p.id)));


ALTER TABLE cu.vw_cu_provv_sopralluogo_fu OWNER TO postgres;

--
-- Name: vw_evidenza_lista_linee; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_evidenza_lista_linee AS
 SELECT el.id_evidenza AS id_cu_evidenza,
    string_agg(l.desc_tipo_linea, ', '::text) AS descr,
    cl.id AS id_cu_linea
   FROM ((cu.cu_evidenza_linee el
     JOIN cu.cu_linee cl ON ((cl.id = el.id_cu_linea)))
     JOIN cu_anag.vw_linee_all l ON ((l.id = cl.id_linea)))
  GROUP BY el.id_evidenza, cl.id;


ALTER TABLE cu.vw_evidenza_lista_linee OWNER TO postgres;

--
-- Name: vw_evidenza_numero_provv; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_evidenza_numero_provv AS
 SELECT e.id AS id_evidenza,
    COALESCE(p.n_provv, (0)::bigint) AS n_provv
   FROM (cu.cu_evidenze e
     LEFT JOIN ( SELECT p_1.id_norma_violata AS id_evidenza,
            count(*) AS n_provv
           FROM cu.cu_provv p_1
          GROUP BY p_1.id_norma_violata) p ON ((e.id = p.id_evidenza)));


ALTER TABLE cu.vw_evidenza_numero_provv OWNER TO postgres;

--
-- Name: vw_evidenze_per_cl; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_evidenze_per_cl AS
 SELECT vce.id_cu_oggetto_cl,
    count(*) AS cnt
   FROM cu.vw_cu_evidenze vce
  GROUP BY vce.id_cu_oggetto_cl;


ALTER TABLE cu.vw_evidenze_per_cl OWNER TO postgres;

--
-- Name: vw_evidenze_per_oggetto; Type: VIEW; Schema: cu; Owner: postgres
--

CREATE VIEW cu.vw_evidenze_per_oggetto AS
 SELECT vce.id_cu_oggetto,
    count(*) AS cnt
   FROM cu.vw_cu_evidenze vce
  GROUP BY vce.id_cu_oggetto;


ALTER TABLE cu.vw_evidenze_per_oggetto OWNER TO postgres;

--
-- Name: 852integratori853AAE; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag."852integratori853AAE" (
    c1 character varying,
    tipo character varying,
    stato_sede_operativa character varying,
    approval_number character varying,
    denominazione_sede_operativa character varying,
    ragione_sociale_impresa character varying,
    partita_iva character varying,
    codice_fiscale character varying,
    indirizzo character varying,
    comune character varying,
    sigla_provincia character varying,
    provincia character varying,
    regione character varying,
    cod_ufficio_veterinario integer,
    ufficio_veterinario character varying,
    attivita character varying,
    stato_attivita character varying,
    descrizione_sezione character varying,
    data_inizio_attivita character varying,
    data_fine_attivita character varying,
    tipo_autorizzazione character varying,
    imballaggio character varying,
    paesi_abilitati_export character varying,
    remark character varying,
    species character varying,
    informazioni_aggiuntive character varying,
    id bigint
);


ALTER TABLE cu_anag."852integratori853AAE" OWNER TO postgres;

--
-- Name: asfo_sian_pool; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.asfo_sian_pool (
    id_ua integer,
    codice_regionale character varying,
    comune character varying,
    nome character varying,
    attivita_prevalente character varying
);


ALTER TABLE cu_anag.asfo_sian_pool OWNER TO postgres;

--
-- Name: asl_remap; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.asl_remap (
    idold bigint,
    idnew bigint
);


ALTER TABLE cu_anag.asl_remap OWNER TO postgres;

--
-- Name: asufc_sian_pool; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.asufc_sian_pool (
    id_ua integer,
    codice_regionale character varying,
    comune character varying,
    nome character varying,
    attivita_prevalente character varying
);


ALTER TABLE cu_anag.asufc_sian_pool OWNER TO postgres;

--
-- Name: asugi_sian_pool; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.asugi_sian_pool (
    id_ua integer,
    codice_regionale character varying(16),
    comune character varying(32),
    nome character varying(128),
    attivita_prevalente character varying(256)
);


ALTER TABLE cu_anag.asugi_sian_pool OWNER TO postgres;

--
-- Name: automezzi; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.automezzi (
    id bigint NOT NULL,
    marca character varying,
    modello character varying,
    targa character varying NOT NULL,
    validita tsrange NOT NULL
);


ALTER TABLE cu_anag.automezzi OWNER TO postgres;

--
-- Name: automezzi_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.automezzi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.automezzi_id_seq OWNER TO postgres;

--
-- Name: codici; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.codici (
    id bigint NOT NULL,
    appl character varying,
    value bigint,
    prefix character varying,
    id_asl bigint
);


ALTER TABLE cu_anag.codici OWNER TO postgres;

--
-- Name: codici_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.codici_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.codici_id_seq OWNER TO postgres;

--
-- Name: codici_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_anag; Owner: postgres
--

ALTER SEQUENCE cu_anag.codici_id_seq OWNED BY cu_anag.codici.id;


--
-- Name: cu_anag_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.cu_anag_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.cu_anag_id_seq OWNER TO postgres;

--
-- Name: import_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.import_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.import_id_seq OWNER TO postgres;

--
-- Name: file_xls_mangimifici; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.file_xls_mangimifici (
    idimport integer,
    id bigint DEFAULT nextval('cu_anag.import_id_seq'::regclass) NOT NULL,
    settore character varying,
    ragione_sociale character varying,
    rappresentante_legale character varying,
    codice_fiscale character varying,
    partita_iva character varying,
    indirizzo_sede_legale character varying,
    asl_di_competenza character varying,
    indirizzo_sede_produttiva character varying,
    comune character varying,
    prov character varying,
    regione character varying,
    numero_di_registrazione_cun character varying,
    denominazione_sede character varying,
    data_inizio_attivita timestamp without time zone,
    data_fine_attivita timestamp without time zone,
    codice_norma character varying,
    riconosciuta_registrata character varying,
    numero_di_registrazione_riconoscimento character varying,
    data_notifica_registrazione timestamp without time zone,
    codice_sezione character varying,
    sezione character varying,
    codice_attivita character varying,
    descrizione_attivita character varying,
    dettaglio_attivita character varying,
    remarks character varying,
    stato character varying,
    data_inizio timestamp without time zone,
    attivita_principale character varying,
    vendita_diretta character varying,
    note character varying
);


ALTER TABLE cu_anag.file_xls_mangimifici OWNER TO postgres;

--
-- Name: file_xls_sintesis; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.file_xls_sintesis (
    idimport integer,
    id bigint DEFAULT nextval('cu_anag.import_id_seq'::regclass) NOT NULL,
    stato_sede_operativa character varying,
    approval_number character varying,
    denominazione_sede_operativa character varying,
    ragione_sociale_impresa character varying,
    partita_iva character varying,
    codice_fiscale character varying,
    indirizzo character varying,
    comune character varying,
    sigla_provincia character varying,
    provincia character varying,
    regione character varying,
    cod_ufficio_veterinario character varying,
    ufficio_veterinario character varying,
    attivita character varying,
    stato_attivita character varying,
    descrizione_sezione character varying,
    data_inizio_attivita timestamp without time zone,
    data_fine_attivita timestamp without time zone,
    tipo_autorizzazione character varying,
    imballaggio character varying,
    paesi_abilitati_export character varying,
    remark character varying,
    species character varying,
    informazion_aggiuntive character varying
);


ALTER TABLE cu_anag.file_xls_sintesis OWNER TO postgres;

--
-- Name: fvg_gisa_imprese; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.fvg_gisa_imprese (
    id numeric(12,0),
    az_id numeric(12,0),
    az_data_inizio date,
    az_data_fine date,
    az_cod_aziendale character varying,
    az_bdn_id character varying,
    az_latitudine character varying,
    az_longitudine character varying,
    az_tipo_impresa character varying,
    az_id_anagrafica numeric(12,0),
    az_denominazione character varying,
    az_an_dato_fiscale character varying,
    az_an_cf character varying,
    az_an_iva character varying,
    az_an_pec character varying,
    az_an_email character varying,
    az_an_sdi character varying,
    az_an_split_payment numeric(1,0),
    az_an_data_nascita date,
    az_an_tipo character varying,
    az_an_tipo_descr character varying,
    az_an_tipo_persona character varying,
    az_an_tipo_pers_descr character varying,
    az_an_data_fine date,
    az_an_data_decesso date,
    az_an_provincia character varying,
    az_an_istat character varying,
    az_an_comune character varying,
    az_an_toponimo character varying,
    az_an_indirizzo character varying,
    az_an_civico character varying,
    az_di_cod_asl character varying,
    az_di_descr_asl character varying,
    sede_operativa character varying,
    sd_id numeric(12,0),
    sd_bdn_id character varying,
    sd_bdn_specie character varying,
    sd_specie_descr character varying,
    sd_cod_tipologia_struttura character varying,
    sd_tipologia_struttura character varying,
    sd_data_inizio date,
    sd_data_fine date,
    sd_vet_id numeric(12,0),
    sd_vet_cf character varying,
    sd_vet_cognome character varying,
    sd_vet_nome character varying,
    sd_an_id numeric(12,0),
    sd_an_nome character varying,
    sd_an_dato_fiscale character varying,
    sd_an_cf character varying,
    sd_an_iva character varying,
    sd_an_pec character varying,
    sd_an_email character varying,
    sd_an_sdi character varying,
    sd_an_split_payment numeric(1,0),
    sd_an_data_nascita date,
    sd_an_tipo character varying,
    sd_an_tipo_descr character varying,
    sd_an_tipo_persona character varying,
    sd_an_tipo_pers_descr character varying,
    sd_an_data_fine date,
    sd_an_data_decesso date,
    sd_an_res_provincia character varying,
    sd_an_res_istat character varying,
    sd_an_res_comune character varying,
    sd_an_res_toponimo character varying,
    sd_an_res_indirizzo character varying,
    sd_an_res_civico character varying,
    sd_an_dom_provincia character varying,
    sd_an_dom_istat character varying,
    sd_an_dom_comune character varying,
    sd_an_dom_toponimo character varying,
    sd_an_dom_indirizzo character varying,
    sd_an_dom_civico character varying,
    figura_aziendale character varying,
    fg_id numeric(12,0),
    fg_data_inizio date,
    fg_data_fine date,
    fg_cod_tipo_figura character varying,
    fg_tipo_figura_descr character varying,
    fg_id_anagrafica numeric(12,0),
    fg_an_nome character varying,
    fg_an_dato_fiscale character varying,
    fg_an_cf character varying,
    fg_an_iva character varying,
    fg_an_pec character varying,
    fg_an_email character varying,
    fg_an_sdi character varying,
    fg_an_split_payment numeric(1,0),
    fg_an_data_nascita date,
    fg_an_tipo character varying,
    fg_an_tipo_descr character varying,
    fg_an_tipo_persona character varying,
    fg_an_tipo_pers_descr character varying,
    fg_an_data_fine date,
    fg_an_res_provincia character varying,
    fg_an_res_istat character varying,
    fg_an_res_comune character varying,
    fg_an_res_toponimo character varying,
    fg_an_res_indirizzo character varying,
    fg_an_res_civico character varying,
    fg_an_dom_provincia character varying,
    fg_an_dom_istat character varying,
    fg_an_dom_comune character varying,
    fg_an_dom_toponimo character varying,
    fg_an_dom_indirizzo character varying,
    fg_an_dom_civico character varying,
    controlli character varying,
    azienda_anagr numeric(1,0),
    sedeop numeric(1,0),
    sedeop_anag numeric(1,0),
    figura_sede numeric(1,0),
    figura_anag numeric(1,0),
    errori character varying,
    score numeric(3,0),
    az_an_cap character varying,
    sd_cod_regionale character varying,
    sd_cod_struttura character varying,
    sd_an_res_cap character varying,
    sd_an_dom_cap character varying,
    fg_an_res_cap character varying,
    fg_an_dom_cap character varying
);


ALTER TABLE cu_anag.fvg_gisa_imprese OWNER TO postgres;

--
-- Name: gisa_imprese; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.gisa_imprese (
    id numeric(12,0),
    az_id numeric(12,0),
    az_data_inizio date,
    az_data_fine date,
    az_cod_aziendale character varying,
    az_bdn_id character varying,
    az_latitudine character varying,
    az_longitudine character varying,
    az_tipo_impresa character varying,
    az_id_anagrafica numeric(12,0),
    az_denominazione character varying,
    az_an_dato_fiscale character varying,
    az_an_cf character varying,
    az_an_iva character varying,
    az_an_pec character varying,
    az_an_email character varying,
    az_an_sdi character varying,
    az_an_split_payment numeric(1,0),
    az_an_data_nascita date,
    az_an_tipo character varying,
    az_an_tipo_descr character varying,
    az_an_tipo_persona character varying,
    az_an_tipo_pers_descr character varying,
    az_an_data_fine date,
    az_an_data_decesso date,
    az_an_provincia character varying,
    az_an_istat character varying,
    az_an_comune character varying,
    az_an_toponimo character varying,
    az_an_indirizzo character varying,
    az_an_civico character varying,
    az_di_cod_asl character varying,
    az_di_descr_asl character varying,
    sede_operativa character varying,
    sd_id numeric(12,0),
    sd_bdn_id character varying,
    sd_bdn_specie character varying,
    sd_specie_descr character varying,
    sd_cod_tipologia_struttura character varying,
    sd_tipologia_struttura character varying,
    sd_data_inizio date,
    sd_data_fine date,
    sd_vet_id numeric(12,0),
    sd_vet_cf character varying,
    sd_vet_cognome character varying,
    sd_vet_nome character varying,
    sd_an_id numeric(12,0),
    sd_an_nome character varying,
    sd_an_dato_fiscale character varying,
    sd_an_cf character varying,
    sd_an_iva character varying,
    sd_an_pec character varying,
    sd_an_email character varying,
    sd_an_sdi character varying,
    sd_an_split_payment numeric(1,0),
    sd_an_data_nascita date,
    sd_an_tipo character varying,
    sd_an_tipo_descr character varying,
    sd_an_tipo_persona character varying,
    sd_an_tipo_pers_descr character varying,
    sd_an_data_fine date,
    sd_an_data_decesso date,
    sd_an_res_provincia character varying,
    sd_an_res_istat character varying,
    sd_an_res_comune character varying,
    sd_an_res_toponimo character varying,
    sd_an_res_indirizzo character varying,
    sd_an_res_civico character varying,
    sd_an_dom_provincia character varying,
    sd_an_dom_istat character varying,
    sd_an_dom_comune character varying,
    sd_an_dom_toponimo character varying,
    sd_an_dom_indirizzo character varying,
    sd_an_dom_civico character varying,
    figura_aziendale character varying,
    fg_id numeric(12,0),
    fg_data_inizio date,
    fg_data_fine date,
    fg_cod_tipo_figura character varying,
    fg_tipo_figura_descr character varying,
    fg_id_anagrafica numeric(12,0),
    fg_an_nome character varying,
    fg_an_dato_fiscale character varying,
    fg_an_cf character varying,
    fg_an_iva character varying,
    fg_an_pec character varying,
    fg_an_email character varying,
    fg_an_sdi character varying,
    fg_an_split_payment numeric(1,0),
    fg_an_data_nascita date,
    fg_an_tipo character varying,
    fg_an_tipo_descr character varying,
    fg_an_tipo_persona character varying,
    fg_an_tipo_pers_descr character varying,
    fg_an_data_fine date,
    fg_an_res_provincia character varying,
    fg_an_res_istat character varying,
    fg_an_res_comune character varying,
    fg_an_res_toponimo character varying,
    fg_an_res_indirizzo character varying,
    fg_an_res_civico character varying,
    fg_an_dom_provincia character varying,
    fg_an_dom_istat character varying,
    fg_an_dom_comune character varying,
    fg_an_dom_toponimo character varying,
    fg_an_dom_indirizzo character varying,
    fg_an_dom_civico character varying,
    controlli character varying,
    azienda_anagr numeric(1,0),
    sedeop numeric(1,0),
    sedeop_anag numeric(1,0),
    figura_sede numeric(1,0),
    figura_anag numeric(1,0),
    errori character varying,
    score numeric(3,0)
);


ALTER TABLE cu_anag.gisa_imprese OWNER TO postgres;

--
-- Name: gisa_imprese_completa_a; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.gisa_imprese_completa_a (
    impresa_id numeric(12,0),
    impresa_ragione_sociale character varying,
    impresa_piva character varying,
    impresa_cf character varying,
    impresa_indirizzo_toponimo character varying,
    impresa_indirizzo character varying,
    impresa_indirizzo_civico character varying,
    impresa_indirizzo_istat_comune character varying,
    impresa_indirizzo_provincia character varying,
    impresa_pec character varying,
    stabilimento_id numeric(12,0),
    stabilimento_denominazione character varying,
    stabilimento_indirizzo_toponimo character varying,
    stabilimento_indirizzo character varying,
    stabilimento_indirizzo_civico character varying,
    stabilimento_indirizzo_istat_comune character varying,
    stabilimento_indirizzo_provincia character varying,
    stabilimento_latitudine character varying,
    stabilimento_longitudine character varying,
    soggetto_id bigint,
    soggetto_nome character varying,
    soggetto_cognome character varying,
    soggetto_sesso character varying,
    soggetto_codice_catastale_comune_nascita text,
    soggetto_data_nascita date,
    soggetto_codice_fiscale character varying,
    soggetto_email character varying,
    soggetto_telefono character varying,
    soggetto_indirizzo_toponimo character varying,
    soggetto_indirizzo character varying,
    soggetto_indirizzo_civico character varying,
    soggetto_indirizzo_istat_comune character varying,
    soggetto_indirizzo_provincia character varying,
    linea_id numeric(12,0),
    linea_data_inizio date,
    linea_data_fine date,
    linea_norma_codice character varying,
    linea_macroarea_codice character varying,
    linea_aggregazione_codice character varying,
    linea_attivita_codice character varying,
    linea_ateco character varying,
    attivita_fissa boolean,
    linea_principale numeric(12,0)
);


ALTER TABLE cu_anag.gisa_imprese_completa_a OWNER TO postgres;

--
-- Name: gisa_imprese_completa_b; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.gisa_imprese_completa_b (
    impresa_id numeric(12,0),
    impresa_ragione_sociale character varying,
    impresa_piva character varying,
    impresa_cf character varying,
    impresa_indirizzo_toponimo character varying,
    impresa_indirizzo character varying,
    impresa_indirizzo_civico character varying,
    impresa_indirizzo_istat_comune character varying,
    impresa_indirizzo_provincia character varying,
    impresa_pec character varying,
    stabilimento_id numeric(12,0),
    stabilimento_denominazione character varying,
    stabilimento_indirizzo_toponimo character varying,
    stabilimento_indirizzo character varying,
    stabilimento_indirizzo_civico character varying,
    stabilimento_indirizzo_istat_comune character varying,
    stabilimento_indirizzo_provincia character varying,
    stabilimento_latitudine character varying,
    stabilimento_longitudine character varying,
    soggetto_id bigint,
    soggetto_nome character varying,
    soggetto_cognome character varying,
    soggetto_sesso character varying,
    soggetto_codice_catastale_comune_nascita text,
    soggetto_data_nascita date,
    soggetto_codice_fiscale character varying,
    soggetto_email character varying,
    soggetto_telefono character varying,
    soggetto_indirizzo_toponimo character varying,
    soggetto_indirizzo character varying,
    soggetto_indirizzo_civico character varying,
    soggetto_indirizzo_istat_comune character varying,
    soggetto_indirizzo_provincia character varying,
    linea_id numeric(12,0),
    linea_data_inizio date,
    linea_data_fine date,
    linea_norma_codice character varying,
    linea_macroarea_codice character varying,
    linea_aggregazione_codice character varying,
    linea_attivita_codice character varying,
    linea_ateco character varying,
    attivita_fissa boolean,
    linea_principale numeric(12,0)
);


ALTER TABLE cu_anag.gisa_imprese_completa_b OWNER TO postgres;

--
-- Name: gisa_imprese_linee_secondarie_a; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.gisa_imprese_linee_secondarie_a (
    impresa_id numeric(12,0),
    stabilimento_id numeric(12,0),
    id_stabilimento_opu integer,
    impresa_ragione_sociale character varying,
    stabilimento_denominazione character varying,
    linea_id numeric(12,0),
    linea_data_inizio date,
    linea_data_fine date,
    linea_norma_codice character varying,
    linea_macroarea_codice character varying,
    linea_aggregazione_codice character varying,
    linea_attivita_codice character varying,
    linea_ateco character varying,
    linea_principale numeric(12,0)
);


ALTER TABLE cu_anag.gisa_imprese_linee_secondarie_a OWNER TO postgres;

--
-- Name: import_anagrafica; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.import_anagrafica (
    id bigint NOT NULL,
    data_inserimento timestamp without time zone,
    tipo bigint,
    esito boolean DEFAULT false,
    data_estr_file timestamp without time zone
);


ALTER TABLE cu_anag.import_anagrafica OWNER TO postgres;

--
-- Name: import_anagrafica_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.import_anagrafica_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.import_anagrafica_id_seq OWNER TO postgres;

--
-- Name: import_anagrafica_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_anag; Owner: postgres
--

ALTER SEQUENCE cu_anag.import_anagrafica_id_seq OWNED BY cu_anag.import_anagrafica.id;


--
-- Name: impresa_figure; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.impresa_figure (
    id bigint NOT NULL,
    id_impresa bigint NOT NULL,
    id_tipo_figura bigint NOT NULL,
    id_indirizzo bigint,
    old_id bigint,
    fonte text,
    descr character varying,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL,
    id_soggetto bigint
);


ALTER TABLE cu_anag.impresa_figure OWNER TO postgres;

--
-- Name: impresa_figure_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.impresa_figure_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.impresa_figure_id_seq OWNER TO postgres;

--
-- Name: impresa_figure_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_anag; Owner: postgres
--

ALTER SEQUENCE cu_anag.impresa_figure_id_seq OWNED BY cu_anag.impresa_figure.id;


--
-- Name: impresa_sedi; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.impresa_sedi (
    id bigint NOT NULL,
    id_impresa bigint NOT NULL,
    id_tipo_sede bigint NOT NULL,
    id_indirizzo bigint NOT NULL,
    pec character varying,
    email character varying,
    old_id bigint,
    fonte text,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL
);


ALTER TABLE cu_anag.impresa_sedi OWNER TO postgres;

--
-- Name: impresa_sedi_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.impresa_sedi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.impresa_sedi_id_seq OWNER TO postgres;

--
-- Name: impresa_sedi_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_anag; Owner: postgres
--

ALTER SEQUENCE cu_anag.impresa_sedi_id_seq OWNED BY cu_anag.impresa_sedi.id;


--
-- Name: imprese_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.imprese_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.imprese_id_seq OWNER TO postgres;

--
-- Name: indirizzi_all; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.indirizzi_all (
    id integer NOT NULL,
    via character varying(300),
    cap character(20),
    provincia character(500),
    nazione character varying(500),
    latitudine double precision,
    longitudine double precision,
    comune integer,
    riferimento_org_id integer,
    riferimento_address_id integer,
    address_type integer,
    comune_testo text,
    tiponimo integer,
    toponimo integer,
    civico text,
    clean text,
    topon text,
    via_old text,
    note_hd text,
    id_soggetto_fisico_update_indirizzo integer,
    lat_old double precision,
    long_old double precision,
    note_recupero_cap text,
    da_rivedere boolean,
    coordinate_da_riverificare boolean,
    presso text,
    id_nazione integer,
    import_fvg boolean
);


ALTER TABLE cu_anag.indirizzi_all OWNER TO postgres;

--
-- Name: is_organization; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.is_organization (
    riferimento_id_nome_tab text
);


ALTER TABLE cu_anag.is_organization OWNER TO postgres;

--
-- Name: mangimifici_reg; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.mangimifici_reg (
    settore character varying,
    ragione_sociale character varying,
    rappresentante_legale character varying,
    cf character varying,
    piva character varying,
    indirizzo_sede_legale character varying,
    asl character varying,
    indirizzo_sede_produttiva character varying,
    comune character varying,
    prov character varying,
    regione character varying,
    cun character varying,
    denominazione_sede character varying,
    "DATA INIZIO ATTIVITA" character varying,
    "DATA FINE ATTIVITA" character varying,
    "CODICE NORMA" character varying,
    ric_reg character varying,
    num_ric_reg character varying,
    data_notifica_registrazione character varying,
    codice_sezione character varying,
    sezione character varying,
    codice_attivita character varying,
    descrizione_attivita character varying,
    dettaglio_attivita character varying,
    remarks character varying,
    stato character varying,
    data_inizio character varying,
    attivita_principale character varying,
    vendfita_diretta character varying,
    note character varying,
    id bigint
);


ALTER TABLE cu_anag.mangimifici_reg OWNER TO postgres;

--
-- Name: new_soggetti; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.new_soggetti (
    id bigint NOT NULL,
    tipo character varying NOT NULL
);


ALTER TABLE cu_anag.new_soggetti OWNER TO postgres;

--
-- Name: ns_remap; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.ns_remap (
    idold integer,
    idnew integer
);


ALTER TABLE cu_anag.ns_remap OWNER TO postgres;

--
-- Name: opu_indirizzo_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.opu_indirizzo_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.opu_indirizzo_id_seq OWNER TO postgres;

--
-- Name: opu_indirizzo_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_anag; Owner: postgres
--

ALTER SEQUENCE cu_anag.opu_indirizzo_id_seq OWNED BY cu_anag.indirizzi_all.id;


--
-- Name: piani_remap; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.piani_remap (
    idold bigint,
    idnew bigint
);


ALTER TABLE cu_anag.piani_remap OWNER TO postgres;

--
-- Name: pratiche_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.pratiche_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.pratiche_id_seq OWNER TO postgres;

--
-- Name: pratiche_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_anag; Owner: postgres
--

ALTER SEQUENCE cu_anag.pratiche_id_seq OWNED BY cu_anag.pratiche.id;


--
-- Name: r_ev; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.r_ev (
    id bigint,
    inizio timestamp without time zone,
    fine timestamp without time zone,
    evento text,
    id_risorsa bigint,
    risorsa text,
    alias text,
    descr_tipo_evento character varying,
    sigla_tipo_evento character varying,
    indirizzo character varying,
    id_calendario bigint,
    descrizione_breve text,
    descrizione text,
    modifica_inizio boolean,
    modifica_durata boolean,
    elimina boolean,
    colore character varying,
    stato character varying,
    durata double precision,
    durata_int interval,
    effettuata boolean,
    presso character varying,
    comune text,
    valido_da timestamp without time zone,
    valido_a timestamp without time zone,
    per_conto text,
    id_partner bigint,
    partner text,
    ruolo text,
    id_anagrafica bigint,
    id_anagrafica_partner bigint,
    id_cu bigint,
    validita_interna boolean,
    id_linea bigint,
    id_piano bigint,
    id_per_conto bigint,
    id_az_sede bigint
);


ALTER TABLE cu_anag.r_ev OWNER TO postgres;

--
-- Name: r_t2; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.r_t2 (
    name_tree character varying,
    id_node bigint,
    id_tree bigint,
    id_node_parent bigint,
    id_node_ref bigint,
    id bigint,
    id_gisa bigint,
    id_asl bigint,
    codice_interno_fk bigint,
    descrizione text,
    n_livello integer,
    anno integer,
    descrizione_breve text,
    ups double precision,
    uba double precision,
    data_scadenza timestamp without time zone,
    trashed_date timestamp with time zone,
    validita tsrange,
    ordinamento character varying,
    inizio_validita timestamp without time zone,
    fine_validita timestamp without time zone
);


ALTER TABLE cu_anag.r_t2 OWNER TO postgres;

--
-- Name: rt_cu_provv_in_corso; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.rt_cu_provv_in_corso (
    id_provv bigint,
    id bigint,
    id_evidenza bigint,
    ord integer,
    id_tipo_provv bigint,
    azione character varying,
    dt date,
    sigla_tipo_provv character varying,
    descr_tipo_provv character varying,
    descr_provv text,
    fu_richiesto boolean,
    id_cu bigint,
    id_az_sede bigint,
    chiuso boolean,
    id_fu bigint,
    id_norma bigint
);


ALTER TABLE cu_anag.rt_cu_provv_in_corso OWNER TO postgres;

--
-- Name: soggetti; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.soggetti (
    id bigint NOT NULL,
    tipo character varying NOT NULL
);


ALTER TABLE cu_anag.soggetti OWNER TO postgres;

--
-- Name: stabilimenti_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.stabilimenti_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.stabilimenti_id_seq OWNER TO postgres;

--
-- Name: stabilimenti_storico_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.stabilimenti_storico_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.stabilimenti_storico_id_seq OWNER TO postgres;

--
-- Name: stabilimenti_storico_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_anag; Owner: postgres
--

ALTER SEQUENCE cu_anag.stabilimenti_storico_id_seq OWNED BY cu_anag.stabilimenti_storico.id;


--
-- Name: stabilimento_automezzi; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.stabilimento_automezzi (
    id bigint NOT NULL,
    id_stabilimento bigint NOT NULL,
    id_automezzo bigint NOT NULL,
    validita tsrange
);


ALTER TABLE cu_anag.stabilimento_automezzi OWNER TO postgres;

--
-- Name: stabilimento_automezzi_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.stabilimento_automezzi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.stabilimento_automezzi_id_seq OWNER TO postgres;

--
-- Name: stabilimento_categorizzazioni; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.stabilimento_categorizzazioni (
    id bigint NOT NULL,
    id_stabilimento bigint,
    validita tsrange,
    categoria_rischio numeric
);


ALTER TABLE cu_anag.stabilimento_categorizzazioni OWNER TO postgres;

--
-- Name: stabilimento_catgorizzazioni_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.stabilimento_catgorizzazioni_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.stabilimento_catgorizzazioni_id_seq OWNER TO postgres;

--
-- Name: stabilimento_catgorizzazioni_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_anag; Owner: postgres
--

ALTER SEQUENCE cu_anag.stabilimento_catgorizzazioni_id_seq OWNED BY cu_anag.stabilimento_categorizzazioni.id;


--
-- Name: stabilimento_catgorizzazioni; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.stabilimento_catgorizzazioni (
    id bigint DEFAULT nextval('cu_anag.stabilimento_catgorizzazioni_id_seq'::regclass) NOT NULL,
    id_stabilimento bigint,
    validita tsrange,
    categoria_rischio numeric
);


ALTER TABLE cu_anag.stabilimento_catgorizzazioni OWNER TO postgres;

--
-- Name: stabilimento_figure; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.stabilimento_figure (
    id bigint,
    id_stabilimento bigint,
    id_soggetto bigint,
    id_tipo_figura bigint,
    id_indirizzo bigint,
    old_id bigint,
    fonte text,
    descr character varying,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL
);


ALTER TABLE cu_anag.stabilimento_figure OWNER TO postgres;

--
-- Name: stabilimento_sedi; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.stabilimento_sedi (
    id bigint NOT NULL,
    id_stabilimento bigint,
    id_tipo_sede bigint,
    id_indirizzo bigint,
    pec character varying,
    email character varying,
    old_id bigint,
    fonte text,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL
);


ALTER TABLE cu_anag.stabilimento_sedi OWNER TO postgres;

--
-- Name: storico_pratiche; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.storico_pratiche (
    id integer NOT NULL,
    id_pratica integer NOT NULL,
    id_stato_pratica integer NOT NULL,
    dt timestamp without time zone NOT NULL,
    user_id integer NOT NULL
);


ALTER TABLE cu_anag.storico_pratiche OWNER TO postgres;

--
-- Name: storico_pratiche_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.storico_pratiche_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.storico_pratiche_id_seq OWNER TO postgres;

--
-- Name: storico_pratiche_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_anag; Owner: postgres
--

ALTER SEQUENCE cu_anag.storico_pratiche_id_seq OWNED BY cu_anag.storico_pratiche.id;


--
-- Name: tipo_import_anagrafica; Type: TABLE; Schema: cu_anag; Owner: postgres
--

CREATE TABLE cu_anag.tipo_import_anagrafica (
    id bigint NOT NULL,
    descr character varying NOT NULL,
    cod character varying
);


ALTER TABLE cu_anag.tipo_import_anagrafica OWNER TO postgres;

--
-- Name: tipo_import_anagrafica_id_seq; Type: SEQUENCE; Schema: cu_anag; Owner: postgres
--

CREATE SEQUENCE cu_anag.tipo_import_anagrafica_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_anag.tipo_import_anagrafica_id_seq OWNER TO postgres;

--
-- Name: tipo_import_anagrafica_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_anag; Owner: postgres
--

ALTER SEQUENCE cu_anag.tipo_import_anagrafica_id_seq OWNED BY cu_anag.tipo_import_anagrafica.id;


--
-- Name: vw_852integratori853aae_imprese; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_852integratori853aae_imprese AS
 SELECT "852integratori853AAE".ragione_sociale_impresa,
    "852integratori853AAE".codice_fiscale,
    "852integratori853AAE".partita_iva,
    (min(("852integratori853AAE".tipo)::text))::character varying AS tipo,
    min("852integratori853AAE".id) AS az_id
   FROM cu_anag."852integratori853AAE"
  GROUP BY "852integratori853AAE".ragione_sociale_impresa, "852integratori853AAE".codice_fiscale, "852integratori853AAE".partita_iva;


ALTER TABLE cu_anag.vw_852integratori853aae_imprese OWNER TO postgres;

--
-- Name: vw_automezzi; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_automezzi AS
 SELECT a.id AS id_automezzo,
    a.marca,
    a.modello,
    a.targa,
    a.validita
   FROM cu_anag.automezzi a;


ALTER TABLE cu_anag.vw_automezzi OWNER TO postgres;

--
-- Name: vw_codici; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_codici AS
 SELECT codici.id AS id_codice,
    codici.id,
    codici.appl,
    codici.value,
    codici.prefix,
    codici.id_asl
   FROM cu_anag.codici;


ALTER TABLE cu_anag.vw_codici OWNER TO postgres;

--
-- Name: vw_fvg_gisa_imprese; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_fvg_gisa_imprese AS
 SELECT fvg_gisa_imprese.id,
    fvg_gisa_imprese.az_id,
    fvg_gisa_imprese.az_data_inizio,
    fvg_gisa_imprese.az_data_fine,
    fvg_gisa_imprese.az_cod_aziendale,
    fvg_gisa_imprese.az_bdn_id,
    fvg_gisa_imprese.az_latitudine,
    fvg_gisa_imprese.az_longitudine,
    fvg_gisa_imprese.az_tipo_impresa,
    fvg_gisa_imprese.az_id_anagrafica,
    fvg_gisa_imprese.az_denominazione,
    fvg_gisa_imprese.az_an_dato_fiscale,
    fvg_gisa_imprese.az_an_cf,
    fvg_gisa_imprese.az_an_iva,
    fvg_gisa_imprese.az_an_pec,
    fvg_gisa_imprese.az_an_email,
    fvg_gisa_imprese.az_an_sdi,
    fvg_gisa_imprese.az_an_split_payment,
    fvg_gisa_imprese.az_an_data_nascita,
    fvg_gisa_imprese.az_an_tipo,
    fvg_gisa_imprese.az_an_tipo_descr,
    fvg_gisa_imprese.az_an_tipo_persona,
    fvg_gisa_imprese.az_an_tipo_pers_descr,
    fvg_gisa_imprese.az_an_data_fine,
    fvg_gisa_imprese.az_an_data_decesso,
    fvg_gisa_imprese.az_an_provincia,
    fvg_gisa_imprese.az_an_istat,
    fvg_gisa_imprese.az_an_comune,
    fvg_gisa_imprese.az_an_toponimo,
    fvg_gisa_imprese.az_an_indirizzo,
    fvg_gisa_imprese.az_an_civico,
    fvg_gisa_imprese.az_di_cod_asl,
    fvg_gisa_imprese.az_di_descr_asl,
    fvg_gisa_imprese.sede_operativa,
    fvg_gisa_imprese.sd_id,
    fvg_gisa_imprese.sd_bdn_id,
    fvg_gisa_imprese.sd_bdn_specie,
    fvg_gisa_imprese.sd_specie_descr,
    fvg_gisa_imprese.sd_cod_tipologia_struttura,
    fvg_gisa_imprese.sd_tipologia_struttura,
    fvg_gisa_imprese.sd_data_inizio,
    fvg_gisa_imprese.sd_data_fine,
    fvg_gisa_imprese.sd_vet_id,
    fvg_gisa_imprese.sd_vet_cf,
    fvg_gisa_imprese.sd_vet_cognome,
    fvg_gisa_imprese.sd_vet_nome,
    fvg_gisa_imprese.sd_an_id,
    fvg_gisa_imprese.sd_an_nome,
    fvg_gisa_imprese.sd_an_dato_fiscale,
    fvg_gisa_imprese.sd_an_cf,
    fvg_gisa_imprese.sd_an_iva,
    fvg_gisa_imprese.sd_an_pec,
    fvg_gisa_imprese.sd_an_email,
    fvg_gisa_imprese.sd_an_sdi,
    fvg_gisa_imprese.sd_an_split_payment,
    fvg_gisa_imprese.sd_an_data_nascita,
    fvg_gisa_imprese.sd_an_tipo,
    fvg_gisa_imprese.sd_an_tipo_descr,
    fvg_gisa_imprese.sd_an_tipo_persona,
    fvg_gisa_imprese.sd_an_tipo_pers_descr,
    fvg_gisa_imprese.sd_an_data_fine,
    fvg_gisa_imprese.sd_an_data_decesso,
    fvg_gisa_imprese.sd_an_res_provincia,
    fvg_gisa_imprese.sd_an_res_istat,
    fvg_gisa_imprese.sd_an_res_comune,
    fvg_gisa_imprese.sd_an_res_toponimo,
    fvg_gisa_imprese.sd_an_res_indirizzo,
    fvg_gisa_imprese.sd_an_res_civico,
    fvg_gisa_imprese.sd_an_dom_provincia,
    fvg_gisa_imprese.sd_an_dom_istat,
    fvg_gisa_imprese.sd_an_dom_comune,
    fvg_gisa_imprese.sd_an_dom_toponimo,
    fvg_gisa_imprese.sd_an_dom_indirizzo,
    fvg_gisa_imprese.sd_an_dom_civico,
    fvg_gisa_imprese.figura_aziendale,
    fvg_gisa_imprese.fg_id,
    fvg_gisa_imprese.fg_data_inizio,
    fvg_gisa_imprese.fg_data_fine,
    fvg_gisa_imprese.fg_cod_tipo_figura,
    fvg_gisa_imprese.fg_tipo_figura_descr,
    fvg_gisa_imprese.fg_id_anagrafica,
    fvg_gisa_imprese.fg_an_nome,
    fvg_gisa_imprese.fg_an_dato_fiscale,
    fvg_gisa_imprese.fg_an_cf,
    fvg_gisa_imprese.fg_an_iva,
    fvg_gisa_imprese.fg_an_pec,
    fvg_gisa_imprese.fg_an_email,
    fvg_gisa_imprese.fg_an_sdi,
    fvg_gisa_imprese.fg_an_split_payment,
    fvg_gisa_imprese.fg_an_data_nascita,
    fvg_gisa_imprese.fg_an_tipo,
    fvg_gisa_imprese.fg_an_tipo_descr,
    fvg_gisa_imprese.fg_an_tipo_persona,
    fvg_gisa_imprese.fg_an_tipo_pers_descr,
    fvg_gisa_imprese.fg_an_data_fine,
    fvg_gisa_imprese.fg_an_res_provincia,
    fvg_gisa_imprese.fg_an_res_istat,
    fvg_gisa_imprese.fg_an_res_comune,
    fvg_gisa_imprese.fg_an_res_toponimo,
    fvg_gisa_imprese.fg_an_res_indirizzo,
    fvg_gisa_imprese.fg_an_res_civico,
    fvg_gisa_imprese.fg_an_dom_provincia,
    fvg_gisa_imprese.fg_an_dom_istat,
    fvg_gisa_imprese.fg_an_dom_comune,
    fvg_gisa_imprese.fg_an_dom_toponimo,
    fvg_gisa_imprese.fg_an_dom_indirizzo,
    fvg_gisa_imprese.fg_an_dom_civico,
    fvg_gisa_imprese.controlli,
    fvg_gisa_imprese.azienda_anagr,
    fvg_gisa_imprese.sedeop,
    fvg_gisa_imprese.sedeop_anag,
    fvg_gisa_imprese.figura_sede,
    fvg_gisa_imprese.figura_anag,
    fvg_gisa_imprese.errori,
    fvg_gisa_imprese.score
   FROM cu_anag.fvg_gisa_imprese
  WHERE (((fvg_gisa_imprese.sd_data_fine IS NULL) OR (fvg_gisa_imprese.sd_data_fine > '2022-12-31'::date)) AND ((fvg_gisa_imprese.az_data_fine IS NULL) OR (fvg_gisa_imprese.az_data_fine > '2022-12-31'::date)) AND ((fvg_gisa_imprese.sd_cod_tipologia_struttura)::text = ANY (ARRAY[('852'::character varying)::text, ('99907'::character varying)::text, ('0SA'::character varying)::text, ('CA'::character varying)::text, ('CG'::character varying)::text, ('FI'::character varying)::text, ('FIE'::character varying)::text, ('MOCA'::character varying)::text, ('PS'::character varying)::text, ('RSP'::character varying)::text, ('SS'::character varying)::text, ('ST'::character varying)::text, ('STA'::character varying)::text, ('T11'::character varying)::text, ('Z01'::character varying)::text])));


ALTER TABLE cu_anag.vw_fvg_gisa_imprese OWNER TO postgres;

--
-- Name: vw_fvg_gisa_imprese_all; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_fvg_gisa_imprese_all AS
 SELECT fvg_gisa_imprese.id,
    fvg_gisa_imprese.az_id,
    fvg_gisa_imprese.az_data_inizio,
    fvg_gisa_imprese.az_data_fine,
    fvg_gisa_imprese.az_cod_aziendale,
    fvg_gisa_imprese.az_bdn_id,
    fvg_gisa_imprese.az_latitudine,
    fvg_gisa_imprese.az_longitudine,
    fvg_gisa_imprese.az_tipo_impresa,
    fvg_gisa_imprese.az_id_anagrafica,
    fvg_gisa_imprese.az_denominazione,
    fvg_gisa_imprese.az_an_dato_fiscale,
    fvg_gisa_imprese.az_an_cf,
    fvg_gisa_imprese.az_an_iva,
    fvg_gisa_imprese.az_an_pec,
    fvg_gisa_imprese.az_an_email,
    fvg_gisa_imprese.az_an_sdi,
    fvg_gisa_imprese.az_an_split_payment,
    fvg_gisa_imprese.az_an_data_nascita,
    fvg_gisa_imprese.az_an_tipo,
    fvg_gisa_imprese.az_an_tipo_descr,
    fvg_gisa_imprese.az_an_tipo_persona,
    fvg_gisa_imprese.az_an_tipo_pers_descr,
    fvg_gisa_imprese.az_an_data_fine,
    fvg_gisa_imprese.az_an_data_decesso,
    fvg_gisa_imprese.az_an_provincia,
    fvg_gisa_imprese.az_an_istat,
    fvg_gisa_imprese.az_an_cap,
    fvg_gisa_imprese.az_an_comune,
    fvg_gisa_imprese.az_an_toponimo,
    fvg_gisa_imprese.az_an_indirizzo,
    fvg_gisa_imprese.az_an_civico,
    fvg_gisa_imprese.az_di_cod_asl,
    fvg_gisa_imprese.az_di_descr_asl,
    fvg_gisa_imprese.sede_operativa,
    fvg_gisa_imprese.sd_id,
    fvg_gisa_imprese.sd_bdn_id,
    fvg_gisa_imprese.sd_bdn_specie,
    fvg_gisa_imprese.sd_specie_descr,
    fvg_gisa_imprese.sd_cod_tipologia_struttura,
    fvg_gisa_imprese.sd_tipologia_struttura,
    fvg_gisa_imprese.sd_cod_regionale,
    fvg_gisa_imprese.sd_cod_struttura,
    fvg_gisa_imprese.sd_data_inizio,
    fvg_gisa_imprese.sd_data_fine,
    fvg_gisa_imprese.sd_vet_id,
    fvg_gisa_imprese.sd_vet_cf,
    fvg_gisa_imprese.sd_vet_cognome,
    fvg_gisa_imprese.sd_vet_nome,
    fvg_gisa_imprese.sd_an_id,
    fvg_gisa_imprese.sd_an_nome,
    fvg_gisa_imprese.sd_an_dato_fiscale,
    fvg_gisa_imprese.sd_an_cf,
    fvg_gisa_imprese.sd_an_iva,
    fvg_gisa_imprese.sd_an_pec,
    fvg_gisa_imprese.sd_an_email,
    fvg_gisa_imprese.sd_an_sdi,
    fvg_gisa_imprese.sd_an_split_payment,
    fvg_gisa_imprese.sd_an_data_nascita,
    fvg_gisa_imprese.sd_an_tipo,
    fvg_gisa_imprese.sd_an_tipo_descr,
    fvg_gisa_imprese.sd_an_tipo_persona,
    fvg_gisa_imprese.sd_an_tipo_pers_descr,
    fvg_gisa_imprese.sd_an_data_fine,
    fvg_gisa_imprese.sd_an_data_decesso,
    fvg_gisa_imprese.sd_an_res_provincia,
    fvg_gisa_imprese.sd_an_res_istat,
    fvg_gisa_imprese.sd_an_res_cap,
    fvg_gisa_imprese.sd_an_res_comune,
    fvg_gisa_imprese.sd_an_res_toponimo,
    fvg_gisa_imprese.sd_an_res_indirizzo,
    fvg_gisa_imprese.sd_an_res_civico,
    fvg_gisa_imprese.sd_an_dom_provincia,
    fvg_gisa_imprese.sd_an_dom_istat,
    fvg_gisa_imprese.sd_an_dom_cap,
    fvg_gisa_imprese.sd_an_dom_comune,
    fvg_gisa_imprese.sd_an_dom_toponimo,
    fvg_gisa_imprese.sd_an_dom_indirizzo,
    fvg_gisa_imprese.sd_an_dom_civico,
    fvg_gisa_imprese.figura_aziendale,
    fvg_gisa_imprese.fg_id,
    fvg_gisa_imprese.fg_data_inizio,
    fvg_gisa_imprese.fg_data_fine,
    fvg_gisa_imprese.fg_cod_tipo_figura,
    fvg_gisa_imprese.fg_tipo_figura_descr,
    fvg_gisa_imprese.fg_id_anagrafica,
    fvg_gisa_imprese.fg_an_nome,
    fvg_gisa_imprese.fg_an_dato_fiscale,
    fvg_gisa_imprese.fg_an_cf,
    fvg_gisa_imprese.fg_an_iva,
    fvg_gisa_imprese.fg_an_pec,
    fvg_gisa_imprese.fg_an_email,
    fvg_gisa_imprese.fg_an_sdi,
    fvg_gisa_imprese.fg_an_split_payment,
    fvg_gisa_imprese.fg_an_data_nascita,
    fvg_gisa_imprese.fg_an_tipo,
    fvg_gisa_imprese.fg_an_tipo_descr,
    fvg_gisa_imprese.fg_an_tipo_persona,
    fvg_gisa_imprese.fg_an_tipo_pers_descr,
    fvg_gisa_imprese.fg_an_data_fine,
    fvg_gisa_imprese.fg_an_res_provincia,
    fvg_gisa_imprese.fg_an_res_istat,
    fvg_gisa_imprese.fg_an_res_cap,
    fvg_gisa_imprese.fg_an_res_comune,
    fvg_gisa_imprese.fg_an_res_toponimo,
    fvg_gisa_imprese.fg_an_res_indirizzo,
    fvg_gisa_imprese.fg_an_res_civico,
    fvg_gisa_imprese.fg_an_dom_provincia,
    fvg_gisa_imprese.fg_an_dom_istat,
    fvg_gisa_imprese.fg_an_dom_cap,
    fvg_gisa_imprese.fg_an_dom_comune,
    fvg_gisa_imprese.fg_an_dom_toponimo,
    fvg_gisa_imprese.fg_an_dom_indirizzo,
    fvg_gisa_imprese.fg_an_dom_civico,
    fvg_gisa_imprese.controlli,
    fvg_gisa_imprese.azienda_anagr,
    fvg_gisa_imprese.sedeop,
    fvg_gisa_imprese.sedeop_anag,
    fvg_gisa_imprese.figura_sede,
    fvg_gisa_imprese.figura_anag,
    fvg_gisa_imprese.errori,
    fvg_gisa_imprese.score
   FROM conf_ext.fvg_gisa_imprese
  WHERE (((fvg_gisa_imprese.fg_data_fine IS NULL) OR (fvg_gisa_imprese.fg_data_fine > CURRENT_TIMESTAMP)) AND ((fvg_gisa_imprese.sd_data_fine IS NULL) OR (fvg_gisa_imprese.sd_data_fine > CURRENT_TIMESTAMP)) AND ((fvg_gisa_imprese.az_data_fine IS NULL) OR (fvg_gisa_imprese.az_data_fine > CURRENT_TIMESTAMP)) AND ((fvg_gisa_imprese.sd_cod_tipologia_struttura)::text = ANY (ARRAY[('852'::character varying)::text, ('99907'::character varying)::text, ('0SA'::character varying)::text, ('OSA'::character varying)::text, ('CA'::character varying)::text, ('CG'::character varying)::text, ('FI'::character varying)::text, ('FIE'::character varying)::text, ('MOCA'::character varying)::text, ('PS'::character varying)::text, ('RSP'::character varying)::text, ('SS'::character varying)::text, ('ST'::character varying)::text, ('STA'::character varying)::text, ('T11'::character varying)::text, ('Z01'::character varying)::text])));


ALTER TABLE cu_anag.vw_fvg_gisa_imprese_all OWNER TO postgres;

--
-- Name: vw_gisa_imprese_completa_ab; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_gisa_imprese_completa_ab AS
 SELECT 'A'::text AS tipo_ab,
    vw_gisa_imprese_completa_a.impresa_id,
    vw_gisa_imprese_completa_a.impresa_ragione_sociale,
    vw_gisa_imprese_completa_a.impresa_piva,
    vw_gisa_imprese_completa_a.impresa_cf,
    vw_gisa_imprese_completa_a.impresa_cod_aziendale,
    vw_gisa_imprese_completa_a.impresa_indirizzo_toponimo,
    vw_gisa_imprese_completa_a.impresa_indirizzo,
    vw_gisa_imprese_completa_a.impresa_indirizzo_civico,
    vw_gisa_imprese_completa_a.impresa_indirizzo_istat_comune,
    vw_gisa_imprese_completa_a.impresa_indirizzo_provincia,
    vw_gisa_imprese_completa_a.impresa_pec,
    vw_gisa_imprese_completa_a.impresa_email,
    vw_gisa_imprese_completa_a.impresa_split_payment,
    vw_gisa_imprese_completa_a.impresa_sdi,
    vw_gisa_imprese_completa_a.impresa_tipo_figura_descr,
    vw_gisa_imprese_completa_a.impresa_tipo_persona,
    vw_gisa_imprese_completa_a.impresa_tipo_pers_descr,
    vw_gisa_imprese_completa_a.stabilimento_cod_tipologia_struttura,
    vw_gisa_imprese_completa_a.impresa_tipologia_struttura,
    vw_gisa_imprese_completa_a.impresa_codice_aziendale,
    vw_gisa_imprese_completa_a.stabilimento_id,
    vw_gisa_imprese_completa_a.stabilimento_denominazione,
    vw_gisa_imprese_completa_a.stabilimento_codice_regionale,
    vw_gisa_imprese_completa_a.stabilimento_indirizzo_toponimo,
    vw_gisa_imprese_completa_a.stabilimento_indirizzo,
    vw_gisa_imprese_completa_a.stabilimento_indirizzo_civico,
    vw_gisa_imprese_completa_a.stabilimento_indirizzo_istat_comune,
    vw_gisa_imprese_completa_a.stabilimento_indirizzo_provincia,
    vw_gisa_imprese_completa_a.stabilimento_indirizzo_cap,
    vw_gisa_imprese_completa_a.stabilimento_latitudine,
    vw_gisa_imprese_completa_a.stabilimento_longitudine,
    vw_gisa_imprese_completa_a.soggetto_id,
    vw_gisa_imprese_completa_a.soggetto_nome,
    vw_gisa_imprese_completa_a.soggetto_cognome,
    vw_gisa_imprese_completa_a.soggetto_sesso,
    vw_gisa_imprese_completa_a.soggetto_codice_catastale_comune_nascita,
    vw_gisa_imprese_completa_a.soggetto_data_nascita,
    vw_gisa_imprese_completa_a.soggetto_codice_fiscale,
    vw_gisa_imprese_completa_a.soggetto_email,
    vw_gisa_imprese_completa_a.soggetto_telefono,
    vw_gisa_imprese_completa_a.soggetto_indirizzo_toponimo,
    vw_gisa_imprese_completa_a.soggetto_indirizzo,
    vw_gisa_imprese_completa_a.soggetto_indirizzo_civico,
    vw_gisa_imprese_completa_a.soggetto_indirizzo_istat_comune,
    vw_gisa_imprese_completa_a.soggetto_indirizzo_provincia,
    vw_gisa_imprese_completa_a.linea_id,
    vw_gisa_imprese_completa_a.linea_data_inizio,
    vw_gisa_imprese_completa_a.linea_data_fine,
    vw_gisa_imprese_completa_a.linea_norma_codice,
    vw_gisa_imprese_completa_a.linea_macroarea_codice,
    vw_gisa_imprese_completa_a.linea_aggregazione_codice,
    vw_gisa_imprese_completa_a.linea_attivita_codice,
    vw_gisa_imprese_completa_a.linea_ateco,
    vw_gisa_imprese_completa_a.attivita_fissa,
    vw_gisa_imprese_completa_a.linea_principale
   FROM conf_ext.vw_gisa_imprese_completa_a
UNION
 SELECT 'B'::text AS tipo_ab,
    vw_gisa_imprese_completa_b.impresa_id,
    vw_gisa_imprese_completa_b.impresa_ragione_sociale,
    vw_gisa_imprese_completa_b.impresa_piva,
    vw_gisa_imprese_completa_b.impresa_cf,
    vw_gisa_imprese_completa_b.impresa_cod_aziendale,
    vw_gisa_imprese_completa_b.impresa_indirizzo_toponimo,
    vw_gisa_imprese_completa_b.impresa_indirizzo,
    vw_gisa_imprese_completa_b.impresa_indirizzo_civico,
    vw_gisa_imprese_completa_b.impresa_indirizzo_istat_comune,
    vw_gisa_imprese_completa_b.impresa_indirizzo_provincia,
    vw_gisa_imprese_completa_b.impresa_pec,
    vw_gisa_imprese_completa_b.impresa_email,
    vw_gisa_imprese_completa_b.impresa_split_payment,
    vw_gisa_imprese_completa_b.impresa_sdi,
    vw_gisa_imprese_completa_b.impresa_tipo_figura_descr,
    vw_gisa_imprese_completa_b.impresa_tipo_persona,
    vw_gisa_imprese_completa_b.impresa_tipo_pers_descr,
    vw_gisa_imprese_completa_b.stabilimento_cod_tipologia_struttura,
    vw_gisa_imprese_completa_b.impresa_tipologia_struttura,
    vw_gisa_imprese_completa_b.impresa_codice_aziendale,
    vw_gisa_imprese_completa_b.stabilimento_id,
    vw_gisa_imprese_completa_b.stabilimento_denominazione,
    vw_gisa_imprese_completa_b.stabilimento_codice_regionale,
    vw_gisa_imprese_completa_b.stabilimento_indirizzo_toponimo,
    vw_gisa_imprese_completa_b.stabilimento_indirizzo,
    vw_gisa_imprese_completa_b.stabilimento_indirizzo_civico,
    vw_gisa_imprese_completa_b.stabilimento_indirizzo_istat_comune,
    vw_gisa_imprese_completa_b.stabilimento_indirizzo_provincia,
    vw_gisa_imprese_completa_b.stabilimento_indirizzo_cap,
    vw_gisa_imprese_completa_b.stabilimento_latitudine,
    vw_gisa_imprese_completa_b.stabilimento_longitudine,
    vw_gisa_imprese_completa_b.soggetto_id,
    vw_gisa_imprese_completa_b.soggetto_nome,
    vw_gisa_imprese_completa_b.soggetto_cognome,
    vw_gisa_imprese_completa_b.soggetto_sesso,
    vw_gisa_imprese_completa_b.soggetto_codice_catastale_comune_nascita,
    vw_gisa_imprese_completa_b.soggetto_data_nascita,
    vw_gisa_imprese_completa_b.soggetto_codice_fiscale,
    vw_gisa_imprese_completa_b.soggetto_email,
    vw_gisa_imprese_completa_b.soggetto_telefono,
    vw_gisa_imprese_completa_b.soggetto_indirizzo_toponimo,
    vw_gisa_imprese_completa_b.soggetto_indirizzo,
    vw_gisa_imprese_completa_b.soggetto_indirizzo_civico,
    vw_gisa_imprese_completa_b.soggetto_indirizzo_istat_comune,
    vw_gisa_imprese_completa_b.soggetto_indirizzo_provincia,
    vw_gisa_imprese_completa_b.linea_id,
    vw_gisa_imprese_completa_b.linea_data_inizio,
    vw_gisa_imprese_completa_b.linea_data_fine,
    vw_gisa_imprese_completa_b.linea_norma_codice,
    vw_gisa_imprese_completa_b.linea_macroarea_codice,
    vw_gisa_imprese_completa_b.linea_aggregazione_codice,
    vw_gisa_imprese_completa_b.linea_attivita_codice,
    vw_gisa_imprese_completa_b.linea_ateco,
    vw_gisa_imprese_completa_b.attivita_fissa,
    vw_gisa_imprese_completa_b.linea_principale
   FROM conf_ext.vw_gisa_imprese_completa_b;


ALTER TABLE cu_anag.vw_gisa_imprese_completa_ab OWNER TO postgres;

--
-- Name: vw_gisa_imprese_linee_secondarie_a; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_gisa_imprese_linee_secondarie_a AS
 SELECT i.impresa_id,
    i.stabilimento_id,
    i.impresa_ragione_sociale,
    i.stabilimento_denominazione,
    p.pr_id AS linea_id,
    p.pr_data_inizio AS linea_data_inizio,
    p.pr_data_fine AS linea_data_fine,
    p.sn_codice AS linea_norma_codice,
    p.ss_codice AS linea_macroarea_codice,
    p.sa_codice AS linea_aggregazione_codice,
    p.sp_codice AS linea_attivita_codice,
    p.pr_cod_attivita AS linea_ateco,
    p.pr_principale AS linea_principale
   FROM (conf_ext.vw_gisa_imprese_completa_a i
     JOIN ( SELECT DISTINCT ON (fvg_gisa_imprese_produzione.pr_id) fvg_gisa_imprese_produzione.pr_id,
            fvg_gisa_imprese_produzione.gi_sd_id,
            fvg_gisa_imprese_produzione.pr_data_inizio,
            fvg_gisa_imprese_produzione.pr_data_fine,
            fvg_gisa_imprese_produzione.sn_codice,
            fvg_gisa_imprese_produzione.ss_codice,
            fvg_gisa_imprese_produzione.sa_codice,
            fvg_gisa_imprese_produzione.sp_codice,
            fvg_gisa_imprese_produzione.pr_cod_attivita,
            fvg_gisa_imprese_produzione.pr_principale
           FROM conf_ext.fvg_gisa_imprese_produzione
          WHERE (((fvg_gisa_imprese_produzione.pr_cod_attivita)::text IN ( SELECT vw_ag_tree_nodes_up_tipo_linee.cod_mod
                   FROM agenda.vw_ag_tree_nodes_up_tipo_linee)) AND ((fvg_gisa_imprese_produzione.pr_principale = (0)::numeric) OR (fvg_gisa_imprese_produzione.pr_principale IS NULL)) AND (NOT (fvg_gisa_imprese_produzione.pr_id IN ( SELECT vw_gisa_imprese_completa_a.linea_id
                   FROM conf_ext.vw_gisa_imprese_completa_a))))
          ORDER BY fvg_gisa_imprese_produzione.pr_id, fvg_gisa_imprese_produzione.gi_sd_id, fvg_gisa_imprese_produzione.pr_data_inizio DESC) p ON ((i.stabilimento_id = p.gi_sd_id)))
  WHERE (p.pr_data_fine IS NULL);


ALTER TABLE cu_anag.vw_gisa_imprese_linee_secondarie_a OWNER TO postgres;

--
-- Name: tipi_figura_impresa; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.tipi_figura_impresa (
    id bigint NOT NULL,
    cod character varying,
    sigla character varying,
    descr character varying
);


ALTER TABLE cu_types.tipi_figura_impresa OWNER TO postgres;

--
-- Name: vw_tipi_figura_impresa; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_tipi_figura_impresa AS
 SELECT tipi_figura_impresa.id AS id_tipo_figura_impresa,
    tipi_figura_impresa.id,
    tipi_figura_impresa.cod,
    tipi_figura_impresa.sigla,
    tipi_figura_impresa.descr
   FROM cu_types.tipi_figura_impresa;


ALTER TABLE cu_types.vw_tipi_figura_impresa OWNER TO postgres;

--
-- Name: vw_impresa_figure_all; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_impresa_figure_all AS
 SELECT f.id AS id_impresa_figura,
    f.id,
    f.id_impresa,
    f.id_soggetto AS id_soggetto_fisico,
    f.id_tipo_figura,
    f.id_indirizzo,
    tf.sigla AS sigla_tipo_figura,
    tf.descr AS descr_tipo_figura,
    imp.cod_tipo_impresa,
    imp.piva AS piva_impresa,
    imp.cf,
    imp.email,
    imp.telefono,
    imp.nome,
    imp.soggetto_fisico_nome,
    imp.cognome,
    imp.cf AS codice_fiscale,
    imp.data_nascita,
    imp.comune_nascita,
    imp.istat_nascita,
    i.toponimo,
    i.indirizzo AS indirizzo_nome,
    i.civico,
    i.cap,
    i.localita,
    i.comune,
    i.comune AS comune_residenza,
    i.istat_comune,
    i.stato_prov AS stato,
    i.nazione,
    i.indirizzo_completo,
    f.fonte,
    lower(f.validita) AS inizio_validita,
    (upper(f.validita) - '1 day'::interval) AS fine_validita,
    f.validita,
    sf.nome AS nome_figura,
    sf.cognome AS cognome_figura,
        CASE
            WHEN ((sogg.tipo_soggetto)::text = 'F'::text) THEN (COALESCE(((sf.nome)::text || ' '::text), ''::text) || (sf.cognome)::text)
            ELSE (sogg.nome)::text
        END AS nome_completo_figura,
    sf.codice_fiscale AS cf_figura,
    tf.cod AS cod_tipo_figura,
    imp.modificabile,
    i.estero,
    (f.id_indirizzo <> sf.indirizzo_id) AS domicilio,
    sf.comune_nascita_descr
   FROM (((((cu_anag.impresa_figure f
     JOIN cu_anag.vw_imprese_all imp ON ((imp.id_impresa = f.id_impresa)))
     JOIN cu_types.vw_tipi_figura_impresa tf ON ((tf.id_tipo_figura_impresa = f.id_tipo_figura)))
     JOIN cu_anag.imprese sogg ON ((f.id_soggetto = sogg.id)))
     LEFT JOIN cu_anag.vw_soggetti_fisici sf ON (((sf.codice_fiscale)::text = (sogg.cf)::text)))
     LEFT JOIN cu_anag.vw_indirizzi i ON ((i.id_indirizzo = f.id_indirizzo)));


ALTER TABLE cu_anag.vw_impresa_figure_all OWNER TO postgres;

--
-- Name: vw_impresa_figure; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_impresa_figure AS
 SELECT vw_impresa_figure_all.id_impresa_figura,
    vw_impresa_figure_all.id,
    vw_impresa_figure_all.id_impresa,
    vw_impresa_figure_all.id_soggetto_fisico,
    vw_impresa_figure_all.id_tipo_figura,
    vw_impresa_figure_all.id_indirizzo,
    vw_impresa_figure_all.sigla_tipo_figura,
    vw_impresa_figure_all.descr_tipo_figura,
    vw_impresa_figure_all.cod_tipo_impresa,
    vw_impresa_figure_all.piva_impresa,
    vw_impresa_figure_all.cf,
    vw_impresa_figure_all.email,
    vw_impresa_figure_all.telefono,
    vw_impresa_figure_all.nome,
    vw_impresa_figure_all.soggetto_fisico_nome,
    vw_impresa_figure_all.cognome,
    vw_impresa_figure_all.codice_fiscale,
    vw_impresa_figure_all.data_nascita,
    vw_impresa_figure_all.comune_nascita,
    vw_impresa_figure_all.istat_nascita,
    vw_impresa_figure_all.toponimo,
    vw_impresa_figure_all.indirizzo_nome,
    vw_impresa_figure_all.civico,
    vw_impresa_figure_all.cap,
    vw_impresa_figure_all.localita,
    vw_impresa_figure_all.comune,
    vw_impresa_figure_all.comune_residenza,
    vw_impresa_figure_all.istat_comune,
    vw_impresa_figure_all.stato,
    vw_impresa_figure_all.nazione,
    vw_impresa_figure_all.indirizzo_completo,
    vw_impresa_figure_all.fonte,
    vw_impresa_figure_all.inizio_validita,
    vw_impresa_figure_all.fine_validita,
    vw_impresa_figure_all.validita,
    vw_impresa_figure_all.nome_figura,
    vw_impresa_figure_all.cognome_figura,
    vw_impresa_figure_all.nome_completo_figura,
    vw_impresa_figure_all.cf_figura,
    vw_impresa_figure_all.cod_tipo_figura,
    vw_impresa_figure_all.modificabile,
    vw_impresa_figure_all.domicilio
   FROM cu_anag.vw_impresa_figure_all
  WHERE (vw_impresa_figure_all.validita && tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));


ALTER TABLE cu_anag.vw_impresa_figure OWNER TO postgres;

--
-- Name: tipi_sede_impresa; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.tipi_sede_impresa (
    id bigint,
    cod character varying,
    sigla character varying,
    descr character varying
);


ALTER TABLE cu_types.tipi_sede_impresa OWNER TO postgres;

--
-- Name: vw_tipi_sede_impresa; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_tipi_sede_impresa AS
 SELECT tipi_sede_impresa.id AS id_tipo_sede_impresa,
    tipi_sede_impresa.id,
    tipi_sede_impresa.cod,
    tipi_sede_impresa.sigla,
    tipi_sede_impresa.descr
   FROM cu_types.tipi_sede_impresa;


ALTER TABLE cu_types.vw_tipi_sede_impresa OWNER TO postgres;

--
-- Name: vw_impresa_sedi_all; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_impresa_sedi_all AS
 SELECT ss.id AS id_impresa_sedi,
    ss.id,
    ss.id_impresa,
    ss.id_tipo_sede,
    ss.id_indirizzo,
    t.sigla AS sigla_tipo_sede,
    t.descr AS descr_tipo_sede,
    s.cod_tipo_impresa,
    s.nome AS ragsoc,
    s.piva,
    s.cf,
    ss.pec,
    ss.email,
    s.split_payement,
    s.sdi,
    i.toponimo,
    i.indirizzo,
    i.civico,
    i.cap,
    i.localita,
    i.comune,
    i.istat_comune,
    i.stato_prov AS stato,
    i.nazione,
    i.indirizzo_completo,
    ss.fonte,
    lower(ss.validita) AS inizio_validita,
    (upper(ss.validita) - '1 day'::interval) AS fine_validita,
    ss.validita,
    t.cod AS cod_tipo_sede,
    s.modificabile,
    i.estero,
    s.pec AS pec_impresa
   FROM (((cu_anag.impresa_sedi ss
     JOIN cu_anag.vw_imprese_all s ON ((ss.id_impresa = s.id_impresa)))
     JOIN cu_types.vw_tipi_sede_impresa t ON ((t.id_tipo_sede_impresa = ss.id_tipo_sede)))
     JOIN cu_anag.vw_indirizzi i ON ((i.id_indirizzo = ss.id_indirizzo)));


ALTER TABLE cu_anag.vw_impresa_sedi_all OWNER TO postgres;

--
-- Name: vw_impresa_sedi; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_impresa_sedi AS
 SELECT vw_impresa_sedi_all.id_impresa_sedi,
    vw_impresa_sedi_all.id,
    vw_impresa_sedi_all.id_impresa,
    vw_impresa_sedi_all.id_tipo_sede,
    vw_impresa_sedi_all.id_indirizzo,
    vw_impresa_sedi_all.sigla_tipo_sede,
    vw_impresa_sedi_all.descr_tipo_sede,
    vw_impresa_sedi_all.cod_tipo_impresa,
    vw_impresa_sedi_all.ragsoc,
    vw_impresa_sedi_all.piva,
    vw_impresa_sedi_all.cf,
    vw_impresa_sedi_all.pec,
    vw_impresa_sedi_all.email,
    vw_impresa_sedi_all.split_payement,
    vw_impresa_sedi_all.sdi,
    vw_impresa_sedi_all.toponimo,
    vw_impresa_sedi_all.indirizzo,
    vw_impresa_sedi_all.civico,
    vw_impresa_sedi_all.cap,
    vw_impresa_sedi_all.localita,
    vw_impresa_sedi_all.comune,
    vw_impresa_sedi_all.istat_comune,
    vw_impresa_sedi_all.stato,
    vw_impresa_sedi_all.nazione,
    vw_impresa_sedi_all.indirizzo_completo,
    vw_impresa_sedi_all.fonte,
    vw_impresa_sedi_all.inizio_validita,
    vw_impresa_sedi_all.fine_validita,
    vw_impresa_sedi_all.validita,
    vw_impresa_sedi_all.cod_tipo_sede,
    vw_impresa_sedi_all.modificabile
   FROM cu_anag.vw_impresa_sedi_all
  WHERE (vw_impresa_sedi_all.validita && tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));


ALTER TABLE cu_anag.vw_impresa_sedi OWNER TO postgres;

--
-- Name: vw_imprese_all_count; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_imprese_all_count AS
 SELECT i.id_impresa,
    i.id,
    i.nome,
    i.cf,
    i.piva,
    i.pec,
    i.email,
    i.sdi,
    i.split_payement,
    i.cod_tipo_impresa,
    i.az_id,
    i.az_cod_aziendale,
    i.az_cod_regionale,
    i.sd_id,
    i.verificato,
    i.fonte,
    i.cognome,
    i.soggetto_fisico_nome,
    i.inizio_validita,
    i.fine_validita,
    i.validita,
    COALESCE(n.numero, (0)::bigint) AS numero
   FROM (cu_anag.vw_imprese_all i
     LEFT JOIN ( SELECT s.id_impresa,
            count(*) AS numero
           FROM cu_anag.vw_stabilimenti s
          GROUP BY s.id_impresa) n ON ((n.id_impresa = i.id)));


ALTER TABLE cu_anag.vw_imprese_all_count OWNER TO postgres;

--
-- Name: vw_imprese_count; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_imprese_count AS
 SELECT i.id_impresa,
    i.id,
    i.nome,
    i.cf,
    i.piva,
    i.pec,
    i.email,
    i.sdi,
    i.split_payement,
    i.cod_tipo_impresa,
    i.az_id,
    i.az_cod_aziendale,
    i.az_cod_regionale,
    i.sd_id,
    i.verificato,
    i.fonte,
    i.cognome,
    i.soggetto_fisico_nome,
    i.inizio_validita,
    i.fine_validita,
    i.validita,
    COALESCE(n.numero, (0)::bigint) AS numero,
    i.id_asl
   FROM (cu_anag.vw_imprese_all i
     LEFT JOIN ( SELECT s.id_impresa,
            count(*) AS numero
           FROM cu_anag.vw_stabilimenti s
          GROUP BY s.id_impresa) n ON ((n.id_impresa = i.id)));


ALTER TABLE cu_anag.vw_imprese_count OWNER TO postgres;

--
-- Name: vw_mangimifici_reg_imprese; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_mangimifici_reg_imprese AS
 SELECT mangimifici_reg.ragione_sociale,
    mangimifici_reg.cf,
    COALESCE(mangimifici_reg.piva, mangimifici_reg.cf) AS piva,
    'MANG'::text AS tipo,
    min(mangimifici_reg.id) AS az_id
   FROM cu_anag.mangimifici_reg
  WHERE ((mangimifici_reg.stato)::text = 'ATTIVA'::text)
  GROUP BY mangimifici_reg.ragione_sociale, mangimifici_reg.cf, COALESCE(mangimifici_reg.piva, mangimifici_reg.cf), 'MANG'::text;


ALTER TABLE cu_anag.vw_mangimifici_reg_imprese OWNER TO postgres;

--
-- Name: vw_mangimifici_reg_linee; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_mangimifici_reg_linee AS
 SELECT mangimifici_reg.ragione_sociale,
    mangimifici_reg.cf,
    mangimifici_reg.denominazione_sede,
    COALESCE(mangimifici_reg.piva, mangimifici_reg.cf) AS piva,
    mangimifici_reg.indirizzo_sede_produttiva,
    mangimifici_reg.comune,
    mangimifici_reg.dettaglio_attivita,
    'MANG'::text AS tipo,
    min(mangimifici_reg.id) AS l_id
   FROM cu_anag.mangimifici_reg
  WHERE ((mangimifici_reg.stato)::text = 'ATTIVA'::text)
  GROUP BY mangimifici_reg.ragione_sociale, mangimifici_reg.cf, mangimifici_reg.denominazione_sede, COALESCE(mangimifici_reg.piva, mangimifici_reg.cf), mangimifici_reg.indirizzo_sede_produttiva, mangimifici_reg.comune, mangimifici_reg.dettaglio_attivita, 'MANG'::text;


ALTER TABLE cu_anag.vw_mangimifici_reg_linee OWNER TO postgres;

--
-- Name: vw_mangimifici_reg_stabilimenti; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_mangimifici_reg_stabilimenti AS
 SELECT mangimifici_reg.ragione_sociale,
    mangimifici_reg.cf,
    mangimifici_reg.denominazione_sede,
    COALESCE(mangimifici_reg.piva, mangimifici_reg.cf) AS piva,
    mangimifici_reg.indirizzo_sede_produttiva,
    'MANG'::text AS tipo,
    mangimifici_reg.cun,
    mangimifici_reg.num_ric_reg,
    mangimifici_reg.ric_reg,
    min(mangimifici_reg.id) AS sd_id
   FROM cu_anag.mangimifici_reg
  WHERE ((mangimifici_reg.stato)::text = 'ATTIVA'::text)
  GROUP BY mangimifici_reg.ragione_sociale, mangimifici_reg.cf, mangimifici_reg.denominazione_sede, COALESCE(mangimifici_reg.piva, mangimifici_reg.cf), mangimifici_reg.indirizzo_sede_produttiva, 'MANG'::text, mangimifici_reg.cun, mangimifici_reg.num_ric_reg, mangimifici_reg.ric_reg;


ALTER TABLE cu_anag.vw_mangimifici_reg_stabilimenti OWNER TO postgres;

--
-- Name: stati_pratiche; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.stati_pratiche (
    id integer NOT NULL,
    cod character varying,
    descr character varying
);


ALTER TABLE cu_types.stati_pratiche OWNER TO postgres;

--
-- Name: tipi_pratiche; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.tipi_pratiche (
    id integer NOT NULL,
    cod character varying,
    descr character varying,
    stab_richiesto boolean DEFAULT false
);


ALTER TABLE cu_types.tipi_pratiche OWNER TO postgres;

--
-- Name: vw_stati_pratiche; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_stati_pratiche AS
 SELECT stati_pratiche.id AS id_stato_pratiche,
    stati_pratiche.id,
    stati_pratiche.cod,
    stati_pratiche.descr
   FROM cu_types.stati_pratiche;


ALTER TABLE cu_types.vw_stati_pratiche OWNER TO postgres;

--
-- Name: vw_tipi_pratiche; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_tipi_pratiche AS
 SELECT tipi_pratiche.id AS id_tipo_pratiche,
    tipi_pratiche.id,
    tipi_pratiche.cod,
    tipi_pratiche.descr,
    tipi_pratiche.stab_richiesto
   FROM cu_types.tipi_pratiche;


ALTER TABLE cu_types.vw_tipi_pratiche OWNER TO postgres;

--
-- Name: vw_pratiche; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_pratiche AS
 SELECT p.id AS id_pratica,
    p.n_pratica,
    (s.cod_regionale)::text AS cod_regionale_pratica,
    p.id_tipo_pratica,
    tp.cod AS cod_tipo_pratica,
    tp.descr AS descr_tipo_pratica,
    p.dt AS dt_pratica,
    s.id_stabilimento,
    s.id,
    s.id_impresa,
    s.sd_id,
    s.nome,
    s.istat,
    s.comune,
    s.toponimo,
    s.indirizzo,
    s.civico,
    s.ragsoc,
    s.cf_impresa,
    s.piva_impresa,
    s.sd_cod_regionale,
    s.nazione,
    s.cap,
    s.cod_tipologia_struttura,
    s.fonte,
    s.az_cod_aziendale,
    s.az_cod_regionale,
    s.cod_tipo_impresa,
    s.siglaprovincia,
    s.indirizzo_luogo,
    s.valida,
    s.id_asl,
    s.verificato,
    s.categoria_rischio,
    s.id_indirizzo,
    s.cod_registrazione,
    s.stato_prov,
    s.istat_comune,
    s.inizio_validita,
    s.fine_validita,
    s.validita,
    s.indirizzo_completo,
    s.descr_cod_naz,
    s.descr_cod_reg,
    s.cod_nazionale,
    s.sigla_tipologia_struttura,
    s.id_tipologia_struttura,
    s.id_asl_stabilimento,
    s.id_asl_impresa,
    s.modificabile,
    s.id_comune,
    s.asl_descr,
    s.categoria_rischio_descr,
    s.pec,
    s.telefono,
    s.chiuso,
    s.split_payement,
    s.sdi,
    s.descrizione_tipologia_struttura,
    s.cod_regionale,
    s.verificato_str,
    s.verificato_descr,
    s.stabilimento_modificabile,
    s.sedi_modificabili,
    s.figure_modificabili,
    s.linee_modificabili,
    s.richiede_codice_regionale,
    s.estero,
    s.latest_storico,
    s.pec_impresa,
    sp.cod AS cod_stato_pratica,
    sp.descr AS descr_stato_pratica,
    p.dt_autorizzazione
   FROM (((cu_anag.pratiche p
     JOIN cu_types.vw_tipi_pratiche tp ON ((tp.id_tipo_pratiche = p.id_tipo_pratica)))
     LEFT JOIN cu_anag.vw_stabilimenti_all s ON ((s.id_stabilimento = p.id_stabilimento)))
     JOIN cu_types.vw_stati_pratiche sp ON ((sp.id_stato_pratiche = p.stato)));


ALTER TABLE cu_anag.vw_pratiche OWNER TO postgres;

--
-- Name: vw_stabilimento_automezzi; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_stabilimento_automezzi AS
 SELECT sa.id AS id_stabilimento_automezzi,
    sa.id_stabilimento,
    sa.id_automezzo,
    sa.validita,
    vsa.nome,
    vsa.cod_regionale,
    vsa.piva_impresa,
    vsa.comune,
    vsa.descrizione_tipologia_struttura,
    lower(sa.validita) AS inizio_validita_stab_automezzi,
    upper(sa.validita) AS fine_validita_stab_automezzi
   FROM ((cu_anag.stabilimento_automezzi sa
     JOIN cu_anag.vw_stabilimenti_all vsa ON ((vsa.id_stabilimento = sa.id_stabilimento)))
     JOIN cu_anag.vw_automezzi va ON ((va.id_automezzo = sa.id_automezzo)));


ALTER TABLE cu_anag.vw_stabilimento_automezzi OWNER TO postgres;

--
-- Name: tipi_figura; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.tipi_figura (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL
);


ALTER TABLE cu_types.tipi_figura OWNER TO postgres;

--
-- Name: vw_tipi_figura; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_tipi_figura AS
 SELECT tipi_figura.id AS id_tipo_figura,
    tipi_figura.id,
    tipi_figura.cod,
    tipi_figura.sigla,
    tipi_figura.descr
   FROM cu_types.tipi_figura;


ALTER TABLE cu_types.vw_tipi_figura OWNER TO postgres;

--
-- Name: vw_stabilimento_figure_all; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_stabilimento_figure_all AS
 SELECT f.id AS id_stabilimento_figura,
    f.id,
    f.id_stabilimento,
    f.id_soggetto AS id_soggetto_fisico,
    f.id_tipo_figura,
    f.id_indirizzo,
    imp.nome,
    imp.cognome,
    imp.cf AS codice_fiscale,
    tf.sigla AS sigla_tipo_figura,
    tf.descr AS descr_tipo_figura,
    i.toponimo,
    i.indirizzo AS indirizzo_nome,
    i.comune,
    s.nome AS nome_stabilimento,
    s.ragsoc,
    imp.email,
    imp.telefono,
    imp.data_nascita,
    imp.comune_nascita,
    i.comune AS comune_residenza,
    i.cap,
    i.civico,
    s.cod_tipo_impresa,
    s.cf_impresa,
    s.piva_impresa,
    imp.cf,
    i.istat_comune,
    f.fonte,
    imp.istat_nascita,
    lower(f.validita) AS inizio_validita,
    (upper(f.validita) - '1 day'::interval) AS fine_validita,
    f.validita,
    i.indirizzo_completo,
    imp.soggetto_fisico_nome,
    imp.id_impresa,
    tf.cod AS cod_tipo_figura,
    f.old_id,
    f.descr,
    f.id_soggetto,
    s.figure_modificabili,
    sf.nome AS nome_figura,
    sf.cognome AS cognome_figura,
        CASE
            WHEN ((imp.tipo_soggetto)::text = 'F'::text) THEN (COALESCE(((sf.nome)::text || ' '::text), ''::text) || (sf.cognome)::text)
            ELSE (imp.nome)::text
        END AS nome_completo_figura,
    sf.codice_fiscale AS cf_figura,
    i.estero,
    s.id_asl,
    (f.id_indirizzo <> sf.indirizzo_id) AS domicilio,
    imp.pec AS pec_impresa,
    sf.comune_nascita_descr
   FROM (((((cu_anag.stabilimento_figure f
     JOIN cu_anag.vw_stabilimenti_all s ON ((s.id_stabilimento = f.id_stabilimento)))
     JOIN cu_anag.vw_imprese_all imp ON ((imp.id_impresa = f.id_soggetto)))
     JOIN cu_types.vw_tipi_figura tf ON ((tf.id_tipo_figura = f.id_tipo_figura)))
     LEFT JOIN cu_anag.vw_soggetti_fisici sf ON (((sf.codice_fiscale)::text = (imp.cf)::text)))
     LEFT JOIN cu_anag.vw_indirizzi i ON ((i.id_indirizzo = f.id_indirizzo)));


ALTER TABLE cu_anag.vw_stabilimento_figure_all OWNER TO postgres;

--
-- Name: vw_stabilimento_figure; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_stabilimento_figure AS
 SELECT sf.id_stabilimento_figura,
    sf.id,
    sf.id_stabilimento,
    sf.id_soggetto_fisico,
    sf.id_tipo_figura,
    sf.id_indirizzo,
    sf.nome,
    sf.cognome,
    sf.codice_fiscale,
    sf.sigla_tipo_figura,
    sf.descr_tipo_figura,
    sf.toponimo,
    sf.indirizzo_nome,
    sf.comune,
    sf.nome_stabilimento,
    sf.ragsoc,
    sf.email,
    sf.telefono,
    sf.data_nascita,
    sf.comune_nascita,
    sf.comune_residenza,
    sf.cap,
    sf.civico,
    sf.cod_tipo_impresa,
    sf.cf_impresa,
    sf.piva_impresa,
    sf.cf,
    sf.istat_comune,
    sf.fonte,
    sf.istat_nascita,
    sf.inizio_validita,
    sf.fine_validita,
    sf.validita,
    sf.id_impresa,
    sf.cod_tipo_figura,
    sf.old_id,
    sf.descr,
    sf.id_soggetto,
    sf.nome_figura,
    sf.cognome_figura,
    sf.nome_completo_figura,
    sf.cf_figura,
    sf.estero,
    sf.domicilio
   FROM cu_anag.vw_stabilimento_figure_all sf
  WHERE (sf.validita && tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));


ALTER TABLE cu_anag.vw_stabilimento_figure OWNER TO postgres;

--
-- Name: tipi_sede; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.tipi_sede (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL
);


ALTER TABLE cu_types.tipi_sede OWNER TO postgres;

--
-- Name: vw_tipi_sede; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_tipi_sede AS
 SELECT tipi_sede.id AS id_tipo_sede,
    tipi_sede.id,
    tipi_sede.cod,
    tipi_sede.sigla,
    tipi_sede.descr
   FROM cu_types.tipi_sede;


ALTER TABLE cu_types.vw_tipi_sede OWNER TO postgres;

--
-- Name: vw_stabilimento_sedi_all; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_stabilimento_sedi_all AS
 SELECT ss.id AS id_stabilimento_sedi,
    ss.id,
    ss.id_stabilimento,
    ss.id_tipo_sede,
    ss.id_indirizzo,
    t.sigla AS sigla_tipo_sede,
    i.toponimo,
    i.indirizzo,
    i.cap,
    i.stato_prov AS stato,
    i.nazione,
    i.comune,
    i.localita,
    t.descr AS descr_tipo_sede,
    i.civico,
    NULL::character varying AS cod_tipo_impresa,
    s.ragsoc,
    i.istat_comune,
    s.cf_impresa,
    s.piva_impresa,
    s.cf_impresa AS cf,
    ss.pec,
    ss.email,
    NULL::character varying AS split_payement,
    NULL::character varying AS sdi,
    s.piva_impresa AS piva,
    lower(ss.validita) AS inizio_validita,
    (upper(ss.validita) - '1 day'::interval) AS fine_validita,
    ss.validita,
    i.indirizzo_completo,
    t.cod AS cod_tipo_sede,
    s.id_impresa,
    ss.old_id,
    ss.fonte,
    s.nome,
    s.sedi_modificabili,
    i.estero,
    s.id_asl,
    s.pec_impresa
   FROM (((cu_anag.stabilimento_sedi ss
     JOIN cu_anag.vw_stabilimenti_all s ON ((ss.id_stabilimento = s.id_stabilimento)))
     JOIN cu_types.vw_tipi_sede t ON ((t.id_tipo_sede = ss.id_tipo_sede)))
     JOIN cu_anag.vw_indirizzi i ON ((i.id_indirizzo = ss.id_indirizzo)));


ALTER TABLE cu_anag.vw_stabilimento_sedi_all OWNER TO postgres;

--
-- Name: vw_stabilimento_sedi; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_stabilimento_sedi AS
 SELECT ss.id_stabilimento_sedi,
    ss.id,
    ss.id_stabilimento,
    ss.id_tipo_sede,
    ss.id_indirizzo,
    ss.sigla_tipo_sede,
    ss.toponimo,
    ss.indirizzo,
    ss.cap,
    ss.stato,
    ss.nazione,
    ss.comune,
    ss.localita,
    ss.descr_tipo_sede,
    ss.civico,
    ss.cod_tipo_impresa,
    ss.ragsoc,
    ss.istat_comune,
    ss.cf_impresa,
    ss.piva_impresa,
    ss.cf,
    ss.pec,
    ss.email,
    ss.split_payement,
    NULL::character varying AS sdi,
    ss.piva,
    ss.inizio_validita,
    ss.fine_validita,
    ss.validita,
    ss.indirizzo_completo,
    ss.cod_tipo_sede,
    ss.id_impresa,
    ss.old_id,
    ss.fonte,
    ss.estero
   FROM cu_anag.vw_stabilimento_sedi_all ss
  WHERE (ss.validita && tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '[)'::text));


ALTER TABLE cu_anag.vw_stabilimento_sedi OWNER TO postgres;

--
-- Name: vw_stabilimento_veterinario; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_stabilimento_veterinario AS
 SELECT DISTINCT l.id_stabilimento,
    n.id_anagrafica,
    n.nominativo
   FROM ((agenda.nominativo_linee nl
     LEFT JOIN cu_anag.vw_linee l ON ((nl.id_linea = l.id)))
     LEFT JOIN agenda.vw_nominativi_struttura n ON ((nl.id_nominativo_struttura = n.id)));


ALTER TABLE cu_anag.vw_stabilimento_veterinario OWNER TO postgres;

--
-- Name: vw_storico_pratiche; Type: VIEW; Schema: cu_anag; Owner: postgres
--

CREATE VIEW cu_anag.vw_storico_pratiche AS
 SELECT s.id,
    s.id_pratica,
    s.id_stato_pratica,
    s.dt,
    s.user_id,
    st.descr AS descr_stato_pratica,
    (((usr.nome)::text || ' '::text) || (usr.cognome)::text) AS nominativo
   FROM ((cu_anag.storico_pratiche s
     JOIN cu_types.vw_stati_pratiche st ON ((st.id_stato_pratiche = s.id_stato_pratica)))
     JOIN rbac.vw_utente_strutture_ruoli usr ON ((usr.id_utente_struttura_ruolo = s.user_id)));


ALTER TABLE cu_anag.vw_storico_pratiche OWNER TO postgres;

--
-- Name: cu_categ_esiti_id_seq; Type: SEQUENCE; Schema: cu_conf; Owner: postgres
--

CREATE SEQUENCE cu_conf.cu_categ_esiti_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_conf.cu_categ_esiti_id_seq OWNER TO postgres;

--
-- Name: cu_categ_esiti_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_conf; Owner: postgres
--

ALTER SEQUENCE cu_conf.cu_categ_esiti_id_seq OWNED BY cu_conf.cu_categ_esiti.id;


--
-- Name: cu_categ_id_seq; Type: SEQUENCE; Schema: cu_conf; Owner: postgres
--

CREATE SEQUENCE cu_conf.cu_categ_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_conf.cu_categ_id_seq OWNER TO postgres;

--
-- Name: cu_categ_nodes_speciali; Type: TABLE; Schema: cu_conf; Owner: postgres
--

CREATE TABLE cu_conf.cu_categ_nodes_speciali (
    id_node bigint NOT NULL,
    validita tsrange
);


ALTER TABLE cu_conf.cu_categ_nodes_speciali OWNER TO postgres;

--
-- Name: cu_conf; Type: TABLE; Schema: cu_conf; Owner: postgres
--

CREATE TABLE cu_conf.cu_conf (
    id bigint NOT NULL,
    area character varying NOT NULL,
    cod character varying NOT NULL,
    descr character varying NOT NULL,
    value character varying NOT NULL,
    tipo character varying NOT NULL,
    validita tsrange DEFAULT tsrange('2023-01-01 00:00:00'::timestamp without time zone, NULL::timestamp without time zone, '[)'::text) NOT NULL,
    idx integer
);


ALTER TABLE cu_conf.cu_conf OWNER TO postgres;

--
-- Name: cu_conf_id_seq; Type: SEQUENCE; Schema: cu_conf; Owner: postgres
--

CREATE SEQUENCE cu_conf.cu_conf_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_conf.cu_conf_id_seq OWNER TO postgres;

--
-- Name: cu_conf_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_conf; Owner: postgres
--

ALTER SEQUENCE cu_conf.cu_conf_id_seq OWNED BY cu_conf.cu_conf.id;


--
-- Name: cu_oggetti_id_seq; Type: SEQUENCE; Schema: cu_conf; Owner: postgres
--

CREATE SEQUENCE cu_conf.cu_oggetti_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_conf.cu_oggetti_id_seq OWNER TO postgres;

--
-- Name: cu_oggetti_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_conf; Owner: postgres
--

ALTER SEQUENCE cu_conf.cu_oggetti_id_seq OWNED BY cu_conf.cu_tipo_oggetti.id;


--
-- Name: cu_piani_categ; Type: TABLE; Schema: cu_conf; Owner: postgres
--

CREATE TABLE cu_conf.cu_piani_categ (
    id bigint NOT NULL,
    id_piano bigint,
    id_node bigint
);


ALTER TABLE cu_conf.cu_piani_categ OWNER TO postgres;

--
-- Name: cu_piani_speciali; Type: TABLE; Schema: cu_conf; Owner: postgres
--

CREATE TABLE cu_conf.cu_piani_speciali (
    id bigint NOT NULL,
    sigla character varying NOT NULL,
    valore character varying NOT NULL,
    validita tsrange DEFAULT tsrange(NULL::timestamp without time zone, NULL::timestamp without time zone, '()'::text) NOT NULL
);


ALTER TABLE cu_conf.cu_piani_speciali OWNER TO postgres;

--
-- Name: cu_piani_speciali_id_seq; Type: SEQUENCE; Schema: cu_conf; Owner: postgres
--

CREATE SEQUENCE cu_conf.cu_piani_speciali_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_conf.cu_piani_speciali_id_seq OWNER TO postgres;

--
-- Name: cu_piani_speciali_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_conf; Owner: postgres
--

ALTER SEQUENCE cu_conf.cu_piani_speciali_id_seq OWNED BY cu_conf.cu_piani_speciali.id;


--
-- Name: cu_requisiti_id_seq; Type: SEQUENCE; Schema: cu_conf; Owner: postgres
--

CREATE SEQUENCE cu_conf.cu_requisiti_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_conf.cu_requisiti_id_seq OWNER TO postgres;

--
-- Name: cu_requisiti_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_conf; Owner: postgres
--

ALTER SEQUENCE cu_conf.cu_requisiti_id_seq OWNED BY cu_conf.cu_requisiti.id;


--
-- Name: cu_tecnica_id_seq; Type: SEQUENCE; Schema: cu_conf; Owner: postgres
--

CREATE SEQUENCE cu_conf.cu_tecnica_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_conf.cu_tecnica_id_seq OWNER TO postgres;

--
-- Name: cu_tecnica_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_conf; Owner: postgres
--

ALTER SEQUENCE cu_conf.cu_tecnica_id_seq OWNED BY cu_conf.cu_tecniche.id;


--
-- Name: cu_tipo_isp_id_seq; Type: SEQUENCE; Schema: cu_conf; Owner: postgres
--

CREATE SEQUENCE cu_conf.cu_tipo_isp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_conf.cu_tipo_isp_id_seq OWNER TO postgres;

--
-- Name: cu_tipo_isp_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_conf; Owner: postgres
--

ALTER SEQUENCE cu_conf.cu_tipo_isp_id_seq OWNED BY cu_conf.cu_tipo_isp.id;


--
-- Name: cu_tipo_oggetto_piani_id_seq; Type: SEQUENCE; Schema: cu_conf; Owner: postgres
--

CREATE SEQUENCE cu_conf.cu_tipo_oggetto_piani_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_conf.cu_tipo_oggetto_piani_id_seq OWNER TO postgres;

--
-- Name: cu_tipo_oggetto_piani_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_conf; Owner: postgres
--

ALTER SEQUENCE cu_conf.cu_tipo_oggetto_piani_id_seq OWNED BY cu_conf.cu_tipo_oggetto_piani.id;


--
-- Name: cu_tipo_per_id_seq; Type: SEQUENCE; Schema: cu_conf; Owner: postgres
--

CREATE SEQUENCE cu_conf.cu_tipo_per_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_conf.cu_tipo_per_id_seq OWNER TO postgres;

--
-- Name: cu_tipo_per_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_conf; Owner: postgres
--

ALTER SEQUENCE cu_conf.cu_tipo_per_id_seq OWNED BY cu_conf.cu_tipo_per.id;


--
-- Name: vw_cu_categ; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_categ AS
 SELECT cu_categ.id AS id_categ,
    cu_categ.id,
    cu_categ.cod,
    cu_categ.sigla,
    cu_categ.descr,
    cu_categ.fattore,
    cu_categ.peso,
    cu_categ.validita
   FROM cu_conf.cu_categ;


ALTER TABLE cu_conf.vw_cu_categ OWNER TO postgres;

--
-- Name: vw_cu_categ_alberi; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_categ_alberi AS
 SELECT vw_cu_categ_nodes_up_descr.id,
    vw_cu_categ_nodes_up_descr.cod,
    vw_cu_categ_nodes_up_descr.sigla,
    vw_cu_categ_nodes_up_descr.descr,
    vw_cu_categ_nodes_up_descr.fattore,
    vw_cu_categ_nodes_up_descr.peso,
    vw_cu_categ_nodes_up_descr.validita,
    vw_cu_categ_nodes_up_descr.id_node,
    vw_cu_categ_nodes_up_descr.id_node_parent,
    vw_cu_categ_nodes_up_descr.path,
    vw_cu_categ_nodes_up_descr.path_ord,
    vw_cu_categ_nodes_up_descr.path_descr,
    vw_cu_categ_nodes_up_descr.lv,
    vw_cu_categ_nodes_up_descr.node_descr,
    vw_cu_categ_nodes_up_descr.ordinamento
   FROM cu_conf.vw_cu_categ_nodes_up_descr
  WHERE (vw_cu_categ_nodes_up_descr.id_node_parent = 61);


ALTER TABLE cu_conf.vw_cu_categ_alberi OWNER TO postgres;

--
-- Name: vw_cu_categ_nodes_down; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_categ_nodes_down AS
 WITH RECURSIVE vw_cu_categ_nodes_down(id_node, id_node_parent, id_node_ref, peso, fattore) AS (
         SELECT n.id_node,
            n.id_node_parent,
            n.id_node AS id_node_ref,
            (0)::numeric AS peso,
            (1)::numeric AS fattore
           FROM (cu_conf.vw_cu_categ_nodes n
             JOIN cu_conf.vw_cu_categ c ON ((c.id = n.id_node)))
        UNION ALL
         SELECT down.id_node,
            down.id_node_parent,
            n.id_parent AS id_node_ref,
            ((down.peso * c.fattore) + c.peso) AS peso,
            c.fattore
           FROM ((vw_cu_categ_nodes_down down
             JOIN cu_conf.cu_categ_nodes n ON (((n.id = down.id_node_ref) AND (n.id_parent IS NOT NULL))))
             JOIN cu_conf.vw_cu_categ c ON ((c.id = n.id)))
        )
 SELECT vw_cu_categ_nodes_down.id_node,
    vw_cu_categ_nodes_down.id_node_parent,
    vw_cu_categ_nodes_down.id_node_ref,
    vw_cu_categ_nodes_down.peso,
    vw_cu_categ_nodes_down.fattore
   FROM vw_cu_categ_nodes_down;


ALTER TABLE cu_conf.vw_cu_categ_nodes_down OWNER TO postgres;

--
-- Name: vw_cu_piani_speciali; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_piani_speciali AS
 SELECT ps.id AS id_cu_piano_speciale,
    ps.id,
    ps.sigla,
    ps.valore,
    ps.validita,
    p.id AS id_piano
   FROM (cu_conf.cu_piani_speciali ps
     JOIN matrix.struttura_piani p ON (((ps.valore)::text = p.alias)));


ALTER TABLE cu_conf.vw_cu_piani_speciali OWNER TO postgres;

--
-- Name: vw_cu_requisiti_validi; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_requisiti_validi AS
 SELECT r.id AS id_requisito,
    r.id,
    r.id_tipo_oggetto,
    r.ord,
    r.norma,
    r.descr,
    r.cl,
    t.sigla AS tipo_oggetto_sigla,
    t.cod AS tipo_oggetto_cod,
    t.descr AS tipo_oggetto_descr,
    n.id_norma
   FROM ((cu_conf.cu_requisiti r
     JOIN cu_conf.vw_cu_tipo_oggetti t ON ((t.id_tipo_oggetto = r.id_tipo_oggetto)))
     JOIN cu_conf.vw_cu_norme n ON ((n.id_norma = r.id_norma)))
  WHERE (r.validita @> (CURRENT_DATE)::timestamp without time zone)
  ORDER BY t.ord, r.ord;


ALTER TABLE cu_conf.vw_cu_requisiti_validi OWNER TO postgres;

--
-- Name: vw_cu_tipo_oggetti_requisiti; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_tipo_oggetti_requisiti AS
 SELECT cto.id AS id_tipo_oggetto,
    cto.id,
    cto.sigla,
    cto.descr,
    cto.cod,
    cr.ord AS ord_requisito,
    cr.norma AS norma_requisito,
    cr.descr AS descr_requisito,
    cr.cl AS cl_requisito
   FROM (cu_conf.cu_tipo_oggetti cto
     LEFT JOIN cu_conf.cu_requisiti cr ON ((cto.id = cr.id_tipo_oggetto)))
  ORDER BY cto.cod, cr.ord;


ALTER TABLE cu_conf.vw_cu_tipo_oggetti_requisiti OWNER TO postgres;

--
-- Name: vw_cu_tipo_oggetti_requisiti_validi; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_tipo_oggetti_requisiti_validi AS
 SELECT cto.id AS id_tipo_oggetto,
    cto.id,
    cto.sigla,
    cto.descr,
    cto.cod,
    cr.ord AS ord_requisito,
    cr.id AS id_requisito,
    cr.norma AS norma_requisito,
    cr.descr AS descr_requisito,
    cr.cl AS cl_requisito,
    cr.enum_list,
    cr.tabella
   FROM (cu_conf.cu_tipo_oggetti cto
     LEFT JOIN cu_conf.cu_requisiti cr ON ((cto.id = cr.id_tipo_oggetto)))
  WHERE (cr.validita @> (CURRENT_DATE)::timestamp without time zone)
  ORDER BY cto.cod, cr.ord;


ALTER TABLE cu_conf.vw_cu_tipo_oggetti_requisiti_validi OWNER TO postgres;

--
-- Name: vw_cu_tipo_oggetti_validi; Type: VIEW; Schema: cu_conf; Owner: postgres
--

CREATE VIEW cu_conf.vw_cu_tipo_oggetti_validi AS
 SELECT cto.id AS id_tipo_oggetto,
    cto.id,
    cto.sigla,
    cto.descr,
    cto.cod,
    cto.validita,
    cto.ord
   FROM cu_conf.cu_tipo_oggetti cto
  WHERE (cto.validita @> LOCALTIMESTAMP)
  ORDER BY cto.ord;


ALTER TABLE cu_conf.vw_cu_tipo_oggetti_validi OWNER TO postgres;

--
-- Name: codici; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.codici (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint,
    appl character varying,
    value bigint,
    prefix character varying,
    id_asl bigint
);


ALTER TABLE cu_his.codici OWNER TO postgres;

--
-- Name: cu; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    codice character varying NOT NULL,
    dt timestamp without time zone NOT NULL,
    id_tecnica bigint NOT NULL,
    preavviso boolean NOT NULL,
    rilievi boolean NOT NULL,
    id_evento bigint,
    id_az_sede bigint,
    id_responsabile bigint,
    chiuso boolean NOT NULL,
    dt_chiusura timestamp without time zone,
    pec character varying,
    note_verbale character varying,
    note_generali character varying,
    dt_preavviso timestamp without time zone,
    mezzo_preavviso character varying,
    km_az numeric,
    km_pr numeric,
    id_stato_cu bigint
);


ALTER TABLE cu_his.cu OWNER TO postgres;

--
-- Name: cu_altri; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_altri (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    nome character varying,
    cognome character varying,
    comune_nascita character varying,
    dt_nascita date,
    cf character varying
);


ALTER TABLE cu_his.cu_altri OWNER TO postgres;

--
-- Name: cu_automezzi; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_automezzi (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_automezzo bigint NOT NULL
);


ALTER TABLE cu_his.cu_automezzi OWNER TO postgres;

--
-- Name: cu_dichiarazioni; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_dichiarazioni (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_cu_nucleo bigint NOT NULL,
    dichiarazione character varying NOT NULL
);


ALTER TABLE cu_his.cu_dichiarazioni OWNER TO postgres;

--
-- Name: cu_evidenza_linee; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_evidenza_linee (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_evidenza bigint NOT NULL,
    id_cu_linea bigint NOT NULL,
    chiuso boolean NOT NULL,
    id_fu bigint
);


ALTER TABLE cu_his.cu_evidenza_linee OWNER TO postgres;

--
-- Name: cu_evidenze; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_evidenze (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_cu_oggetto_cl bigint NOT NULL,
    id_cu_grado_evidenza bigint,
    evidenza character varying,
    risultanza character varying,
    id_cu_classe_evidenza bigint NOT NULL,
    ord integer
);


ALTER TABLE cu_his.cu_evidenze OWNER TO postgres;

--
-- Name: cu_indirizzi; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_indirizzi (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id integer NOT NULL,
    id_cu bigint NOT NULL,
    id_indirizzo bigint NOT NULL
);


ALTER TABLE cu_his.cu_indirizzi OWNER TO postgres;

--
-- Name: cu_linee; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_linee (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_cu bigint,
    id_linea bigint NOT NULL,
    ord integer NOT NULL,
    linea_originaria boolean
);


ALTER TABLE cu_his.cu_linee OWNER TO postgres;

--
-- Name: cu_nominativo_provv; Type: TABLE; Schema: cu_his; Owner: gisa_fvg
--

CREATE TABLE cu_his.cu_nominativo_provv (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_nominativo bigint NOT NULL
);


ALTER TABLE cu_his.cu_nominativo_provv OWNER TO gisa_fvg;

--
-- Name: cu_norme_violate; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_norme_violate (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_norma bigint NOT NULL
);


ALTER TABLE cu_his.cu_norme_violate OWNER TO postgres;

--
-- Name: cu_nucleo; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_nucleo (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_nominativo bigint NOT NULL,
    ord character varying NOT NULL,
    id_tipo_isp bigint,
    id_tipo_nucleo integer NOT NULL,
    ruolo character varying,
    per_conto_di bigint,
    id_tipo_per bigint,
    custode_verbale boolean
);


ALTER TABLE cu_his.cu_nucleo OWNER TO postgres;

--
-- Name: cu_nucleo_periodi; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_nucleo_periodi (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_cu_nucleo bigint NOT NULL,
    periodo tsrange NOT NULL,
    id_cu_piano bigint
);


ALTER TABLE cu_his.cu_nucleo_periodi OWNER TO postgres;

--
-- Name: cu_oggetti; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_oggetti (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    ord integer NOT NULL,
    id_tipo_oggetto bigint NOT NULL,
    chiuso boolean NOT NULL,
    id_stato_oggetto bigint
);


ALTER TABLE cu_his.cu_oggetti OWNER TO postgres;

--
-- Name: cu_oggetti_cl; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_oggetti_cl (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_cu_oggetto bigint NOT NULL,
    id_requisito bigint NOT NULL,
    id_stato_cl bigint,
    chiuso boolean NOT NULL
);


ALTER TABLE cu_his.cu_oggetti_cl OWNER TO postgres;

--
-- Name: cu_piani; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_piani (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_piano bigint NOT NULL,
    ord integer NOT NULL,
    id_perconto_di bigint NOT NULL
);


ALTER TABLE cu_his.cu_piani OWNER TO postgres;

--
-- Name: cu_provv; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_provv (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_norma_violata bigint NOT NULL,
    ord integer NOT NULL,
    id_tipo_provv bigint NOT NULL,
    azione character varying,
    dt date,
    chiuso boolean,
    id_fu bigint
);


ALTER TABLE cu_his.cu_provv OWNER TO postgres;

--
-- Name: cu_provv_fu; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_provv_fu (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_provv bigint NOT NULL,
    ord integer,
    risolta boolean
);


ALTER TABLE cu_his.cu_provv_fu OWNER TO postgres;

--
-- Name: cu_provv_sopralluogo; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_provv_sopralluogo (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id integer NOT NULL,
    id_cu bigint,
    id_cu_grado_evidenza bigint,
    id_cu_classe_evidenza bigint NOT NULL,
    evidenza character varying,
    id_tipo_provv bigint NOT NULL,
    dt date,
    id_cu_linea bigint NOT NULL,
    id_piano bigint NOT NULL,
    id_nominativo bigint NOT NULL
);


ALTER TABLE cu_his.cu_provv_sopralluogo OWNER TO postgres;

--
-- Name: cu_provv_sopralluogo_fu; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.cu_provv_sopralluogo_fu (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_cu bigint NOT NULL,
    id_provv bigint NOT NULL,
    ord integer,
    risolta boolean
);


ALTER TABLE cu_his.cu_provv_sopralluogo_fu OWNER TO postgres;

--
-- Name: impresa_figure; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.impresa_figure (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint,
    id_impresa bigint,
    id_tipo_figura bigint,
    id_indirizzo bigint,
    old_id bigint,
    fonte text,
    descr character varying,
    validita tsrange,
    id_soggetto bigint
);


ALTER TABLE cu_his.impresa_figure OWNER TO postgres;

--
-- Name: impresa_sedi; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.impresa_sedi (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint,
    id_impresa bigint,
    id_tipo_sede bigint,
    id_indirizzo bigint,
    pec character varying,
    email character varying,
    old_id bigint,
    fonte text,
    validita tsrange
);


ALTER TABLE cu_his.impresa_sedi OWNER TO postgres;

--
-- Name: imprese; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.imprese (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint,
    nome character varying,
    cf character varying,
    piva character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    az_id bigint,
    az_cod_aziendale character varying,
    az_cod_regionale character varying,
    sd_id bigint,
    verificato boolean,
    fonte character varying,
    validita tsrange,
    tipo_soggetto character varying
);


ALTER TABLE cu_his.imprese OWNER TO postgres;

--
-- Name: indirizzi; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.indirizzi (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint,
    toponimo character varying,
    indirizzo character varying,
    cap text,
    stato_prov character varying,
    nazione text,
    istat_comune character varying,
    comune character varying,
    localita text,
    civico character varying,
    latitudine character varying,
    longitudine character varying,
    verificato boolean,
    fonte text
);


ALTER TABLE cu_his.indirizzi OWNER TO postgres;

--
-- Name: linee; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.linee (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint,
    id_stabilimento bigint,
    id_tipo_linea integer,
    validita tsrange,
    attivita_fissa boolean,
    linea_principale boolean,
    verificato boolean,
    fonte text,
    data_ultima_visita timestamp without time zone,
    id_esterno character varying
);


ALTER TABLE cu_his.linee OWNER TO postgres;

--
-- Name: pratiche; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.pratiche (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id integer NOT NULL,
    id_tipo_pratica integer,
    n_pratica text,
    dt timestamp without time zone,
    id_stabilimento bigint,
    stato integer,
    dt_autorizzazione timestamp without time zone
);


ALTER TABLE cu_his.pratiche OWNER TO postgres;

--
-- Name: presenza; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.presenza (
    count bigint
);


ALTER TABLE cu_his.presenza OWNER TO postgres;

--
-- Name: riepilogo_cu; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.riepilogo_cu (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL
);


ALTER TABLE cu_his.riepilogo_cu OWNER TO postgres;

--
-- Name: riepilogo_cu_nodes; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.riepilogo_cu_nodes (
    id bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying,
    id_node_parent integer
);


ALTER TABLE cu_his.riepilogo_cu_nodes OWNER TO postgres;

--
-- Name: riepilogo_cu_nodes_id_seq; Type: SEQUENCE; Schema: cu_his; Owner: postgres
--

CREATE SEQUENCE cu_his.riepilogo_cu_nodes_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_his.riepilogo_cu_nodes_id_seq OWNER TO postgres;

--
-- Name: riepilogo_cu_nodes_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_his; Owner: postgres
--

ALTER SEQUENCE cu_his.riepilogo_cu_nodes_id_seq OWNED BY cu_his.riepilogo_cu_nodes.id;


--
-- Name: soggetti_fisici; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.soggetti_fisici (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint,
    titolo character varying,
    cognome character varying,
    nome character varying,
    comune_nascita character varying,
    codice_fiscale character varying,
    sesso character varying,
    telefono character varying,
    email character varying,
    pec character varying,
    telefono2 character varying,
    data_nascita date,
    documento_identita character varying,
    indirizzo_id bigint,
    verificato boolean,
    fonte character varying
);


ALTER TABLE cu_his.soggetti_fisici OWNER TO postgres;

--
-- Name: stabilimenti; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.stabilimenti (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint,
    id_impresa bigint,
    nome character varying,
    sd_id numeric(12,0),
    id_indirizzo bigint,
    cod_regionale character varying,
    verificato boolean,
    fonte character varying,
    categoria_rischio numeric,
    validita tsrange,
    cod_nazionale character varying,
    id_tipologia_struttura bigint,
    pec character varying,
    telefono character varying,
    sdi character varying
);


ALTER TABLE cu_his.stabilimenti OWNER TO postgres;

--
-- Name: stabilimento_figure; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.stabilimento_figure (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint,
    id_stabilimento bigint,
    id_soggetto bigint,
    id_tipo_figura bigint,
    id_indirizzo bigint,
    old_id bigint,
    fonte text,
    descr character varying,
    validita tsrange
);


ALTER TABLE cu_his.stabilimento_figure OWNER TO postgres;

--
-- Name: stabilimento_sedi; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.stabilimento_sedi (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id bigint,
    id_stabilimento bigint,
    id_tipo_sede bigint,
    id_indirizzo bigint,
    pec character varying,
    email character varying,
    old_id bigint,
    fonte text,
    validita tsrange
);


ALTER TABLE cu_his.stabilimento_sedi OWNER TO postgres;

--
-- Name: storico_pratiche; Type: TABLE; Schema: cu_his; Owner: postgres
--

CREATE TABLE cu_his.storico_pratiche (
    his_id bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    his_ts_transazione timestamp with time zone,
    id integer NOT NULL,
    id_pratica integer NOT NULL,
    id_stato_pratica integer NOT NULL,
    dt timestamp without time zone NOT NULL,
    user_id integer NOT NULL
);


ALTER TABLE cu_his.storico_pratiche OWNER TO postgres;

--
-- Name: vw_cu; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu AS
 SELECT c.his_id,
    c.his_validita,
    c.his_id_transazione,
    c.his_ts,
    c.his_ts_transazione,
    c.id,
    c.codice,
    c.dt,
    c.id_tecnica,
    c.preavviso,
    c.rilievi,
    c.id_evento,
    c.id_az_sede,
    c.id_responsabile,
    c.chiuso,
    c.dt_chiusura,
    c.pec,
    c.note_verbale,
    c.note_generali,
    c.dt_preavviso,
    c.mezzo_preavviso,
    c.km_az,
    c.km_pr,
    c.id_stato_cu,
    lower(c.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(c.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    t.sigla AS sigla_tecnica,
    t.descr AS descr_tecnica,
    a.nome AS denominazione_sede_operativa,
    (ind.comune)::character varying(32) AS comune,
        CASE
            WHEN c.chiuso THEN 'Chiuso'::text
            ELSE 'Aperto'::text
        END AS stato,
    vcsc.sigla AS sigla_stato,
    vcsc.descr AS descr_stato,
    t.cod AS cod_tecnica,
    a.pec AS pec_stabilimento,
    NULL::text AS data_chiusura_minima,
    a.cod_regionale,
    (c.km_az)::character varying AS auto_az,
    (c.km_pr)::character varying AS auto_pr
   FROM ((((((cu_his.cu c
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = c.his_id_transazione)))
     LEFT JOIN cu_conf.vw_cu_tecniche t ON ((c.id_tecnica = t.id_tecnica)))
     LEFT JOIN cu_anag.stabilimenti a ON ((c.id_az_sede = a.id)))
     LEFT JOIN cu_anag.vw_indirizzi ind ON ((ind.id = a.id_indirizzo)))
     LEFT JOIN matrix.vw_nominativi_struttura vns ON ((vns.id_nominativo = c.id_responsabile)))
     LEFT JOIN cu_types.vw_cu_stati_cu vcsc ON ((c.id_stato_cu = vcsc.id_stato_cu)));


ALTER TABLE cu_his.vw_cu OWNER TO postgres;

--
-- Name: vw_cu_altri; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_altri AS
 SELECT ca.his_id,
    ca.his_validita,
    ca.his_id_transazione,
    ca.his_ts,
    ca.his_ts_transazione,
    ca.id,
    ca.nome,
    ca.cognome,
    ca.comune_nascita,
    ca.dt_nascita,
    ca.cf,
    lower(ca.his_validita) AS inizio_validita_log,
    (to_char(lower(ca.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo
   FROM (cu_his.cu_altri ca
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = ca.his_id_transazione)));


ALTER TABLE cu_his.vw_cu_altri OWNER TO postgres;

--
-- Name: vw_cu_automezzi; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_automezzi AS
 SELECT ca.his_id,
    ca.his_validita,
    ca.his_id_transazione,
    ca.his_ts,
    ca.his_ts_transazione,
    ca.id,
    ca.id_automezzo,
    ca.id_cu,
    va.marca,
    va.modello,
    va.targa,
    lower(ca.his_validita) AS inizio_validita_log,
    (to_char(lower(ca.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo
   FROM ((cu_his.cu_automezzi ca
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = ca.his_id_transazione)))
     LEFT JOIN cu_anag.vw_automezzi va ON ((ca.id_automezzo = va.id_automezzo)));


ALTER TABLE cu_his.vw_cu_automezzi OWNER TO postgres;

--
-- Name: vw_cu_dichiarazioni; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_dichiarazioni AS
 SELECT cd.his_id,
    cd.his_validita,
    cd.his_id_transazione,
    cd.his_ts,
    cd.his_ts_transazione,
    cd.id,
    cd.id_cu_nucleo,
    cd.dichiarazione,
    lower(cd.his_validita) AS inizio_validita_log,
    (to_char(lower(cd.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    vcn.nominativo AS nominativo_nucleo,
    vcn.descr_tipo_nucleo,
    vcn.ruolo,
    vcn.dt_nascita,
    vcn.comune_nascita,
    vcn.cf,
    vcn.id_cu
   FROM ((cu_his.cu_dichiarazioni cd
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = cd.his_id_transazione)))
     JOIN cu.vw_cu_nucleo vcn ON ((vcn.id_cu_nucleo = cd.id_cu_nucleo)));


ALTER TABLE cu_his.vw_cu_dichiarazioni OWNER TO postgres;

--
-- Name: vw_cu_evidenza_linee; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_evidenza_linee AS
 SELECT cel.his_id,
    cel.his_validita,
    cel.his_id_transazione,
    cel.his_ts,
    cel.his_ts_transazione,
    cel.id,
    cel.id_evidenza,
    cel.id_cu_linea,
    cel.chiuso,
    cel.id_fu,
    lower(cel.his_validita) AS inizio_validita_log,
    (to_char(lower(cel.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    vce.evidenza,
    vce.descr_grado_evidenza,
    vce.descr_classe_evidenza,
    vce.norma
   FROM ((cu_his.cu_evidenza_linee cel
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = cel.his_id_transazione)))
     LEFT JOIN cu.vw_cu_evidenza_linee vce ON ((vce.id_evidenza = cel.id_evidenza)));


ALTER TABLE cu_his.vw_cu_evidenza_linee OWNER TO postgres;

--
-- Name: vw_cu_evidenze; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_evidenze AS
 SELECT ce.his_id,
    ce.his_validita,
    ce.his_id_transazione,
    ce.his_ts,
    ce.his_ts_transazione,
    ce.id,
    ce.id_cu_oggetto_cl,
    ce.id_cu_grado_evidenza,
    ce.evidenza,
    ce.risultanza,
    ce.id_cu_classe_evidenza,
    ce.ord,
    lower(ce.his_validita) AS inizio_validita_log,
    (to_char(lower(ce.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    vce.descr_grado_evidenza,
    vce.descr_classe_evidenza,
    vce.descr_oggetto,
    vce.descr_requisito,
    vce.norma,
    vce.denominazione_sede_operativa,
    vce.id_cu
   FROM ((cu_his.cu_evidenze ce
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = ce.his_id_transazione)))
     LEFT JOIN cu.vw_cu_evidenze vce ON ((vce.id_evidenza = ce.id)));


ALTER TABLE cu_his.vw_cu_evidenze OWNER TO postgres;

--
-- Name: vw_cu_linee; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_linee AS
 SELECT cl.his_id,
    cl.his_validita,
    cl.his_id_transazione,
    cl.his_ts,
    cl.his_ts_transazione,
    cl.id,
    cl.id_cu,
    cl.id_linea,
    cl.ord,
    cl.linea_originaria,
    lower(cl.his_validita) AS inizio_validita_log,
    (to_char(lower(cl.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    al.denominazione_sede_operativa,
    al.comune,
    al.desc_tipo_linea,
    c.id_az_sede
   FROM (((cu_his.cu_linee cl
     JOIN cu.cu c ON ((cl.id_cu = c.id)))
     JOIN agenda.vw_linee al ON ((al.id_linea = cl.id_linea)))
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = cl.his_id_transazione)));


ALTER TABLE cu_his.vw_cu_linee OWNER TO postgres;

--
-- Name: vw_cu_nominativo_provv; Type: VIEW; Schema: cu_his; Owner: gisa_fvg
--

CREATE VIEW cu_his.vw_cu_nominativo_provv AS
 SELECT np.his_id,
    np.his_validita,
    np.his_id_transazione,
    np.his_ts,
    np.his_ts_transazione,
    np.id,
    np.id AS id_nomintivo_provv,
    np.id_cu,
    np.id_nominativo,
    vns.nominativo,
    vns.id_struttura,
    vns.descrizione_breve
   FROM (((cu_his.cu_nominativo_provv np
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = np.his_id_transazione)))
     LEFT JOIN cu.vw_cu_nominativo_provv va ON ((np.id = va.id_nominativo_provv)))
     LEFT JOIN matrix.vw_nominativi_struttura vns ON ((vns.id_nominativo = np.id_nominativo)));


ALTER TABLE cu_his.vw_cu_nominativo_provv OWNER TO gisa_fvg;

--
-- Name: vw_cu_norme_violate; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_norme_violate AS
 SELECT cnv.his_id,
    cnv.his_validita,
    cnv.his_id_transazione,
    cnv.his_ts,
    cnv.his_ts_transazione,
    cnv.id,
    cnv.id_cu,
    cnv.id_norma,
    lower(cnv.his_validita) AS inizio_validita_log,
    (to_char(lower(cnv.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    n.norma,
    c.chiuso AS cu_chiuso
   FROM (((cu_his.cu_norme_violate cnv
     JOIN cu.cu c ON ((c.id = cnv.id_cu)))
     JOIN cu_conf.vw_cu_norme n ON ((n.id_norma = cnv.id_norma)))
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = cnv.his_id_transazione)));


ALTER TABLE cu_his.vw_cu_norme_violate OWNER TO postgres;

--
-- Name: vw_cu_nucleo; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_nucleo AS
 SELECT cn.his_id,
    cn.his_validita,
    cn.his_id_transazione,
    cn.his_ts,
    cn.his_ts_transazione,
    cn.id,
    cn.id_cu,
    cn.id_nominativo,
    cn.ord,
    cn.id_tipo_isp,
    cn.id_tipo_nucleo,
    cn.ruolo,
    cn.per_conto_di,
    cn.id_tipo_per,
    cn.custode_verbale,
    lower(cn.his_validita) AS inizio_validita_log,
    (to_char(lower(cn.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    vcn.nominativo AS nominativo_nucleo,
    vcn.descr_tipo_nucleo,
    vcn.ruolo AS ruolo_nucleo,
    vcn.dt_nascita,
    vcn.comune_nascita,
    vcn.cf
   FROM ((cu_his.cu_nucleo cn
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = cn.his_id_transazione)))
     JOIN cu.vw_cu_nucleo vcn ON ((vcn.id_cu_nucleo = cn.id)));


ALTER TABLE cu_his.vw_cu_nucleo OWNER TO postgres;

--
-- Name: vw_cu_nucleo_periodi; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_nucleo_periodi AS
 SELECT cnp.his_id,
    cnp.his_validita,
    cnp.his_id_transazione,
    cnp.his_ts,
    cnp.his_ts_transazione,
    cnp.id,
    cnp.id_cu_nucleo,
    cnp.periodo,
    cnp.id_cu_piano,
    lower(cnp.his_validita) AS inizio_validita_log,
    (to_char(lower(cnp.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    vcnp.nominativo AS nominativo_nucleo,
    vcnp.inizio,
    vcnp.fine,
    vcnp.ruolo,
    vcnp.descrizione_piano,
    vcnp.descrizione_struttura,
    vcnp.descr_isp,
    vcnp.nominativo_altri,
    vcnp.qualifica_cu,
    vcnp.dt_nascita,
    vcnp.comune_nascita,
    vcnp.cf,
    vcnp.descr_per,
    vcnp.sigla_tipo_nucleo,
    vcnp.id_cu
   FROM ((cu_his.cu_nucleo_periodi cnp
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = cnp.his_id_transazione)))
     LEFT JOIN cu.vw_cu_nucleo_periodi vcnp ON ((vcnp.id_nucleo_periodo = cnp.id)));


ALTER TABLE cu_his.vw_cu_nucleo_periodi OWNER TO postgres;

--
-- Name: vw_cu_oggetti; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_oggetti AS
 SELECT co.his_id,
    co.his_validita,
    co.his_id_transazione,
    co.his_ts,
    co.his_ts_transazione,
    co.id,
    co.id_cu,
    co.ord,
    co.id_tipo_oggetto,
    co.chiuso,
    co.id_stato_oggetto,
    lower(co.his_validita) AS inizio_validita_log,
    (to_char(lower(co.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    vco.descr_oggetto,
    vco.denominazione_sede_operativa,
    vco.descr_stato,
    vco.dt_cu,
    vco.cod_oggetto,
    vco.sigla_oggetto
   FROM ((cu_his.cu_oggetti co
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = co.his_id_transazione)))
     LEFT JOIN cu.vw_cu_oggetti vco ON ((vco.id_cu_oggetto = co.id)));


ALTER TABLE cu_his.vw_cu_oggetti OWNER TO postgres;

--
-- Name: vw_cu_oggetti_cl; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_oggetti_cl AS
 SELECT coc.his_id,
    coc.his_validita,
    coc.his_id_transazione,
    coc.his_ts,
    coc.his_ts_transazione,
    coc.id,
    coc.id_cu_oggetto,
    coc.id_requisito,
    coc.id_stato_cl,
    coc.chiuso,
    lower(coc.his_validita) AS inizio_validita_log,
    (to_char(lower(coc.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    vcoc.descr_oggetto,
    vcoc.descr_requisito,
    vcoc.descr_stato,
    vcoc.denominazione_sede_operativa,
    vcoc.norma,
    vcoc.dt_cu,
    vcoc.id_cu
   FROM ((cu_his.cu_oggetti_cl coc
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = coc.his_id_transazione)))
     LEFT JOIN cu.vw_cu_oggetti_cl vcoc ON ((vcoc.id_cu_oggetto_cl = coc.id)));


ALTER TABLE cu_his.vw_cu_oggetti_cl OWNER TO postgres;

--
-- Name: vw_cu_piani; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_piani AS
 SELECT cp.his_id,
    cp.his_validita,
    cp.his_id_transazione,
    cp.his_ts,
    cp.his_ts_transazione,
    cp.id,
    cp.id_cu,
    cp.id_piano,
    cp.ord,
    cp.id_perconto_di,
    lower(cp.his_validita) AS inizio_validita_log,
    (to_char(lower(cp.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    vcp.descrizione_completa_piano,
    vcp.sigla_tecnica,
    vcp.chiuso
   FROM ((cu_his.cu_piani cp
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = cp.his_id_transazione)))
     LEFT JOIN cu.vw_cu_piani vcp ON ((vcp.id_cu_piano = cp.id)));


ALTER TABLE cu_his.vw_cu_piani OWNER TO postgres;

--
-- Name: vw_cu_provv; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_provv AS
 SELECT cp.his_id,
    cp.his_validita,
    cp.his_id_transazione,
    cp.his_ts,
    cp.his_ts_transazione,
    cp.id,
    cp.id_norma_violata,
    cp.ord,
    cp.id_tipo_provv,
    cp.azione,
    cp.dt,
    cp.chiuso,
    cp.id_fu,
    lower(cp.his_validita) AS inizio_validita_log,
    (to_char(lower(cp.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    vcp.descr_tipo_provv,
    vcp.norma,
    vcp.id_cu
   FROM ((cu_his.cu_provv cp
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = cp.his_id_transazione)))
     LEFT JOIN cu.vw_cu_provv vcp ON ((vcp.id_provv = cp.id)));


ALTER TABLE cu_his.vw_cu_provv OWNER TO postgres;

--
-- Name: vw_cu_provv_fu; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_provv_fu AS
 SELECT cpf.his_id,
    cpf.his_validita,
    cpf.his_id_transazione,
    cpf.his_ts,
    cpf.his_ts_transazione,
    cpf.id,
    cpf.id_cu,
    cpf.id_provv,
    cpf.ord,
    cpf.risolta,
    lower(cpf.his_validita) AS inizio_validita_log,
    (to_char(lower(cpf.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    vcpf.dt,
    vcpf.descr_provv,
    vcpf.risolta_descr,
    vcpf.norma
   FROM ((cu_his.cu_provv_fu cpf
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = cpf.his_id_transazione)))
     LEFT JOIN cu.vw_cu_provv_fu vcpf ON ((vcpf.id_provv_fu = cpf.id)));


ALTER TABLE cu_his.vw_cu_provv_fu OWNER TO postgres;

--
-- Name: vw_cu_provv_sopralluogo; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_provv_sopralluogo AS
 SELECT cps.his_id,
    cps.his_validita,
    cps.his_id_transazione,
    cps.his_ts,
    cps.his_ts_transazione,
    cps.id,
    cps.id_cu,
    cps.id_cu_grado_evidenza,
    cps.id_cu_classe_evidenza,
    cps.evidenza,
    cps.id_tipo_provv,
    cps.dt,
    cps.id_cu_linea,
    cps.id_piano,
    cps.id_nominativo,
    lower(cps.his_validita) AS inizio_validita_log,
    (to_char(lower(cps.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    vcps.descr_tipo_provv,
    vcps.descr_grado_evidenza,
    vcps.descr_classe_evidenza,
    vcps.descr_linee,
    vcps.descrizione_completa_piano,
    vcps.nominativo_vet,
    vcps.descr_provv
   FROM ((cu_his.cu_provv_sopralluogo cps
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = cps.his_id_transazione)))
     LEFT JOIN cu.vw_cu_provv_sopralluogo vcps ON ((vcps.id = cps.id)));


ALTER TABLE cu_his.vw_cu_provv_sopralluogo OWNER TO postgres;

--
-- Name: vw_cu_provv_sopralluogo_fu; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_cu_provv_sopralluogo_fu AS
 SELECT cpsf.his_id,
    cpsf.his_validita,
    cpsf.his_id_transazione,
    cpsf.his_ts,
    cpsf.his_ts_transazione,
    cpsf.id,
    cpsf.id_cu,
    cpsf.id_provv,
    cpsf.ord,
    cpsf.risolta,
    lower(cpsf.his_validita) AS inizio_validita_log,
    (to_char(lower(cpsf.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    vcpsf.evidenza,
    vcpsf.descr_tipo_provv,
    vcpsf.dt,
    vcpsf.descr_grado_evidenza,
    vcpsf.descr_classe_evidenza,
    vcpsf.descr_linee,
    vcpsf.descrizione_completa_piano,
    vcpsf.nominativo_vet,
    vcpsf.risolta_descr,
    vcpsf.descr_provv
   FROM ((cu_his.cu_provv_sopralluogo_fu cpsf
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = cpsf.his_id_transazione)))
     LEFT JOIN cu.vw_cu_provv_sopralluogo_fu vcpsf ON ((vcpsf.id = cpsf.id)));


ALTER TABLE cu_his.vw_cu_provv_sopralluogo_fu OWNER TO postgres;

--
-- Name: vw_indirizzi; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_indirizzi AS
 SELECT i.his_id,
    i.his_validita,
    i.his_id_transazione,
    i.his_ts,
    i.his_ts_transazione,
    i.id,
    i.toponimo,
    i.indirizzo,
    i.cap,
    i.stato_prov,
    i.nazione,
    i.istat_comune,
    i.comune,
    i.localita,
    i.civico,
    i.latitudine,
    i.longitudine,
    i.verificato,
    i.fonte,
    lower(i.his_validita) AS inizio_validita_log,
    vi.indirizzo_completo,
    vt.nominativo,
    (to_char(lower(i.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log
   FROM ((cu_his.indirizzi i
     LEFT JOIN cu_anag.vw_indirizzi vi ON ((vi.id_indirizzo = i.id)))
     JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = i.his_id_transazione)));


ALTER TABLE cu_his.vw_indirizzi OWNER TO postgres;

--
-- Name: vw_impresa_figure; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_impresa_figure AS
 SELECT if2.his_id,
    if2.his_validita,
    if2.his_id_transazione,
    if2.his_ts,
    if2.his_ts_transazione,
    if2.id,
    if2.id_impresa,
    if2.id_tipo_figura,
    if2.id_indirizzo,
    if2.old_id,
    if2.fonte,
    if2.descr,
    if2.validita,
    if2.id_soggetto,
    lower(if2.his_validita) AS inizio_validita_log,
    vifa.nome_completo_figura,
    vifa.descr_tipo_figura,
    vifa.cf_figura,
    vt.nominativo,
    (to_char(lower(if2.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vi.indirizzo_completo
   FROM (((cu_his.impresa_figure if2
     LEFT JOIN cu_anag.vw_impresa_figure_all vifa ON ((if2.id_soggetto = vifa.id_soggetto_fisico)))
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = if2.his_id_transazione)))
     LEFT JOIN cu_his.vw_indirizzi vi ON (((vi.id = if2.id_indirizzo) AND (if2.his_validita && vi.his_validita))));


ALTER TABLE cu_his.vw_impresa_figure OWNER TO postgres;

--
-- Name: vw_impresa_sedi; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_impresa_sedi AS
 SELECT is2.his_id,
    is2.his_validita,
    is2.his_id_transazione,
    is2.his_ts,
    is2.his_ts_transazione,
    is2.id,
    is2.id_impresa,
    is2.id_tipo_sede,
    is2.id_indirizzo,
    is2.pec,
    is2.email,
    is2.old_id,
    is2.fonte,
    is2.validita,
    lower(is2.his_validita) AS inizio_validita_log,
    vtsi.descr,
    vt.nominativo,
    (to_char(lower(is2.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vi.indirizzo_completo
   FROM (((cu_his.impresa_sedi is2
     JOIN cu_types.vw_tipi_sede_impresa vtsi ON ((vtsi.id_tipo_sede_impresa = is2.id_tipo_sede)))
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = is2.his_id_transazione)))
     LEFT JOIN cu_his.vw_indirizzi vi ON (((vi.id = is2.id_indirizzo) AND (is2.his_validita && vi.his_validita))));


ALTER TABLE cu_his.vw_impresa_sedi OWNER TO postgres;

--
-- Name: vw_imprese; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_imprese AS
 SELECT i.his_id,
    i.his_validita,
    i.his_id_transazione,
    i.his_ts,
    i.his_ts_transazione,
    i.id,
    i.nome,
    i.cf,
    i.piva,
    i.pec,
    i.email,
    i.sdi,
    i.split_payement,
    i.cod_tipo_impresa,
    i.az_id,
    i.az_cod_aziendale,
    i.az_cod_regionale,
    i.sd_id,
    i.verificato,
    i.fonte,
    i.validita,
    i.tipo_soggetto,
    lower(i.his_validita) AS inizio_validita_log,
    vt.nominativo,
    vcti.descr AS desc_tipo_impresa,
    (to_char(lower(i.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log
   FROM ((cu_his.imprese i
     JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = i.his_id_transazione)))
     JOIN cu_types.vw_cu_tipo_imprese vcti ON (((vcti.cod)::text = (i.cod_tipo_impresa)::text)));


ALTER TABLE cu_his.vw_imprese OWNER TO postgres;

--
-- Name: vw_linee; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_linee AS
 SELECT l.his_id,
    l.his_validita,
    l.his_id_transazione,
    l.his_ts,
    l.his_ts_transazione,
    l.id,
    l.id_stabilimento,
    l.id_tipo_linea,
    l.validita,
    l.attivita_fissa,
    l.linea_principale,
    l.verificato,
    l.fonte,
    l.data_ultima_visita,
    l.id_esterno,
    lower(l.his_validita) AS inizio_validita_log,
    vtl.descr_completa,
    vt.nominativo,
    (to_char(lower(l.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log
   FROM ((cu_his.linee l
     JOIN agenda.vw_tipo_linee vtl ON ((vtl.id_tipo_linea = l.id_tipo_linea)))
     JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = l.his_id_transazione)));


ALTER TABLE cu_his.vw_linee OWNER TO postgres;

--
-- Name: vw_pratiche; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_pratiche AS
 SELECT p.his_id,
    p.his_validita,
    p.his_id_transazione,
    p.his_ts,
    p.his_ts_transazione,
    p.id,
    p.id_tipo_pratica,
    p.n_pratica,
    p.dt,
    p.id_stabilimento,
    p.stato,
    lower(p.his_validita) AS inizio_validita_log,
    (to_char(lower(p.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    vp.descr_tipo_pratica,
    vp.nome AS nome_stab,
    vp.cf_impresa,
    vp.pec_impresa,
    vp.piva_impresa,
    vp.ragsoc AS ragsoc_impresa,
    vp.indirizzo_completo,
    vp.descrizione_tipologia_struttura,
    vp.cod_regionale_pratica,
    vp.az_cod_aziendale,
    vp.az_cod_regionale,
    vp.pec,
    vp.telefono,
    vp.split_payement,
    vp.sdi,
    vp.asl_descr,
    vp.cod_tipo_impresa,
    vp.cod_nazionale,
    vp.descr_stato_pratica
   FROM ((cu_his.pratiche p
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = p.his_id_transazione)))
     LEFT JOIN cu_anag.vw_pratiche vp ON ((vp.id_pratica = p.id)));


ALTER TABLE cu_his.vw_pratiche OWNER TO postgres;

--
-- Name: vw_ref_cu; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu AS
 SELECT c.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu'::text AS tabella,
    t.id_user,
    t.nominativo,
    c.his_validita
   FROM (cu_his.cu c
     LEFT JOIN cu_log.vw_transazioni t ON ((c.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu OWNER TO postgres;

--
-- Name: vw_ref_cu_altri; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_altri AS
 SELECT a.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_altri'::text AS tabella,
    t.id_user,
    t.nominativo,
    a.his_validita
   FROM (((cu_his.cu_altri a
     JOIN cu_his.cu_nucleo cn ON (((a.id = cn.id_nominativo) AND (cn.his_validita @> lower(a.his_validita)))))
     JOIN cu_his.cu c ON (((c.id = cn.id_cu) AND (c.his_validita @> lower(a.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((a.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_altri OWNER TO postgres;

--
-- Name: vw_ref_cu_automezzi; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_automezzi AS
 SELECT ca.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_automezzi'::text AS tabella,
    t.id_user,
    t.nominativo,
    ca.his_validita
   FROM ((cu_his.cu_automezzi ca
     JOIN cu_his.cu c ON (((c.id = ca.id_cu) AND (c.his_validita @> lower(ca.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((ca.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_automezzi OWNER TO postgres;

--
-- Name: vw_ref_cu_dichiarazioni; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_dichiarazioni AS
 SELECT a.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_dichiarazioni'::text AS tabella,
    t.id_user,
    t.nominativo,
    a.his_validita
   FROM (((cu_his.cu_dichiarazioni a
     JOIN cu_his.cu_nucleo cn ON (((a.id_cu_nucleo = cn.id) AND (cn.his_validita @> lower(a.his_validita)))))
     JOIN cu_his.cu c ON (((c.id = cn.id_cu) AND (c.his_validita @> lower(a.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((a.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_dichiarazioni OWNER TO postgres;

--
-- Name: vw_ref_cu_evidenza_linee; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_evidenza_linee AS
 SELECT el.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_evidenza_linee'::text AS tabella,
    t.id_user,
    t.nominativo,
    el.his_validita
   FROM (((((cu_his.cu_evidenza_linee el
     JOIN cu_his.cu_evidenze e ON (((el.id_evidenza = e.id) AND (e.his_validita @> lower(el.his_validita)))))
     JOIN cu_his.cu_oggetti_cl coc ON (((coc.id = e.id_cu_oggetto_cl) AND (coc.his_validita @> lower(el.his_validita)))))
     JOIN cu_his.cu_oggetti co ON (((co.id = coc.id_cu_oggetto) AND (co.his_validita @> lower(el.his_validita)))))
     JOIN cu_his.cu c ON (((c.id = co.id_cu) AND (c.his_validita @> lower(el.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((el.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_evidenza_linee OWNER TO postgres;

--
-- Name: vw_ref_cu_evidenze; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_evidenze AS
 SELECT e.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_evidenze'::text AS tabella,
    t.id_user,
    t.nominativo,
    e.his_validita
   FROM ((((cu_his.cu_evidenze e
     JOIN cu_his.cu_oggetti_cl coc ON (((coc.id = e.id_cu_oggetto_cl) AND (coc.his_validita @> lower(e.his_validita)))))
     JOIN cu_his.cu_oggetti co ON (((co.id = coc.id_cu_oggetto) AND (co.his_validita @> lower(e.his_validita)))))
     JOIN cu_his.cu c ON (((c.id = co.id_cu) AND (c.his_validita @> lower(e.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((e.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_evidenze OWNER TO postgres;

--
-- Name: vw_ref_cu_linee; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_linee AS
 SELECT cl.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_linee'::text AS tabella,
    t.id_user,
    t.nominativo,
    cl.his_validita
   FROM ((cu_his.cu_linee cl
     JOIN cu_his.cu c ON (((c.id = cl.id_cu) AND (c.his_validita @> lower(cl.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((cl.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_linee OWNER TO postgres;

--
-- Name: vw_ref_cu_nominativo_provv; Type: VIEW; Schema: cu_his; Owner: gisa_fvg
--

CREATE VIEW cu_his.vw_ref_cu_nominativo_provv AS
 SELECT ca.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_automezzi'::text AS tabella,
    t.id_user,
    t.nominativo,
    ca.his_validita
   FROM ((cu_his.cu_nominativo_provv ca
     JOIN cu_his.cu c ON (((c.id = ca.id_cu) AND (c.his_validita @> lower(ca.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((ca.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_nominativo_provv OWNER TO gisa_fvg;

--
-- Name: vw_ref_cu_norme_violate; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_norme_violate AS
 SELECT nv.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_norme_violate'::text AS tabella,
    t.id_user,
    t.nominativo,
    nv.his_validita
   FROM ((cu_his.cu_norme_violate nv
     JOIN cu_his.cu c ON (((c.id = nv.id_cu) AND (c.his_validita @> lower(nv.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((nv.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_norme_violate OWNER TO postgres;

--
-- Name: vw_ref_cu_nucleo; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_nucleo AS
 SELECT cn.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_nucleo'::text AS tabella,
    t.id_user,
    t.nominativo,
    cn.his_validita
   FROM ((cu_his.cu_nucleo cn
     JOIN cu_his.cu c ON (((c.id = cn.id_cu) AND (c.his_validita @> lower(cn.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((cn.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_nucleo OWNER TO postgres;

--
-- Name: vw_ref_cu_nucleo_periodi; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_nucleo_periodi AS
 SELECT cnp.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'nucleo_periodi'::text AS tabella,
    t.id_user,
    t.nominativo,
    cnp.his_validita
   FROM (((cu_his.cu_nucleo_periodi cnp
     JOIN cu_his.cu_nucleo cn ON (((cnp.id_cu_nucleo = cn.id) AND (cn.his_validita @> lower(cnp.his_validita)))))
     JOIN cu_his.cu c ON (((c.id = cn.id_cu) AND (c.his_validita @> lower(cnp.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((cnp.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_nucleo_periodi OWNER TO postgres;

--
-- Name: vw_ref_cu_oggetti; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_oggetti AS
 SELECT co.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_oggetti'::text AS tabella,
    t.id_user,
    t.nominativo,
    co.his_validita
   FROM ((cu_his.cu_oggetti co
     JOIN cu_his.cu c ON (((c.id = co.id_cu) AND (c.his_validita @> lower(co.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((co.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_oggetti OWNER TO postgres;

--
-- Name: vw_ref_cu_oggetti_cl; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_oggetti_cl AS
 SELECT coc.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_oggetti_cl'::text AS tabella,
    t.id_user,
    t.nominativo,
    coc.his_validita
   FROM (((cu_his.cu_oggetti_cl coc
     JOIN cu_his.cu_oggetti co ON (((coc.id_cu_oggetto = co.id) AND (co.his_validita @> lower(coc.his_validita)))))
     JOIN cu_his.cu c ON (((c.id = co.id_cu) AND (c.his_validita @> lower(coc.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((coc.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_oggetti_cl OWNER TO postgres;

--
-- Name: vw_ref_cu_piani; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_piani AS
 SELECT p.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_piani'::text AS tabella,
    t.id_user,
    t.nominativo,
    p.his_validita
   FROM ((cu_his.cu_piani p
     JOIN cu_his.cu c ON (((c.id = p.id_cu) AND (c.his_validita @> lower(p.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((p.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_piani OWNER TO postgres;

--
-- Name: vw_ref_cu_provv; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_provv AS
 SELECT cp.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_provv'::text AS tabella,
    t.id_user,
    t.nominativo,
    cp.his_validita
   FROM (((cu_his.cu_provv cp
     JOIN cu_his.cu_norme_violate nv ON (((nv.id = cp.id_norma_violata) AND (nv.his_validita @> lower(cp.his_validita)))))
     JOIN cu_his.cu c ON (((c.id = nv.id_cu) AND (c.his_validita @> lower(cp.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((cp.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_provv OWNER TO postgres;

--
-- Name: vw_ref_cu_provv_fu; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_provv_fu AS
 SELECT cp.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_provv_fu'::text AS tabella,
    t.id_transazione,
    t.nominativo,
    cp.his_validita
   FROM ((cu_his.cu_provv_fu cp
     JOIN cu_his.cu c ON (((c.id = cp.id_cu) AND (c.his_validita @> lower(cp.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((cp.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_provv_fu OWNER TO postgres;

--
-- Name: vw_ref_cu_provv_sopralluogo; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_provv_sopralluogo AS
 SELECT ps.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_provv_sopralluogo'::text AS tabella,
    t.id_user,
    t.nominativo,
    ps.his_validita
   FROM ((cu_his.cu_provv_sopralluogo ps
     JOIN cu_his.cu c ON (((c.id = ps.id_cu) AND (c.his_validita @> lower(ps.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((ps.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_provv_sopralluogo OWNER TO postgres;

--
-- Name: vw_ref_cu_provv_sopralluogo_fu; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_provv_sopralluogo_fu AS
 SELECT ps.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_provv_sopralluogo_fu'::text AS tabella,
    t.id_user,
    t.nominativo,
    ps.his_validita
   FROM ((cu_his.cu_provv_sopralluogo_fu ps
     JOIN cu_his.cu c ON (((c.id = ps.id_cu) AND (c.his_validita @> lower(ps.his_validita)))))
     LEFT JOIN cu_log.vw_transazioni t ON ((ps.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_cu_provv_sopralluogo_fu OWNER TO postgres;

--
-- Name: vw_ref_impresa_figure; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_impresa_figure AS
 SELECT i.his_id_transazione,
    i.id,
    i2.piva AS descr_oggetto,
    'impresa_figure'::text AS tabella,
    t.id_user,
    t.nominativo,
    i.his_validita
   FROM ((cu_his.impresa_figure i
     LEFT JOIN cu_log.vw_transazioni t ON ((i.his_id_transazione = t.id_transazione)))
     JOIN cu_his.imprese i2 ON ((i2.id = i.id_impresa)));


ALTER TABLE cu_his.vw_ref_impresa_figure OWNER TO postgres;

--
-- Name: vw_ref_impresa_sedi; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_impresa_sedi AS
 SELECT i.his_id_transazione,
    i.id,
    i2.piva AS descr_oggetto,
    'impresa_sedi'::text AS tabella,
    t.id_user,
    t.nominativo,
    i.his_validita
   FROM ((cu_his.impresa_sedi i
     LEFT JOIN cu_log.vw_transazioni t ON ((i.his_id_transazione = t.id_transazione)))
     JOIN cu_his.imprese i2 ON ((i2.id = i.id_impresa)));


ALTER TABLE cu_his.vw_ref_impresa_sedi OWNER TO postgres;

--
-- Name: vw_ref_imprese; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_imprese AS
 SELECT i.his_id_transazione,
    i.id,
    i.piva AS descr_oggetto,
    'imprese'::text AS tabella,
    t.id_user,
    t.nominativo,
    i.his_validita
   FROM (cu_his.imprese i
     LEFT JOIN cu_log.vw_transazioni t ON ((i.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_imprese OWNER TO postgres;

--
-- Name: vw_ref_soggetti_fisici; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_soggetti_fisici AS
 SELECT sf.his_id_transazione,
    sf.id,
    sf.codice_fiscale AS descr_oggetto,
    'soggetti_fisici'::text AS tabella,
    t.id_user,
    t.nominativo,
    sf.his_validita
   FROM (cu_his.soggetti_fisici sf
     LEFT JOIN cu_log.vw_transazioni t ON ((sf.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_soggetti_fisici OWNER TO postgres;

--
-- Name: vw_ref_stabilimenti; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_stabilimenti AS
 SELECT s.his_id_transazione,
    s.id,
    s.cod_regionale AS descr_oggetto,
    'stabilimenti'::text AS tabella,
    t.id_user,
    t.nominativo,
    s.his_validita
   FROM (cu_his.stabilimenti s
     LEFT JOIN cu_log.vw_transazioni t ON ((s.his_id_transazione = t.id_transazione)));


ALTER TABLE cu_his.vw_ref_stabilimenti OWNER TO postgres;

--
-- Name: vw_ref_stabilimento_figure; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_stabilimento_figure AS
 SELECT sf.his_id_transazione,
    sf.id,
    s.cod_regionale AS descr_oggetto,
    'stabilimento_figure'::text AS tabella,
    t.id_user,
    t.nominativo,
    sf.his_validita
   FROM ((cu_his.stabilimento_figure sf
     LEFT JOIN cu_log.vw_transazioni t ON ((sf.his_id_transazione = t.id_transazione)))
     JOIN cu_his.stabilimenti s ON ((s.id = sf.id_stabilimento)));


ALTER TABLE cu_his.vw_ref_stabilimento_figure OWNER TO postgres;

--
-- Name: vw_ref_stabilimento_sedi; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_stabilimento_sedi AS
 SELECT ss.his_id_transazione,
    ss.id,
    s.cod_regionale AS descr_oggetto,
    'stabilimento_sedi'::text AS tabella,
    t.id_user,
    t.nominativo,
    ss.his_validita
   FROM ((cu_his.stabilimento_sedi ss
     LEFT JOIN cu_log.vw_transazioni t ON ((ss.his_id_transazione = t.id_transazione)))
     JOIN cu_his.stabilimenti s ON ((s.id = ss.id_stabilimento)));


ALTER TABLE cu_his.vw_ref_stabilimento_sedi OWNER TO postgres;

--
-- Name: vw_tree_nodes_asl; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_asl AS
 SELECT vw_tree_nodes.name_tree,
    vw_tree_nodes.id_node,
    vw_tree_nodes.id_tree,
    vw_tree_nodes.id_node_parent,
    vw_tree_nodes.validita
   FROM matrix.vw_tree_nodes
  WHERE ((vw_tree_nodes.name_tree)::text = 'Struttura ASL'::text);


ALTER TABLE matrix.vw_tree_nodes_asl OWNER TO postgres;

--
-- Name: vw_tree_nodes_asl_descr; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_asl_descr AS
 SELECT ta.name_tree,
    ta.id_node,
    ta.id_tree,
    ta.id_node_parent,
    a.id,
    a.id_gisa,
    a.id_asl,
    a.codice_interno_fk,
    a.descrizione,
    a.n_livello,
    a.descrizione_breve,
    a.ups,
    a.uba,
    a.anno,
    ap.id AS p_id,
    ap.id_gisa AS p_id_gisa,
    ap.id_asl AS p_id_asl,
    ap.codice_interno_fk AS p_codice_interno_fk,
    ap.descrizione AS p_descrizione,
    ap.n_livello AS p_n_livello,
    ap.descrizione AS p_descrizione_breve,
    ap.uba AS p_uba,
    ap.ups AS p_ups,
    ap.anno AS p_anno,
    ta.validita
   FROM ((matrix.vw_tree_nodes_asl ta
     JOIN matrix.struttura_asl a ON ((a.id = ta.id_node)))
     LEFT JOIN matrix.struttura_asl ap ON ((ap.id = ta.id_node_parent)));


ALTER TABLE matrix.vw_tree_nodes_asl_descr OWNER TO postgres;

--
-- Name: servizi; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.servizi (
    id bigint NOT NULL,
    descr character varying,
    id_ref bigint,
    type character varying
);


ALTER TABLE trf.servizi OWNER TO postgres;

--
-- Name: trf_att_inviate; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_att_inviate (
    id bigint NOT NULL,
    id_trf_attivita bigint,
    tm_invio timestamp without time zone,
    str_j json
);


ALTER TABLE trf.trf_att_inviate OWNER TO postgres;

--
-- Name: trf_att_inviate_stati; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_att_inviate_stati (
    id bigint NOT NULL,
    id_att_inviata bigint,
    ret character varying,
    id_trf_att_inviate_tipo_stati bigint,
    ts timestamp without time zone
);


ALTER TABLE trf.trf_att_inviate_stati OWNER TO postgres;

--
-- Name: trf_attivita; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_attivita (
    id bigint NOT NULL,
    id_cliente bigint,
    id_servizio bigint,
    data_da timestamp without time zone,
    data_a timestamp without time zone,
    id_trf_operatore bigint,
    note character varying,
    imponibile character varying,
    id_tariffa bigint,
    per_conto_di bigint,
    id_ref_attivita bigint,
    id_type_attivita character varying,
    closed boolean,
    data_closed timestamp without time zone,
    id_fattura bigint,
    conto_addebito character varying,
    per_conto_di_struttura bigint
);


ALTER TABLE trf.trf_attivita OWNER TO postgres;

--
-- Name: trf_attivita_dettagli; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_attivita_dettagli (
    id bigint NOT NULL,
    id_trf_attivita bigint NOT NULL,
    id_tariffa bigint,
    valore character varying,
    costo numeric
);


ALTER TABLE trf.trf_attivita_dettagli OWNER TO postgres;

--
-- Name: trf_attivita_forfet; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_attivita_forfet (
    id bigint,
    id_cliente bigint,
    id_servizio bigint,
    data_da timestamp without time zone,
    data_a timestamp without time zone,
    id_trf_operatore bigint,
    note character varying,
    imponibile character varying,
    id_tariffa bigint,
    per_conto_di bigint,
    id_ref_attivita bigint,
    id_type_attivita character varying,
    closed boolean,
    data_closed timestamp without time zone,
    id_fattura bigint,
    id_stato bigint DEFAULT 1 NOT NULL
);


ALTER TABLE trf.trf_attivita_forfet OWNER TO postgres;

--
-- Name: vw_servizi; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_servizi AS
 SELECT s.id,
    s.descr,
    s.id AS id_servizio,
    (sp.descrizione_piano)::character varying AS descr_servizio,
    s.id_ref AS id_piano,
    sp.descrizione_piano,
    sp.descrizione_piano AS descrizione
   FROM (trf.servizi s
     JOIN matrix.vw_struttura_piani sp ON (((sp.id = s.id_ref) AND ((s.type)::text = 'piano'::text))))
UNION
 SELECT s.id,
    s.descr,
    s.id AS id_servizio,
    s.descr AS descr_servizio,
    s.id_ref AS id_piano,
    NULL::text AS descrizione_piano,
    s.descr AS descrizione
   FROM trf.servizi s
  WHERE (s.type IS NULL);


ALTER TABLE trf.vw_servizi OWNER TO postgres;

--
-- Name: trf_att_inviate_tipo_stati; Type: TABLE; Schema: trf_types; Owner: postgres
--

CREATE TABLE trf_types.trf_att_inviate_tipo_stati (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    azione character varying DEFAULT 'SEND'::character varying NOT NULL
);


ALTER TABLE trf_types.trf_att_inviate_tipo_stati OWNER TO postgres;

--
-- Name: vw_trf_att_inviate_ultimo_stato; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_att_inviate_ultimo_stato AS
 SELECT DISTINCT ON (ais.id_att_inviata) ais.id_att_inviata,
    ais.ret,
    ais.id_trf_att_inviate_tipo_stati AS id_trf_stato,
    ais.ts,
    s.descr,
    s.azione
   FROM (trf.trf_att_inviate_stati ais
     JOIN trf_types.trf_att_inviate_tipo_stati s ON ((s.id = ais.id_trf_att_inviate_tipo_stati)))
  ORDER BY ais.id_att_inviata, ais.ts DESC;


ALTER TABLE trf.vw_trf_att_inviate_ultimo_stato OWNER TO postgres;

--
-- Name: vw_trf_operatori; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_operatori AS
 SELECT DISTINCT n.id_anagrafica AS id,
    (n.nominativo)::character varying AS descr,
    n.id_anagrafica AS id_trf_operatore,
    (n.nominativo)::character varying AS descr_trf_operatore
   FROM matrix.nominativi n;


ALTER TABLE trf.vw_trf_operatori OWNER TO postgres;

--
-- Name: vw_trf_attivita; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_attivita AS
 SELECT a.id,
    a.id AS id_trf_attivita,
    a.id_cliente,
    c.descr_cliente,
    a.id_servizio,
    (s.descrizione)::character varying AS descr_servizio,
    a.data_da,
    a.data_a,
    a.id_trf_operatore,
    o.descr_trf_operatore,
    a.note,
    a.imponibile,
    a.id_tariffa,
    t.sigla_tariffa,
    t.descr_tariffa,
    COALESCE(s.descrizione_piano, (s.descr_servizio)::text) AS descrizione_piano,
    a.per_conto_di,
    (sa.descrizione)::character varying AS descrizione_asl,
    (sa.descrizione_breve)::character varying AS descrizione_breve_asl,
    t.valido_da,
    t.valido_a,
    c.rag_soc,
    c.comune,
    c.indirizzo,
        CASE
            WHEN ((date_part('dow'::text, a.data_a) >= (1)::double precision) AND (date_part('dow'::text, a.data_a) <= (5)::double precision)) THEN 'Feriale'::text
            ELSE 'Festivo'::text
        END AS tipo_giorno,
    (tot.totale)::bigint AS totale,
    a.closed,
    a.id_fattura,
    NULL::bigint AS numero_fattura,
        CASE
            WHEN a.closed THEN 'Chiusa'::text
            ELSE 'Aperta'::text
        END AS closed_str,
    c.indirizzo_completo,
    ((c.descr_cliente)::text || COALESCE((' '::text || c.indirizzo_completo), ''::text)) AS descr_cliente_con_indirizzo,
    tot.totale AS totale_non_approsimato
   FROM ((((((trf.trf_attivita a
     LEFT JOIN trf.vw_clienti c ON ((c.id_cliente = a.id_cliente)))
     LEFT JOIN trf.vw_servizi s ON ((s.id_servizio = a.id_servizio)))
     LEFT JOIN trf.vw_trf_operatori o ON ((a.id_trf_operatore = o.id_trf_operatore)))
     LEFT JOIN trf.vw_tariffe t ON ((t.id_tariffa = a.id_tariffa)))
     LEFT JOIN matrix.vw_tree_nodes_asl_descr sa ON ((sa.id_node = a.per_conto_di)))
     LEFT JOIN ( SELECT trf_attivita_dettagli.id_trf_attivita,
            sum((trf_attivita_dettagli.valore)::double precision) AS totale
           FROM trf.trf_attivita_dettagli
          GROUP BY trf_attivita_dettagli.id_trf_attivita) tot ON ((tot.id_trf_attivita = a.id)));


ALTER TABLE trf.vw_trf_attivita OWNER TO postgres;

--
-- Name: vw_trf_att_inviate; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_att_inviate AS
 SELECT ai.id,
    ai.id_trf_attivita,
    ai.tm_invio,
    ai.str_j,
    us.descr AS descr_stato,
    us.ts,
    a.descr_cliente,
    a.data_da,
    a.descr_servizio,
    ((us.azione)::text = 'SEND'::text) AS selezionabile,
    us.azione,
    us.ts AS tm_ultimo_invio
   FROM ((trf.vw_trf_attivita a
     JOIN trf.trf_att_inviate ai ON ((ai.id_trf_attivita = a.id_trf_attivita)))
     JOIN trf.vw_trf_att_inviate_ultimo_stato us ON ((us.id_att_inviata = ai.id)))
  ORDER BY ai.tm_invio DESC;


ALTER TABLE trf.vw_trf_att_inviate OWNER TO postgres;

--
-- Name: vw_trf_att_inviate_tipo_stati; Type: VIEW; Schema: trf_types; Owner: postgres
--

CREATE VIEW trf_types.vw_trf_att_inviate_tipo_stati AS
 SELECT trf_att_inviate_tipo_stati.id AS id_att_inviate_tipo_stati,
    trf_att_inviate_tipo_stati.id,
    trf_att_inviate_tipo_stati.cod,
    trf_att_inviate_tipo_stati.sigla,
    trf_att_inviate_tipo_stati.descr
   FROM trf_types.trf_att_inviate_tipo_stati;


ALTER TABLE trf_types.vw_trf_att_inviate_tipo_stati OWNER TO postgres;

--
-- Name: vw_trf_att_inviate_stati; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_att_inviate_stati AS
 SELECT s.id,
    s.id_att_inviata,
    s.ret,
    s.id_trf_att_inviate_tipo_stati,
    s.ts,
    t.descr AS descr_stato
   FROM (trf.trf_att_inviate_stati s
     JOIN trf_types.vw_trf_att_inviate_tipo_stati t ON ((s.id_trf_att_inviate_tipo_stati = t.id_att_inviate_tipo_stati)));


ALTER TABLE trf.vw_trf_att_inviate_stati OWNER TO postgres;

--
-- Name: trf_attivita_forfet_stati; Type: TABLE; Schema: trf_types; Owner: postgres
--

CREATE TABLE trf_types.trf_attivita_forfet_stati (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    descr character varying NOT NULL,
    finale boolean
);


ALTER TABLE trf_types.trf_attivita_forfet_stati OWNER TO postgres;

--
-- Name: vw_trf_attivita_forfet_stati; Type: VIEW; Schema: trf_types; Owner: postgres
--

CREATE VIEW trf_types.vw_trf_attivita_forfet_stati AS
 SELECT trf_attivita_forfet_stati.id AS id_stato,
    trf_attivita_forfet_stati.id,
    trf_attivita_forfet_stati.cod,
    trf_attivita_forfet_stati.descr,
    trf_attivita_forfet_stati.finale
   FROM trf_types.trf_attivita_forfet_stati;


ALTER TABLE trf_types.vw_trf_attivita_forfet_stati OWNER TO postgres;

--
-- Name: vw_trf_attivita_forfet; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_attivita_forfet AS
 SELECT a.id,
    a.id AS id_trf_attivita,
    a.id_cliente,
    c.descr AS descr_cliente,
    a.id_servizio,
    (s.descrizione)::character varying AS descr_servizio,
    a.data_da,
    a.data_a,
    a.id_trf_operatore,
    o.descr_trf_operatore,
    a.note,
    a.imponibile,
    a.id_tariffa,
    t.sigla_tariffa,
    t.descr_tariffa,
    COALESCE(s.descrizione_piano, (s.descr_servizio)::text) AS descrizione_piano,
    a.per_conto_di,
    (sa.descrizione)::character varying AS descrizione_asl,
    (sa.descrizione_breve)::character varying AS descrizione_breve_asl,
    t.valido_da,
    t.valido_a,
    c.rag_soc,
    c.comune,
    c.indirizzo,
        CASE
            WHEN ((date_part('dow'::text, a.data_a) >= (1)::double precision) AND (date_part('dow'::text, a.data_a) <= (5)::double precision)) THEN 'Feriale'::text
            ELSE 'Festivo'::text
        END AS tipo_giorno,
    tot.totale,
    a.closed,
    a.id_fattura,
    a.id_stato,
    st.cod,
    st.descr,
    st.finale,
    c.piva
   FROM (((((((trf.trf_attivita_forfet a
     JOIN trf_types.vw_trf_attivita_forfet_stati st ON ((a.id_stato = st.id_stato)))
     LEFT JOIN trf.vw_clienti c ON ((c.id_cliente = a.id_cliente)))
     LEFT JOIN trf.vw_servizi s ON ((s.id_servizio = a.id_servizio)))
     LEFT JOIN trf.vw_trf_operatori o ON ((a.id_trf_operatore = o.id_trf_operatore)))
     LEFT JOIN trf.vw_tariffe t ON ((t.id_tariffa = a.id_tariffa)))
     LEFT JOIN matrix.vw_tree_nodes_asl_descr sa ON ((sa.id_node = a.per_conto_di)))
     LEFT JOIN ( SELECT trf_attivita_dettagli.id_trf_attivita,
            sum((trf_attivita_dettagli.valore)::integer) AS totale
           FROM trf.trf_attivita_dettagli
          GROUP BY trf_attivita_dettagli.id_trf_attivita) tot ON ((tot.id_trf_attivita = a.id)));


ALTER TABLE trf.vw_trf_attivita_forfet OWNER TO postgres;

--
-- Name: clienti; Type: TABLE; Schema: trf_his; Owner: postgres
--

CREATE TABLE trf_his.clienti (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    descr character varying,
    id_ref bigint,
    type character varying,
    piva character varying
);


ALTER TABLE trf_his.clienti OWNER TO postgres;

--
-- Name: tariffa_strutture; Type: TABLE; Schema: trf_his; Owner: postgres
--

CREATE TABLE trf_his.tariffa_strutture (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_tariffa bigint NOT NULL,
    id_asl bigint,
    validita tsrange NOT NULL
);


ALTER TABLE trf_his.tariffa_strutture OWNER TO postgres;

--
-- Name: tariffa_voci; Type: TABLE; Schema: trf_his; Owner: postgres
--

CREATE TABLE trf_his.tariffa_voci (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_tariffa_struttura bigint NOT NULL,
    scaglione numrange,
    ordine integer
);


ALTER TABLE trf_his.tariffa_voci OWNER TO postgres;

--
-- Name: tariffa_voci_calcolo; Type: TABLE; Schema: trf_his; Owner: postgres
--

CREATE TABLE trf_his.tariffa_voci_calcolo (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id_tariffa_voce bigint,
    valore numeric,
    tipo integer
);


ALTER TABLE trf_his.tariffa_voci_calcolo OWNER TO postgres;

--
-- Name: tariffe; Type: TABLE; Schema: trf_his; Owner: postgres
--

CREATE TABLE trf_his.tariffe (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_tariffario bigint,
    sigla character varying,
    descr character varying,
    cod_iva character varying,
    nota character varying,
    visibile_trf boolean DEFAULT true,
    visibile_fatt boolean DEFAULT true,
    id_u_mis bigint,
    visibile_piani boolean,
    visibile_contabilita boolean,
    pdc character varying,
    ordine_tariffa integer,
    validita tsrange,
    livello_asl boolean DEFAULT false NOT NULL,
    cod_conto_iva character varying,
    limiti numrange
);


ALTER TABLE trf_his.tariffe OWNER TO postgres;

--
-- Name: trf_att_inviate; Type: TABLE; Schema: trf_his; Owner: postgres
--

CREATE TABLE trf_his.trf_att_inviate (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_trf_attivita bigint,
    tm_invio timestamp without time zone,
    str_j json
);


ALTER TABLE trf_his.trf_att_inviate OWNER TO postgres;

--
-- Name: trf_att_inviate_stati; Type: TABLE; Schema: trf_his; Owner: postgres
--

CREATE TABLE trf_his.trf_att_inviate_stati (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    his_ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_att_inviata bigint,
    ret character varying,
    id_trf_att_inviate_tipo_stati bigint,
    ts timestamp without time zone
);


ALTER TABLE trf_his.trf_att_inviate_stati OWNER TO postgres;

--
-- Name: trf_attivita; Type: TABLE; Schema: trf_his; Owner: postgres
--

CREATE TABLE trf_his.trf_attivita (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint,
    id_cliente bigint,
    id_servizio bigint,
    data_da timestamp without time zone,
    data_a timestamp without time zone,
    id_trf_operatore bigint,
    note character varying,
    imponibile character varying,
    id_tariffa bigint,
    per_conto_di bigint,
    id_ref_attivita bigint,
    id_type_attivita character varying,
    closed boolean,
    data_closed timestamp without time zone,
    id_fattura bigint,
    conto_addebito character varying,
    per_conto_di_struttura bigint
);


ALTER TABLE trf_his.trf_attivita OWNER TO postgres;

--
-- Name: trf_attivita_dettagli; Type: TABLE; Schema: trf_his; Owner: postgres
--

CREATE TABLE trf_his.trf_attivita_dettagli (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint NOT NULL,
    id_trf_attivita bigint NOT NULL,
    id_tariffa bigint,
    valore character varying,
    costo numeric
);


ALTER TABLE trf_his.trf_attivita_dettagli OWNER TO postgres;

--
-- Name: trf_attivita_forfet; Type: TABLE; Schema: trf_his; Owner: postgres
--

CREATE TABLE trf_his.trf_attivita_forfet (
    id_his bigint,
    his_validita tsrange,
    his_id_transazione bigint,
    ts timestamp with time zone,
    ts_transazione timestamp with time zone,
    id bigint,
    id_cliente bigint,
    id_servizio bigint,
    data_da timestamp without time zone,
    data_a timestamp without time zone,
    id_trf_operatore bigint,
    note character varying,
    imponibile character varying,
    id_tariffa bigint,
    per_conto_di bigint,
    id_ref_attivita bigint,
    id_type_attivita character varying,
    closed boolean,
    data_closed timestamp without time zone,
    id_fattura bigint,
    id_stato bigint NOT NULL
);


ALTER TABLE trf_his.trf_attivita_forfet OWNER TO postgres;

--
-- Name: vw_ref_clienti; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_clienti AS
 SELECT c.his_id_transazione,
    c.id,
    c.descr AS descr_oggetto,
    'clienti'::text AS tabella,
    t.id_user,
    t.nominativo,
    c.his_validita
   FROM (trf_his.clienti c
     LEFT JOIN cu_log.vw_transazioni t ON ((c.his_id_transazione = t.id_transazione)));


ALTER TABLE trf_his.vw_ref_clienti OWNER TO postgres;

--
-- Name: vw_tariffe; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_tariffe AS
 SELECT tvc.id_his,
    tvc.his_validita,
    tvc.his_id_transazione,
    tvc.ts,
    tvc.ts_transazione,
    tvc.id,
    tvc.id_tariffario,
    tvc.sigla,
    tvc.descr,
    tvc.cod_iva,
    tvc.nota,
    tvc.visibile_trf,
    tvc.visibile_fatt,
    tvc.id_u_mis,
    tvc.visibile_piani,
    tvc.visibile_contabilita,
    tvc.pdc,
    tvc.ordine_tariffa,
    tvc.validita,
    tvc.livello_asl,
    tvc.cod_conto_iva,
    tvc.limiti,
    lower(tvc.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(tvc.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log
   FROM ((trf_his.tariffe tvc
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = tvc.his_id_transazione)))
     JOIN trf.vw_tariffe vt2 ON ((vt2.id_tariffa = tvc.id)));


ALTER TABLE trf_his.vw_tariffe OWNER TO postgres;

--
-- Name: vw_ref_tariffa_strutture; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_tariffa_strutture AS
 SELECT ts.his_id_transazione,
    ts.id,
    vt.sigla AS descr_oggetto,
    'tariffa_strutture'::text AS tabella,
    t.id_user,
    t.nominativo,
    ts.his_validita
   FROM ((trf_his.tariffa_strutture ts
     LEFT JOIN cu_log.vw_transazioni t ON ((ts.his_id_transazione = t.id_transazione)))
     JOIN trf_his.vw_tariffe vt ON ((vt.id = ts.id_tariffa)));


ALTER TABLE trf_his.vw_ref_tariffa_strutture OWNER TO postgres;

--
-- Name: vw_ref_tariffa_voci; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_tariffa_voci AS
 SELECT tv.his_id_transazione,
    tv.id,
    vrts.descr_oggetto,
    'tariffa_voci'::text AS tabella,
    t.id_user,
    t.nominativo,
    tv.his_validita
   FROM ((trf_his.tariffa_voci tv
     LEFT JOIN cu_log.vw_transazioni t ON ((tv.his_id_transazione = t.id_transazione)))
     JOIN trf_his.vw_ref_tariffa_strutture vrts ON ((vrts.id = tv.id_tariffa_struttura)));


ALTER TABLE trf_his.vw_ref_tariffa_voci OWNER TO postgres;

--
-- Name: vw_ref_tariffa_voci_calcolo; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_tariffa_voci_calcolo AS
 SELECT tvc.his_id_transazione,
    tvc.id_tariffa_voce AS id,
    vrtv.descr_oggetto,
    'tariffa_voci_calcolo'::text AS tabella,
    t.id_user,
    t.nominativo,
    tvc.his_validita
   FROM ((trf_his.tariffa_voci_calcolo tvc
     LEFT JOIN cu_log.vw_transazioni t ON ((tvc.his_id_transazione = t.id_transazione)))
     JOIN trf_his.vw_ref_tariffa_voci vrtv ON ((vrtv.id = tvc.id_tariffa_voce)));


ALTER TABLE trf_his.vw_ref_tariffa_voci_calcolo OWNER TO postgres;

--
-- Name: vw_ref_tariffe; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_tariffe AS
 SELECT t2.his_id_transazione,
    t2.id,
    t2.sigla AS descr_oggetto,
    'tariffe'::text AS tabella,
    t.id_user,
    t.nominativo,
    t2.his_validita
   FROM (trf_his.tariffe t2
     LEFT JOIN cu_log.vw_transazioni t ON ((t2.his_id_transazione = t.id_transazione)));


ALTER TABLE trf_his.vw_ref_tariffe OWNER TO postgres;

--
-- Name: vw_trf_att_inviate; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_trf_att_inviate AS
 SELECT tai.id_his,
    tai.his_validita AS validita,
    tai.his_id_transazione,
    tai.ts,
    tai.ts_transazione,
    tai.id,
    tai.id_trf_attivita,
    tai.tm_invio,
    tai.str_j,
    lower(tai.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(tai.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vtai.descr_stato,
    vtai.descr_cliente,
    vtai.descr_servizio,
    vtai.azione,
    vtai.tm_ultimo_invio
   FROM ((trf_his.trf_att_inviate tai
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = tai.his_id_transazione)))
     JOIN trf.vw_trf_att_inviate vtai ON ((vtai.id = tai.id)));


ALTER TABLE trf_his.vw_trf_att_inviate OWNER TO postgres;

--
-- Name: vw_ref_trf_att_inviate; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_trf_att_inviate AS
 SELECT tai.his_id_transazione,
    tai.id,
    vtai.descr_cliente AS descr_oggetto,
    'trf_att_inviate'::text AS tabella,
    t.id_user,
    t.nominativo,
    tai.his_validita
   FROM ((trf_his.trf_att_inviate tai
     LEFT JOIN cu_log.vw_transazioni t ON ((tai.his_id_transazione = t.id_transazione)))
     JOIN trf_his.vw_trf_att_inviate vtai ON ((vtai.id = tai.id)));


ALTER TABLE trf_his.vw_ref_trf_att_inviate OWNER TO postgres;

--
-- Name: vw_trf_att_inviate_stati; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_trf_att_inviate_stati AS
 SELECT tas.id_his,
    tas.his_validita,
    tas.his_id_transazione,
    tas.his_ts,
    tas.ts_transazione,
    tas.id,
    tas.id_att_inviata,
    tas.ret,
    tas.id_trf_att_inviate_tipo_stati,
    tas.ts,
    lower(tas.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(tas.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vtais.descr_stato
   FROM ((trf_his.trf_att_inviate_stati tas
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = tas.his_id_transazione)))
     JOIN trf.vw_trf_att_inviate_stati vtais ON ((tas.id = vtais.id)));


ALTER TABLE trf_his.vw_trf_att_inviate_stati OWNER TO postgres;

--
-- Name: vw_ref_trf_att_inviate_stati; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_trf_att_inviate_stati AS
 SELECT tais.his_id_transazione,
    tais.id,
    vtai.descr_stato AS descr_oggetto,
    'trf_att_inviate_stati'::text AS tabella,
    t.id_user,
    t.nominativo,
    tais.his_validita
   FROM ((trf_his.trf_att_inviate_stati tais
     LEFT JOIN cu_log.vw_transazioni t ON ((tais.his_id_transazione = t.id_transazione)))
     JOIN trf_his.vw_trf_att_inviate_stati vtai ON ((vtai.id = tais.id)));


ALTER TABLE trf_his.vw_ref_trf_att_inviate_stati OWNER TO postgres;

--
-- Name: vw_trf_attivita; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_trf_attivita AS
 SELECT ta.id_his,
    ta.his_validita AS validita,
    ta.his_id_transazione,
    ta.ts,
    ta.ts_transazione,
    ta.id,
    ta.id_cliente,
    ta.id_servizio,
    ta.data_da,
    ta.data_a,
    ta.id_trf_operatore,
    ta.note,
    ta.imponibile,
    ta.id_tariffa,
    ta.per_conto_di,
    ta.id_ref_attivita,
    ta.id_type_attivita,
    ta.closed,
    ta.data_closed,
    ta.id_fattura,
    ta.conto_addebito,
    ta.per_conto_di_struttura,
    lower(ta.his_validita) AS inizio_validita_log,
    vt.nominativo,
    vta.descr_cliente,
    vta.descr_servizio,
    vta.descr_trf_operatore,
    vta.descr_tariffa,
    vta.descrizione_piano,
    (to_char(lower(ta.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log
   FROM ((trf_his.trf_attivita ta
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = ta.his_id_transazione)))
     JOIN trf.vw_trf_attivita vta ON ((vta.id_trf_attivita = ta.id)));


ALTER TABLE trf_his.vw_trf_attivita OWNER TO postgres;

--
-- Name: vw_ref_trf_attivita; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_trf_attivita AS
 SELECT ta.his_id_transazione,
    ta.id,
    va.descr_servizio AS descr_oggetto,
    'trf_attivita'::text AS tabella,
    t.id_user,
    t.nominativo,
    ta.his_validita
   FROM ((trf_his.trf_attivita ta
     LEFT JOIN cu_log.vw_transazioni t ON ((ta.his_id_transazione = t.id_transazione)))
     JOIN trf_his.vw_trf_attivita va ON ((va.id = ta.id)));


ALTER TABLE trf_his.vw_ref_trf_attivita OWNER TO postgres;

--
-- Name: vw_trf_attivita_dettagli; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_trf_attivita_dettagli AS
 SELECT tad.id_his,
    tad.his_validita AS validita,
    tad.his_id_transazione,
    tad.ts,
    tad.ts_transazione,
    tad.id,
    tad.id_trf_attivita,
    tad.id_tariffa,
    tad.valore,
    tad.costo,
    lower(tad.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(tad.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vta.descr_cliente,
    vta.descr_servizio,
    vta.descr_trf_operatore,
    vta.descr_tariffa,
    vta.descrizione_piano
   FROM ((trf_his.trf_attivita_dettagli tad
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = tad.his_id_transazione)))
     JOIN trf.vw_trf_attivita vta ON ((vta.id_trf_attivita = tad.id_trf_attivita)));


ALTER TABLE trf_his.vw_trf_attivita_dettagli OWNER TO postgres;

--
-- Name: vw_ref_trf_attivita_dettagli; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_trf_attivita_dettagli AS
 SELECT tad.his_id_transazione,
    tad.id,
    vtad.descr_cliente AS descr_oggetto,
    'trf_attivita_dettagli'::text AS tabella,
    t.id_user,
    t.nominativo,
    tad.his_validita
   FROM ((trf_his.trf_attivita_dettagli tad
     LEFT JOIN cu_log.vw_transazioni t ON ((tad.his_id_transazione = t.id_transazione)))
     JOIN trf_his.vw_trf_attivita_dettagli vtad ON ((vtad.id = tad.id)));


ALTER TABLE trf_his.vw_ref_trf_attivita_dettagli OWNER TO postgres;

--
-- Name: vw_trf_attivita_forfet; Type: VIEW; Schema: trf_his; Owner: gisa_fvg
--

CREATE VIEW trf_his.vw_trf_attivita_forfet AS
 SELECT taf.id_his,
    taf.his_validita AS validita,
    taf.his_id_transazione,
    taf.ts,
    taf.ts_transazione,
    taf.id,
    taf.id_cliente,
    taf.id_servizio,
    taf.data_da,
    taf.data_a,
    taf.id_trf_operatore,
    taf.note,
    taf.imponibile,
    taf.id_tariffa,
    taf.per_conto_di,
    taf.id_ref_attivita,
    taf.id_type_attivita,
    taf.closed,
    taf.data_closed,
    taf.id_fattura,
    taf.id_stato,
    lower(taf.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(taf.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vtaf.descr_cliente,
    vtaf.descr_servizio,
    vtaf.descr_trf_operatore,
    vtaf.descr_tariffa,
    vtaf.descrizione_piano,
    vtaf.descr
   FROM ((trf_his.trf_attivita_forfet taf
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = taf.his_id_transazione)))
     JOIN trf.vw_trf_attivita_forfet vtaf ON ((vtaf.id = taf.id)));


ALTER TABLE trf_his.vw_trf_attivita_forfet OWNER TO gisa_fvg;

--
-- Name: vw_ref_trf_attivita_forfet; Type: VIEW; Schema: trf_his; Owner: gisa_fvg
--

CREATE VIEW trf_his.vw_ref_trf_attivita_forfet AS
 SELECT taf.his_id_transazione,
    taf.id,
    vtaf.descr_cliente AS descr_oggetto,
    'trf_attivita_forfet'::text AS tabella,
    t.id_user,
    t.nominativo,
    taf.his_validita
   FROM ((trf_his.trf_attivita_forfet taf
     LEFT JOIN cu_log.vw_transazioni t ON ((taf.his_id_transazione = t.id_transazione)))
     JOIN trf_his.vw_trf_attivita_forfet vtaf ON ((vtaf.id = taf.id)));


ALTER TABLE trf_his.vw_ref_trf_attivita_forfet OWNER TO gisa_fvg;

--
-- Name: vw_ref_all_cu; Type: VIEW; Schema: cu_his; Owner: gisa_fvg
--

CREATE VIEW cu_his.vw_ref_all_cu AS
 SELECT vw_ref_cu.his_id_transazione,
    vw_ref_cu.id,
    vw_ref_cu.descr_oggetto,
    vw_ref_cu.tabella,
    vw_ref_cu.id_user,
    vw_ref_cu.nominativo,
    vw_ref_cu.his_validita
   FROM cu_his.vw_ref_cu
UNION
 SELECT vw_ref_cu_altri.his_id_transazione,
    vw_ref_cu_altri.id,
    vw_ref_cu_altri.descr_oggetto,
    vw_ref_cu_altri.tabella,
    vw_ref_cu_altri.id_user,
    vw_ref_cu_altri.nominativo,
    vw_ref_cu_altri.his_validita
   FROM cu_his.vw_ref_cu_altri
UNION
 SELECT vw_ref_cu_dichiarazioni.his_id_transazione,
    vw_ref_cu_dichiarazioni.id,
    vw_ref_cu_dichiarazioni.descr_oggetto,
    vw_ref_cu_dichiarazioni.tabella,
    vw_ref_cu_dichiarazioni.id_user,
    vw_ref_cu_dichiarazioni.nominativo,
    vw_ref_cu_dichiarazioni.his_validita
   FROM cu_his.vw_ref_cu_dichiarazioni
UNION
 SELECT vw_ref_cu_evidenza_linee.his_id_transazione,
    vw_ref_cu_evidenza_linee.id,
    vw_ref_cu_evidenza_linee.descr_oggetto,
    vw_ref_cu_evidenza_linee.tabella,
    vw_ref_cu_evidenza_linee.id_user,
    vw_ref_cu_evidenza_linee.nominativo,
    vw_ref_cu_evidenza_linee.his_validita
   FROM cu_his.vw_ref_cu_evidenza_linee
UNION
 SELECT vw_ref_cu_evidenze.his_id_transazione,
    vw_ref_cu_evidenze.id,
    vw_ref_cu_evidenze.descr_oggetto,
    vw_ref_cu_evidenze.tabella,
    vw_ref_cu_evidenze.id_user,
    vw_ref_cu_evidenze.nominativo,
    vw_ref_cu_evidenze.his_validita
   FROM cu_his.vw_ref_cu_evidenze
UNION
 SELECT vw_ref_cu_linee.his_id_transazione,
    vw_ref_cu_linee.id,
    vw_ref_cu_linee.descr_oggetto,
    vw_ref_cu_linee.tabella,
    vw_ref_cu_linee.id_user,
    vw_ref_cu_linee.nominativo,
    vw_ref_cu_linee.his_validita
   FROM cu_his.vw_ref_cu_linee
UNION
 SELECT vw_ref_cu_norme_violate.his_id_transazione,
    vw_ref_cu_norme_violate.id,
    vw_ref_cu_norme_violate.descr_oggetto,
    vw_ref_cu_norme_violate.tabella,
    vw_ref_cu_norme_violate.id_user,
    vw_ref_cu_norme_violate.nominativo,
    vw_ref_cu_norme_violate.his_validita
   FROM cu_his.vw_ref_cu_norme_violate
UNION
 SELECT vw_ref_cu_nucleo.his_id_transazione,
    vw_ref_cu_nucleo.id,
    vw_ref_cu_nucleo.descr_oggetto,
    vw_ref_cu_nucleo.tabella,
    vw_ref_cu_nucleo.id_user,
    vw_ref_cu_nucleo.nominativo,
    vw_ref_cu_nucleo.his_validita
   FROM cu_his.vw_ref_cu_nucleo
UNION
 SELECT vw_ref_cu_nucleo_periodi.his_id_transazione,
    vw_ref_cu_nucleo_periodi.id,
    vw_ref_cu_nucleo_periodi.descr_oggetto,
    vw_ref_cu_nucleo_periodi.tabella,
    vw_ref_cu_nucleo_periodi.id_user,
    vw_ref_cu_nucleo_periodi.nominativo,
    vw_ref_cu_nucleo_periodi.his_validita
   FROM cu_his.vw_ref_cu_nucleo_periodi
UNION
 SELECT vw_ref_cu_oggetti.his_id_transazione,
    vw_ref_cu_oggetti.id,
    vw_ref_cu_oggetti.descr_oggetto,
    vw_ref_cu_oggetti.tabella,
    vw_ref_cu_oggetti.id_user,
    vw_ref_cu_oggetti.nominativo,
    vw_ref_cu_oggetti.his_validita
   FROM cu_his.vw_ref_cu_oggetti
UNION
 SELECT vw_ref_cu_oggetti_cl.his_id_transazione,
    vw_ref_cu_oggetti_cl.id,
    vw_ref_cu_oggetti_cl.descr_oggetto,
    vw_ref_cu_oggetti_cl.tabella,
    vw_ref_cu_oggetti_cl.id_user,
    vw_ref_cu_oggetti_cl.nominativo,
    vw_ref_cu_oggetti_cl.his_validita
   FROM cu_his.vw_ref_cu_oggetti_cl
UNION
 SELECT vw_ref_cu_piani.his_id_transazione,
    vw_ref_cu_piani.id,
    vw_ref_cu_piani.descr_oggetto,
    vw_ref_cu_piani.tabella,
    vw_ref_cu_piani.id_user,
    vw_ref_cu_piani.nominativo,
    vw_ref_cu_piani.his_validita
   FROM cu_his.vw_ref_cu_piani
UNION
 SELECT vw_ref_cu_provv.his_id_transazione,
    vw_ref_cu_provv.id,
    vw_ref_cu_provv.descr_oggetto,
    vw_ref_cu_provv.tabella,
    vw_ref_cu_provv.id_user,
    vw_ref_cu_provv.nominativo,
    vw_ref_cu_provv.his_validita
   FROM cu_his.vw_ref_cu_provv
UNION
 SELECT vw_ref_cu_provv_fu.his_id_transazione,
    vw_ref_cu_provv_fu.id,
    vw_ref_cu_provv_fu.descr_oggetto,
    vw_ref_cu_provv_fu.tabella,
    vw_ref_cu_provv_fu.id_transazione AS id_user,
    vw_ref_cu_provv_fu.nominativo,
    vw_ref_cu_provv_fu.his_validita
   FROM cu_his.vw_ref_cu_provv_fu
UNION
 SELECT vw_ref_cu_provv_sopralluogo.his_id_transazione,
    vw_ref_cu_provv_sopralluogo.id,
    vw_ref_cu_provv_sopralluogo.descr_oggetto,
    vw_ref_cu_provv_sopralluogo.tabella,
    vw_ref_cu_provv_sopralluogo.id_user,
    vw_ref_cu_provv_sopralluogo.nominativo,
    vw_ref_cu_provv_sopralluogo.his_validita
   FROM cu_his.vw_ref_cu_provv_sopralluogo
UNION
 SELECT vw_ref_cu_provv_sopralluogo_fu.his_id_transazione,
    vw_ref_cu_provv_sopralluogo_fu.id,
    vw_ref_cu_provv_sopralluogo_fu.descr_oggetto,
    vw_ref_cu_provv_sopralluogo_fu.tabella,
    vw_ref_cu_provv_sopralluogo_fu.id_user,
    vw_ref_cu_provv_sopralluogo_fu.nominativo,
    vw_ref_cu_provv_sopralluogo_fu.his_validita
   FROM cu_his.vw_ref_cu_provv_sopralluogo_fu
UNION
 SELECT vw_ref_cu_automezzi.his_id_transazione,
    vw_ref_cu_automezzi.id,
    vw_ref_cu_automezzi.descr_oggetto,
    vw_ref_cu_automezzi.tabella,
    vw_ref_cu_automezzi.id_user,
    vw_ref_cu_automezzi.nominativo,
    vw_ref_cu_automezzi.his_validita
   FROM cu_his.vw_ref_cu_automezzi
UNION
 SELECT vw_ref_clienti.his_id_transazione,
    vw_ref_clienti.id,
    vw_ref_clienti.descr_oggetto,
    vw_ref_clienti.tabella,
    vw_ref_clienti.id_user,
    vw_ref_clienti.nominativo,
    vw_ref_clienti.his_validita
   FROM trf_his.vw_ref_clienti
UNION
 SELECT vw_ref_impresa_figure.his_id_transazione,
    vw_ref_impresa_figure.id,
    vw_ref_impresa_figure.descr_oggetto,
    vw_ref_impresa_figure.tabella,
    vw_ref_impresa_figure.id_user,
    vw_ref_impresa_figure.nominativo,
    vw_ref_impresa_figure.his_validita
   FROM cu_his.vw_ref_impresa_figure
UNION
 SELECT vw_ref_impresa_sedi.his_id_transazione,
    vw_ref_impresa_sedi.id,
    vw_ref_impresa_sedi.descr_oggetto,
    vw_ref_impresa_sedi.tabella,
    vw_ref_impresa_sedi.id_user,
    vw_ref_impresa_sedi.nominativo,
    vw_ref_impresa_sedi.his_validita
   FROM cu_his.vw_ref_impresa_sedi
UNION
 SELECT vw_ref_imprese.his_id_transazione,
    vw_ref_imprese.id,
    vw_ref_imprese.descr_oggetto,
    vw_ref_imprese.tabella,
    vw_ref_imprese.id_user,
    vw_ref_imprese.nominativo,
    vw_ref_imprese.his_validita
   FROM cu_his.vw_ref_imprese
UNION
 SELECT vw_ref_stabilimenti.his_id_transazione,
    vw_ref_stabilimenti.id,
    vw_ref_stabilimenti.descr_oggetto,
    vw_ref_stabilimenti.tabella,
    vw_ref_stabilimenti.id_user,
    vw_ref_stabilimenti.nominativo,
    vw_ref_stabilimenti.his_validita
   FROM cu_his.vw_ref_stabilimenti
UNION
 SELECT vw_ref_stabilimento_figure.his_id_transazione,
    vw_ref_stabilimento_figure.id,
    vw_ref_stabilimento_figure.descr_oggetto,
    vw_ref_stabilimento_figure.tabella,
    vw_ref_stabilimento_figure.id_user,
    vw_ref_stabilimento_figure.nominativo,
    vw_ref_stabilimento_figure.his_validita
   FROM cu_his.vw_ref_stabilimento_figure
UNION
 SELECT vw_ref_stabilimento_sedi.his_id_transazione,
    vw_ref_stabilimento_sedi.id,
    vw_ref_stabilimento_sedi.descr_oggetto,
    vw_ref_stabilimento_sedi.tabella,
    vw_ref_stabilimento_sedi.id_user,
    vw_ref_stabilimento_sedi.nominativo,
    vw_ref_stabilimento_sedi.his_validita
   FROM cu_his.vw_ref_stabilimento_sedi
UNION
 SELECT vw_ref_soggetti_fisici.his_id_transazione,
    vw_ref_soggetti_fisici.id,
    vw_ref_soggetti_fisici.descr_oggetto,
    vw_ref_soggetti_fisici.tabella,
    vw_ref_soggetti_fisici.id_user,
    vw_ref_soggetti_fisici.nominativo,
    vw_ref_soggetti_fisici.his_validita
   FROM cu_his.vw_ref_soggetti_fisici
UNION
 SELECT vw_ref_tariffa_strutture.his_id_transazione,
    vw_ref_tariffa_strutture.id,
    vw_ref_tariffa_strutture.descr_oggetto,
    vw_ref_tariffa_strutture.tabella,
    vw_ref_tariffa_strutture.id_user,
    vw_ref_tariffa_strutture.nominativo,
    vw_ref_tariffa_strutture.his_validita
   FROM trf_his.vw_ref_tariffa_strutture
UNION
 SELECT vw_ref_tariffa_voci.his_id_transazione,
    vw_ref_tariffa_voci.id,
    vw_ref_tariffa_voci.descr_oggetto,
    vw_ref_tariffa_voci.tabella,
    vw_ref_tariffa_voci.id_user,
    vw_ref_tariffa_voci.nominativo,
    vw_ref_tariffa_voci.his_validita
   FROM trf_his.vw_ref_tariffa_voci
UNION
 SELECT vw_ref_tariffa_voci_calcolo.his_id_transazione,
    vw_ref_tariffa_voci_calcolo.id,
    vw_ref_tariffa_voci_calcolo.descr_oggetto,
    vw_ref_tariffa_voci_calcolo.tabella,
    vw_ref_tariffa_voci_calcolo.id_user,
    vw_ref_tariffa_voci_calcolo.nominativo,
    vw_ref_tariffa_voci_calcolo.his_validita
   FROM trf_his.vw_ref_tariffa_voci_calcolo
UNION
 SELECT vw_ref_tariffe.his_id_transazione,
    vw_ref_tariffe.id,
    vw_ref_tariffe.descr_oggetto,
    vw_ref_tariffe.tabella,
    vw_ref_tariffe.id_user,
    vw_ref_tariffe.nominativo,
    vw_ref_tariffe.his_validita
   FROM trf_his.vw_ref_tariffe
UNION
 SELECT vw_ref_trf_att_inviate.his_id_transazione,
    vw_ref_trf_att_inviate.id,
    vw_ref_trf_att_inviate.descr_oggetto,
    vw_ref_trf_att_inviate.tabella,
    vw_ref_trf_att_inviate.id_user,
    vw_ref_trf_att_inviate.nominativo,
    vw_ref_trf_att_inviate.his_validita
   FROM trf_his.vw_ref_trf_att_inviate
UNION
 SELECT vw_ref_trf_att_inviate_stati.his_id_transazione,
    vw_ref_trf_att_inviate_stati.id,
    vw_ref_trf_att_inviate_stati.descr_oggetto,
    vw_ref_trf_att_inviate_stati.tabella,
    vw_ref_trf_att_inviate_stati.id_user,
    vw_ref_trf_att_inviate_stati.nominativo,
    vw_ref_trf_att_inviate_stati.his_validita
   FROM trf_his.vw_ref_trf_att_inviate_stati
UNION
 SELECT vw_ref_trf_attivita.his_id_transazione,
    vw_ref_trf_attivita.id,
    vw_ref_trf_attivita.descr_oggetto,
    vw_ref_trf_attivita.tabella,
    vw_ref_trf_attivita.id_user,
    vw_ref_trf_attivita.nominativo,
    vw_ref_trf_attivita.his_validita
   FROM trf_his.vw_ref_trf_attivita
UNION
 SELECT vw_ref_trf_attivita_dettagli.his_id_transazione,
    vw_ref_trf_attivita_dettagli.id,
    vw_ref_trf_attivita_dettagli.descr_oggetto,
    vw_ref_trf_attivita_dettagli.tabella,
    vw_ref_trf_attivita_dettagli.id_user,
    vw_ref_trf_attivita_dettagli.nominativo,
    vw_ref_trf_attivita_dettagli.his_validita
   FROM trf_his.vw_ref_trf_attivita_dettagli
UNION
 SELECT vw_ref_trf_attivita_forfet.his_id_transazione,
    vw_ref_trf_attivita_forfet.id,
    vw_ref_trf_attivita_forfet.descr_oggetto,
    vw_ref_trf_attivita_forfet.tabella,
    vw_ref_trf_attivita_forfet.id_user,
    vw_ref_trf_attivita_forfet.nominativo,
    vw_ref_trf_attivita_forfet.his_validita
   FROM trf_his.vw_ref_trf_attivita_forfet
UNION
 SELECT vw_ref_asl_piani.his_id_transazione,
    vw_ref_asl_piani.id,
    vw_ref_asl_piani.descr_oggetto,
    vw_ref_asl_piani.tabella,
    vw_ref_asl_piani.id_user,
    vw_ref_asl_piani.nominativo,
    vw_ref_asl_piani.his_validita
   FROM ag_his.vw_ref_asl_piani
UNION
 SELECT vw_ref_attivita.his_id_transazione,
    vw_ref_attivita.id,
    vw_ref_attivita.descr_oggetto,
    vw_ref_attivita.tabella,
    vw_ref_attivita.id_user,
    vw_ref_attivita.nominativo,
    vw_ref_attivita.his_validita
   FROM ag_his.vw_ref_attivita
UNION
 SELECT vw_ref_avvisi.his_id_transazione,
    vw_ref_avvisi.id,
    vw_ref_avvisi.descr_oggetto,
    vw_ref_avvisi.tabella,
    vw_ref_avvisi.id_user,
    vw_ref_avvisi.nominativo,
    vw_ref_avvisi.his_validita
   FROM ag_his.vw_ref_avvisi
UNION
 SELECT vw_ref_avviso_risorse.his_id_transazione,
    vw_ref_avviso_risorse.id,
    vw_ref_avviso_risorse.descr_oggetto,
    vw_ref_avviso_risorse.tabella,
    vw_ref_avviso_risorse.id_user,
    vw_ref_avviso_risorse.nominativo,
    vw_ref_avviso_risorse.his_validita
   FROM ag_his.vw_ref_avviso_risorse
UNION
 SELECT vw_ref_cf_liste.his_id_transazione,
    vw_ref_cf_liste.id,
    vw_ref_cf_liste.descr_oggetto,
    vw_ref_cf_liste.tabella,
    vw_ref_cf_liste.id_user,
    vw_ref_cf_liste.nominativo,
    vw_ref_cf_liste.his_validita
   FROM ag_his.vw_ref_cf_liste
UNION
 SELECT vw_ref_elab_cals.his_id_transazione,
    vw_ref_elab_cals.id,
    vw_ref_elab_cals.descr_oggetto,
    vw_ref_elab_cals.tabella,
    vw_ref_elab_cals.id_user,
    vw_ref_elab_cals.nominativo,
    vw_ref_elab_cals.his_validita
   FROM ag_his.vw_ref_elab_cals
UNION
 SELECT vw_ref_eventi.his_id_transazione,
    vw_ref_eventi.id,
    vw_ref_eventi.descr_oggetto,
    vw_ref_eventi.tabella,
    vw_ref_eventi.id_user,
    vw_ref_eventi.nominativo,
    vw_ref_eventi.his_validita
   FROM ag_his.vw_ref_eventi
UNION
 SELECT vw_ref_linea_piani.his_id_transazione,
    vw_ref_linea_piani.id,
    vw_ref_linea_piani.descr_oggetto,
    vw_ref_linea_piani.tabella,
    vw_ref_linea_piani.id_user,
    vw_ref_linea_piani.nominativo,
    vw_ref_linea_piani.his_validita
   FROM ag_his.vw_ref_linea_piani
UNION
 SELECT vw_ref_linee_selezionate.his_id_transazione,
    vw_ref_linee_selezionate.id,
    vw_ref_linee_selezionate.descr_oggetto,
    vw_ref_linee_selezionate.tabella,
    vw_ref_linee_selezionate.id_user,
    vw_ref_linee_selezionate.nominativo,
    vw_ref_linee_selezionate.his_validita
   FROM ag_his.vw_ref_linee_selezionate
UNION
 SELECT vw_ref_lista_import.his_id_transazione,
    vw_ref_lista_import.id,
    vw_ref_lista_import.descr_oggetto,
    vw_ref_lista_import.tabella,
    vw_ref_lista_import.id_user,
    vw_ref_lista_import.nominativo,
    vw_ref_lista_import.his_validita
   FROM ag_his.vw_ref_lista_import
UNION
 SELECT vw_ref_nominativo_az_sedi.his_id_transazione,
    vw_ref_nominativo_az_sedi.id,
    vw_ref_nominativo_az_sedi.descr_oggetto,
    vw_ref_nominativo_az_sedi.tabella,
    vw_ref_nominativo_az_sedi.id_user,
    vw_ref_nominativo_az_sedi.nominativo,
    vw_ref_nominativo_az_sedi.his_validita
   FROM ag_his.vw_ref_nominativo_az_sedi
UNION
 SELECT vw_ref_nominativo_comuni.his_id_transazione,
    vw_ref_nominativo_comuni.id,
    vw_ref_nominativo_comuni.descr_oggetto,
    vw_ref_nominativo_comuni.tabella,
    vw_ref_nominativo_comuni.id_user,
    vw_ref_nominativo_comuni.nominativo,
    vw_ref_nominativo_comuni.his_validita
   FROM ag_his.vw_ref_nominativo_comuni
UNION
 SELECT vw_ref_nominativo_linee.his_id_transazione,
    vw_ref_nominativo_linee.id,
    vw_ref_nominativo_linee.descr_oggetto,
    vw_ref_nominativo_linee.tabella,
    vw_ref_nominativo_linee.id_user,
    vw_ref_nominativo_linee.nominativo,
    vw_ref_nominativo_linee.his_validita
   FROM ag_his.vw_ref_nominativo_linee
UNION
 SELECT vw_ref_nominativo_piani.his_id_transazione,
    vw_ref_nominativo_piani.id,
    vw_ref_nominativo_piani.descr_oggetto,
    vw_ref_nominativo_piani.tabella,
    vw_ref_nominativo_piani.id_user,
    vw_ref_nominativo_piani.nominativo,
    vw_ref_nominativo_piani.his_validita
   FROM ag_his.vw_ref_nominativo_piani
UNION
 SELECT vw_ref_piano_freq.his_id_transazione,
    vw_ref_piano_freq.id,
    vw_ref_piano_freq.descr_oggetto,
    vw_ref_piano_freq.tabella,
    vw_ref_piano_freq.id_user,
    vw_ref_piano_freq.nominativo,
    vw_ref_piano_freq.his_validita
   FROM ag_his.vw_ref_piano_freq
UNION
 SELECT vw_ref_piano_periodo.his_id_transazione,
    vw_ref_piano_periodo.id,
    vw_ref_piano_periodo.descr_oggetto,
    vw_ref_piano_periodo.tabella,
    vw_ref_piano_periodo.id_user,
    vw_ref_piano_periodo.nominativo,
    vw_ref_piano_periodo.his_validita
   FROM ag_his.vw_ref_piano_periodo
UNION
 SELECT vw_ref_piano_tipo_linea.his_id_transazione,
    vw_ref_piano_tipo_linea.id,
    vw_ref_piano_tipo_linea.descr_oggetto,
    vw_ref_piano_tipo_linea.tabella,
    vw_ref_piano_tipo_linea.id_user,
    vw_ref_piano_tipo_linea.nominativo,
    vw_ref_piano_tipo_linea.his_validita
   FROM ag_his.vw_ref_piano_tipo_linea
UNION
 SELECT vw_ref_struttura_asl.his_id_transazione,
    vw_ref_struttura_asl.id,
    vw_ref_struttura_asl.descr_oggetto,
    vw_ref_struttura_asl.tabella,
    vw_ref_struttura_asl.id_user,
    vw_ref_struttura_asl.nominativo,
    vw_ref_struttura_asl.his_validita
   FROM ag_his.vw_ref_struttura_asl
UNION
 SELECT vw_ref_struttura_comuni.his_id_transazione,
    vw_ref_struttura_comuni.id,
    vw_ref_struttura_comuni.descr_oggetto,
    vw_ref_struttura_comuni.tabella,
    vw_ref_struttura_comuni.id_user,
    vw_ref_struttura_comuni.nominativo,
    vw_ref_struttura_comuni.his_validita
   FROM ag_his.vw_ref_struttura_comuni
UNION
 SELECT vw_ref_struttura_piani.his_id_transazione,
    vw_ref_struttura_piani.id,
    vw_ref_struttura_piani.descr_oggetto,
    vw_ref_struttura_piani.tabella,
    vw_ref_struttura_piani.id_user,
    vw_ref_struttura_piani.nominativo,
    vw_ref_struttura_piani.his_validita
   FROM ag_his.vw_ref_struttura_piani
UNION
 SELECT vw_ref_tipo_lista_piano.his_id_transazione,
    vw_ref_tipo_lista_piano.id,
    vw_ref_tipo_lista_piano.descr_oggetto,
    vw_ref_tipo_lista_piano.tabella,
    vw_ref_tipo_lista_piano.id_user,
    vw_ref_tipo_lista_piano.nominativo,
    vw_ref_tipo_lista_piano.his_validita
   FROM ag_his.vw_ref_tipo_lista_piano
UNION
 SELECT vw_ref_tipo_liste.his_id_transazione,
    vw_ref_tipo_liste.id,
    vw_ref_tipo_liste.descr_oggetto,
    vw_ref_tipo_liste.tabella,
    vw_ref_tipo_liste.id_user,
    vw_ref_tipo_liste.nominativo,
    vw_ref_tipo_liste.his_validita
   FROM ag_his.vw_ref_tipo_liste
UNION
 SELECT vw_ref_tipologia_controllo_piani.his_id_transazione,
    vw_ref_tipologia_controllo_piani.id,
    vw_ref_tipologia_controllo_piani.descr_oggetto,
    vw_ref_tipologia_controllo_piani.tabella,
    vw_ref_tipologia_controllo_piani.id_user,
    vw_ref_tipologia_controllo_piani.nominativo,
    vw_ref_tipologia_controllo_piani.his_validita
   FROM ag_his.vw_ref_tipologia_controllo_piani
UNION
 SELECT vw_ref_tree_nodes.his_id_transazione,
    vw_ref_tree_nodes.id,
    vw_ref_tree_nodes.descr_oggetto,
    vw_ref_tree_nodes.tabella,
    vw_ref_tree_nodes.id_user,
    vw_ref_tree_nodes.nominativo,
    vw_ref_tree_nodes.his_validita
   FROM ag_his.vw_ref_tree_nodes
UNION
 SELECT vw_ref_unita_di_crisi.his_id_transazione,
    vw_ref_unita_di_crisi.id,
    vw_ref_unita_di_crisi.descr_oggetto,
    vw_ref_unita_di_crisi.tabella,
    vw_ref_unita_di_crisi.id_user,
    vw_ref_unita_di_crisi.nominativo,
    vw_ref_unita_di_crisi.his_validita
   FROM ag_his.vw_ref_unita_di_crisi
UNION
 SELECT vw_ref_utente_strutture.his_id_transazione,
    vw_ref_utente_strutture.id,
    vw_ref_utente_strutture.descr_oggetto,
    vw_ref_utente_strutture.tabella,
    vw_ref_utente_strutture.id_user,
    vw_ref_utente_strutture.nominativo,
    vw_ref_utente_strutture.his_validita
   FROM ag_his.vw_ref_utente_strutture
UNION
 SELECT vw_ref_elab_cals_params.his_id_transazione,
    vw_ref_elab_cals_params.id,
    vw_ref_elab_cals_params.descr_oggetto,
    vw_ref_elab_cals_params.tabella,
    vw_ref_elab_cals_params.id_user,
    vw_ref_elab_cals_params.nominativo,
    vw_ref_elab_cals_params.his_validita
   FROM ag_his.vw_ref_elab_cals_params
UNION
 SELECT vw_ref_elab_cal_params_ns_piani.his_id_transazione,
    vw_ref_elab_cal_params_ns_piani.id,
    vw_ref_elab_cal_params_ns_piani.descr_oggetto,
    vw_ref_elab_cal_params_ns_piani.tabella,
    vw_ref_elab_cal_params_ns_piani.id_user,
    vw_ref_elab_cal_params_ns_piani.nominativo,
    vw_ref_elab_cal_params_ns_piani.his_validita
   FROM ag_his.vw_ref_elab_cal_params_ns_piani
UNION
 SELECT vw_ref_cu_nominativo_provv.his_id_transazione,
    vw_ref_cu_nominativo_provv.id,
    vw_ref_cu_nominativo_provv.descr_oggetto,
    vw_ref_cu_nominativo_provv.tabella,
    vw_ref_cu_nominativo_provv.id_user,
    vw_ref_cu_nominativo_provv.nominativo,
    vw_ref_cu_nominativo_provv.his_validita
   FROM cu_his.vw_ref_cu_nominativo_provv
  ORDER BY 1;


ALTER TABLE cu_his.vw_ref_all_cu OWNER TO gisa_fvg;

--
-- Name: vw_ref_all; Type: VIEW; Schema: cu_his; Owner: gisa_fvg
--

CREATE VIEW cu_his.vw_ref_all AS
 SELECT vw_ref_all_cu.his_id_transazione,
    vw_ref_all_cu.id,
    vw_ref_all_cu.descr_oggetto,
    vw_ref_all_cu.tabella,
    vw_ref_all_cu.id_user,
    vw_ref_all_cu.nominativo,
    vw_ref_all_cu.his_validita
   FROM cu_his.vw_ref_all_cu;


ALTER TABLE cu_his.vw_ref_all OWNER TO gisa_fvg;

--
-- Name: vw_ref_cu_altri_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_altri_fast AS
 SELECT a.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_altri'::text AS tabella,
    a.his_validita
   FROM ((cu_his.cu_altri a
     JOIN cu_his.cu_nucleo cn ON (((a.id = cn.id_nominativo) AND (cn.his_validita @> lower(a.his_validita)))))
     JOIN cu_his.cu c ON (((c.id = cn.id_cu) AND (c.his_validita @> lower(a.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_altri_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_dichiarazioni_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_dichiarazioni_fast AS
 SELECT a.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_dichiarazioni'::text AS tabella,
    a.his_validita
   FROM ((cu_his.cu_dichiarazioni a
     JOIN cu_his.cu_nucleo cn ON (((a.id_cu_nucleo = cn.id) AND (cn.his_validita @> lower(a.his_validita)))))
     JOIN cu_his.cu c ON (((c.id = cn.id_cu) AND (c.his_validita @> lower(a.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_dichiarazioni_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_evidenza_linee_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_evidenza_linee_fast AS
 SELECT el.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_evidenza_linee'::text AS tabella,
    el.his_validita
   FROM ((((cu_his.cu_evidenza_linee el
     JOIN cu_his.cu_evidenze e ON (((el.id_evidenza = e.id) AND (e.his_validita @> lower(el.his_validita)))))
     JOIN cu_his.cu_oggetti_cl coc ON (((coc.id = e.id_cu_oggetto_cl) AND (coc.his_validita @> lower(el.his_validita)))))
     JOIN cu_his.cu_oggetti co ON (((co.id = coc.id_cu_oggetto) AND (co.his_validita @> lower(el.his_validita)))))
     JOIN cu_his.cu c ON (((c.id = co.id_cu) AND (c.his_validita @> lower(el.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_evidenza_linee_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_evidenze_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_evidenze_fast AS
 SELECT e.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_evidenze'::text AS tabella,
    e.his_validita
   FROM (((cu_his.cu_evidenze e
     JOIN cu_his.cu_oggetti_cl coc ON (((coc.id = e.id_cu_oggetto_cl) AND (coc.his_validita @> lower(e.his_validita)))))
     JOIN cu_his.cu_oggetti co ON (((co.id = coc.id_cu_oggetto) AND (co.his_validita @> lower(e.his_validita)))))
     JOIN cu_his.cu c ON (((c.id = co.id_cu) AND (c.his_validita @> lower(e.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_evidenze_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_fast AS
 SELECT c.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu'::text AS tabella,
    c.his_validita
   FROM cu_his.cu c;


ALTER TABLE cu_his.vw_ref_cu_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_linee_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_linee_fast AS
 SELECT cl.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_linee'::text AS tabella,
    cl.his_validita
   FROM (cu_his.cu_linee cl
     JOIN cu_his.cu c ON (((c.id = cl.id_cu) AND (c.his_validita @> lower(cl.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_linee_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_norme_violate_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_norme_violate_fast AS
 SELECT nv.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_norme_violate'::text AS tabella,
    nv.his_validita
   FROM (cu_his.cu_norme_violate nv
     JOIN cu_his.cu c ON (((c.id = nv.id_cu) AND (c.his_validita @> lower(nv.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_norme_violate_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_nucleo_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_nucleo_fast AS
 SELECT cn.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_nucleo'::text AS tabella,
    cn.his_validita
   FROM (cu_his.cu_nucleo cn
     JOIN cu_his.cu c ON (((c.id = cn.id_cu) AND (c.his_validita @> lower(cn.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_nucleo_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_nucleo_periodi_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_nucleo_periodi_fast AS
 SELECT cnp.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'nucleo_periodi'::text AS tabella,
    cnp.his_validita
   FROM ((cu_his.cu_nucleo_periodi cnp
     JOIN cu_his.cu_nucleo cn ON (((cnp.id_cu_nucleo = cn.id) AND (cn.his_validita @> lower(cnp.his_validita)))))
     JOIN cu_his.cu c ON (((c.id = cn.id_cu) AND (c.his_validita @> lower(cnp.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_nucleo_periodi_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_oggetti_cl_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_oggetti_cl_fast AS
 SELECT coc.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_oggetti_cl'::text AS tabella,
    coc.his_validita
   FROM ((cu_his.cu_oggetti_cl coc
     JOIN cu_his.cu_oggetti co ON (((coc.id_cu_oggetto = co.id) AND (co.his_validita @> lower(coc.his_validita)))))
     JOIN cu_his.cu c ON (((c.id = co.id_cu) AND (c.his_validita @> lower(coc.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_oggetti_cl_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_oggetti_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_oggetti_fast AS
 SELECT co.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_oggetti'::text AS tabella,
    co.his_validita
   FROM (cu_his.cu_oggetti co
     JOIN cu_his.cu c ON (((c.id = co.id_cu) AND (c.his_validita @> lower(co.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_oggetti_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_piani_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_piani_fast AS
 SELECT p.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_piani'::text AS tabella,
    p.his_validita
   FROM (cu_his.cu_piani p
     JOIN cu_his.cu c ON (((c.id = p.id_cu) AND (c.his_validita @> lower(p.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_piani_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_provv_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_provv_fast AS
 SELECT cp.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_provv'::text AS tabella,
    cp.his_validita
   FROM ((cu_his.cu_provv cp
     JOIN cu_his.cu_norme_violate nv ON (((nv.id = cp.id_norma_violata) AND (nv.his_validita @> lower(cp.his_validita)))))
     JOIN cu_his.cu c ON (((c.id = nv.id_cu) AND (c.his_validita @> lower(cp.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_provv_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_provv_fu_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_provv_fu_fast AS
 SELECT cp.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_provv_fu'::text AS tabella,
    cp.his_validita
   FROM (cu_his.cu_provv_fu cp
     JOIN cu_his.cu c ON (((c.id = cp.id_cu) AND (c.his_validita @> lower(cp.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_provv_fu_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_provv_sopralluogo_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_provv_sopralluogo_fast AS
 SELECT ps.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_provv_sopralluogo'::text AS tabella,
    ps.his_validita
   FROM (cu_his.cu_provv_sopralluogo ps
     JOIN cu_his.cu c ON (((c.id = ps.id_cu) AND (c.his_validita @> lower(ps.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_provv_sopralluogo_fast OWNER TO postgres;

--
-- Name: vw_ref_cu_provv_sopralluogo_fu_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_provv_sopralluogo_fu_fast AS
 SELECT ps.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_provv_sopralluogo_fu'::text AS tabella,
    ps.his_validita
   FROM (cu_his.cu_provv_sopralluogo_fu ps
     JOIN cu_his.cu c ON (((c.id = ps.id_cu) AND (c.his_validita @> lower(ps.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_provv_sopralluogo_fu_fast OWNER TO postgres;

--
-- Name: vw_ref_impresa_figure_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_impresa_figure_fast AS
 SELECT i.his_id_transazione,
    i.id,
    i2.piva AS descr_oggetto,
    'impresa_figure'::text AS tabella,
    i.his_validita
   FROM (cu_his.impresa_figure i
     JOIN cu_his.imprese i2 ON ((i2.id = i.id_impresa)));


ALTER TABLE cu_his.vw_ref_impresa_figure_fast OWNER TO postgres;

--
-- Name: vw_ref_impresa_sedi_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_impresa_sedi_fast AS
 SELECT i.his_id_transazione,
    i.id,
    i2.piva AS descr_oggetto,
    'impresa_sedi'::text AS tabella,
    i.his_validita
   FROM (cu_his.impresa_sedi i
     JOIN cu_his.imprese i2 ON ((i2.id = i.id_impresa)));


ALTER TABLE cu_his.vw_ref_impresa_sedi_fast OWNER TO postgres;

--
-- Name: vw_ref_imprese_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_imprese_fast AS
 SELECT i.his_id_transazione,
    i.id,
    i.piva AS descr_oggetto,
    'imprese'::text AS tabella,
    i.his_validita
   FROM cu_his.imprese i;


ALTER TABLE cu_his.vw_ref_imprese_fast OWNER TO postgres;

--
-- Name: vw_ref_soggetti_fisici_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_soggetti_fisici_fast AS
 SELECT sf.his_id_transazione,
    sf.id,
    sf.codice_fiscale AS descr_oggetto,
    'soggetti_fisici'::text AS tabella,
    sf.his_validita
   FROM cu_his.soggetti_fisici sf;


ALTER TABLE cu_his.vw_ref_soggetti_fisici_fast OWNER TO postgres;

--
-- Name: vw_ref_stabilimenti_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_stabilimenti_fast AS
 SELECT s.his_id_transazione,
    s.id,
    s.cod_regionale AS descr_oggetto,
    'stabilimenti'::text AS tabella,
    s.his_validita
   FROM cu_his.stabilimenti s;


ALTER TABLE cu_his.vw_ref_stabilimenti_fast OWNER TO postgres;

--
-- Name: vw_ref_stabilimento_figure_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_stabilimento_figure_fast AS
 SELECT sf.his_id_transazione,
    sf.id,
    s.cod_regionale AS descr_oggetto,
    'stabilimento_figure'::text AS tabella,
    sf.his_validita
   FROM (cu_his.stabilimento_figure sf
     JOIN cu_his.stabilimenti s ON ((s.id = sf.id_stabilimento)));


ALTER TABLE cu_his.vw_ref_stabilimento_figure_fast OWNER TO postgres;

--
-- Name: vw_ref_stabilimento_sedi_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_stabilimento_sedi_fast AS
 SELECT ss.his_id_transazione,
    ss.id,
    s.cod_regionale AS descr_oggetto,
    'stabilimento_sedi'::text AS tabella,
    ss.his_validita
   FROM (cu_his.stabilimento_sedi ss
     JOIN cu_his.stabilimenti s ON ((s.id = ss.id_stabilimento)));


ALTER TABLE cu_his.vw_ref_stabilimento_sedi_fast OWNER TO postgres;

--
-- Name: vw_ref_clienti_fast; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_clienti_fast AS
 SELECT c.his_id_transazione,
    c.id,
    c.descr AS descr_oggetto,
    'clienti'::text AS tabella,
    c.his_validita
   FROM trf_his.clienti c;


ALTER TABLE trf_his.vw_ref_clienti_fast OWNER TO postgres;

--
-- Name: vw_ref_tariffa_strutture_fast; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_tariffa_strutture_fast AS
 SELECT ts.his_id_transazione,
    ts.id,
    vt.sigla AS descr_oggetto,
    'tariffa_strutture'::text AS tabella,
    ts.his_validita
   FROM (trf_his.tariffa_strutture ts
     JOIN trf_his.vw_tariffe vt ON ((vt.id = ts.id_tariffa)));


ALTER TABLE trf_his.vw_ref_tariffa_strutture_fast OWNER TO postgres;

--
-- Name: vw_ref_tariffa_voci_calcolo_fast; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_tariffa_voci_calcolo_fast AS
 SELECT tvc.his_id_transazione,
    tvc.id_tariffa_voce AS id,
    vrtv.descr_oggetto,
    'tariffa_voci_calcolo'::text AS tabella,
    tvc.his_validita
   FROM (trf_his.tariffa_voci_calcolo tvc
     JOIN trf_his.vw_ref_tariffa_voci vrtv ON ((vrtv.id = tvc.id_tariffa_voce)));


ALTER TABLE trf_his.vw_ref_tariffa_voci_calcolo_fast OWNER TO postgres;

--
-- Name: vw_ref_tariffa_voci_fast; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_tariffa_voci_fast AS
 SELECT tv.his_id_transazione,
    tv.id,
    vrts.descr_oggetto,
    'tariffa_voci'::text AS tabella,
    tv.his_validita
   FROM (trf_his.tariffa_voci tv
     JOIN trf_his.vw_ref_tariffa_strutture vrts ON ((vrts.id = tv.id_tariffa_struttura)));


ALTER TABLE trf_his.vw_ref_tariffa_voci_fast OWNER TO postgres;

--
-- Name: vw_ref_tariffe_fast; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_tariffe_fast AS
 SELECT t2.his_id_transazione,
    t2.id,
    t2.sigla AS descr_oggetto,
    'tariffe'::text AS tabella,
    t2.his_validita
   FROM trf_his.tariffe t2;


ALTER TABLE trf_his.vw_ref_tariffe_fast OWNER TO postgres;

--
-- Name: vw_ref_trf_att_inviate_fast; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_trf_att_inviate_fast AS
 SELECT tai.his_id_transazione,
    tai.id,
    s.descr AS descr_oggetto,
    'trf_att_inviate'::text AS tabella,
    tai.his_validita
   FROM ((trf_his.trf_att_inviate tai
     JOIN trf_his.trf_attivita ta ON (((tai.id_trf_attivita = ta.id) AND (ta.his_validita @> lower(tai.his_validita)))))
     JOIN trf.servizi s ON ((s.id = ta.id_servizio)));


ALTER TABLE trf_his.vw_ref_trf_att_inviate_fast OWNER TO postgres;

--
-- Name: vw_ref_trf_att_inviate_stati_fast; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_trf_att_inviate_stati_fast AS
 SELECT tais.his_id_transazione,
    tais.id,
    s.descr AS descr_oggetto,
    'trf_att_inviate_stati'::text AS tabella,
    tais.his_validita
   FROM (((trf_his.trf_att_inviate_stati tais
     JOIN trf_his.trf_att_inviate tai ON (((tais.id_att_inviata = tai.id) AND (tai.his_validita @> lower(tais.his_validita)))))
     JOIN trf_his.trf_attivita ta ON (((tai.id_trf_attivita = ta.id) AND (ta.his_validita @> lower(tais.his_validita)))))
     JOIN trf.servizi s ON ((s.id = ta.id_servizio)));


ALTER TABLE trf_his.vw_ref_trf_att_inviate_stati_fast OWNER TO postgres;

--
-- Name: vw_ref_trf_attivita_dettagli_fast; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_trf_attivita_dettagli_fast AS
 SELECT tad.his_id_transazione,
    tad.id,
    s.descr AS descr_oggetto,
    'trf_attivita_dettagli'::text AS tabella,
    tad.his_validita
   FROM ((trf_his.trf_attivita_dettagli tad
     JOIN trf_his.trf_attivita ta ON (((tad.id_trf_attivita = ta.id) AND (ta.his_validita @> lower(tad.his_validita)))))
     JOIN trf.servizi s ON ((s.id = ta.id_servizio)));


ALTER TABLE trf_his.vw_ref_trf_attivita_dettagli_fast OWNER TO postgres;

--
-- Name: vw_ref_trf_attivita_fast; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_trf_attivita_fast AS
 SELECT ta.his_id_transazione,
    ta.id,
    s.descr AS descr_oggetto,
    'trf_attivita'::text AS tabella,
    ta.his_validita
   FROM (trf_his.trf_attivita ta
     LEFT JOIN trf.servizi s ON ((s.id = ta.id_servizio)));


ALTER TABLE trf_his.vw_ref_trf_attivita_fast OWNER TO postgres;

--
-- Name: vw_ref_trf_attivita_forfet_fast; Type: VIEW; Schema: trf_his; Owner: gisa_fvg
--

CREATE VIEW trf_his.vw_ref_trf_attivita_forfet_fast AS
 SELECT taf.his_id_transazione,
    taf.id,
    s.descr AS descr_oggetto,
    'trf_attivita_forfet'::text AS tabella,
    taf.his_validita
   FROM (trf_his.trf_attivita_forfet taf
     JOIN trf.servizi s ON ((taf.id_servizio = s.id)));


ALTER TABLE trf_his.vw_ref_trf_attivita_forfet_fast OWNER TO gisa_fvg;

--
-- Name: vw_ref_all_cu_simple; Type: VIEW; Schema: cu_his; Owner: gisa_fvg
--

CREATE VIEW cu_his.vw_ref_all_cu_simple AS
 SELECT vw_ref_cu_fast.his_id_transazione,
    vw_ref_cu_fast.id,
    vw_ref_cu_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_fast
UNION
 SELECT vw_ref_cu_altri_fast.his_id_transazione,
    vw_ref_cu_altri_fast.id,
    vw_ref_cu_altri_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_altri_fast
UNION
 SELECT vw_ref_cu_dichiarazioni_fast.his_id_transazione,
    vw_ref_cu_dichiarazioni_fast.id,
    vw_ref_cu_dichiarazioni_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_dichiarazioni_fast
UNION
 SELECT vw_ref_cu_evidenza_linee_fast.his_id_transazione,
    vw_ref_cu_evidenza_linee_fast.id,
    vw_ref_cu_evidenza_linee_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_evidenza_linee_fast
UNION
 SELECT vw_ref_cu_evidenze_fast.his_id_transazione,
    vw_ref_cu_evidenze_fast.id,
    vw_ref_cu_evidenze_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_evidenze_fast
UNION
 SELECT vw_ref_cu_linee_fast.his_id_transazione,
    vw_ref_cu_linee_fast.id,
    vw_ref_cu_linee_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_linee_fast
UNION
 SELECT vw_ref_cu_norme_violate_fast.his_id_transazione,
    vw_ref_cu_norme_violate_fast.id,
    vw_ref_cu_norme_violate_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_norme_violate_fast
UNION
 SELECT vw_ref_cu_nucleo_fast.his_id_transazione,
    vw_ref_cu_nucleo_fast.id,
    vw_ref_cu_nucleo_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_nucleo_fast
UNION
 SELECT vw_ref_cu_nucleo_periodi_fast.his_id_transazione,
    vw_ref_cu_nucleo_periodi_fast.id,
    vw_ref_cu_nucleo_periodi_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_nucleo_periodi_fast
UNION
 SELECT vw_ref_cu_oggetti_fast.his_id_transazione,
    vw_ref_cu_oggetti_fast.id,
    vw_ref_cu_oggetti_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_oggetti_fast
UNION
 SELECT vw_ref_cu_oggetti_cl_fast.his_id_transazione,
    vw_ref_cu_oggetti_cl_fast.id,
    vw_ref_cu_oggetti_cl_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_oggetti_cl_fast
UNION
 SELECT vw_ref_cu_piani_fast.his_id_transazione,
    vw_ref_cu_piani_fast.id,
    vw_ref_cu_piani_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_piani_fast
UNION
 SELECT vw_ref_cu_provv_fast.his_id_transazione,
    vw_ref_cu_provv_fast.id,
    vw_ref_cu_provv_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_provv_fast
UNION
 SELECT vw_ref_cu_provv_fu_fast.his_id_transazione,
    vw_ref_cu_provv_fu_fast.id,
    vw_ref_cu_provv_fu_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_provv_fu_fast
UNION
 SELECT vw_ref_cu_provv_sopralluogo_fast.his_id_transazione,
    vw_ref_cu_provv_sopralluogo_fast.id,
    vw_ref_cu_provv_sopralluogo_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_provv_sopralluogo_fast
UNION
 SELECT vw_ref_cu_provv_sopralluogo_fu_fast.his_id_transazione,
    vw_ref_cu_provv_sopralluogo_fu_fast.id,
    vw_ref_cu_provv_sopralluogo_fu_fast.descr_oggetto
   FROM cu_his.vw_ref_cu_provv_sopralluogo_fu_fast
UNION
 SELECT vw_ref_cu_automezzi.his_id_transazione,
    vw_ref_cu_automezzi.id,
    vw_ref_cu_automezzi.descr_oggetto
   FROM cu_his.vw_ref_cu_automezzi
UNION
 SELECT vw_ref_impresa_figure_fast.his_id_transazione,
    vw_ref_impresa_figure_fast.id,
    vw_ref_impresa_figure_fast.descr_oggetto
   FROM cu_his.vw_ref_impresa_figure_fast
UNION
 SELECT vw_ref_impresa_sedi_fast.his_id_transazione,
    vw_ref_impresa_sedi_fast.id,
    vw_ref_impresa_sedi_fast.descr_oggetto
   FROM cu_his.vw_ref_impresa_sedi_fast
UNION
 SELECT vw_ref_imprese_fast.his_id_transazione,
    vw_ref_imprese_fast.id,
    vw_ref_imprese_fast.descr_oggetto
   FROM cu_his.vw_ref_imprese_fast
UNION
 SELECT vw_ref_stabilimenti_fast.his_id_transazione,
    vw_ref_stabilimenti_fast.id,
    vw_ref_stabilimenti_fast.descr_oggetto
   FROM cu_his.vw_ref_stabilimenti_fast
UNION
 SELECT vw_ref_stabilimento_figure_fast.his_id_transazione,
    vw_ref_stabilimento_figure_fast.id,
    vw_ref_stabilimento_figure_fast.descr_oggetto
   FROM cu_his.vw_ref_stabilimento_figure_fast
UNION
 SELECT vw_ref_stabilimento_sedi_fast.his_id_transazione,
    vw_ref_stabilimento_sedi_fast.id,
    vw_ref_stabilimento_sedi_fast.descr_oggetto
   FROM cu_his.vw_ref_stabilimento_sedi_fast
UNION
 SELECT vw_ref_soggetti_fisici_fast.his_id_transazione,
    vw_ref_soggetti_fisici_fast.id,
    vw_ref_soggetti_fisici_fast.descr_oggetto
   FROM cu_his.vw_ref_soggetti_fisici_fast
UNION
 SELECT vw_ref_clienti_fast.his_id_transazione,
    vw_ref_clienti_fast.id,
    vw_ref_clienti_fast.descr_oggetto
   FROM trf_his.vw_ref_clienti_fast
UNION
 SELECT vw_ref_tariffa_strutture_fast.his_id_transazione,
    vw_ref_tariffa_strutture_fast.id,
    vw_ref_tariffa_strutture_fast.descr_oggetto
   FROM trf_his.vw_ref_tariffa_strutture_fast
UNION
 SELECT vw_ref_tariffa_voci_fast.his_id_transazione,
    vw_ref_tariffa_voci_fast.id,
    vw_ref_tariffa_voci_fast.descr_oggetto
   FROM trf_his.vw_ref_tariffa_voci_fast
UNION
 SELECT vw_ref_tariffa_voci_calcolo_fast.his_id_transazione,
    vw_ref_tariffa_voci_calcolo_fast.id,
    vw_ref_tariffa_voci_calcolo_fast.descr_oggetto
   FROM trf_his.vw_ref_tariffa_voci_calcolo_fast
UNION
 SELECT vw_ref_tariffe_fast.his_id_transazione,
    vw_ref_tariffe_fast.id,
    vw_ref_tariffe_fast.descr_oggetto
   FROM trf_his.vw_ref_tariffe_fast
UNION
 SELECT vw_ref_trf_att_inviate_fast.his_id_transazione,
    vw_ref_trf_att_inviate_fast.id,
    vw_ref_trf_att_inviate_fast.descr_oggetto
   FROM trf_his.vw_ref_trf_att_inviate_fast
UNION
 SELECT vw_ref_trf_att_inviate_stati_fast.his_id_transazione,
    vw_ref_trf_att_inviate_stati_fast.id,
    vw_ref_trf_att_inviate_stati_fast.descr_oggetto
   FROM trf_his.vw_ref_trf_att_inviate_stati_fast
UNION
 SELECT vw_ref_trf_attivita_fast.his_id_transazione,
    vw_ref_trf_attivita_fast.id,
    vw_ref_trf_attivita_fast.descr_oggetto
   FROM trf_his.vw_ref_trf_attivita_fast
UNION
 SELECT vw_ref_trf_attivita_dettagli_fast.his_id_transazione,
    vw_ref_trf_attivita_dettagli_fast.id,
    vw_ref_trf_attivita_dettagli_fast.descr_oggetto
   FROM trf_his.vw_ref_trf_attivita_dettagli_fast
UNION
 SELECT vw_ref_trf_attivita_forfet_fast.his_id_transazione,
    vw_ref_trf_attivita_forfet_fast.id,
    vw_ref_trf_attivita_forfet_fast.descr_oggetto
   FROM trf_his.vw_ref_trf_attivita_forfet_fast
UNION
 SELECT vw_ref_asl_piani_fast.his_id_transazione,
    vw_ref_asl_piani_fast.id,
    vw_ref_asl_piani_fast.descr_oggetto
   FROM ag_his.vw_ref_asl_piani_fast
UNION
 SELECT vw_ref_attivita_fast.his_id_transazione,
    vw_ref_attivita_fast.id,
    vw_ref_attivita_fast.descr_oggetto
   FROM ag_his.vw_ref_attivita_fast
UNION
 SELECT vw_ref_avvisi_fast.his_id_transazione,
    vw_ref_avvisi_fast.id,
    vw_ref_avvisi_fast.descr_oggetto
   FROM ag_his.vw_ref_avvisi_fast
UNION
 SELECT vw_ref_avviso_risorse_fast.his_id_transazione,
    vw_ref_avviso_risorse_fast.id,
    vw_ref_avviso_risorse_fast.descr_oggetto
   FROM ag_his.vw_ref_avviso_risorse_fast
UNION
 SELECT vw_ref_cf_liste_fast.his_id_transazione,
    vw_ref_cf_liste_fast.id,
    vw_ref_cf_liste_fast.descr_oggetto
   FROM ag_his.vw_ref_cf_liste_fast
UNION
 SELECT vw_ref_elab_cals_fast.his_id_transazione,
    vw_ref_elab_cals_fast.id,
    vw_ref_elab_cals_fast.descr_oggetto
   FROM ag_his.vw_ref_elab_cals_fast
UNION
 SELECT vw_ref_eventi_fast.his_id_transazione,
    vw_ref_eventi_fast.id,
    vw_ref_eventi_fast.descr_oggetto
   FROM ag_his.vw_ref_eventi_fast
UNION
 SELECT vw_ref_linea_piani_fast.his_id_transazione,
    vw_ref_linea_piani_fast.id,
    vw_ref_linea_piani_fast.descr_oggetto
   FROM ag_his.vw_ref_linea_piani_fast
UNION
 SELECT vw_ref_linee_selezionate_fast.his_id_transazione,
    vw_ref_linee_selezionate_fast.id,
    vw_ref_linee_selezionate_fast.descr_oggetto
   FROM ag_his.vw_ref_linee_selezionate_fast
UNION
 SELECT vw_ref_lista_import_fast.his_id_transazione,
    vw_ref_lista_import_fast.id,
    vw_ref_lista_import_fast.descr_oggetto
   FROM ag_his.vw_ref_lista_import_fast
UNION
 SELECT vw_ref_nominativo_az_sedi_fast.his_id_transazione,
    vw_ref_nominativo_az_sedi_fast.id,
    vw_ref_nominativo_az_sedi_fast.descr_oggetto
   FROM ag_his.vw_ref_nominativo_az_sedi_fast
UNION
 SELECT vw_ref_nominativo_comuni_fast.his_id_transazione,
    vw_ref_nominativo_comuni_fast.id,
    vw_ref_nominativo_comuni_fast.descr_oggetto
   FROM ag_his.vw_ref_nominativo_comuni_fast
UNION
 SELECT vw_ref_nominativo_linee_fast.his_id_transazione,
    vw_ref_nominativo_linee_fast.id,
    vw_ref_nominativo_linee_fast.descr_oggetto
   FROM ag_his.vw_ref_nominativo_linee_fast
UNION
 SELECT vw_ref_nominativo_piani_fast.his_id_transazione,
    vw_ref_nominativo_piani_fast.id,
    vw_ref_nominativo_piani_fast.descr_oggetto
   FROM ag_his.vw_ref_nominativo_piani_fast
UNION
 SELECT vw_ref_piano_freq_fast.his_id_transazione,
    vw_ref_piano_freq_fast.id,
    vw_ref_piano_freq_fast.descr_oggetto
   FROM ag_his.vw_ref_piano_freq_fast
UNION
 SELECT vw_ref_piano_periodo_fast.his_id_transazione,
    vw_ref_piano_periodo_fast.id,
    vw_ref_piano_periodo_fast.descr_oggetto
   FROM ag_his.vw_ref_piano_periodo_fast
UNION
 SELECT vw_ref_piano_tipo_linea_fast.his_id_transazione,
    vw_ref_piano_tipo_linea_fast.id,
    vw_ref_piano_tipo_linea_fast.descr_oggetto
   FROM ag_his.vw_ref_piano_tipo_linea_fast
UNION
 SELECT vw_ref_struttura_asl_fast.his_id_transazione,
    vw_ref_struttura_asl_fast.id,
    vw_ref_struttura_asl_fast.descr_oggetto
   FROM ag_his.vw_ref_struttura_asl_fast
UNION
 SELECT vw_ref_struttura_comuni_fast.his_id_transazione,
    vw_ref_struttura_comuni_fast.id,
    vw_ref_struttura_comuni_fast.descr_oggetto
   FROM ag_his.vw_ref_struttura_comuni_fast
UNION
 SELECT vw_ref_struttura_piani_fast.his_id_transazione,
    vw_ref_struttura_piani_fast.id,
    vw_ref_struttura_piani_fast.descr_oggetto
   FROM ag_his.vw_ref_struttura_piani_fast
UNION
 SELECT vw_ref_tipo_lista_piano_fast.his_id_transazione,
    vw_ref_tipo_lista_piano_fast.id,
    vw_ref_tipo_lista_piano_fast.descr_oggetto
   FROM ag_his.vw_ref_tipo_lista_piano_fast
UNION
 SELECT vw_ref_tipo_liste_fast.his_id_transazione,
    vw_ref_tipo_liste_fast.id,
    vw_ref_tipo_liste_fast.descr_oggetto
   FROM ag_his.vw_ref_tipo_liste_fast
UNION
 SELECT vw_ref_tipologia_controllo_piani_fast.his_id_transazione,
    vw_ref_tipologia_controllo_piani_fast.id,
    vw_ref_tipologia_controllo_piani_fast.descr_oggetto
   FROM ag_his.vw_ref_tipologia_controllo_piani_fast
UNION
 SELECT vw_ref_tree_nodes_fast.his_id_transazione,
    vw_ref_tree_nodes_fast.id,
    vw_ref_tree_nodes_fast.descr_oggetto
   FROM ag_his.vw_ref_tree_nodes_fast
UNION
 SELECT vw_ref_unita_di_crisi_fast.his_id_transazione,
    vw_ref_unita_di_crisi_fast.id,
    vw_ref_unita_di_crisi_fast.descr_oggetto
   FROM ag_his.vw_ref_unita_di_crisi_fast
UNION
 SELECT vw_ref_utente_strutture_fast.his_id_transazione,
    vw_ref_utente_strutture_fast.id,
    vw_ref_utente_strutture_fast.descr_oggetto
   FROM ag_his.vw_ref_utente_strutture_fast
UNION
 SELECT vw_ref_elab_cals_params_fast.his_id_transazione,
    vw_ref_elab_cals_params_fast.id,
    vw_ref_elab_cals_params_fast.descr_oggetto
   FROM ag_his.vw_ref_elab_cals_params_fast
UNION
 SELECT vw_ref_elab_cal_params_ns_piani_fast.his_id_transazione,
    vw_ref_elab_cal_params_ns_piani_fast.id,
    vw_ref_elab_cal_params_ns_piani_fast.descr_oggetto
   FROM ag_his.vw_ref_elab_cal_params_ns_piani_fast
UNION
 SELECT vw_ref_cu_nominativo_provv.his_id_transazione,
    vw_ref_cu_nominativo_provv.id,
    vw_ref_cu_nominativo_provv.descr_oggetto
   FROM cu_his.vw_ref_cu_nominativo_provv
  ORDER BY 1;


ALTER TABLE cu_his.vw_ref_all_cu_simple OWNER TO gisa_fvg;

--
-- Name: vw_ref_cu_automezzi_fast; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_ref_cu_automezzi_fast AS
 SELECT ca.his_id_transazione,
    c.id,
    c.codice AS descr_oggetto,
    'cu_automezzi'::text AS tabella,
    ca.his_validita
   FROM (cu_his.cu_automezzi ca
     JOIN cu_his.cu c ON (((c.id = ca.id_cu) AND (c.his_validita @> lower(ca.his_validita)))));


ALTER TABLE cu_his.vw_ref_cu_automezzi_fast OWNER TO postgres;

--
-- Name: vw_riepilogo_cu_nodes_up; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_riepilogo_cu_nodes_up AS
 WITH RECURSIVE vw_riepilogo_cu_nodes_up(id_node, id_node_parent, path) AS (
         SELECT riepilogo_cu_nodes.id AS id_node,
            riepilogo_cu_nodes.id_node_parent,
            (riepilogo_cu_nodes.id)::text AS path,
            riepilogo_cu_nodes.ordinamento AS path_ord,
            riepilogo_cu_nodes.node_descr AS path_descr,
            0 AS lv,
            riepilogo_cu_nodes.node_descr,
            riepilogo_cu_nodes.ordinamento
           FROM cu_his.riepilogo_cu_nodes
          WHERE (riepilogo_cu_nodes.id_node_parent IS NULL)
        UNION ALL
         SELECT n.id AS id_node,
            n.id_node_parent,
            ((up.path || '/'::text) || n.id),
            (((up.path_ord)::text || '/'::text) || (n.ordinamento)::text),
            (((up.path_descr)::text || '/'::text) || (n.node_descr)::text),
            (up.lv + 1) AS lv,
            (n.node_descr)::text AS node_descr,
            up.ordinamento
           FROM (vw_riepilogo_cu_nodes_up up
             JOIN cu_his.riepilogo_cu_nodes n ON ((up.id_node = n.id_node_parent)))
        )
 SELECT vw_riepilogo_cu_nodes_up.id_node,
    vw_riepilogo_cu_nodes_up.id_node_parent,
    vw_riepilogo_cu_nodes_up.path,
    vw_riepilogo_cu_nodes_up.path_ord,
    vw_riepilogo_cu_nodes_up.path_descr,
    vw_riepilogo_cu_nodes_up.lv,
    vw_riepilogo_cu_nodes_up.node_descr,
    vw_riepilogo_cu_nodes_up.ordinamento
   FROM vw_riepilogo_cu_nodes_up
  ORDER BY vw_riepilogo_cu_nodes_up.path;


ALTER TABLE cu_his.vw_riepilogo_cu_nodes_up OWNER TO postgres;

--
-- Name: vw_riepilogo_cu_nodes_up_descr; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_riepilogo_cu_nodes_up_descr AS
 SELECT c.id,
    c.cod,
    c.sigla,
    c.descr,
    cn.id_node,
    cn.id_node_parent,
    cn.path,
    cn.path_ord,
    cn.path_descr,
    cn.lv,
    cn.node_descr,
    cn.ordinamento
   FROM (cu_his.vw_riepilogo_cu_nodes_up cn
     JOIN cu_his.riepilogo_cu c ON ((cn.id_node = c.id)));


ALTER TABLE cu_his.vw_riepilogo_cu_nodes_up_descr OWNER TO postgres;

--
-- Name: vw_soggetti_fisici; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_soggetti_fisici AS
 SELECT sf.his_id,
    sf.his_validita,
    sf.his_id_transazione,
    sf.his_ts,
    sf.his_ts_transazione,
    sf.id,
    sf.titolo,
    sf.cognome,
    sf.nome,
    sf.comune_nascita,
    sf.codice_fiscale,
    sf.sesso,
    sf.telefono,
    sf.email,
    sf.pec,
    sf.telefono2,
    sf.data_nascita,
    sf.documento_identita,
    sf.indirizzo_id,
    sf.verificato,
    sf.fonte,
    lower(sf.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(sf.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    (COALESCE(c.denominazione_it, ((('>'::text || (sf.comune_nascita)::text) || '<'::text))::character varying))::character varying(50) AS comune_nascita_descr,
    ((COALESCE(sf.nome, ''::character varying))::text || COALESCE((' '::text || (sf.cognome)::text), ''::text)) AS nome_completo,
    vi.indirizzo_completo
   FROM ((((cu_his.soggetti_fisici sf
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = sf.his_id_transazione)))
     LEFT JOIN cu_anag.vw_indirizzi i ON ((i.id = sf.indirizzo_id)))
     LEFT JOIN conf_ext.vw_codici_vigenti_catastali c ON (((c.codcatastale)::text = (sf.comune_nascita)::text)))
     LEFT JOIN cu_his.vw_indirizzi vi ON (((vi.id = sf.indirizzo_id) AND (sf.his_validita && vi.his_validita))));


ALTER TABLE cu_his.vw_soggetti_fisici OWNER TO postgres;

--
-- Name: categorie_rischio; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.categorie_rischio (
    id bigint NOT NULL,
    codice character varying,
    sigla character varying,
    descrizione character varying
);


ALTER TABLE cu_types.categorie_rischio OWNER TO postgres;

--
-- Name: vw_categorie_rischio; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_categorie_rischio AS
 SELECT categorie_rischio.id AS id_categoria_rischio,
    categorie_rischio.id,
    categorie_rischio.codice,
    categorie_rischio.sigla,
    categorie_rischio.descrizione
   FROM cu_types.categorie_rischio;


ALTER TABLE cu_types.vw_categorie_rischio OWNER TO postgres;

--
-- Name: vw_stabilimenti; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_stabilimenti AS
 SELECT s.his_id,
    s.his_validita,
    s.his_id_transazione,
    s.his_ts,
    s.his_ts_transazione,
    s.id,
    s.id_impresa,
    s.nome,
    s.sd_id,
    s.id_indirizzo,
    s.cod_regionale,
    s.verificato,
    s.fonte,
    s.categoria_rischio,
    s.validita,
    s.cod_nazionale,
    s.id_tipologia_struttura,
    s.pec,
    s.telefono,
    s.sdi,
    lower(s.his_validita) AS inizio_validita_log,
    vt.nominativo,
    vcr.descrizione AS descr_categoria_rischio,
    vts.descrizione AS descr_tipologia_struttura,
    (to_char(lower(s.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vi.indirizzo_completo
   FROM ((((cu_his.stabilimenti s
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = s.his_id_transazione)))
     LEFT JOIN cu_types.vw_categorie_rischio vcr ON (((vcr.id_categoria_rischio)::numeric = s.categoria_rischio)))
     LEFT JOIN cu_types.vw_tipologie_struttura vts ON ((vts.id_tipologia_struttura = s.id_tipologia_struttura)))
     LEFT JOIN cu_his.vw_indirizzi vi ON (((vi.id = s.id_indirizzo) AND (s.his_validita && vi.his_validita))));


ALTER TABLE cu_his.vw_stabilimenti OWNER TO postgres;

--
-- Name: vw_stabilimento_figure; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_stabilimento_figure AS
 SELECT sf.his_id,
    sf.his_validita,
    sf.his_id_transazione,
    sf.his_ts,
    sf.his_ts_transazione,
    sf.id,
    sf.id_stabilimento,
    sf.id_soggetto,
    sf.id_tipo_figura,
    sf.id_indirizzo,
    sf.old_id,
    sf.fonte,
    sf.descr,
    sf.validita,
    lower(sf.his_validita) AS inizio_validita_log,
    vsfa.descr_tipo_figura,
    vsfa.nome_completo_figura,
    vsfa.cf_figura,
    vt.nominativo,
    (to_char(lower(sf.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vi.indirizzo_completo
   FROM (((cu_his.stabilimento_figure sf
     LEFT JOIN cu_anag.vw_stabilimento_figure_all vsfa ON ((vsfa.id_soggetto_fisico = sf.id_soggetto)))
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = sf.his_id_transazione)))
     LEFT JOIN cu_his.vw_indirizzi vi ON (((vi.id = sf.id_indirizzo) AND (sf.his_validita && vi.his_validita))));


ALTER TABLE cu_his.vw_stabilimento_figure OWNER TO postgres;

--
-- Name: vw_stabilimento_sedi; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_stabilimento_sedi AS
 SELECT ss.his_id,
    ss.his_validita,
    ss.his_id_transazione,
    ss.his_ts,
    ss.his_ts_transazione,
    ss.id,
    ss.id_stabilimento,
    ss.id_tipo_sede,
    ss.id_indirizzo,
    ss.pec,
    ss.email,
    ss.old_id,
    ss.fonte,
    ss.validita,
    lower(ss.his_validita) AS inizio_validita_log,
    vts.descr,
    vt.nominativo,
    (to_char(lower(ss.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vi.indirizzo_completo
   FROM (((cu_his.stabilimento_sedi ss
     JOIN cu_types.vw_tipi_sede vts ON ((vts.id_tipo_sede = ss.id_tipo_sede)))
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = ss.his_id_transazione)))
     LEFT JOIN cu_his.vw_indirizzi vi ON (((vi.id = ss.id_indirizzo) AND (ss.his_validita && vi.his_validita))));


ALTER TABLE cu_his.vw_stabilimento_sedi OWNER TO postgres;

--
-- Name: vw_storico_pratiche; Type: VIEW; Schema: cu_his; Owner: postgres
--

CREATE VIEW cu_his.vw_storico_pratiche AS
 SELECT sp.his_id,
    sp.his_validita,
    sp.his_id_transazione,
    sp.his_ts,
    sp.his_ts_transazione,
    sp.id,
    sp.id_pratica,
    sp.id_stato_pratica,
    sp.dt,
    sp.user_id,
    lower(sp.his_validita) AS inizio_validita_log,
    (to_char(lower(sp.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    vt.nominativo,
    vsp.descr_stato_pratica,
    vsp.nominativo AS nominativo_pratica
   FROM ((cu_his.storico_pratiche sp
     LEFT JOIN cu_log.vw_transazioni vt ON ((vt.id_transazione = sp.his_id_transazione)))
     LEFT JOIN cu_anag.vw_storico_pratiche vsp ON ((vsp.id = sp.id)));


ALTER TABLE cu_his.vw_storico_pratiche OWNER TO postgres;

--
-- Name: call_logs; Type: TABLE; Schema: cu_log; Owner: postgres
--

CREATE TABLE cu_log.call_logs (
    id bigint NOT NULL,
    id_transazione bigint,
    procedura character varying,
    fase character varying,
    ts timestamp without time zone,
    val character varying
);


ALTER TABLE cu_log.call_logs OWNER TO postgres;

--
-- Name: call_logs_id_seq; Type: SEQUENCE; Schema: cu_log; Owner: postgres
--

CREATE SEQUENCE cu_log.call_logs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_log.call_logs_id_seq OWNER TO postgres;

--
-- Name: call_logs_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_log; Owner: postgres
--

ALTER SEQUENCE cu_log.call_logs_id_seq OWNED BY cu_log.call_logs.id;


--
-- Name: his_id_seq; Type: SEQUENCE; Schema: cu_log; Owner: postgres
--

CREATE SEQUENCE cu_log.his_id_seq
    START WITH 1000000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_log.his_id_seq OWNER TO postgres;

--
-- Name: operazioni; Type: TABLE; Schema: cu_log; Owner: postgres
--

CREATE TABLE cu_log.operazioni (
    id bigint NOT NULL,
    id_transazione bigint,
    procedura character varying,
    fase character varying,
    ts_start timestamp without time zone,
    ts_transazione timestamp without time zone,
    val character varying,
    ts_end timestamp without time zone,
    ret character varying,
    id_trattato bigint,
    identificativo character varying
);


ALTER TABLE cu_log.operazioni OWNER TO postgres;

--
-- Name: operazioni_id_seq; Type: SEQUENCE; Schema: cu_log; Owner: postgres
--

CREATE SEQUENCE cu_log.operazioni_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_log.operazioni_id_seq OWNER TO postgres;

--
-- Name: operazioni_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_log; Owner: postgres
--

ALTER SEQUENCE cu_log.operazioni_id_seq OWNED BY cu_log.operazioni.id;


--
-- Name: transazioni_id_seq; Type: SEQUENCE; Schema: cu_log; Owner: postgres
--

CREATE SEQUENCE cu_log.transazioni_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_log.transazioni_id_seq OWNER TO postgres;

--
-- Name: transazioni_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_log; Owner: postgres
--

ALTER SEQUENCE cu_log.transazioni_id_seq OWNED BY cu_log.transazioni.id;


--
-- Name: cu_classe_evidenze_id_seq; Type: SEQUENCE; Schema: cu_types; Owner: postgres
--

CREATE SEQUENCE cu_types.cu_classe_evidenze_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_types.cu_classe_evidenze_id_seq OWNER TO postgres;

--
-- Name: cu_classe_evidenze_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_types; Owner: postgres
--

ALTER SEQUENCE cu_types.cu_classe_evidenze_id_seq OWNED BY cu_types.cu_classe_evidenze.id;


--
-- Name: cu_grado_evidenze_id_seq; Type: SEQUENCE; Schema: cu_types; Owner: postgres
--

CREATE SEQUENCE cu_types.cu_grado_evidenze_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_types.cu_grado_evidenze_id_seq OWNER TO postgres;

--
-- Name: cu_grado_evidenze_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_types; Owner: postgres
--

ALTER SEQUENCE cu_types.cu_grado_evidenze_id_seq OWNED BY cu_types.cu_grado_evidenze.id;


--
-- Name: cu_stati_cl_id_seq; Type: SEQUENCE; Schema: cu_types; Owner: postgres
--

CREATE SEQUENCE cu_types.cu_stati_cl_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_types.cu_stati_cl_id_seq OWNER TO postgres;

--
-- Name: cu_stati_cl_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_types; Owner: postgres
--

ALTER SEQUENCE cu_types.cu_stati_cl_id_seq OWNED BY cu_types.cu_stati_cl.id;


--
-- Name: cu_stati_cu_id_seq; Type: SEQUENCE; Schema: cu_types; Owner: postgres
--

CREATE SEQUENCE cu_types.cu_stati_cu_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_types.cu_stati_cu_id_seq OWNER TO postgres;

--
-- Name: cu_stati_cu_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_types; Owner: postgres
--

ALTER SEQUENCE cu_types.cu_stati_cu_id_seq OWNED BY cu_types.cu_stati_cu.id;


--
-- Name: cu_stati_oggetto_id_seq; Type: SEQUENCE; Schema: cu_types; Owner: postgres
--

CREATE SEQUENCE cu_types.cu_stati_oggetto_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_types.cu_stati_oggetto_id_seq OWNER TO postgres;

--
-- Name: cu_stati_oggetto_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_types; Owner: postgres
--

ALTER SEQUENCE cu_types.cu_stati_oggetto_id_seq OWNED BY cu_types.cu_stati_oggetto.id;


--
-- Name: cu_tipi_provv_id_seq; Type: SEQUENCE; Schema: cu_types; Owner: postgres
--

CREATE SEQUENCE cu_types.cu_tipi_provv_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_types.cu_tipi_provv_id_seq OWNER TO postgres;

--
-- Name: cu_tipi_provv_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_types; Owner: postgres
--

ALTER SEQUENCE cu_types.cu_tipi_provv_id_seq OWNED BY cu_types.cu_tipi_provv.id;


--
-- Name: cu_tipo_nucleo_id_seq; Type: SEQUENCE; Schema: cu_types; Owner: postgres
--

CREATE SEQUENCE cu_types.cu_tipo_nucleo_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_types.cu_tipo_nucleo_id_seq OWNER TO postgres;

--
-- Name: cu_tipo_nucleo_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_types; Owner: postgres
--

ALTER SEQUENCE cu_types.cu_tipo_nucleo_id_seq OWNED BY cu_types.cu_tipo_nucleo.id;


--
-- Name: cu_tipo_oggetti_evidenze; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.cu_tipo_oggetti_evidenze (
    id bigint,
    id_oggetto bigint,
    id_classe_evidenza bigint
);


ALTER TABLE cu_types.cu_tipo_oggetti_evidenze OWNER TO postgres;

--
-- Name: cu_tipo_oggetti_evidenze_id_seq; Type: SEQUENCE; Schema: cu_types; Owner: postgres
--

CREATE SEQUENCE cu_types.cu_tipo_oggetti_evidenze_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_types.cu_tipo_oggetti_evidenze_id_seq OWNER TO postgres;

--
-- Name: cu_tipo_oggetti_provvedimenti; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.cu_tipo_oggetti_provvedimenti (
    id bigint,
    id_oggetto bigint,
    id_tipo_provvedimento bigint
);


ALTER TABLE cu_types.cu_tipo_oggetti_provvedimenti OWNER TO postgres;

--
-- Name: cu_tipo_oggetti_provvedimenti_id_seq; Type: SEQUENCE; Schema: cu_types; Owner: postgres
--

CREATE SEQUENCE cu_types.cu_tipo_oggetti_provvedimenti_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_types.cu_tipo_oggetti_provvedimenti_id_seq OWNER TO postgres;

--
-- Name: stati_pratiche_id_seq; Type: SEQUENCE; Schema: cu_types; Owner: postgres
--

CREATE SEQUENCE cu_types.stati_pratiche_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_types.stati_pratiche_id_seq OWNER TO postgres;

--
-- Name: stati_pratiche_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_types; Owner: postgres
--

ALTER SEQUENCE cu_types.stati_pratiche_id_seq OWNED BY cu_types.stati_pratiche.id;


--
-- Name: strutture_asl; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.strutture_asl (
    id integer,
    cod integer,
    sigla character varying,
    descrizione character varying,
    "descrizione breve" character varying
);


ALTER TABLE cu_types.strutture_asl OWNER TO postgres;

--
-- Name: tipi_figura_id_seq; Type: SEQUENCE; Schema: cu_types; Owner: postgres
--

CREATE SEQUENCE cu_types.tipi_figura_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_types.tipi_figura_id_seq OWNER TO postgres;

--
-- Name: tipi_figura_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_types; Owner: postgres
--

ALTER SEQUENCE cu_types.tipi_figura_id_seq OWNED BY cu_types.tipi_figura.id;


--
-- Name: tipi_pratiche_id_seq; Type: SEQUENCE; Schema: cu_types; Owner: postgres
--

CREATE SEQUENCE cu_types.tipi_pratiche_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_types.tipi_pratiche_id_seq OWNER TO postgres;

--
-- Name: tipi_pratiche_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_types; Owner: postgres
--

ALTER SEQUENCE cu_types.tipi_pratiche_id_seq OWNED BY cu_types.tipi_pratiche.id;


--
-- Name: tipi_sede_id_seq; Type: SEQUENCE; Schema: cu_types; Owner: postgres
--

CREATE SEQUENCE cu_types.tipi_sede_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_types.tipi_sede_id_seq OWNER TO postgres;

--
-- Name: tipi_sede_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_types; Owner: postgres
--

ALTER SEQUENCE cu_types.tipi_sede_id_seq OWNED BY cu_types.tipi_sede.id;


--
-- Name: tipo_import_anagrafica; Type: TABLE; Schema: cu_types; Owner: postgres
--

CREATE TABLE cu_types.tipo_import_anagrafica (
    id bigint NOT NULL,
    cod character varying
);


ALTER TABLE cu_types.tipo_import_anagrafica OWNER TO postgres;

--
-- Name: tipo_import_anagrafica_id_seq; Type: SEQUENCE; Schema: cu_types; Owner: postgres
--

CREATE SEQUENCE cu_types.tipo_import_anagrafica_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_types.tipo_import_anagrafica_id_seq OWNER TO postgres;

--
-- Name: tipo_import_anagrafica_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_types; Owner: postgres
--

ALTER SEQUENCE cu_types.tipo_import_anagrafica_id_seq OWNED BY cu_types.tipo_import_anagrafica.id;


--
-- Name: vw_cu_stati_oggetto; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_cu_stati_oggetto AS
 SELECT cu_stati_oggetto.id AS id_stato_oggetto,
    cu_stati_oggetto.id,
    cu_stati_oggetto.sigla,
    cu_stati_oggetto.descr,
    cu_stati_oggetto.cod,
    cu_stati_oggetto.ord,
    cu_stati_oggetto.evidenze,
    cu_stati_oggetto.tooltip
   FROM cu_types.cu_stati_oggetto;


ALTER TABLE cu_types.vw_cu_stati_oggetto OWNER TO postgres;

--
-- Name: vw_tipo_import_anagrafica; Type: VIEW; Schema: cu_types; Owner: postgres
--

CREATE VIEW cu_types.vw_tipo_import_anagrafica AS
 SELECT v.id,
    v.cod,
    t.descrizione AS descr
   FROM (cu_types.tipo_import_anagrafica v
     JOIN cu_types.tipologie_struttura t ON (((v.cod)::text = (t.codice)::text)));


ALTER TABLE cu_types.vw_tipo_import_anagrafica OWNER TO postgres;

--
-- Name: form_definition; Type: TABLE; Schema: cu_ui; Owner: postgres
--

CREATE TABLE cu_ui.form_definition (
    id bigint NOT NULL,
    funct character varying NOT NULL,
    id_user bigint,
    type_user character varying,
    str_conf character varying,
    note character varying,
    sigla character varying
);


ALTER TABLE cu_ui.form_definition OWNER TO postgres;

--
-- Name: form_definition_detail; Type: TABLE; Schema: cu_ui; Owner: postgres
--

CREATE TABLE cu_ui.form_definition_detail (
    id bigint NOT NULL,
    id_form_definition bigint NOT NULL,
    str_conf character varying,
    note character varying,
    ord integer DEFAULT 1 NOT NULL
);


ALTER TABLE cu_ui.form_definition_detail OWNER TO postgres;

--
-- Name: form_definition_id_seq; Type: SEQUENCE; Schema: cu_ui; Owner: postgres
--

CREATE SEQUENCE cu_ui.form_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_ui.form_definition_id_seq OWNER TO postgres;

--
-- Name: form_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_ui; Owner: postgres
--

ALTER SEQUENCE cu_ui.form_definition_id_seq OWNED BY cu_ui.form_definition.id;


--
-- Name: form_defintion_detail_id_seq; Type: SEQUENCE; Schema: cu_ui; Owner: postgres
--

CREATE SEQUENCE cu_ui.form_defintion_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_ui.form_defintion_detail_id_seq OWNER TO postgres;

--
-- Name: form_defintion_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_ui; Owner: postgres
--

ALTER SEQUENCE cu_ui.form_defintion_detail_id_seq OWNED BY cu_ui.form_definition_detail.id;


--
-- Name: grid_definition; Type: TABLE; Schema: cu_ui; Owner: postgres
--

CREATE TABLE cu_ui.grid_definition (
    id bigint NOT NULL,
    funct character varying,
    id_user bigint,
    type_user character varying,
    str_conf character varying,
    note character varying
);


ALTER TABLE cu_ui.grid_definition OWNER TO postgres;

--
-- Name: grid_definition_id_seq; Type: SEQUENCE; Schema: cu_ui; Owner: postgres
--

CREATE SEQUENCE cu_ui.grid_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_ui.grid_definition_id_seq OWNER TO postgres;

--
-- Name: grid_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_ui; Owner: postgres
--

ALTER SEQUENCE cu_ui.grid_definition_id_seq OWNED BY cu_ui.grid_definition.id;


--
-- Name: menu; Type: TABLE; Schema: cu_ui; Owner: postgres
--

CREATE TABLE cu_ui.menu (
    id integer NOT NULL,
    cod character varying
);


ALTER TABLE cu_ui.menu OWNER TO postgres;

--
-- Name: menu_id_seq; Type: SEQUENCE; Schema: cu_ui; Owner: postgres
--

CREATE SEQUENCE cu_ui.menu_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_ui.menu_id_seq OWNER TO postgres;

--
-- Name: menu_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_ui; Owner: postgres
--

ALTER SEQUENCE cu_ui.menu_id_seq OWNED BY cu_ui.menu.id;


--
-- Name: menu_item_modes; Type: TABLE; Schema: cu_ui; Owner: postgres
--

CREATE TABLE cu_ui.menu_item_modes (
    id integer NOT NULL,
    id_menu_item integer,
    lev integer,
    modality character varying,
    lev_range numrange DEFAULT '(,)'::numrange NOT NULL,
    id_asl numeric,
    id_ruolo bigint
);


ALTER TABLE cu_ui.menu_item_modes OWNER TO postgres;

--
-- Name: menu_item_modes_id_seq; Type: SEQUENCE; Schema: cu_ui; Owner: postgres
--

CREATE SEQUENCE cu_ui.menu_item_modes_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_ui.menu_item_modes_id_seq OWNER TO postgres;

--
-- Name: menu_item_modes_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_ui; Owner: postgres
--

ALTER SEQUENCE cu_ui.menu_item_modes_id_seq OWNED BY cu_ui.menu_item_modes.id;


--
-- Name: menu_items; Type: TABLE; Schema: cu_ui; Owner: postgres
--

CREATE TABLE cu_ui.menu_items (
    id integer NOT NULL,
    id_menu integer NOT NULL,
    descr character varying,
    cod character varying,
    ord integer,
    icon character varying
);


ALTER TABLE cu_ui.menu_items OWNER TO postgres;

--
-- Name: menu_items_id_seq; Type: SEQUENCE; Schema: cu_ui; Owner: postgres
--

CREATE SEQUENCE cu_ui.menu_items_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_ui.menu_items_id_seq OWNER TO postgres;

--
-- Name: menu_items_id_seq; Type: SEQUENCE OWNED BY; Schema: cu_ui; Owner: postgres
--

ALTER SEQUENCE cu_ui.menu_items_id_seq OWNED BY cu_ui.menu_items.id;


--
-- Name: messaggi_ui; Type: TABLE; Schema: cu_ui; Owner: postgres
--

CREATE TABLE cu_ui.messaggi_ui (
    id bigint NOT NULL,
    procedura character varying,
    valore character varying,
    msg character varying
);


ALTER TABLE cu_ui.messaggi_ui OWNER TO postgres;

--
-- Name: messaggi_ui_id_seq; Type: SEQUENCE; Schema: cu_ui; Owner: postgres
--

CREATE SEQUENCE cu_ui.messaggi_ui_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cu_ui.messaggi_ui_id_seq OWNER TO postgres;

--
-- Name: vw_form_definition; Type: VIEW; Schema: cu_ui; Owner: postgres
--

CREATE VIEW cu_ui.vw_form_definition AS
 SELECT form_definition.id AS id_form_definition,
    form_definition.id,
    form_definition.funct,
    form_definition.id_user,
    form_definition.type_user,
    form_definition.str_conf,
    form_definition.note,
    form_definition.sigla
   FROM cu_ui.form_definition;


ALTER TABLE cu_ui.vw_form_definition OWNER TO postgres;

--
-- Name: vw_form_definition_detail; Type: VIEW; Schema: cu_ui; Owner: postgres
--

CREATE VIEW cu_ui.vw_form_definition_detail AS
 SELECT fdd.id AS id_form_definition_detail,
    fdd.id,
    fdd.id_form_definition,
    fdd.str_conf,
    fdd.note,
    fdd.ord,
    fd.funct,
    fd.id_user,
    fd.type_user,
    fd.sigla
   FROM (cu_ui.vw_form_definition fd
     LEFT JOIN cu_ui.form_definition_detail fdd ON ((fdd.id_form_definition = fd.id_form_definition)));


ALTER TABLE cu_ui.vw_form_definition_detail OWNER TO postgres;

--
-- Name: pdf; Type: TABLE; Schema: documenti; Owner: postgres
--

CREATE TABLE documenti.pdf (
    id bigint NOT NULL,
    id_modulo bigint NOT NULL,
    descr_modulo character varying NOT NULL,
    filename character varying,
    data bytea,
    validita tsrange DEFAULT tsrange((CURRENT_TIMESTAMP)::timestamp without time zone, NULL::timestamp without time zone, '()'::text)
);


ALTER TABLE documenti.pdf OWNER TO postgres;

--
-- Name: pdf_id_seq; Type: SEQUENCE; Schema: documenti; Owner: postgres
--

CREATE SEQUENCE documenti.pdf_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE documenti.pdf_id_seq OWNER TO postgres;

--
-- Name: pdf_id_seq; Type: SEQUENCE OWNED BY; Schema: documenti; Owner: postgres
--

ALTER SEQUENCE documenti.pdf_id_seq OWNED BY documenti.pdf.id;


--
-- Name: vw_pdf; Type: VIEW; Schema: documenti; Owner: postgres
--

CREATE VIEW documenti.vw_pdf AS
 SELECT pdf.id AS id_pdf,
    pdf.id AS id_modulo,
    pdf.descr_modulo,
    pdf.filename
   FROM documenti.pdf;


ALTER TABLE documenti.vw_pdf OWNER TO postgres;

--
-- Name: aree; Type: TABLE; Schema: log; Owner: postgres
--

CREATE TABLE log.aree (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    schema character varying NOT NULL
);


ALTER TABLE log.aree OWNER TO postgres;

--
-- Name: area_id_seq; Type: SEQUENCE; Schema: log; Owner: postgres
--

CREATE SEQUENCE log.area_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE log.area_id_seq OWNER TO postgres;

--
-- Name: area_id_seq; Type: SEQUENCE OWNED BY; Schema: log; Owner: postgres
--

ALTER SEQUENCE log.area_id_seq OWNED BY log.aree.id;


--
-- Name: funzioni; Type: TABLE; Schema: log; Owner: postgres
--

CREATE TABLE log.funzioni (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    id_area bigint NOT NULL,
    tipo character varying,
    vista character varying,
    identificativo character varying
);


ALTER TABLE log.funzioni OWNER TO postgres;

--
-- Name: funzioni_id_seq; Type: SEQUENCE; Schema: log; Owner: postgres
--

CREATE SEQUENCE log.funzioni_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE log.funzioni_id_seq OWNER TO postgres;

--
-- Name: funzioni_id_seq; Type: SEQUENCE OWNED BY; Schema: log; Owner: postgres
--

ALTER SEQUENCE log.funzioni_id_seq OWNED BY log.funzioni.id;


--
-- Name: funzioni_id_seq1; Type: SEQUENCE; Schema: log; Owner: postgres
--

CREATE SEQUENCE log.funzioni_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE log.funzioni_id_seq1 OWNER TO postgres;

--
-- Name: funzioni_id_seq1; Type: SEQUENCE OWNED BY; Schema: log; Owner: postgres
--

ALTER SEQUENCE log.funzioni_id_seq1 OWNED BY log.funzioni.id;


--
-- Name: funzioni_id_seq2; Type: SEQUENCE; Schema: log; Owner: postgres
--

CREATE SEQUENCE log.funzioni_id_seq2
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE log.funzioni_id_seq2 OWNER TO postgres;

--
-- Name: funzioni_id_seq2; Type: SEQUENCE OWNED BY; Schema: log; Owner: postgres
--

ALTER SEQUENCE log.funzioni_id_seq2 OWNED BY log.funzioni.id;


--
-- Name: log_id_seq; Type: SEQUENCE; Schema: log; Owner: postgres
--

CREATE SEQUENCE log.log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE log.log_id_seq OWNER TO postgres;

--
-- Name: vw_aree; Type: VIEW; Schema: log; Owner: postgres
--

CREATE VIEW log.vw_aree AS
 SELECT aree.id AS id_area,
    aree.id,
    aree.cod,
    aree.sigla,
    aree.descr,
    aree.schema
   FROM log.aree;


ALTER TABLE log.vw_aree OWNER TO postgres;

--
-- Name: vw_funzioni; Type: VIEW; Schema: log; Owner: postgres
--

CREATE VIEW log.vw_funzioni AS
 SELECT f.id AS id_funzione,
    f.id,
    f.cod,
    f.sigla,
    f.descr,
    f.id_area,
    a.cod AS cod_area,
    a.sigla AS sigla_area,
    a.descr AS descr_area,
    f.tipo,
    f.vista,
    f.identificativo
   FROM (log.funzioni f
     JOIN log.vw_aree a ON ((a.id_area = f.id_area)))
  WHERE (f.tipo IS NOT NULL);


ALTER TABLE log.vw_funzioni OWNER TO postgres;

--
-- Name: vw_ag_operazioni; Type: VIEW; Schema: log; Owner: postgres
--

CREATE VIEW log.vw_ag_operazioni AS
 SELECT DISTINCT ON (t.id) u.cf,
    t.id AS id_transazione,
        CASE
            WHEN ((f.tipo)::text = 'U'::text) THEN 'Modifica'::character varying
            ELSE 'Lettura'::character varying
        END AS tipo,
    f.descr,
    t.ts,
    f.id_funzione,
    f.vista,
    (to_char(t.ts, 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log,
    COALESCE(NULLIF(TRIM(TRAILING ','::text FROM "substring"((o.ret)::text, (strpos((o.ret)::text, '"esito":'::text) + 8), (strpos(SUBSTRING(o.ret FROM strpos((o.ret)::text, '"esito":'::text)), ','::text) - 8))), ''::text), 'true'::text) AS esito,
    f.cod_area,
    f.identificativo,
    (COALESCE(((u.nome)::text || ' '::text), ''::text) || (u.cognome)::text) AS nominativo
   FROM (((ag_log.operazioni o
     JOIN ag_log.transazioni t ON ((t.id = o.id_transazione)))
     JOIN log.vw_funzioni f ON (((o.fase)::text = (f.cod)::text)))
     JOIN rbac.vw_utente_strutture_ruoli u ON ((t.id_user = u.id_utente_struttura_ruolo)))
  WHERE (f.tipo IS NOT NULL)
  ORDER BY t.id DESC;


ALTER TABLE log.vw_ag_operazioni OWNER TO postgres;

--
-- Name: vw_cu_operazioni; Type: VIEW; Schema: log; Owner: postgres
--

CREATE VIEW log.vw_cu_operazioni AS
 SELECT DISTINCT ON (t.id) u.cf,
    t.id AS id_transazione,
        CASE
            WHEN ((f.tipo)::text = 'U'::text) THEN 'Modifica'::character varying
            WHEN ((f.tipo)::text = 'R'::text) THEN 'Lettura'::character varying
            ELSE NULL::character varying
        END AS tipo,
    f.descr,
    t.ts,
    f.id_funzione,
    f.vista,
    (to_char(t.ts, 'HH24:MI:SS'::text))::time without time zone AS ora,
    COALESCE(NULLIF(TRIM(TRAILING ','::text FROM "substring"((o.ret)::text, (strpos((o.ret)::text, '"esito":'::text) + 8), (strpos(SUBSTRING(o.ret FROM strpos((o.ret)::text, '"esito":'::text)), ','::text) - 8))), ''::text), 'true'::text) AS esito,
    f.cod_area,
    f.identificativo,
    o.val,
    (COALESCE(((u.nome)::text || ' '::text), ''::text) || (u.cognome)::text) AS nominativo
   FROM (((cu_log.operazioni o
     JOIN cu_log.transazioni t ON ((t.id = o.id_transazione)))
     JOIN log.vw_funzioni f ON (((o.fase)::text = (f.cod)::text)))
     JOIN rbac.vw_utente_strutture_ruoli u ON ((t.id_user = u.id_utente_struttura_ruolo)))
  WHERE (f.tipo IS NOT NULL)
  ORDER BY t.id DESC;


ALTER TABLE log.vw_cu_operazioni OWNER TO postgres;

--
-- Name: operazioni; Type: TABLE; Schema: rbac_log; Owner: postgres
--

CREATE TABLE rbac_log.operazioni (
    id bigint NOT NULL,
    id_transazione bigint,
    procedura character varying,
    fase character varying,
    ts_start timestamp without time zone,
    ts_transazione timestamp without time zone,
    val character varying,
    ts_end timestamp without time zone,
    ret character varying,
    id_trattato bigint
);


ALTER TABLE rbac_log.operazioni OWNER TO postgres;

--
-- Name: transazioni; Type: TABLE; Schema: rbac_log; Owner: postgres
--

CREATE TABLE rbac_log.transazioni (
    id bigint NOT NULL,
    id_user bigint NOT NULL,
    ts timestamp without time zone NOT NULL,
    descr character varying
);


ALTER TABLE rbac_log.transazioni OWNER TO postgres;

--
-- Name: vw_rbac_operazioni; Type: VIEW; Schema: log; Owner: postgres
--

CREATE VIEW log.vw_rbac_operazioni AS
 SELECT DISTINCT ON (t.id) u.cf,
    t.id AS id_transazione,
        CASE
            WHEN ((f.tipo)::text = 'U'::text) THEN 'Modifica'::character varying
            ELSE 'Lettura'::character varying
        END AS tipo,
    f.descr,
    t.ts,
    f.id_funzione,
    f.vista,
    (to_char(t.ts, 'HH24:MI:SS'::text))::time without time zone AS ora,
    COALESCE(NULLIF(TRIM(TRAILING ','::text FROM "substring"((o.ret)::text, (strpos((o.ret)::text, '"esito":'::text) + 8), (strpos(SUBSTRING(o.ret FROM strpos((o.ret)::text, '"esito":'::text)), ','::text) - 8))), ''::text), 'true'::text) AS esito,
    f.cod_area,
    f.identificativo,
    (COALESCE(((u.nome)::text || ' '::text), ''::text) || (u.cognome)::text) AS nominativo
   FROM (((rbac_log.operazioni o
     JOIN rbac_log.transazioni t ON ((t.id = o.id_transazione)))
     JOIN log.vw_funzioni f ON (((o.fase)::text = (f.cod)::text)))
     JOIN rbac.vw_utente_strutture_ruoli u ON ((t.id_user = u.id_utente_struttura_ruolo)))
  WHERE (f.tipo IS NOT NULL)
  ORDER BY t.id DESC;


ALTER TABLE log.vw_rbac_operazioni OWNER TO postgres;

--
-- Name: vw_operazioni; Type: VIEW; Schema: log; Owner: postgres
--

CREATE VIEW log.vw_operazioni AS
 SELECT vw_ag_operazioni.cf,
    vw_ag_operazioni.id_transazione,
    vw_ag_operazioni.tipo,
    vw_ag_operazioni.descr,
    vw_ag_operazioni.ts,
    vw_ag_operazioni.id_funzione,
    vw_ag_operazioni.vista,
    vw_ag_operazioni.ora_inizio_validita_log,
    vw_ag_operazioni.esito,
    vw_ag_operazioni.cod_area,
    vw_ag_operazioni.identificativo,
    vw_ag_operazioni.nominativo
   FROM log.vw_ag_operazioni
UNION
 SELECT vw_cu_operazioni.cf,
    vw_cu_operazioni.id_transazione,
    vw_cu_operazioni.tipo,
    vw_cu_operazioni.descr,
    vw_cu_operazioni.ts,
    vw_cu_operazioni.id_funzione,
    vw_cu_operazioni.vista,
    vw_cu_operazioni.ora AS ora_inizio_validita_log,
    vw_cu_operazioni.esito,
    vw_cu_operazioni.cod_area,
    vw_cu_operazioni.identificativo,
    vw_cu_operazioni.nominativo
   FROM log.vw_cu_operazioni
UNION
 SELECT vw_rbac_operazioni.cf,
    vw_rbac_operazioni.id_transazione,
    vw_rbac_operazioni.tipo,
    vw_rbac_operazioni.descr,
    vw_rbac_operazioni.ts,
    vw_rbac_operazioni.id_funzione,
    vw_rbac_operazioni.vista,
    vw_rbac_operazioni.ora AS ora_inizio_validita_log,
    vw_rbac_operazioni.esito,
    vw_rbac_operazioni.cod_area,
    vw_rbac_operazioni.identificativo,
    vw_rbac_operazioni.nominativo
   FROM log.vw_rbac_operazioni;


ALTER TABLE log.vw_operazioni OWNER TO postgres;

--
-- Name: a13; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.a13 (
    alias character varying(32767),
    descr character varying(32767),
    avellino character varying(32767),
    benevento character varying(32767),
    caserta character varying(32767),
    na1 character varying(32767),
    na2 character varying(32767),
    na3 character varying(32767),
    salerno character varying(32767),
    totale character varying(32767)
);


ALTER TABLE matrix.a13 OWNER TO postgres;

--
-- Name: a14; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.a14 (
    alias character varying(32767),
    descr character varying(32767),
    liv character varying(32767),
    avellino character varying(32767),
    benevento character varying(32767),
    caserta character varying(32767),
    na1 character varying(32767),
    na2 character varying(32767),
    na3 character varying(32767),
    sa character varying(32767)
);


ALTER TABLE matrix.a14 OWNER TO postgres;

--
-- Name: ag_types; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.ag_types (
    nextval bigint,
    att character varying,
    sez character varying
);


ALTER TABLE matrix.ag_types OWNER TO postgres;

--
-- Name: anagrafica; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.anagrafica (
    id_anagrafica bigint,
    nominativo text,
    codice_fiscale text,
    qualifica text
);


ALTER TABLE matrix.anagrafica OWNER TO postgres;

--
-- Name: app_formule; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.app_formule (
    id bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    parent bigint,
    alias text,
    path_ord text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    fattore_ups double precision,
    fattore_uba double precision,
    descrizione_breve character varying
);


ALTER TABLE matrix.app_formule OWNER TO postgres;

--
-- Name: avvisi; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.avvisi (
    testo text,
    sistema text
);


ALTER TABLE matrix.avvisi OWNER TO postgres;

--
-- Name: borsellino_log; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.borsellino_log (
    ups real,
    uba real,
    id_struttura bigint,
    dat timestamp without time zone
);


ALTER TABLE matrix.borsellino_log OWNER TO postgres;

--
-- Name: comuni; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.comuni (
    id integer,
    cod_comune text,
    cod_regione text,
    cod_provincia text,
    nome text,
    istat text,
    codiceistatasl text,
    codice text,
    codice_old text,
    codiceistatasl_old text,
    cap text,
    notused boolean,
    cod_nazione integer,
    codiceasl_bdn text,
    codice_nuovo text,
    codice_nuovo_ text,
    istat_comune_provincia text,
    cap_ text,
    istat_pre text,
    note_hd text,
    reverse_cap text,
    codice_catastale text,
    denominazione_it character varying
);


ALTER TABLE matrix.comuni OWNER TO postgres;

--
-- Name: comuni_gisa; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.comuni_gisa (
    id bigint,
    cod_comune character varying,
    cod_regione character varying,
    cod_provincia character varying,
    nome character varying,
    istat character varying,
    codiceistatasl character varying,
    codice character varying,
    codice_old character varying,
    codiceistatasl_old character varying,
    cap character varying,
    notused character varying,
    cod_nazione character varying,
    codiceasl_bdn character varying,
    codice_nuovo character varying,
    codice_nuovo_ character varying,
    istat_comune_provincia character varying,
    cap_ character varying,
    istat_pre character varying,
    note_hd character varying,
    reverse_cap character varying,
    codice_catastale character varying
);


ALTER TABLE matrix.comuni_gisa OWNER TO postgres;

--
-- Name: dpar_2020; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.dpar_2020 (
    sezione character varying(32767),
    numerazione character varying(32767),
    obiettivo character varying(32767),
    sottopiano character varying(32767),
    note character varying(32767),
    avellino character varying(32767),
    benevento character varying(32767),
    caserta character varying(32767),
    napoli1 character varying(32767),
    napoli2 character varying(32767),
    napoli3 character varying(32767),
    salerno character varying(32767),
    id integer
);


ALTER TABLE matrix.dpar_2020 OWNER TO postgres;

--
-- Name: dpar_coll; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.dpar_coll (
    id_piano integer,
    id_struttura integer,
    target double precision,
    id_gisa_asl bigint,
    id_gisa_piano bigint
);


ALTER TABLE matrix.dpar_coll OWNER TO postgres;

--
-- Name: dpat_indicatore_new; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.dpat_indicatore_new (
    rng int8range,
    id integer,
    cod_raggruppamento integer,
    id_piano_attivita integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_esame text,
    codice_interno_indicatore integer,
    alias_indicatore text,
    codice_interno_piani_gestione_cu integer,
    codice_interno_attivita_gestione_cu text,
    codice_interno_univoco_tipo_attivita_gestione_cu text,
    codice_alias_indicatore text,
    extra_gisa boolean,
    flag_benessere boolean,
    entered timestamp without time zone,
    modified timestamp without time zone,
    entered_by integer,
    modified_by integer,
    note_hd text
);


ALTER TABLE matrix.dpat_indicatore_new OWNER TO postgres;

--
-- Name: dpat_indicatore_new_bakcup; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.dpat_indicatore_new_bakcup (
    id bigint,
    cod_raggruppamento bigint,
    id_piano_attivita integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_esame text,
    tipo_attivita text,
    codice_interno_indicatore integer,
    alias_indicatore text,
    codice_interno_piani_gestione_cu integer,
    codice_interno_attivita_gestione_cu text,
    codice_interno_univoco_tipo_attivita_gestione_cu text,
    codice_alias_indicatore text,
    extra_gisa boolean
);


ALTER TABLE matrix.dpat_indicatore_new_bakcup OWNER TO postgres;

--
-- Name: dpat_piano_attivita_new; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.dpat_piano_attivita_new (
    rng int8range,
    id integer,
    cod_raggruppamento integer,
    id_sezione integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_esame text,
    tipo_attivita text,
    codice_interno_piano integer,
    codice_interno_attivita integer,
    alias_piano text,
    alias_attivita text,
    codice_alias_attivita text,
    entered timestamp without time zone,
    modified timestamp without time zone,
    entered_by integer,
    modified_by integer,
    note_hd text
);


ALTER TABLE matrix.dpat_piano_attivita_new OWNER TO postgres;

--
-- Name: dpat_sez_new; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.dpat_sez_new (
    rng int8range,
    id integer,
    cod_raggruppamento integer,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying,
    entered timestamp without time zone,
    modified timestamp without time zone,
    entered_by integer,
    modified_by integer
);


ALTER TABLE matrix.dpat_sez_new OWNER TO postgres;

--
-- Name: formule_20221006; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.formule_20221006 (
    id bigint,
    descrizione text,
    testo text,
    contiene_uba boolean,
    valida_ups boolean,
    valida_uba boolean,
    fattore_fin double precision
);


ALTER TABLE matrix.formule_20221006 OWNER TO postgres;

--
-- Name: formule_backup; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.formule_backup (
    id bigint,
    descrizione text,
    testo text,
    contiene_uba boolean,
    valida_ups boolean,
    valida_uba boolean,
    fattore_fin double precision
);


ALTER TABLE matrix.formule_backup OWNER TO postgres;

--
-- Name: formule_h; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.formule_h (
    rng int8range,
    id bigint,
    descrizione text,
    testo text,
    contiene_uba boolean,
    valida_ups boolean,
    valida_uba boolean,
    fattore_fin double precision
);


ALTER TABLE matrix.formule_h OWNER TO postgres;

--
-- Name: get_info_masterlist_allev; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.get_info_masterlist_allev (
    specie character varying(16),
    tipologia_struttura character varying(64),
    orientamento_produttivo character varying(128),
    specie_allev character varying(4),
    tipologia_strutt character varying(16),
    orientamento_prod_esteso character varying(32),
    orientamento character varying(8)
);


ALTER TABLE matrix.get_info_masterlist_allev OWNER TO postgres;

--
-- Name: id_formule_temp; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.id_formule_temp (
    id_gisa bigint,
    id_formula_ups bigint,
    id_formula_uba bigint,
    anno integer
);


ALTER TABLE matrix.id_formule_temp OWNER TO postgres;

--
-- Name: import_xls; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.import_xls (
    nome_file text,
    nome_foglio text,
    rownum integer,
    carico_effettivo_uos_uba text,
    carico_effettivo_uos_ups text,
    carico_minimo_uba text,
    carico_minimo_uip text,
    carico_teorico_uba text,
    carico_teorico_uba_2 text,
    carico_teorico_uip text,
    carico_teorico_uip_2 text,
    carico_teorico_uip_3 text,
    carico_teorico_uos_uba text,
    carico_teorico_uos_ups text,
    carico_totale_uoc_uba text,
    carico_totale_uoc_ups text,
    cf text,
    fattori_esterni text,
    fattori_negativi text,
    fattori_personali text,
    iaoa text,
    iapz text,
    livelli_uba_ora text,
    livelli_uba_ora_2 text,
    livelli_uba_ora_3 text,
    livello_formativo text,
    nominativi text,
    perc_sottr text,
    perc_sottr_2 text,
    perc_sottr_3 text,
    qualifica text,
    sanita_animale text,
    sian text,
    struttura text,
    uoc text,
    uos text,
    uos_articolazioni text
);


ALTER TABLE matrix.import_xls OWNER TO postgres;

--
-- Name: import_xls_backup; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.import_xls_backup (
    nome_file text,
    nome_foglio text,
    rownum integer,
    carico_effettivo_uos_uba text,
    carico_effettivo_uos_ups text,
    carico_minimo_uba text,
    carico_minimo_uip text,
    carico_teorico_uba text,
    carico_teorico_uba_2 text,
    carico_teorico_uip text,
    carico_teorico_uip_2 text,
    carico_teorico_uip_3 text,
    carico_teorico_uos_uba text,
    carico_teorico_uos_ups text,
    carico_totale_uoc_uba text,
    carico_totale_uoc_ups text,
    cf text,
    fattori_esterni text,
    fattori_negativi text,
    fattori_personali text,
    iaoa text,
    iapz text,
    livelli_uba_ora text,
    livelli_uba_ora_2 text,
    livelli_uba_ora_3 text,
    livello_formativo text,
    nominativi text,
    perc_sottr text,
    perc_sottr_2 text,
    perc_sottr_3 text,
    qualifica text,
    sanita_animale text,
    sian text,
    struttura text,
    uoc text,
    uos text,
    uos_articolazioni text
);


ALTER TABLE matrix.import_xls_backup OWNER TO postgres;

--
-- Name: import_xls_backupnew; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.import_xls_backupnew (
    nome_file text,
    nome_foglio text,
    rownum integer,
    carico_effettivo_uos_uba text,
    carico_effettivo_uos_ups text,
    carico_minimo_uba text,
    carico_minimo_uip text,
    carico_teorico_uba text,
    carico_teorico_uba_2 text,
    carico_teorico_uip text,
    carico_teorico_uip_2 text,
    carico_teorico_uip_3 text,
    carico_teorico_uos_uba text,
    carico_teorico_uos_ups text,
    carico_totale_uoc_uba text,
    carico_totale_uoc_ups text,
    cf text,
    fattori_esterni text,
    fattori_negativi text,
    fattori_personali text,
    iaoa text,
    iapz text,
    livelli_uba_ora text,
    livelli_uba_ora_2 text,
    livelli_uba_ora_3 text,
    livello_formativo text,
    nominativi text,
    perc_sottr text,
    perc_sottr_2 text,
    perc_sottr_3 text,
    qualifica text,
    sanita_animale text,
    sian text,
    struttura text,
    uoc text,
    uos text,
    uos_articolazioni text
);


ALTER TABLE matrix.import_xls_backupnew OWNER TO postgres;

--
-- Name: import_xls_mod; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.import_xls_mod (
    nome_file text,
    nome_foglio text,
    rownum integer,
    carico_effettivo_uos_uba text,
    carico_effettivo_uos_ups text,
    carico_minimo_uba text,
    carico_minimo_uip text,
    carico_teorico_uba text,
    carico_teorico_uba_2 text,
    carico_teorico_uip text,
    carico_teorico_uip_2 text,
    carico_teorico_uip_3 text,
    carico_teorico_uos_uba text,
    carico_teorico_uos_ups text,
    carico_totale_uoc_uba text,
    carico_totale_uoc_ups text,
    cf text,
    fattori_esterni text,
    fattori_negativi text,
    fattori_personali text,
    iaoa text,
    iapz text,
    livelli_uba_ora text,
    livelli_uba_ora_2 text,
    livelli_uba_ora_3 text,
    livello_formativo text,
    nominativi text,
    perc_sottr text,
    perc_sottr_2 text,
    perc_sottr_3 text,
    qualifica text,
    sanita_animale text,
    sian text,
    struttura text,
    uoc text,
    uos text,
    uos_articolazioni text
);


ALTER TABLE matrix.import_xls_mod OWNER TO postgres;

--
-- Name: imprese; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.imprese (
    id bigint,
    riferimento_id_impresa integer,
    riferimento_nome_tab_impresa text,
    ragione_sociale text,
    codice_fiscale text,
    codice_fiscale_rappresentante text,
    partita_iva text,
    nominativo_rappresentante text,
    comune_leg text,
    provincia_leg text,
    indirizzo_leg text,
    cap_leg text,
    fatturazione_elettronica boolean,
    split_payment boolean,
    codice_sdi text,
    id_indirizzo_fatturazione integer,
    comune_fatturazione text,
    provincia_fatturazione text,
    indirizzo_fatturazione text,
    cap_fatturazione text
);


ALTER TABLE matrix.imprese OWNER TO postgres;

--
-- Name: lock_asl; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.lock_asl (
    asl bigint,
    is_locked boolean,
    anno integer
);


ALTER TABLE matrix.lock_asl OWNER TO postgres;

--
-- Name: lock_asl_log; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.lock_asl_log (
    asl bigint,
    is_locked boolean,
    utente text,
    dat timestamp without time zone
);


ALTER TABLE matrix.lock_asl_log OWNER TO postgres;

--
-- Name: lock_asl_mod4; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.lock_asl_mod4 (
    asl bigint,
    is_locked boolean,
    anno integer
);


ALTER TABLE matrix.lock_asl_mod4 OWNER TO postgres;

--
-- Name: ml_allev; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.ml_allev (
    specie character varying,
    tipologia_struttura character varying,
    orientamento_produttivo character varying,
    specie_allev character varying,
    tipologia_strutt character varying,
    orientamento_prod_esteso character varying,
    orientamento character varying
);


ALTER TABLE matrix.ml_allev OWNER TO postgres;

--
-- Name: mod4_fattori; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.mod4_fattori (
    id integer NOT NULL,
    descr text,
    max_perc integer,
    enabled boolean DEFAULT true,
    note text,
    numero numeric,
    ricalcolo_cf boolean,
    mostra_altre_uos boolean,
    univoco_asl boolean,
    solo_tpal boolean,
    limite_uoc numeric,
    limite_asl numeric,
    numero_incompatibile character varying
);


ALTER TABLE matrix.mod4_fattori OWNER TO postgres;

--
-- Name: mod4_fattori_id_seq; Type: SEQUENCE; Schema: matrix; Owner: postgres
--

CREATE SEQUENCE matrix.mod4_fattori_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE matrix.mod4_fattori_id_seq OWNER TO postgres;

--
-- Name: mod4_fattori_id_seq; Type: SEQUENCE OWNED BY; Schema: matrix; Owner: postgres
--

ALTER SEQUENCE matrix.mod4_fattori_id_seq OWNED BY matrix.mod4_fattori.id;


--
-- Name: mod4_nominativi_20200129; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.mod4_nominativi_20200129 (
    id bigint,
    id_nominativo_struttura bigint,
    livello_formativo integer,
    carico_annuale integer,
    perc_sottr integer,
    perc_sottr2 integer,
    fattore1 boolean,
    fattore2 boolean,
    fattore3 boolean,
    uba_ora real,
    fattori_text character varying,
    ups smallint,
    uba smallint
);


ALTER TABLE matrix.mod4_nominativi_20200129 OWNER TO postgres;

--
-- Name: mod4_nominativi_back_20200114; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.mod4_nominativi_back_20200114 (
    id bigint,
    id_nominativo_struttura bigint,
    livello_formativo integer,
    carico_annuale integer,
    perc_sottr integer,
    perc_sottr2 integer,
    fattore1 boolean,
    fattore2 boolean,
    fattore3 boolean,
    uba_ora real,
    fattori_text character varying,
    ups smallint,
    uba smallint
);


ALTER TABLE matrix.mod4_nominativi_back_20200114 OWNER TO postgres;

--
-- Name: mod4_nominativi_fattori; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.mod4_nominativi_fattori (
    id integer NOT NULL,
    id_nominativo_struttura bigint,
    id_fattore bigint,
    valore double precision
);


ALTER TABLE matrix.mod4_nominativi_fattori OWNER TO postgres;

--
-- Name: mod4_nominativi_fattori_id_seq; Type: SEQUENCE; Schema: matrix; Owner: postgres
--

CREATE SEQUENCE matrix.mod4_nominativi_fattori_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE matrix.mod4_nominativi_fattori_id_seq OWNER TO postgres;

--
-- Name: mod4_nominativi_fattori_id_seq; Type: SEQUENCE OWNED BY; Schema: matrix; Owner: postgres
--

ALTER SEQUENCE matrix.mod4_nominativi_fattori_id_seq OWNED BY matrix.mod4_nominativi_fattori.id;


--
-- Name: mod4_nominativi_h; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.mod4_nominativi_h (
    rng int8range,
    id bigint,
    id_nominativo_struttura bigint,
    livello_formativo integer,
    carico_annuale integer,
    perc_sottr integer,
    perc_sottr2 integer,
    fattore1 boolean,
    fattore2 boolean,
    fattore3 boolean,
    uba_ora real,
    fattori_text character varying,
    ups smallint,
    uba smallint
);


ALTER TABLE matrix.mod4_nominativi_h OWNER TO postgres;

--
-- Name: mod4_nominativi_id_seq; Type: SEQUENCE; Schema: matrix; Owner: postgres
--

CREATE SEQUENCE matrix.mod4_nominativi_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE matrix.mod4_nominativi_id_seq OWNER TO postgres;

--
-- Name: mod4_nominativi_id_seq; Type: SEQUENCE OWNED BY; Schema: matrix; Owner: postgres
--

ALTER SEQUENCE matrix.mod4_nominativi_id_seq OWNED BY matrix.mod4_nominativi.id;


--
-- Name: mod4_strutture; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.mod4_strutture (
    id integer NOT NULL,
    id_struttura bigint,
    sottr integer,
    fattore1 boolean,
    fattore2 boolean,
    ups integer,
    uba integer
);


ALTER TABLE matrix.mod4_strutture OWNER TO postgres;

--
-- Name: mod4_strutture_back_20200114; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.mod4_strutture_back_20200114 (
    id integer,
    id_struttura bigint,
    sottr integer,
    fattore1 boolean,
    fattore2 boolean,
    ups integer,
    uba integer
);


ALTER TABLE matrix.mod4_strutture_back_20200114 OWNER TO postgres;

--
-- Name: mod4_strutture_h; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.mod4_strutture_h (
    rng int8range,
    id integer,
    id_struttura bigint,
    sottr integer,
    fattore1 boolean,
    fattore2 boolean,
    ups integer,
    uba integer
);


ALTER TABLE matrix.mod4_strutture_h OWNER TO postgres;

--
-- Name: mod4_strutture_id_seq; Type: SEQUENCE; Schema: matrix; Owner: postgres
--

CREATE SEQUENCE matrix.mod4_strutture_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE matrix.mod4_strutture_id_seq OWNER TO postgres;

--
-- Name: mod4_strutture_id_seq; Type: SEQUENCE OWNED BY; Schema: matrix; Owner: postgres
--

ALTER SEQUENCE matrix.mod4_strutture_id_seq OWNED BY matrix.mod4_strutture.id;


--
-- Name: struttura_asl_ref_new; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.struttura_asl_ref_new AS
 WITH RECURSIVE a_r(id, id_padre, id_asl, descrizione, n_livello, ups, uba, descrizione_breve, id_ref, anno, id_gisa) AS (
         SELECT a.id,
            ad.p_id AS id_padre,
            a.id_asl,
            a.descrizione,
            a.n_livello,
            a.ups,
            a.uba,
            a.descrizione_breve,
            a.id AS id_ref,
            ad.anno,
            ad.id_gisa
           FROM (matrix.struttura_asl a
             JOIN matrix.vw_tree_nodes_asl_descr ad ON ((ad.id_node = a.id)))
        UNION ALL
         SELECT a_r_1.id,
            a2.p_id,
            a2.id_asl,
            a2.descrizione,
            a2.n_livello,
            a2.ups,
            a2.uba,
            a2.descrizione_breve,
            ad.p_id,
            ad.anno,
            a_r_1.id_gisa
           FROM (((matrix.struttura_asl a
             JOIN a_r a_r_1 ON ((a_r_1.id_ref = a.id)))
             JOIN matrix.vw_tree_nodes_asl_descr ad ON ((ad.id = a.id)))
             JOIN matrix.vw_tree_nodes_asl_descr a2 ON ((a2.id = ad.id_node_parent)))
          WHERE (ad.p_id IS NOT NULL)
        )
 SELECT a_r.id,
    a_r.id_padre,
    a_r.id_asl,
    a_r.descrizione,
    a_r.n_livello,
    a_r.ups,
    a_r.uba,
    a_r.descrizione_breve,
    a_r.id_ref,
    a_r.anno,
    a_r.id_gisa
   FROM a_r;


ALTER TABLE matrix.struttura_asl_ref_new OWNER TO postgres;

--
-- Name: mvw_struttura_asl_ref_new; Type: MATERIALIZED VIEW; Schema: matrix; Owner: postgres
--

CREATE MATERIALIZED VIEW matrix.mvw_struttura_asl_ref_new AS
 SELECT struttura_asl_ref_new.id,
    struttura_asl_ref_new.id_padre,
    struttura_asl_ref_new.id_asl,
    struttura_asl_ref_new.descrizione,
    struttura_asl_ref_new.n_livello,
    struttura_asl_ref_new.ups,
    struttura_asl_ref_new.uba,
    struttura_asl_ref_new.descrizione_breve,
    struttura_asl_ref_new.id_ref,
    struttura_asl_ref_new.anno,
    struttura_asl_ref_new.id_gisa
   FROM matrix.struttura_asl_ref_new
  WITH NO DATA;


ALTER TABLE matrix.mvw_struttura_asl_ref_new OWNER TO postgres;

--
-- Name: n; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.n (
    count bigint
);


ALTER TABLE matrix.n OWNER TO postgres;

--
-- Name: nominativi_back; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.nominativi_back (
    id integer,
    id_nominativo_gisa bigint,
    id_anagrafica bigint,
    nominativo text,
    codice_fiscale text,
    qualifica text
);


ALTER TABLE matrix.nominativi_back OWNER TO postgres;

--
-- Name: nominativi_back_20200114; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.nominativi_back_20200114 (
    id integer,
    id_nominativo_gisa bigint,
    id_anagrafica bigint,
    nominativo text,
    codice_fiscale text,
    qualifica text
);


ALTER TABLE matrix.nominativi_back_20200114 OWNER TO postgres;

--
-- Name: nominativi_h; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.nominativi_h (
    rng int8range,
    id integer,
    id_nominativo_gisa bigint,
    id_anagrafica bigint,
    nominativo text,
    codice_fiscale text,
    qualifica text
);


ALTER TABLE matrix.nominativi_h OWNER TO postgres;

--
-- Name: nominativi_struttura_back; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.nominativi_struttura_back (
    id integer,
    id_nominativo bigint,
    id_struttura bigint
);


ALTER TABLE matrix.nominativi_struttura_back OWNER TO postgres;

--
-- Name: nominativi_struttura_back_20200114; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.nominativi_struttura_back_20200114 (
    id integer,
    id_nominativo bigint,
    id_struttura bigint
);


ALTER TABLE matrix.nominativi_struttura_back_20200114 OWNER TO postgres;

--
-- Name: oia_nodo; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.oia_nodo (
    rng int8range,
    id integer,
    id_padre integer,
    id_asl integer,
    descrizione_lunga character varying,
    n_livello smallint,
    entered timestamp with time zone,
    entered_by integer,
    modified timestamp with time zone,
    modified_by integer,
    trashed_date timestamp with time zone,
    tipologia_struttura integer,
    comune text,
    enabled boolean,
    obsoleto boolean,
    confermato boolean,
    id_strumento_calcolo integer,
    codice_interno_fk integer,
    nome character varying,
    id_utente integer,
    mail text,
    indirizzo text,
    delegato integer,
    descrizione_comune text,
    id_oia_nodo_temp integer,
    data_scadenza timestamp without time zone,
    disabilitata boolean,
    stato integer,
    anno integer,
    descrizione_area_struttura_complessa text,
    id_lookup_area_struttura_asl integer,
    ui_struttura_foglio_att_iniziale integer,
    ui_struttura_foglio_att_finale integer,
    id_utente_edit integer,
    percentuale_area_a integer,
    stato_all2 integer,
    stato_all6 integer,
    codice_interno_univoco integer,
    descrizione_area_struttura character varying,
    data_congelamento timestamp without time zone
);


ALTER TABLE matrix.oia_nodo OWNER TO postgres;

--
-- Name: oia_nodo_2019_new; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.oia_nodo_2019_new (
    id integer,
    id_padre integer,
    id_asl integer,
    descrizione_lunga character varying,
    n_livello smallint,
    entered timestamp with time zone,
    entered_by integer,
    modified timestamp with time zone,
    modified_by integer,
    trashed_date timestamp with time zone,
    tipologia_struttura integer,
    comune text,
    enabled boolean,
    obsoleto boolean,
    confermato boolean,
    id_strumento_calcolo integer,
    codice_interno_fk integer,
    nome character varying,
    id_utente integer,
    mail text,
    indirizzo text,
    delegato integer,
    descrizione_comune text,
    id_oia_nodo_temp integer,
    data_scadenza timestamp without time zone,
    disabilitata boolean,
    stato integer,
    anno integer,
    descrizione_area_struttura_complessa text,
    id_lookup_area_struttura_asl integer,
    ui_struttura_foglio_att_iniziale integer,
    ui_struttura_foglio_att_finale integer,
    id_utente_edit integer,
    percentuale_area_a integer,
    stato_all2 integer,
    stato_all6 integer,
    codice_interno_univoco integer,
    descrizione_area_struttura character varying
);


ALTER TABLE matrix.oia_nodo_2019_new OWNER TO postgres;

--
-- Name: oia_nodo_2020; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.oia_nodo_2020 (
    id integer,
    id_padre integer,
    id_asl integer,
    descrizione_lunga character varying,
    n_livello smallint,
    entered timestamp with time zone,
    entered_by integer,
    modified timestamp with time zone,
    modified_by integer,
    trashed_date timestamp with time zone,
    tipologia_struttura integer,
    comune text,
    enabled boolean,
    obsoleto boolean,
    confermato boolean,
    id_strumento_calcolo integer,
    codice_interno_fk integer,
    nome character varying,
    id_utente integer,
    mail text,
    indirizzo text,
    delegato integer,
    descrizione_comune text,
    id_oia_nodo_temp integer,
    data_scadenza timestamp without time zone,
    disabilitata boolean,
    stato integer,
    anno integer,
    descrizione_area_struttura_complessa text,
    id_lookup_area_struttura_asl integer,
    ui_struttura_foglio_att_iniziale integer,
    ui_struttura_foglio_att_finale integer,
    id_utente_edit integer,
    percentuale_area_a integer,
    stato_all2 integer,
    stato_all6 integer,
    codice_interno_univoco integer,
    descrizione_area_struttura character varying
);


ALTER TABLE matrix.oia_nodo_2020 OWNER TO postgres;

--
-- Name: oid_matrix; Type: SEQUENCE; Schema: matrix; Owner: postgres
--

CREATE SEQUENCE matrix.oid_matrix
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE matrix.oid_matrix OWNER TO postgres;

--
-- Name: operation_log; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.operation_log (
    id_piano bigint,
    id_struttura bigint,
    target real,
    utente text,
    dat timestamp without time zone
);


ALTER TABLE matrix.operation_log OWNER TO postgres;

--
-- Name: operation_log_28mar; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.operation_log_28mar (
    id_piano bigint,
    id_struttura bigint,
    target real,
    utente text,
    dat timestamp without time zone
);


ALTER TABLE matrix.operation_log_28mar OWNER TO postgres;

--
-- Name: prog_d19; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.prog_d19 (
    id integer,
    id_struttura integer,
    id_piano integer,
    target double precision
);


ALTER TABLE matrix.prog_d19 OWNER TO postgres;

--
-- Name: risorse; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.risorse (
    id bigint,
    cf text,
    nominativi text
);


ALTER TABLE matrix.risorse OWNER TO postgres;

--
-- Name: risorse_strutture; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.risorse_strutture (
    id_asl bigint,
    id_risorsa bigint,
    carico_minimo_uba text,
    carico_minimo_uip text,
    carico_teorico_uba text,
    carico_teorico_uba_2 text,
    carico_teorico_uip text,
    carico_teorico_uip_2 text,
    carico_teorico_uip_3 text,
    fattori_esterni text,
    fattori_negativi text,
    fattori_personali text,
    livelli_uba_ora text,
    livelli_uba_ora_2 text,
    livelli_uba_ora_3 text,
    livello_formativo text,
    perc_sottr text,
    perc_sottr_2 text,
    perc_sottr_3 text,
    qualifica text,
    periodo daterange
);


ALTER TABLE matrix.risorse_strutture OWNER TO postgres;

--
-- Name: risorse_strutture_2; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.risorse_strutture_2 (
    id_asl bigint,
    id_risorsa bigint,
    carico_minimo_uba text,
    carico_minimo_uip text,
    carico_teorico_uba text,
    carico_teorico_uba_2 text,
    carico_teorico_uip text,
    carico_teorico_uip_2 text,
    carico_teorico_uip_3 text,
    fattori_esterni text,
    fattori_negativi text,
    fattori_personali text,
    livelli_uba_ora text,
    livelli_uba_ora_2 text,
    livelli_uba_ora_3 text,
    livello_formativo text,
    perc_sottr text,
    perc_sottr_2 text,
    perc_sottr_3 text,
    qualifica text,
    periodo daterange
);


ALTER TABLE matrix.risorse_strutture_2 OWNER TO postgres;

--
-- Name: stabilimenti; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.stabilimenti (
    id bigint,
    id_impresa bigint,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    riferimento_id_impresa integer,
    riferimento_nome_tab_impresa text,
    ragione_sociale text,
    asl_rif integer,
    asl text,
    codice_fiscale text,
    codice_fiscale_rappresentante text,
    partita_iva text,
    n_reg text,
    nominativo_rappresentante text,
    comune text,
    provincia_stab text,
    indirizzo text,
    cap_stab text,
    comune_leg text,
    provincia_leg text,
    indirizzo_leg text,
    cap_leg text,
    latitudine_stab double precision,
    longitudine_stab double precision,
    categoria_rischio integer,
    prossimo_controllo timestamp without time zone,
    id_controllo_ultima_categorizzazione integer,
    data_controllo_ultima_categorizzazione timestamp without time zone,
    tipo_categorizzazione text,
    data_inserimento timestamp without time zone,
    livello_rischio text,
    tipologia integer,
    categoria_rischio_qualitativa text,
    approval_number text,
    impresa_id_opu integer,
    stabilimento_id_opu integer,
    impresa_id_organization integer,
    stabilimento_id_organization integer
);


ALTER TABLE matrix.stabilimenti OWNER TO postgres;

--
-- Name: stabilimenti_linee; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.stabilimenti_linee (
    id bigint,
    id_stabilimento bigint,
    id_attivita integer,
    id_linea integer,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    num_riconoscimento text,
    n_linea text,
    data_inizio_attivita timestamp without time zone,
    data_fine_attivita timestamp without time zone,
    macroarea text,
    aggregazione text,
    attivita text,
    path_attivita_completo text,
    norma text,
    id_norma integer,
    codice_macroarea text,
    codice_aggregazione text,
    codice_attivita text,
    stato text,
    id_stato integer,
    miscela boolean,
    tipo_attivita_descrizione text,
    tipo_attivita integer,
    sintesis boolean
);


ALTER TABLE matrix.stabilimenti_linee OWNER TO postgres;

--
-- Name: struttura_asl_191803; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_asl_191803 (
    id integer,
    id_padre integer,
    id_asl integer,
    descrizione character varying,
    n_livello smallint,
    ups double precision,
    uba double precision,
    descrizione_breve character varying
);


ALTER TABLE matrix.struttura_asl_191803 OWNER TO postgres;

--
-- Name: struttura_asl_2019; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_asl_2019 (
    id integer,
    id_asl integer,
    descrizione character varying,
    n_livello_gisa smallint,
    descrizione_breve character varying,
    id_gisa bigint,
    perc_sottr text
);


ALTER TABLE matrix.struttura_asl_2019 OWNER TO postgres;

--
-- Name: struttura_asl_h; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_asl_h (
    rng int8range,
    id integer,
    id_gisa integer,
    id_padre integer,
    id_asl integer,
    descrizione character varying,
    n_livello smallint,
    descrizione_breve text
);


ALTER TABLE matrix.struttura_asl_h OWNER TO postgres;

--
-- Name: struttura_asl_old; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_asl_old (
    id integer,
    id_padre integer,
    id_asl integer,
    descrizione character varying,
    n_livello smallint,
    ups double precision,
    uba double precision,
    descrizione_breve character varying
);


ALTER TABLE matrix.struttura_asl_old OWNER TO postgres;

--
-- Name: struttura_asl_old_da_cancellare; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_asl_old_da_cancellare (
    id integer,
    id_padre integer,
    id_asl integer,
    descrizione character varying,
    n_livello smallint,
    ups double precision,
    uba double precision,
    descrizione_breve character varying
);


ALTER TABLE matrix.struttura_asl_old_da_cancellare OWNER TO postgres;

--
-- Name: struttura_asl_prod; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_asl_prod (
    id integer,
    id_padre integer,
    id_asl integer,
    descrizione character varying,
    n_livello smallint,
    ups double precision,
    uba double precision,
    descrizione_breve character varying
);


ALTER TABLE matrix.struttura_asl_prod OWNER TO postgres;

--
-- Name: vw_struttura_asl; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_struttura_asl AS
 WITH RECURSIVE asl_p(id, id_padre, id_asl, descrizione, n_livello, ups, uba, descrizione_breve, path, path_ord) AS (
         SELECT struttura_asl_old_da_cancellare.id,
            struttura_asl_old_da_cancellare.id_padre,
            struttura_asl_old_da_cancellare.id_asl,
            struttura_asl_old_da_cancellare.descrizione,
            struttura_asl_old_da_cancellare.n_livello,
            struttura_asl_old_da_cancellare.ups,
            struttura_asl_old_da_cancellare.uba,
            struttura_asl_old_da_cancellare.descrizione_breve,
            struttura_asl_old_da_cancellare.descrizione_breve AS path,
            struttura_asl_old_da_cancellare.descrizione_breve AS path_ord
           FROM matrix.struttura_asl_old_da_cancellare
          WHERE (struttura_asl_old_da_cancellare.id_padre IS NULL)
        UNION ALL
         SELECT f.id,
            f.id_padre,
            f.id_asl,
            f.descrizione,
            f.n_livello,
            f.ups,
            f.uba,
            f.descrizione_breve,
            (((p.path)::text || '/'::text) || (f.descrizione_breve)::text),
            (((p.path_ord)::text || '-'::text) || (f.descrizione_breve)::text)
           FROM (asl_p p
             JOIN matrix.struttura_asl_old_da_cancellare f ON ((p.id = f.id_padre)))
        )
 SELECT asl_p.id,
    asl_p.id_padre,
    asl_p.id_asl,
    asl_p.descrizione,
    asl_p.n_livello,
    asl_p.ups,
    asl_p.uba,
    asl_p.descrizione_breve,
    asl_p.path,
    asl_p.path_ord
   FROM asl_p;


ALTER TABLE matrix.vw_struttura_asl OWNER TO postgres;

--
-- Name: struttura_asl_ref; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.struttura_asl_ref AS
 WITH RECURSIVE a_r(id, id_padre, id_asl, descrizione, n_livello, ups, uba, descrizione_breve, id_ref, path, path_ord) AS (
         SELECT a.id,
            a.id_padre,
            a.id_asl,
            a.descrizione,
            a.n_livello,
            a.ups,
            a.uba,
            a.descrizione_breve,
            a.id AS id_ref,
            a.path,
            a.path_ord
           FROM matrix.vw_struttura_asl a
        UNION ALL
         SELECT a_r_1.id,
            a2.id_padre,
            a2.id_asl,
            a2.descrizione,
            a2.n_livello,
            a2.ups,
            a2.uba,
            a2.descrizione_breve,
            a.id_padre,
            a.path,
            a.path_ord
           FROM ((matrix.vw_struttura_asl a
             JOIN a_r a_r_1 ON ((a_r_1.id_ref = a.id)))
             JOIN matrix.struttura_asl_old_da_cancellare a2 ON ((a2.id = a.id_padre)))
          WHERE (a.id_padre IS NOT NULL)
        )
 SELECT a_r.id,
    a_r.id_padre,
    a_r.id_asl,
    a_r.descrizione,
    a_r.n_livello,
    a_r.ups,
    a_r.uba,
    a_r.descrizione_breve,
    a_r.id_ref,
    a_r.path,
    a_r.path_ord
   FROM a_r;


ALTER TABLE matrix.struttura_asl_ref OWNER TO postgres;

--
-- Name: struttura_asl_test_20200114; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_asl_test_20200114 (
    id bigint,
    id_gisa bigint,
    id_asl bigint,
    codice_interno_fk bigint,
    descrizione text,
    n_livello integer,
    anno integer,
    descrizione_breve text,
    ups double precision,
    uba double precision
);


ALTER TABLE matrix.struttura_asl_test_20200114 OWNER TO postgres;

--
-- Name: struttura_asl_test_back; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_asl_test_back (
    id bigint,
    id_gisa bigint,
    id_asl bigint,
    codice_interno_fk bigint,
    descrizione text,
    n_livello integer,
    anno integer,
    descrizione_breve text,
    ups double precision,
    uba double precision
);


ALTER TABLE matrix.struttura_asl_test_back OWNER TO postgres;

--
-- Name: struttura_asl_test_back_20200122; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_asl_test_back_20200122 (
    id bigint,
    id_gisa bigint,
    id_asl bigint,
    codice_interno_fk bigint,
    descrizione text,
    n_livello integer,
    anno integer,
    descrizione_breve text,
    ups double precision,
    uba double precision
);


ALTER TABLE matrix.struttura_asl_test_back_20200122 OWNER TO postgres;

--
-- Name: struttura_asl_test_h; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_asl_test_h (
    rng int8range,
    id integer,
    id_gisa integer,
    id_padre integer,
    id_asl integer,
    descrizione character varying,
    n_livello smallint,
    descrizione_breve text
);


ALTER TABLE matrix.struttura_asl_test_h OWNER TO postgres;

--
-- Name: struttura_piani20200713; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piani20200713 (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying,
    ha_campioni boolean,
    id_tipo_tecnica bigint
);


ALTER TABLE matrix.struttura_piani20200713 OWNER TO postgres;

--
-- Name: struttura_piani20200928; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piani20200928 (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying,
    ha_campioni boolean,
    id_tipo_tecnica bigint
);


ALTER TABLE matrix.struttura_piani20200928 OWNER TO postgres;

--
-- Name: struttura_piani_2019; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piani_2019 (
    id bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    path_ord text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve character varying
);


ALTER TABLE matrix.struttura_piani_2019 OWNER TO postgres;

--
-- Name: struttura_piani_20200722; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piani_20200722 (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying,
    ha_campioni boolean,
    id_tipo_tecnica bigint
);


ALTER TABLE matrix.struttura_piani_20200722 OWNER TO postgres;

--
-- Name: struttura_piani_20210126; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piani_20210126 (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying,
    ha_campioni boolean,
    id_tipo_tecnica bigint
);


ALTER TABLE matrix.struttura_piani_20210126 OWNER TO postgres;

--
-- Name: struttura_piani_back_20200122; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piani_back_20200122 (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    path_ord text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying
);


ALTER TABLE matrix.struttura_piani_back_20200122 OWNER TO postgres;

--
-- Name: struttura_piani_coll; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piani_coll (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying,
    ha_campioni boolean,
    id_tipo_tecnica bigint
);


ALTER TABLE matrix.struttura_piani_coll OWNER TO postgres;

--
-- Name: struttura_piani_h; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piani_h (
    rng int8range,
    id bigint NOT NULL,
    id_gisa bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    parent bigint,
    alias text,
    path_ord text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text
);


ALTER TABLE matrix.struttura_piani_h OWNER TO postgres;

--
-- Name: struttura_piani_test_20200114; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piani_test_20200114 (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    path_ord text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying
);


ALTER TABLE matrix.struttura_piani_test_20200114 OWNER TO postgres;

--
-- Name: struttura_piani_test_h; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piani_test_h (
    rng int8range,
    id bigint,
    id_gisa bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    parent bigint,
    alias text,
    path_ord text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text
);


ALTER TABLE matrix.struttura_piani_test_h OWNER TO postgres;

--
-- Name: struttura_piano_target_11; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piano_target_11 (
    id integer,
    id_struttura integer,
    id_piano integer,
    target double precision
);


ALTER TABLE matrix.struttura_piano_target_11 OWNER TO postgres;

--
-- Name: struttura_piano_target_20200107; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piano_target_20200107 (
    id integer,
    id_struttura integer,
    id_piano integer,
    target double precision,
    valore double precision,
    ups_impegnati double precision,
    uba_impegnati double precision,
    ups_target double precision,
    uba_target double precision
);


ALTER TABLE matrix.struttura_piano_target_20200107 OWNER TO postgres;

--
-- Name: struttura_piano_target_20200220; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piano_target_20200220 (
    id integer,
    id_struttura integer,
    id_piano integer,
    target double precision
);


ALTER TABLE matrix.struttura_piano_target_20200220 OWNER TO postgres;

--
-- Name: struttura_piano_target_20200608; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piano_target_20200608 (
    id integer,
    id_struttura integer,
    id_piano integer,
    target double precision
);


ALTER TABLE matrix.struttura_piano_target_20200608 OWNER TO postgres;

--
-- Name: struttura_piano_target_230712; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piano_target_230712 (
    id integer,
    id_struttura integer,
    id_piano integer,
    target double precision
);


ALTER TABLE matrix.struttura_piano_target_230712 OWNER TO postgres;

--
-- Name: struttura_piano_target_test; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.struttura_piano_target_test (
    id integer,
    id_struttura integer,
    id_piano integer,
    target double precision
);


ALTER TABLE matrix.struttura_piano_target_test OWNER TO postgres;

--
-- Name: tables_history; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.tables_history (
    id integer NOT NULL,
    "table" character varying,
    status character varying
);


ALTER TABLE matrix.tables_history OWNER TO postgres;

--
-- Name: tables_history_id_seq; Type: SEQUENCE; Schema: matrix; Owner: postgres
--

CREATE SEQUENCE matrix.tables_history_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE matrix.tables_history_id_seq OWNER TO postgres;

--
-- Name: tables_history_id_seq; Type: SEQUENCE OWNED BY; Schema: matrix; Owner: postgres
--

ALTER SEQUENCE matrix.tables_history_id_seq OWNED BY matrix.tables_history.id;


--
-- Name: target_backup_a1413; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.target_backup_a1413 (
    id integer,
    id_struttura integer,
    id_piano integer,
    target double precision
);


ALTER TABLE matrix.target_backup_a1413 OWNER TO postgres;

--
-- Name: tmp_imprese; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.tmp_imprese (
    id bigint,
    riferimento_id_impresa integer,
    riferimento_nome_tab_impresa text,
    ragione_sociale text,
    codice_fiscale text,
    codice_fiscale_rappresentante text,
    partita_iva text,
    nominativo_rappresentante text,
    comune_leg text,
    provincia_leg text,
    indirizzo_leg text,
    cap_leg text,
    fatturazione_elettronica boolean,
    split_payment boolean,
    codice_sdi text,
    id_indirizzo_fatturazione integer,
    comune_fatturazione text,
    provincia_fatturazione text,
    indirizzo_fatturazione text,
    cap_fatturazione text
);


ALTER TABLE matrix.tmp_imprese OWNER TO postgres;

--
-- Name: tmp_stabilimenti; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.tmp_stabilimenti (
    id bigint,
    id_impresa bigint,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    riferimento_id_impresa integer,
    riferimento_nome_tab_impresa text,
    ragione_sociale text,
    asl_rif integer,
    asl text,
    codice_fiscale text,
    codice_fiscale_rappresentante text,
    partita_iva text,
    n_reg text,
    nominativo_rappresentante text,
    comune text,
    provincia_stab text,
    indirizzo text,
    cap_stab text,
    comune_leg text,
    provincia_leg text,
    indirizzo_leg text,
    cap_leg text,
    latitudine_stab double precision,
    longitudine_stab double precision,
    categoria_rischio integer,
    prossimo_controllo timestamp without time zone,
    id_controllo_ultima_categorizzazione integer,
    data_controllo_ultima_categorizzazione timestamp without time zone,
    tipo_categorizzazione text,
    data_inserimento timestamp without time zone,
    livello_rischio text,
    tipologia integer,
    categoria_rischio_qualitativa text,
    approval_number text,
    impresa_id_opu integer,
    stabilimento_id_opu integer,
    impresa_id_organization integer,
    stabilimento_id_organization integer
);


ALTER TABLE matrix.tmp_stabilimenti OWNER TO postgres;

--
-- Name: tmp_stabilimenti_linee; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.tmp_stabilimenti_linee (
    id bigint,
    id_stabilimento bigint,
    id_attivita integer,
    id_linea integer,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    num_riconoscimento text,
    n_linea text,
    data_inizio_attivita timestamp without time zone,
    data_fine_attivita timestamp without time zone,
    macroarea text,
    aggregazione text,
    attivita text,
    path_attivita_completo text,
    norma text,
    id_norma integer,
    codice_macroarea text,
    codice_aggregazione text,
    codice_attivita text,
    stato text,
    id_stato integer,
    miscela boolean,
    tipo_attivita_descrizione text,
    tipo_attivita integer,
    sintesis boolean
);


ALTER TABLE matrix.tmp_stabilimenti_linee OWNER TO postgres;

--
-- Name: tree_anno; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.tree_anno (
    anno integer,
    id_tree bigint,
    id_root bigint
);


ALTER TABLE matrix.tree_anno OWNER TO postgres;

--
-- Name: tree_anno_back_20200114; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.tree_anno_back_20200114 (
    anno integer,
    id_tree bigint,
    id_root bigint
);


ALTER TABLE matrix.tree_anno_back_20200114 OWNER TO postgres;

--
-- Name: tree_anno_coll; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.tree_anno_coll (
    anno integer,
    id_tree bigint,
    id_root bigint
);


ALTER TABLE matrix.tree_anno_coll OWNER TO postgres;

--
-- Name: tree_nodes_2019; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.tree_nodes_2019 (
    id bigint NOT NULL,
    id_tree bigint NOT NULL,
    id_parent bigint
);


ALTER TABLE matrix.tree_nodes_2019 OWNER TO postgres;

--
-- Name: tree_nodes_20200142; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.tree_nodes_20200142 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE matrix.tree_nodes_20200142 OWNER TO postgres;

--
-- Name: tree_nodes_back_20200114; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.tree_nodes_back_20200114 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE matrix.tree_nodes_back_20200114 OWNER TO postgres;

--
-- Name: tree_nodes_coll; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.tree_nodes_coll (
    id bigint NOT NULL,
    id_tree bigint NOT NULL,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE matrix.tree_nodes_coll OWNER TO postgres;

--
-- Name: trees_coll; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.trees_coll (
    id bigint NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE matrix.trees_coll OWNER TO postgres;

--
-- Name: upd_descr_breve; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.upd_descr_breve (
    id integer NOT NULL,
    tipo character varying,
    to_be_rep character varying,
    rep character varying,
    condition character varying,
    ordine integer,
    tabella character varying,
    metodo character varying
);


ALTER TABLE matrix.upd_descr_breve OWNER TO postgres;

--
-- Name: upd_descr_breve_id_seq; Type: SEQUENCE; Schema: matrix; Owner: postgres
--

CREATE SEQUENCE matrix.upd_descr_breve_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE matrix.upd_descr_breve_id_seq OWNER TO postgres;

--
-- Name: upd_descr_breve_id_seq; Type: SEQUENCE OWNED BY; Schema: matrix; Owner: postgres
--

ALTER SEQUENCE matrix.upd_descr_breve_id_seq OWNED BY matrix.upd_descr_breve.id;


--
-- Name: update_xls; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.update_xls (
    nome_file text,
    nome_foglio text,
    rownum integer,
    carico_effettivo_uos_uba text,
    carico_effettivo_uos_ups text,
    carico_minimo_uba text,
    carico_minimo_uip text,
    carico_teorico_uba text,
    carico_teorico_uba_2 text,
    carico_teorico_uip text,
    carico_teorico_uip_2 text,
    carico_teorico_uip_3 text,
    carico_teorico_uos_uba text,
    carico_teorico_uos_ups text,
    carico_totale_uoc_uba text,
    carico_totale_uoc_ups text,
    cf text,
    fattori_esterni text,
    fattori_negativi text,
    fattori_personali text,
    iaoa text,
    iapz text,
    livelli_uba_ora text,
    livelli_uba_ora_2 text,
    livelli_uba_ora_3 text,
    livello_formativo text,
    nominativi text,
    perc_sottr text,
    perc_sottr_2 text,
    perc_sottr_3 text,
    qualifica text,
    sanita_animale text,
    sian text,
    struttura text,
    uoc text,
    uos text,
    uos_articolazioni text
);


ALTER TABLE matrix.update_xls OWNER TO postgres;

--
-- Name: utenti_abilitati_produzione; Type: TABLE; Schema: matrix; Owner: postgres
--

CREATE TABLE matrix.utenti_abilitati_produzione (
    id bigint NOT NULL,
    codice_fiscale character varying,
    cognome character varying,
    nome character varying
);


ALTER TABLE matrix.utenti_abilitati_produzione OWNER TO postgres;

--
-- Name: vw_tree_nodes_down; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_down AS
 WITH RECURSIVE vw_tree_nodes_down(name_tree, id_node, id_tree, id_node_parent, id_node_ref, dist_node) AS (
         SELECT vw_tree_nodes.name_tree,
            vw_tree_nodes.id_node,
            vw_tree_nodes.id_tree,
            vw_tree_nodes.id_node_parent,
            vw_tree_nodes.id_node AS id_node_ref,
            1 AS dist_node,
            vw_tree_nodes.validita,
            vw_tree_nodes.ordinamento
           FROM matrix.vw_tree_nodes
        UNION ALL
         SELECT down.name_tree,
            down.id_node,
            down.id_tree,
            down.id_node_parent,
            n.id_parent AS id_node_ref,
            (down.dist_node + 1),
            down.validita,
            down.ordinamento
           FROM (vw_tree_nodes_down down
             JOIN matrix.tree_nodes n ON (((n.id = down.id_node_ref) AND (n.id_parent IS NOT NULL))))
        )
 SELECT vw_tree_nodes_down.name_tree,
    vw_tree_nodes_down.id_node,
    vw_tree_nodes_down.id_tree,
    vw_tree_nodes_down.id_node_parent,
    vw_tree_nodes_down.id_node_ref,
    vw_tree_nodes_down.dist_node,
    vw_tree_nodes_down.validita,
    vw_tree_nodes_down.ordinamento
   FROM vw_tree_nodes_down;


ALTER TABLE matrix.vw_tree_nodes_down OWNER TO postgres;

--
-- Name: vw_asl_tree_by_ref; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_asl_tree_by_ref AS
 SELECT d.id_node_ref,
    u.name_tree,
    u.id_node,
    u.id_tree,
    u.id_node_parent,
    u.path,
    u.path_ord,
    u.path_descr,
    u.id,
    u.id_gisa,
    u.id_asl,
    u.codice_interno_fk,
    u.descrizione,
    u.n_livello,
    u.anno,
    u.descrizione_breve,
    u.ups,
    u.uba
   FROM (matrix.vw_tree_nodes_down d
     JOIN matrix.vw_tree_nodes_up_asl u ON ((d.id_node = u.id_node)));


ALTER TABLE matrix.vw_asl_tree_by_ref OWNER TO postgres;

--
-- Name: vw_comuni; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_comuni AS
 SELECT c.id,
    c.cod_comune,
    c.cod_regione,
    c.cod_provincia,
    c.nome,
    c.istat,
    c.codiceistatasl,
    c.codice,
    c.codice_old,
    c.codiceistatasl_old,
    c.cap,
    c.notused,
    c.cod_nazione,
    c.codiceasl_bdn,
    c.codice_nuovo,
    c.codice_nuovo_,
    c.istat_comune_provincia,
    c.cap_,
    c.istat_pre,
    c.note_hd,
    c.reverse_cap,
    c.codice_catastale,
    c.denominazione_it
   FROM matrix.comuni c
  WHERE (c.notused IS NOT TRUE);


ALTER TABLE matrix.vw_comuni OWNER TO postgres;

--
-- Name: vw_struttura_piani_ref; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_struttura_piani_ref AS
 WITH RECURSIVE p_r(id, cod_raggruppamento, anno, descrizione, ordinamento, data_scadenza, stato, codice_interno, color, path, livello, parent, alias, path_ord, id_formula_ups, id_formula_uba, fattore_ups, fattore_uba, descrizione_breve, id_ref) AS (
         SELECT struttura_piani_old.id,
            struttura_piani_old.cod_raggruppamento,
            struttura_piani_old.anno,
            struttura_piani_old.descrizione,
            struttura_piani_old.ordinamento,
            struttura_piani_old.data_scadenza,
            struttura_piani_old.stato,
            struttura_piani_old.codice_interno,
            struttura_piani_old.color,
            struttura_piani_old.path,
            struttura_piani_old.livello,
            struttura_piani_old.parent,
            struttura_piani_old.alias,
            struttura_piani_old.path_ord,
            struttura_piani_old.id_formula_ups,
            struttura_piani_old.id_formula_uba,
            fu.fattore_fin AS fattore_ups,
            fb.fattore_fin AS fattore_uba,
            struttura_piani_old.descrizione_breve,
            struttura_piani_old.id AS id_ref
           FROM ((matrix.struttura_piani_old
             LEFT JOIN matrix.formule_20201020 fu ON ((fu.id = struttura_piani_old.id_formula_ups)))
             LEFT JOIN matrix.formule_20201020 fb ON ((fb.id = struttura_piani_old.id_formula_uba)))
        UNION ALL
         SELECT p_r_1.id,
            p2.cod_raggruppamento,
            p2.anno,
            p2.descrizione,
            p2.ordinamento,
            p2.data_scadenza,
            p2.stato,
            p2.codice_interno,
            p2.color,
            p2.path,
            p2.livello,
            p2.parent,
            p2.alias,
            p2.path_ord,
            p2.id_formula_ups,
            p2.id_formula_uba,
            p_r_1.fattore_ups,
            p_r_1.fattore_uba,
            p2.descrizione_breve,
            p.parent
           FROM ((matrix.struttura_piani_old p
             JOIN p_r p_r_1 ON ((p_r_1.id_ref = p.id)))
             JOIN matrix.struttura_piani_old p2 ON ((p.parent = p2.id)))
          WHERE (p.parent IS NOT NULL)
        )
 SELECT p_r.id,
    p_r.cod_raggruppamento,
    p_r.anno,
    p_r.descrizione,
    p_r.ordinamento,
    p_r.data_scadenza,
    p_r.stato,
    p_r.codice_interno,
    p_r.color,
    p_r.path,
    p_r.livello,
    p_r.parent,
    p_r.alias,
    p_r.path_ord,
    p_r.id_formula_ups,
    p_r.id_formula_uba,
    p_r.fattore_ups,
    p_r.fattore_uba,
    p_r.descrizione_breve,
    p_r.id_ref
   FROM p_r;


ALTER TABLE matrix.vw_struttura_piani_ref OWNER TO postgres;

--
-- Name: vw_target; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_target AS
 SELECT t.id_struttura,
    p_r.id_ref AS id_piano,
    sum(t.target) AS target,
    '2019'::text AS anno_controllo,
    sum((t.target * p_r.fattore_ups)) AS target_ups,
    sum((t.target * p_r.fattore_uba)) AS target_uba
   FROM (matrix.struttura_piano_target t
     JOIN matrix.vw_struttura_piani_ref p_r ON ((p_r.id = t.id_piano)))
  GROUP BY t.id_struttura, p_r.id_ref;


ALTER TABLE matrix.vw_target OWNER TO postgres;

--
-- Name: vw_distribuiti; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_distribuiti AS
 SELECT a.id_padre AS id_struttura,
    t.id_piano,
    sum(t.target) AS distribuiti
   FROM (matrix.vw_target t
     JOIN matrix.struttura_asl_old_da_cancellare a ON ((t.id_struttura = a.id)))
  GROUP BY a.id_padre, t.id_piano;


ALTER TABLE matrix.vw_distribuiti OWNER TO postgres;

--
-- Name: vw_formule_h; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_formule_h AS
 SELECT formule_20201020.id,
    formule_20201020.descrizione,
    formule_20201020.testo,
    formule_20201020.contiene_uba,
    formule_20201020.valida_ups,
    formule_20201020.valida_uba,
    formule_20201020.fattore_fin
   FROM matrix.formule_20201020;


ALTER TABLE matrix.vw_formule_h OWNER TO postgres;

--
-- Name: vw_imprese; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_imprese AS
 SELECT m.id,
    m.riferimento_id_impresa,
    m.riferimento_nome_tab_impresa,
    m.ragione_sociale,
    m.codice_fiscale,
    m.codice_fiscale_rappresentante,
    m.partita_iva,
    m.nominativo_rappresentante,
    m.comune_leg,
    m.provincia_leg,
    m.indirizzo_leg,
    m.cap_leg,
    m.fatturazione_elettronica,
    m.split_payment,
    m.codice_sdi,
    m.id_indirizzo_fatturazione,
    m.comune_fatturazione,
    m.provincia_fatturazione,
    m.indirizzo_fatturazione,
    m.cap_fatturazione
   FROM matrix.imprese m;


ALTER TABLE matrix.vw_imprese OWNER TO postgres;

--
-- Name: vw_mod4_strutture; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_mod4_strutture AS
 SELECT mod4_strutture.id,
    mod4_strutture.id_struttura,
    mod4_strutture.sottr,
    mod4_strutture.fattore1,
    mod4_strutture.fattore2,
    mod4_strutture.ups,
    mod4_strutture.uba,
    a.id AS id_node_struttura
   FROM (matrix.mod4_strutture
     LEFT JOIN matrix.struttura_asl a ON ((a.id_gisa = mod4_strutture.id_struttura)));


ALTER TABLE matrix.vw_mod4_strutture OWNER TO postgres;

--
-- Name: vw_mod4_strutture_h; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_mod4_strutture_h AS
 SELECT mod4_strutture.id,
    mod4_strutture.id_struttura,
    mod4_strutture.sottr,
    mod4_strutture.fattore1,
    mod4_strutture.fattore2,
    mod4_strutture.ups,
    mod4_strutture.uba
   FROM matrix.mod4_strutture;


ALTER TABLE matrix.vw_mod4_strutture_h OWNER TO postgres;

--
-- Name: vw_nominativi_h; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_nominativi_h AS
 SELECT (nominativi.id)::integer AS id,
    nominativi.id_nominativo_gisa,
    nominativi.id_anagrafica,
    nominativi.nominativo,
    (nominativi.codice_fiscale)::text AS codice_fiscale,
    (nominativi.qualifica)::text AS qualifica
   FROM matrix.nominativi;


ALTER TABLE matrix.vw_nominativi_h OWNER TO postgres;

--
-- Name: vw_nominativi_struttura_validi; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_nominativi_struttura_validi AS
 SELECT ns.id,
    ns.id_nominativo,
    ns.id_struttura,
    ns.nominativo,
    ns.descrizione_breve,
    ns.id_node_struttura,
    ns.id_anagrafica,
    ns.anno,
    ns.codice_interno_fk,
    ns.descrizione,
    ns.codice_fiscale,
    ns.id_asl
   FROM (matrix.vw_nominativi_struttura ns
     JOIN rbac.utente_strutture us ON ((ns.id = us.id)))
  WHERE (us.validita @> (CURRENT_TIMESTAMP)::timestamp without time zone);


ALTER TABLE matrix.vw_nominativi_struttura_validi OWNER TO postgres;

--
-- Name: vw_nominativi_struttura_validi_operativi; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_nominativi_struttura_validi_operativi AS
 SELECT vw_nominativi_struttura_validi.id,
    vw_nominativi_struttura_validi.id_nominativo,
    vw_nominativi_struttura_validi.id_struttura,
    vw_nominativi_struttura_validi.nominativo,
    vw_nominativi_struttura_validi.descrizione_breve,
    vw_nominativi_struttura_validi.id_node_struttura,
    vw_nominativi_struttura_validi.id_anagrafica,
    vw_nominativi_struttura_validi.anno,
    vw_nominativi_struttura_validi.codice_interno_fk,
    vw_nominativi_struttura_validi.descrizione,
    vw_nominativi_struttura_validi.codice_fiscale,
    vw_nominativi_struttura_validi.id_asl
   FROM matrix.vw_nominativi_struttura_validi
  WHERE (vw_nominativi_struttura_validi.id_asl > 0);


ALTER TABLE matrix.vw_nominativi_struttura_validi_operativi OWNER TO postgres;

--
-- Name: vw_risorse; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_risorse AS
 SELECT vw_nominativi.id_anagrafica,
    min(vw_nominativi.nominativo) AS nominativo,
    min(vw_nominativi.codice_fiscale) AS codice_fiscale,
    min(vw_nominativi.qualifica) AS qualifica
   FROM matrix.vw_nominativi
  GROUP BY vw_nominativi.id_anagrafica;


ALTER TABLE matrix.vw_risorse OWNER TO postgres;

--
-- Name: vw_stabilimenti; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_stabilimenti AS
 SELECT m.id,
    m.id_impresa,
    m.riferimento_id,
    m.riferimento_id_nome_tab,
    m.riferimento_id_impresa,
    m.riferimento_nome_tab_impresa,
    m.ragione_sociale,
    m.asl_rif,
    m.asl,
    m.codice_fiscale,
    m.codice_fiscale_rappresentante,
    m.partita_iva,
    m.n_reg,
    m.nominativo_rappresentante,
    m.comune,
    m.provincia_stab,
    m.indirizzo,
    m.cap_stab,
    m.comune_leg,
    m.provincia_leg,
    m.indirizzo_leg,
    m.cap_leg,
    m.latitudine_stab,
    m.longitudine_stab,
    m.categoria_rischio,
    m.prossimo_controllo,
    m.id_controllo_ultima_categorizzazione,
    m.data_controllo_ultima_categorizzazione,
    m.tipo_categorizzazione,
    m.data_inserimento,
    m.livello_rischio,
    m.tipologia,
    m.categoria_rischio_qualitativa,
    m.approval_number,
    m.impresa_id_opu,
    m.stabilimento_id_opu,
    m.impresa_id_organization,
    m.stabilimento_id_organization
   FROM matrix.stabilimenti m;


ALTER TABLE matrix.vw_stabilimenti OWNER TO postgres;

--
-- Name: vw_stabilimenti_linee; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_stabilimenti_linee AS
 SELECT m.id,
    m.id_stabilimento,
    m.id_attivita,
    m.id_linea,
    m.riferimento_id,
    m.riferimento_id_nome_tab,
    m.num_riconoscimento,
    m.n_linea,
    m.data_inizio_attivita,
    m.data_fine_attivita,
    m.macroarea,
    m.aggregazione,
    m.attivita,
    m.path_attivita_completo,
    m.norma,
    m.id_norma,
    m.codice_macroarea,
    m.codice_aggregazione,
    m.codice_attivita,
    m.stato,
    m.id_stato,
    m.miscela,
    m.tipo_attivita_descrizione,
    m.tipo_attivita,
    m.sintesis
   FROM matrix.stabilimenti_linee m;


ALTER TABLE matrix.vw_stabilimenti_linee OWNER TO postgres;

--
-- Name: vw_struttura_piani_ref_no_rend_new; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_struttura_piani_ref_no_rend_new AS
 WITH RECURSIVE p_r(id, id_gisa, cod_raggruppamento, anno, descrizione, ordinamento, data_scadenza, stato, codice_interno, color, livello, parent, alias, id_formula_ups, id_formula_uba, fattore_ups, fattore_uba, descrizione_breve, id_ref) AS (
         SELECT struttura_piani.id,
            struttura_piani.id_gisa,
            struttura_piani.cod_raggruppamento,
            struttura_piani.anno,
            struttura_piani.descrizione,
            struttura_piani.ordinamento,
            struttura_piani.data_scadenza,
            struttura_piani.stato,
            struttura_piani.codice_interno,
            struttura_piani.color,
            struttura_piani.livello,
            struttura_piani.p_id AS parent,
            struttura_piani.alias,
            pp.id_formula_ups,
            pp.id_formula_uba,
            fu.fattore_fin AS fattore_ups,
            fb.fattore_fin AS fattore_uba,
            pp.descrizione_breve,
            struttura_piani.id AS id_ref
           FROM (((matrix.vw_tree_nodes_piani_descr struttura_piani
             JOIN matrix.struttura_piani pp ON ((pp.id = struttura_piani.id)))
             LEFT JOIN matrix.formule fu ON ((fu.id = pp.id_formula_ups)))
             LEFT JOIN matrix.formule fb ON ((fb.id = pp.id_formula_uba)))
        UNION ALL
         SELECT p_r_1.id,
            p_r_1.id_gisa,
            p2.cod_raggruppamento,
            p2.anno,
            p2.descrizione,
            p2.ordinamento,
            p2.data_scadenza,
            p2.stato,
            p2.codice_interno,
            p2.color,
            p2.livello,
            p.p_id AS parent,
            p2.alias,
            pp2.id_formula_ups,
            pp2.id_formula_uba,
            p_r_1.fattore_ups,
            p_r_1.fattore_uba,
            pp2.descrizione_breve,
            p.p_id AS parent
           FROM (((matrix.vw_tree_nodes_piani_descr p
             JOIN matrix.struttura_piani pp2 ON ((pp2.id = p.id)))
             JOIN p_r p_r_1 ON ((p_r_1.id_ref = p.id)))
             JOIN matrix.vw_tree_nodes_piani_descr p2 ON ((p.p_id = p2.id)))
          WHERE (p.p_id IS NOT NULL)
        )
 SELECT p_r.id,
    p_r.id_gisa,
    p_r.cod_raggruppamento,
    p_r.anno,
    p_r.descrizione,
    p_r.ordinamento,
    p_r.data_scadenza,
    p_r.stato,
    p_r.codice_interno,
    p_r.color,
    p_r.livello,
    p_r.parent,
    p_r.alias,
    p_r.id_formula_ups,
    p_r.id_formula_uba,
    p_r.fattore_ups,
    p_r.fattore_uba,
    p_r.descrizione_breve,
    p_r.id_ref
   FROM p_r;


ALTER TABLE matrix.vw_struttura_piani_ref_no_rend_new OWNER TO postgres;

--
-- Name: vw_struttura_piano_impegnato_tree; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_struttura_piano_impegnato_tree AS
 SELECT ps.id_node_parent AS id_struttura,
    pp.descrizione,
    d.id_node_ref,
    u.path_ord,
    sum(t.target) AS sum,
    sum((t.target * p.fattore_ups)) AS target_ups,
    sum((t.target * p.fattore_uba)) AS target_uba
   FROM (((((matrix.struttura_piano_target t
     JOIN matrix.vw_tree_nodes_down d ON ((t.id_piano = d.id_node)))
     JOIN matrix.vw_struttura_piani p ON ((d.id_node = p.id)))
     JOIN matrix.vw_struttura_piani pp ON ((d.id_node_ref = pp.id)))
     JOIN matrix.vw_tree_nodes_up_piani u ON ((u.id_node = pp.id)))
     JOIN matrix.vw_tree_nodes ps ON ((t.id_struttura = ps.id_node)))
  WHERE ((p.data_scadenza IS NULL) OR (p.data_scadenza > now()))
  GROUP BY ps.id_node_parent, pp.descrizione, d.id_node_ref, u.path_ord
  ORDER BY u.path_ord;


ALTER TABLE matrix.vw_struttura_piano_impegnato_tree OWNER TO postgres;

--
-- Name: vw_struttura_piano_target_tree; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_struttura_piano_target_tree AS
 SELECT t.id_struttura,
    pp.descrizione,
    d.id_node_ref,
    u.path_ord,
    sum(t.target) AS sum,
    sum((t.target * p.fattore_ups)) AS target_ups,
    sum((t.target * p.fattore_uba)) AS target_uba
   FROM ((((matrix.struttura_piano_target t
     JOIN matrix.vw_tree_nodes_down d ON ((t.id_piano = d.id_node)))
     JOIN matrix.vw_struttura_piani p ON ((d.id_node = p.id)))
     JOIN matrix.vw_struttura_piani pp ON ((d.id_node_ref = pp.id)))
     JOIN matrix.vw_tree_nodes_up_piani u ON ((u.id_node = pp.id)))
  WHERE ((p.data_scadenza IS NULL) OR (p.data_scadenza > now()))
  GROUP BY t.id_struttura, pp.descrizione, d.id_node_ref, u.path_ord
  ORDER BY u.path_ord;


ALTER TABLE matrix.vw_struttura_piano_target_tree OWNER TO postgres;

--
-- Name: vw_struttura_piano_target_tree_no_rend; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_struttura_piano_target_tree_no_rend AS
 SELECT t.id_struttura,
    pp.descrizione,
    d.id_node_ref,
    u.path_ord,
    sum(t.target) AS sum,
    sum((t.target * p.fattore_ups)) AS target_ups,
    sum((t.target * p.fattore_uba)) AS target_uba
   FROM ((((matrix.struttura_piano_target t
     JOIN matrix.vw_tree_nodes_down d ON ((t.id_piano = d.id_node)))
     JOIN matrix.vw_struttura_piani p ON ((d.id_node = p.id)))
     JOIN matrix.vw_struttura_piani pp ON ((d.id_node_ref = pp.id)))
     JOIN matrix.vw_tree_nodes_up_piani u ON ((u.id_node = pp.id)))
  WHERE (NOT (t.id_piano IN ( SELECT struttura_piani.id
           FROM matrix.struttura_piani
          WHERE (struttura_piani.id_gisa IN ( SELECT r.id_piano
                   FROM "Analisi_dev".piani_no_rend r)))))
  GROUP BY t.id_struttura, pp.descrizione, d.id_node_ref, u.path_ord
  ORDER BY u.path_ord;


ALTER TABLE matrix.vw_struttura_piano_target_tree_no_rend OWNER TO postgres;

--
-- Name: vw_strutture_appartenenza_by_nominativo; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_strutture_appartenenza_by_nominativo AS
 SELECT DISTINCT (ns.id)::integer AS id_origin,
    (ns2.id)::integer AS id,
    upper(((nv.desc_strutt_complessa || '->'::text) || sa.descrizione_breve)) AS uos
   FROM ((((((matrix.nominativi_struttura ns
     JOIN matrix.nominativi n ON ((n.id = ns.id_nominativo)))
     JOIN matrix.nominativi n2 ON ((n2.id_anagrafica = n.id_anagrafica)))
     JOIN matrix.nominativi_struttura ns2 ON ((n2.id = ns2.id_nominativo)))
     JOIN "Analisi_dev".vw_dpat_get_nominativi_validi nv ON ((nv.id_nominativo = n2.id_nominativo_gisa)))
     JOIN "Analisi_dev".vw_dpat_get_nominativi_validi nv2 ON ((nv2.id_nominativo = n.id_nominativo_gisa)))
     JOIN matrix.struttura_asl sa ON (((sa.id_gisa = nv.id_struttura_semplice) AND (sa.anno = nv.anno) AND (nv2.anno = nv.anno))))
  ORDER BY ((ns2.id)::integer);


ALTER TABLE matrix.vw_strutture_appartenenza_by_nominativo OWNER TO postgres;

--
-- Name: vw_tree_anno; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_anno AS
 SELECT t.name,
    ta.anno,
    ta.id_tree,
    ta.id_root AS root_id
   FROM (matrix.tree_anno ta
     JOIN matrix.trees t ON ((ta.id_tree = t.id)));


ALTER TABLE matrix.vw_tree_anno OWNER TO postgres;

--
-- Name: vw_tree_nodes_down_asl; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_down_asl AS
 SELECT vw_tree_nodes_down.name_tree,
    vw_tree_nodes_down.id_node,
    vw_tree_nodes_down.id_tree,
    vw_tree_nodes_down.id_node_parent,
    vw_tree_nodes_down.id_node_ref
   FROM matrix.vw_tree_nodes_down
  WHERE ((vw_tree_nodes_down.name_tree)::text = 'Struttura ASL'::text);


ALTER TABLE matrix.vw_tree_nodes_down_asl OWNER TO postgres;

--
-- Name: vw_tree_nodes_down_asl_descr; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_down_asl_descr AS
 SELECT d.name_tree,
    d.id_node,
    d.id_tree,
    d.id_node_parent,
    d.id_node_ref,
    a.id,
    a.id_gisa,
    a.id_asl,
    a.codice_interno_fk,
    a.descrizione,
    a.n_livello,
    a.anno,
    a.descrizione_breve,
    a.ups,
    a.uba,
    upper(d.validita) AS data_scadenza,
    ((upper(d.validita))::character varying)::timestamp with time zone AS trashed_date,
    d.validita,
    d.ordinamento,
    lower(d.validita) AS inizio_validita,
    upper(d.validita) AS fine_validita
   FROM (matrix.vw_tree_nodes_down d
     JOIN matrix.struttura_asl a ON ((a.id = d.id_node)))
  WHERE ((a.id_asl <> 14) OR (a.id_asl IS NULL));


ALTER TABLE matrix.vw_tree_nodes_down_asl_descr OWNER TO postgres;

--
-- Name: vw_tree_nodes_down_piani; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_down_piani AS
 SELECT vw_tree_nodes_down.name_tree,
    vw_tree_nodes_down.id_node,
    vw_tree_nodes_down.id_tree,
    vw_tree_nodes_down.id_node_parent,
    vw_tree_nodes_down.id_node_ref
   FROM matrix.vw_tree_nodes_down
  WHERE ((vw_tree_nodes_down.name_tree)::text = 'Struttura Piani'::text);


ALTER TABLE matrix.vw_tree_nodes_down_piani OWNER TO postgres;

--
-- Name: vw_tree_nodes_down_piani_descr; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_down_piani_descr AS
 SELECT d.name_tree,
    d.id_node,
    d.id_tree,
    d.id_node_parent,
    d.id_node_ref,
    p2.path_ord,
    p2.path_descr,
    p2.id,
    p2.id_gisa,
    p2.cod_raggruppamento,
    p2.anno,
    p2.descrizione,
    p2.ordinamento,
    p2.data_scadenza,
    p2.stato,
    p2.codice_interno,
    p2.color,
    p2.path,
    p2.livello,
    p2.alias,
    p2.id_formula_ups,
    p2.id_formula_uba,
    p2.descrizione_breve,
    p2.codice_interno_univoco,
    p2.ha_campioni,
    p2.id_tipo_tecnica,
    p.path_ord AS r_path_ord,
    p.path_descr AS r_path_descr,
    p.id AS r_id,
    p.id_gisa AS r_id_gisa,
    p.cod_raggruppamento AS r_cod_raggruppamento,
    p.anno AS r_anno,
    p.descrizione AS r_descrizione,
    p.ordinamento AS r_ordinamento,
    p.data_scadenza AS r_data_scadenza,
    p.stato AS r_stato,
    p.codice_interno AS r_codice_interno,
    p.color AS r_color,
    p.path AS r_path,
    p.livello AS r_livello,
    p.alias AS r_alias,
    p.id_formula_ups AS r_id_formula_ups,
    p.id_formula_uba AS r_id_formula_uba,
    p.descrizione_breve AS r_descrizione_breve,
    p.codice_interno_univoco AS r_codice_interno_univoco,
    p.ha_campioni AS r_ha_campioni,
    p.id_tipo_tecnica AS r_id_tipo_tecnica
   FROM ((matrix.vw_tree_nodes_down_piani d
     JOIN matrix.vw_tree_nodes_up_piani p ON ((p.id_node = d.id_node_ref)))
     JOIN matrix.vw_tree_nodes_up_piani p2 ON ((p2.id_node = d.id_node)))
  ORDER BY p.path_ord;


ALTER TABLE matrix.vw_tree_nodes_down_piani_descr OWNER TO postgres;

--
-- Name: vw_tree_nodes_tariffario; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_tariffario AS
 SELECT vw_tree_nodes.name_tree,
    vw_tree_nodes.id_node,
    vw_tree_nodes.id_tree,
    vw_tree_nodes.id_node_parent,
    vw_tree_nodes.ordinamento
   FROM matrix.vw_tree_nodes
  WHERE ((vw_tree_nodes.name_tree)::text = 'Tariffario'::text);


ALTER TABLE matrix.vw_tree_nodes_tariffario OWNER TO postgres;

--
-- Name: vw_tree_nodes_tariffario_descr; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_tariffario_descr AS
 SELECT ta.name_tree,
    ta.id_node,
    ta.id_tree,
    ta.id_node_parent,
    a.id_tariffa,
    a.id_tariffario,
    a.sigla_tariffa,
    a.descr_tariffa,
    a.asl,
    a.valido_da,
    a.valido_a,
    ap.id_tariffa AS p_id_tariffa,
    ap.sigla_tariffa AS p_sigla_tariffa,
    ap.descr_tariffa AS p_descr_tariffa,
    ta.ordinamento,
    a.visibile_trf,
    a.visibile_fatt,
    up.path_ord,
    a.limite_inf,
    a.limite_sup,
    a.limiti,
    a.descr_con_u_mis
   FROM (((matrix.vw_tree_nodes_tariffario ta
     JOIN trf.vw_tariffe a ON ((a.id = ta.id_node)))
     LEFT JOIN trf.vw_tariffe ap ON ((ap.id = ta.id_node_parent)))
     LEFT JOIN matrix.vw_tree_nodes_up up ON ((up.id_node = ta.id_node)));


ALTER TABLE matrix.vw_tree_nodes_tariffario_descr OWNER TO postgres;

--
-- Name: vw_tree_nodes_up_tariffario; Type: VIEW; Schema: matrix; Owner: postgres
--

CREATE VIEW matrix.vw_tree_nodes_up_tariffario AS
 SELECT vw_tree_nodes_up.name_tree,
    vw_tree_nodes_up.id_node,
    vw_tree_nodes_up.id_tree,
    vw_tree_nodes_up.id_node_parent,
    vw_tree_nodes_up.path,
    vw_tree_nodes_up.path_ord,
    vw_tree_nodes_up.path_descr,
    a.id_tariffa,
    a.id_tariffario,
    a.sigla_tariffa,
    a.descr_tariffa,
    a.asl,
    a.valido_da,
    a.valido_a,
    vw_tree_nodes_up.lv,
    vw_tree_nodes_up.lv AS lev,
    a.visibile_trf,
    a.visibile_fatt,
    a.visibile_piani,
    a.visibile_contabilita,
    a.valido_da_tariffa,
    a.valido_a_tariffa
   FROM (matrix.vw_tree_nodes_up
     JOIN trf.vw_tariffe a ON ((vw_tree_nodes_up.id_node = a.id)))
  WHERE ((vw_tree_nodes_up.name_tree)::text = 'Tariffario'::text);


ALTER TABLE matrix.vw_tree_nodes_up_tariffario OWNER TO postgres;

--
-- Name: bck_load_eventi_associti_2024_03_24; Type: TABLE; Schema: prog_2024; Owner: postgres
--

CREATE TABLE prog_2024.bck_load_eventi_associti_2024_03_24 (
    id_nominativo bigint,
    id_tipo_evento integer,
    inizio timestamp without time zone,
    fine timestamp without time zone,
    id_linea bigint,
    id_attivita integer,
    id_piano integer,
    effettuata boolean,
    id_partner bigint,
    valido_da timestamp without time zone,
    valido_a timestamp without time zone,
    per_conto bigint,
    id_elab integer,
    id_cu integer,
    partner_per_conto integer,
    validita_interna boolean,
    quantita integer
);


ALTER TABLE prog_2024.bck_load_eventi_associti_2024_03_24 OWNER TO postgres;

--
-- Name: ispettori; Type: TABLE; Schema: prog_2024; Owner: postgres
--

CREATE TABLE prog_2024.ispettori (
    nome text,
    ruolo text,
    id_ruolo bigint,
    id_utente bigint,
    username text,
    codice_interno_struttura bigint,
    id_asl integer,
    password text,
    codice_fiscale text
);


ALTER TABLE prog_2024.ispettori OWNER TO postgres;

--
-- Name: ispettori_2; Type: TABLE; Schema: prog_2024; Owner: postgres
--

CREATE TABLE prog_2024.ispettori_2 (
    nome text,
    ruolo text,
    id_ruolo bigint,
    id_utente bigint,
    username text,
    codice_interno_struttura bigint,
    id_asl integer,
    password text,
    codice_fiscale text
);


ALTER TABLE prog_2024.ispettori_2 OWNER TO postgres;

--
-- Name: liste; Type: TABLE; Schema: prog_2024; Owner: postgres
--

CREATE TABLE prog_2024.liste (
    id_ua integer,
    asl character varying,
    nome character varying,
    cod_regionale character varying,
    controllore_programmato character varying,
    c1 character varying,
    c2 character varying
);


ALTER TABLE prog_2024.liste OWNER TO postgres;

--
-- Name: vw_load_eventi_associti; Type: VIEW; Schema: prog_2024; Owner: postgres
--

CREATE VIEW prog_2024.vw_load_eventi_associti AS
 SELECT l.id_nominativo,
    1 AS id_tipo_evento,
    lower(d.dd) AS inizio,
    upper(d.dd) AS fine,
    l.id_linea,
    '-1'::integer AS id_attivita,
    l.id_piano,
    false AS effettuata,
    NULL::text AS id_partner,
    NULL::text AS valido_da,
    NULL::text AS valido_a,
    l.id_struttura AS per_conto,
    '-1'::integer AS id_elab,
    NULL::text AS id_cu,
    NULL::text AS partner_per_conto,
    true AS validita_interna,
    1 AS quantita
   FROM (( SELECT ns.id_nominativo,
            row_number() OVER (PARTITION BY ns.id_nominativo) AS prog,
            ln.id AS id_linea,
            ptl.id_piano,
            sc.id_struttura
           FROM ((((((((cu_anag.vw_stabilimenti s
             JOIN prog_2024.liste l_1 ON (((l_1.id_ua)::numeric = s.sd_id)))
             JOIN cu_anag.linee ln ON (((ln.id_stabilimento = s.id) AND ln.linea_principale)))
             JOIN agenda.piano_tipo_linea ptl ON ((ptl.id_tipo_linea = ln.id_tipo_linea)))
             JOIN matrix.struttura_piani sp ON (((sp.id = ptl.id_piano) AND (sp.alias ~~ 'C5%'::text))))
             JOIN agenda.comuni c ON (((c.istat_comune)::text = (s.istat)::text)))
             JOIN agenda.vw_struttura_comuni sc ON (((sc.id_comune = c.id) AND (sc.descrizione_breve ~~* '%VET%B%'::text) AND (sc.anno = 2024) AND (NOT (sc.id_struttura IN ( SELECT vw_tree_nodes_up_asl.id_node_parent
                   FROM matrix.vw_tree_nodes_up_asl
                  WHERE (vw_tree_nodes_up_asl.id_node_parent IS NOT NULL)))))))
             JOIN prog_2024.ispettori i ON ((upper((l_1.controllore_programmato)::text) = upper(i.username))))
             JOIN matrix.vw_nominativi_struttura ns ON ((ns.id_anagrafica = i.id_utente)))
          WHERE (((l_1.c2)::text = ANY (ARRAY[('AOA'::character varying)::text, ('PESCHERECCI'::character varying)::text, ('MALGHE'::character varying)::text])) AND (sc.descrizione_breve !~~* '%dipartimentale%'::text))) l
     JOIN ( SELECT row_number() OVER (ORDER BY d_1.d) AS prog,
            tsrange(((d_1.d)::timestamp without time zone + '08:00:00'::interval), ((d_1.d)::timestamp without time zone + '11:00:00'::interval), '[)'::text) AS dd
           FROM generate_series('2024-03-25 00:00:00+01'::timestamp with time zone, '2024-12-31 00:00:00+01'::timestamp with time zone, '1 day'::interval) d_1(d)
          WHERE ((NOT (d_1.d IN ( SELECT festivita.dt
                   FROM agenda.festivita))) AND (EXTRACT(dow FROM d_1.d) >= (1)::numeric) AND (EXTRACT(dow FROM d_1.d) <= (5)::numeric))) d ON ((d.prog = l.prog)));


ALTER TABLE prog_2024.vw_load_eventi_associti OWNER TO postgres;

--
-- Name: _latest_categ; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public._latest_categ (
    dt_storico timestamp without time zone
);


ALTER TABLE public._latest_categ OWNER TO postgres;

--
-- Name: automezzi_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.automezzi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.automezzi_id_seq OWNER TO postgres;

--
-- Name: az_presente_bdn; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.az_presente_bdn (
    cod_azienda character varying
);


ALTER TABLE public.az_presente_bdn OWNER TO postgres;

--
-- Name: c; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.c (
    count bigint
);


ALTER TABLE public.c OWNER TO postgres;

--
-- Name: idcu; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.idcu (
    id_cu bigint
);


ALTER TABLE public.idcu OWNER TO postgres;

--
-- Name: idpermesso; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.idpermesso (
    id_permesso bigint
);


ALTER TABLE public.idpermesso OWNER TO postgres;

--
-- Name: idroot; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.idroot (
    id_categorizzazione_rischio bigint
);


ALTER TABLE public.idroot OWNER TO postgres;

--
-- Name: idstruttura_uoc; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.idstruttura_uoc (
    id_node_parent bigint
);


ALTER TABLE public.idstruttura_uoc OWNER TO postgres;

--
-- Name: ind_esiste; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ind_esiste (
    count bigint
);


ALTER TABLE public.ind_esiste OWNER TO postgres;

--
-- Name: istat_cap; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.istat_cap (
    istat text,
    cap text
);


ALTER TABLE public.istat_cap OWNER TO postgres;

--
-- Name: j_piani; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.j_piani (
    replace json
);


ALTER TABLE public.j_piani OWNER TO postgres;

--
-- Name: j_stabilimento; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.j_stabilimento (
    "Insegna" text,
    "CodTipologiaStruttura" text,
    "Indirizzo" text,
    "Comune" character varying
);


ALTER TABLE public.j_stabilimento OWNER TO postgres;

--
-- Name: j_user_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.j_user_info (
    row_to_json json
);


ALTER TABLE public.j_user_info OWNER TO postgres;

--
-- Name: livelli_rischio; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.livelli_rischio (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    descr character varying NOT NULL,
    ord integer
);


ALTER TABLE public.livelli_rischio OWNER TO postgres;

--
-- Name: livelli_rishio_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.livelli_rishio_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.livelli_rishio_id_seq OWNER TO postgres;

--
-- Name: livelli_rishio_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.livelli_rishio_id_seq OWNED BY public.livelli_rischio.id;


--
-- Name: master_list_allevamenti; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.master_list_allevamenti (
    id_attivita integer,
    macroarea text,
    gruppo_specie text,
    att text
);


ALTER TABLE public.master_list_allevamenti OWNER TO postgres;

--
-- Name: mater_list_allevamenti_full; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.mater_list_allevamenti_full (
    macroarea text,
    aggregazione text,
    attivita text,
    specie text,
    tipo text,
    gruppo_specie text,
    att text
);


ALTER TABLE public.mater_list_allevamenti_full OWNER TO postgres;

--
-- Name: ml_allev_da_gisa; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ml_allev_da_gisa (
    id integer,
    descr text,
    cod text,
    path_ord text,
    path_descr text,
    id_node_parent integer,
    lev integer,
    ordinamento character varying,
    path_cod character varying
);


ALTER TABLE public.ml_allev_da_gisa OWNER TO postgres;

--
-- Name: ml_allevamenti_lev_1; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ml_allevamenti_lev_1 (
    id bigint,
    id_parent text,
    descr text
);


ALTER TABLE public.ml_allevamenti_lev_1 OWNER TO postgres;

--
-- Name: ml_allevamenti_lev_2; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ml_allevamenti_lev_2 (
    id bigint,
    id_parent bigint,
    descr text
);


ALTER TABLE public.ml_allevamenti_lev_2 OWNER TO postgres;

--
-- Name: n; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.n (
    count bigint
);


ALTER TABLE public.n OWNER TO postgres;

--
-- Name: n_ev; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.n_ev (
    count bigint
);


ALTER TABLE public.n_ev OWNER TO postgres;

--
-- Name: n_gruppi_foglie; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.n_gruppi_foglie (
    count bigint
);


ALTER TABLE public.n_gruppi_foglie OWNER TO postgres;

--
-- Name: n_pratiche; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.n_pratiche (
    count bigint
);


ALTER TABLE public.n_pratiche OWNER TO postgres;

--
-- Name: nominativi_struttura; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.nominativi_struttura AS
 SELECT us.id,
    us.id_nominativo,
    us.id_struttura,
    u.nominativo,
    a.descrizione_breve,
    a.id AS id_node_struttura,
    u.id_utente AS id_anagrafica,
    a.anno,
    a.codice_interno_fk,
    a.descrizione,
    (u.cf)::text AS codice_fiscale,
    a.id_asl
   FROM ((rbac.utente_strutture us
     JOIN rbac.vw_utenti u ON ((u.id = us.id_utente)))
     JOIN matrix.struttura_asl a ON ((a.id = us.id_struttura)))
  WHERE ((u.id_asl)::integer > 0);


ALTER TABLE public.nominativi_struttura OWNER TO postgres;

--
-- Name: r_att; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.r_att (
    id bigint,
    id_cliente bigint,
    id_servizio bigint,
    data_da timestamp without time zone,
    data_a timestamp without time zone,
    id_trf_operatore bigint,
    note character varying,
    imponibile character varying,
    id_tariffa bigint,
    per_conto_di bigint,
    id_ref_attivita bigint,
    id_type_attivita character varying,
    closed boolean,
    data_closed timestamp without time zone,
    id_fattura bigint
);


ALTER TABLE public.r_att OWNER TO postgres;

--
-- Name: r_cun; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.r_cun (
    id_cu_nucleo bigint,
    id bigint,
    id_cu bigint,
    id_ns bigint,
    ord character varying,
    id_tipo_isp bigint,
    nominativo text,
    id_tipo_nucleo integer,
    sigla_tipo_nucleo character varying,
    descr_tipo_nucleo character varying,
    ruolo text,
    sigla_tipo_isp character varying,
    id_nominativo bigint,
    per_conto_di bigint,
    sigla_per character varying,
    descr_per character varying,
    id_tipo_per bigint
);


ALTER TABLE public.r_cun OWNER TO postgres;

--
-- Name: r_ns; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.r_ns (
    id integer,
    id_nominativo bigint,
    id_struttura bigint,
    nominativo text,
    descrizione_breve text,
    id_node_struttura bigint,
    id_anagrafica bigint,
    anno integer,
    codice_interno_fk bigint,
    descrizione text
);


ALTER TABLE public.r_ns OWNER TO postgres;

--
-- Name: rec; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rec (
    indirizzo_azienda character varying,
    cap_azienda character varying,
    codistat integer,
    latitudine double precision,
    longitudine double precision,
    data_chius_azienda timestamp without time zone
);


ALTER TABLE public.rec OWNER TO postgres;

--
-- Name: role_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.role_info (
    role_id integer,
    role_descr character varying,
    responsabile boolean,
    livello integer,
    qualifica character varying
);


ALTER TABLE public.role_info OWNER TO postgres;

--
-- Name: rt; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rt (
    json_agg json
);


ALTER TABLE public.rt OWNER TO postgres;

--
-- Name: rt_cu_categ; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rt_cu_categ (
    row_to_json json
);


ALTER TABLE public.rt_cu_categ OWNER TO postgres;

--
-- Name: shell; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.shell (
    res character varying
);


ALTER TABLE public.shell OWNER TO postgres;

--
-- Name: ui_def; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ui_def (
    id bigint,
    funct character varying,
    id_user bigint,
    type_user character varying,
    str_conf character varying,
    note character varying,
    sigla character varying
);


ALTER TABLE public.ui_def OWNER TO postgres;

--
-- Name: v_data; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.v_data (
    btrim text
);


ALTER TABLE public.v_data OWNER TO postgres;

--
-- Name: v_piani; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.v_piani (
    replace text
);


ALTER TABLE public.v_piani OWNER TO postgres;

--
-- Name: vl; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.vl (
    max timestamp without time zone
);


ALTER TABLE public.vl OWNER TO postgres;

--
-- Name: vw_imprese_all; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.vw_imprese_all AS
 SELECT i.id AS id_impresa,
    i.id,
    COALESCE(i.nome, (sf.nome_completo)::character varying) AS nome,
    i.cf,
    (regexp_replace((i.piva)::text, '^IT'::text, ''::text))::character varying AS piva,
    i.pec,
    i.email,
    i.sdi,
    i.split_payement,
    i.cod_tipo_impresa,
    i.az_id,
    i.az_cod_aziendale,
    i.az_cod_regionale,
    i.sd_id,
    i.verificato,
    i.fonte,
    sf.cognome,
    sf.nome AS soggetto_fisico_nome,
    lower(i.validita) AS inizio_validita,
    (upper(i.validita) - '1 day'::interval) AS fine_validita,
    i.validita,
    NULL::bigint AS id_asl,
    sf.telefono,
    sf.data_nascita,
    sf.comune_nascita,
    sf.istat_nascita,
    sf.indirizzo_id AS id_indirizzo,
    i.tipo_soggetto,
    ti.descr AS descr_tipo_impresa,
    upper_inf(i.validita) AS modificabile,
    sf.comune_nascita_descr
   FROM ((cu_anag.imprese i
     LEFT JOIN cu_types.vw_cu_tipo_imprese ti ON (((i.cod_tipo_impresa)::text = (ti.cod)::text)))
     LEFT JOIN cu_anag.vw_soggetti_fisici sf ON ((((i.tipo_soggetto)::text = 'F'::text) AND ((i.cf)::text = (sf.codice_fiscale)::text) AND (i.cf IS NOT NULL))));


ALTER TABLE public.vw_imprese_all OWNER TO postgres;

--
-- Name: vw_livelli_rischio; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.vw_livelli_rischio AS
 SELECT livelli_rischio.id,
    livelli_rischio.id AS id_livello_rischio,
    livelli_rischio.cod AS cod_livello_rischio,
    livelli_rischio.descr AS descr_livello_rischio,
    livelli_rischio.ord AS ord_livello_rischio
   FROM public.livelli_rischio;


ALTER TABLE public.vw_livelli_rischio OWNER TO postgres;

--
-- Name: vw_master_list_allevamenti; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.vw_master_list_allevamenti AS
 SELECT master_list_allevamenti.id_attivita,
    master_list_allevamenti.macroarea,
    master_list_allevamenti.gruppo_specie,
    ((master_list_allevamenti.gruppo_specie || ' - '::text) || master_list_allevamenti.att) AS att,
    l2.id AS id_parent
   FROM (public.master_list_allevamenti
     JOIN public.ml_allevamenti_lev_2 l2 ON ((l2.descr = master_list_allevamenti.gruppo_specie)));


ALTER TABLE public.vw_master_list_allevamenti OWNER TO postgres;

--
-- Name: vw_master_list_allevamenti_full; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.vw_master_list_allevamenti_full AS
 SELECT mlaf.macroarea,
    mlaf.aggregazione,
    mlaf.attivita,
    mlaf.specie,
    mlaf.tipo,
    mlaf.gruppo_specie,
    mlaf.att,
    ml.id_attivita,
    l2.id AS id_parent
   FROM ((public.mater_list_allevamenti_full mlaf
     JOIN public.ml_allevamenti_lev_2 l2 ON ((l2.descr = mlaf.gruppo_specie)))
     JOIN public.vw_master_list_allevamenti ml ON (((ml.macroarea = mlaf.macroarea) AND (ml.gruppo_specie = mlaf.gruppo_specie) AND (ml.att = ((mlaf.gruppo_specie || ' - '::text) || mlaf.att)))));


ALTER TABLE public.vw_master_list_allevamenti_full OWNER TO postgres;

--
-- Name: vw_ml_allev; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.vw_ml_allev AS
 SELECT ml_allev_da_gisa.id,
    ml_allev_da_gisa.descr,
    ml_allev_da_gisa.cod,
    ml_allev_da_gisa.path_ord,
    ml_allev_da_gisa.path_descr,
    ml_allev_da_gisa.id_node_parent,
    ml_allev_da_gisa.lev,
    ml_allev_da_gisa.ordinamento,
    ml_allev_da_gisa.path_cod
   FROM public.ml_allev_da_gisa;


ALTER TABLE public.vw_ml_allev OWNER TO postgres;

--
-- Name: config_adhoc; Type: TABLE; Schema: ra; Owner: postgres
--

CREATE TABLE ra.config_adhoc (
    id integer,
    cod_raggruppamento bigint,
    motivo boolean,
    query character varying,
    enabled boolean,
    alias character varying,
    descr character varying
);


ALTER TABLE ra.config_adhoc OWNER TO postgres;

--
-- Name: config_iuv; Type: TABLE; Schema: ra; Owner: postgres
--

CREATE TABLE ra.config_iuv (
    id integer,
    cod_raggruppamento bigint,
    motivo boolean,
    query character varying,
    enabled boolean,
    alias character varying,
    descr character varying
);


ALTER TABLE ra.config_iuv OWNER TO postgres;

--
-- Name: estrazioni; Type: TABLE; Schema: ra; Owner: postgres
--

CREATE TABLE ra.estrazioni (
    id bigint,
    report character varying,
    descr character varying,
    query character varying,
    enabled boolean,
    note character varying,
    filename character varying,
    date_filter boolean,
    date_end_filter boolean,
    asl_filter boolean
);


ALTER TABLE ra.estrazioni OWNER TO postgres;

--
-- Name: h_gisa_controlli_ufficiali; Type: TABLE; Schema: ra; Owner: postgres
--

CREATE TABLE ra.h_gisa_controlli_ufficiali (
    id_controllo bigint,
    codice_linea text,
    id_motivo bigint,
    id_unita_operativa bigint,
    data_inizio_controllo timestamp without time zone,
    riferimento_id bigint,
    riferimento_nome_tab text,
    eseguiti bigint,
    fonte text,
    rng int8range
);


ALTER TABLE ra.h_gisa_controlli_ufficiali OWNER TO postgres;

--
-- Name: lookup_norme; Type: TABLE; Schema: ra; Owner: postgres
--

CREATE TABLE ra.lookup_norme (
    norma text,
    id_norma integer
);


ALTER TABLE ra.lookup_norme OWNER TO postgres;

--
-- Name: mvw_adhoc; Type: TABLE; Schema: ra; Owner: postgres
--

CREATE TABLE ra.mvw_adhoc (
    id_asl integer,
    cod_raggruppamento integer,
    data timestamp without time zone,
    eseguiti bigint,
    fonte integer
);


ALTER TABLE ra.mvw_adhoc OWNER TO postgres;

--
-- Name: mvw_get_campioni_validi; Type: MATERIALIZED VIEW; Schema: ra; Owner: postgres
--

CREATE MATERIALIZED VIEW ra.mvw_get_campioni_validi AS
 SELECT vw_get_campioni_validi.id_asl,
    vw_get_campioni_validi.asl,
    vw_get_campioni_validi.motivazione_campione,
    vw_get_campioni_validi.id_piano,
    vw_get_campioni_validi.id_attivita,
    vw_get_campioni_validi.id_campione,
    vw_get_campioni_validi.data_prelievo,
    vw_get_campioni_validi.identificativo_campione,
    vw_get_campioni_validi.prelevatore_1_a4,
    vw_get_campioni_validi.prelevatore_2_a4,
    vw_get_campioni_validi.prelevatore_3_a4,
    vw_get_campioni_validi.strategia_campionamento_a1,
    vw_get_campioni_validi.capitoli_piani_a3,
    vw_get_campioni_validi.specie_alimento_b6,
    vw_get_campioni_validi.metodo_produzione_b7,
    vw_get_campioni_validi.anno_campione,
    vw_get_campioni_validi.data_chiusura_campione,
    vw_get_campioni_validi.id_controllo_ufficiale,
    vw_get_campioni_validi.esito,
    vw_get_campioni_validi.punteggio_campione,
    vw_get_campioni_validi.responsabilita_positiva,
    vw_get_campioni_validi.data_esito_analita,
    vw_get_campioni_validi.esito_motivazione_respingimento,
    vw_get_campioni_validi.note_esito_campione,
    vw_get_campioni_validi.codice_accettazione,
    vw_get_campioni_validi.num_verbale,
    vw_get_campioni_validi.barcode,
    vw_get_campioni_validi.analita_lev_1,
    vw_get_campioni_validi.analita_lev_2,
    vw_get_campioni_validi.analita_lev_3,
    vw_get_campioni_validi.analita_lev_4,
    vw_get_campioni_validi.matrice_lev_1,
    vw_get_campioni_validi.matrice_lev_2,
    vw_get_campioni_validi.matrice_lev_3,
    vw_get_campioni_validi.note_campione,
    vw_get_campioni_validi.anno_controllo,
    vw_get_campioni_validi.codice_interno_piano,
    vw_get_campioni_validi.descrizione_esito_esame,
    vw_get_campioni_validi.motivazione_non_conformita,
    vw_get_campioni_validi.rendicontabile,
    vw_get_campioni_validi.codice_preaccettazione,
    (vw_get_campioni_validi.id_controllo_ufficiale)::bigint AS id_controllo,
    COALESCE(vw_get_campioni_validi.id_piano, vw_get_campioni_validi.id_attivita) AS id_motivo
   FROM "Analisi_dev".vw_get_campioni_validi
  WHERE (vw_get_campioni_validi.id_controllo_ufficiale <> 'null'::text)
  WITH NO DATA;


ALTER TABLE ra.mvw_get_campioni_validi OWNER TO postgres;

--
-- Name: mvw_iuv; Type: TABLE; Schema: ra; Owner: postgres
--

CREATE TABLE ra.mvw_iuv (
    id_asl integer,
    cod_raggruppamento integer,
    data timestamp without time zone,
    eseguiti bigint,
    fonte integer,
    nucleo character varying
);


ALTER TABLE ra.mvw_iuv OWNER TO postgres;

--
-- Name: session_log; Type: TABLE; Schema: ra; Owner: postgres
--

CREATE TABLE ra.session_log (
    id character varying,
    last_timestamp timestamp without time zone,
    id_asl integer
);


ALTER TABLE ra.session_log OWNER TO postgres;

--
-- Name: vw_rendic_iuv; Type: VIEW; Schema: ra; Owner: postgres
--

CREATE VIEW ra.vw_rendic_iuv AS
 SELECT sa.descrizione_breve AS asl,
    m.data,
    ((sp.alias || ' - '::text) || sp.descrizione_breve) AS motivo,
    m.eseguiti,
    upper((m.nucleo)::text) AS veterinario_o_utente_inserimento
   FROM ((((ra.mvw_iuv m
     JOIN ra.config_iuv c ON ((m.fonte = c.id)))
     JOIN matrix.struttura_asl sa ON (((sa.id_asl = m.id_asl) AND (sa.n_livello = 1) AND ((sa.anno)::double precision = date_part('year'::text, m.data)))))
     JOIN matrix.struttura_piani sp ON (((sp.cod_raggruppamento = m.cod_raggruppamento) AND ((sp.anno)::double precision = date_part('year'::text, m.data)))))
     JOIN matrix.vw_tree_nodes_piani_descr pd ON ((pd.id = sp.id)))
  WHERE ((c.motivo IS FALSE) AND c.enabled AND (m.nucleo IS NOT NULL))
  ORDER BY m.data, sa.descrizione_breve, pd.p_ordinamento;


ALTER TABLE ra.vw_rendic_iuv OWNER TO postgres;

--
-- Name: vw_struttura_piani_ref_adhoc; Type: VIEW; Schema: ra; Owner: postgres
--

CREATE VIEW ra.vw_struttura_piani_ref_adhoc AS
 WITH RECURSIVE p_r(id, id_gisa, cod_raggruppamento, anno, descrizione, ordinamento, data_scadenza, stato, codice_interno, color, livello, parent, alias, id_formula_ups, id_formula_uba, fattore_ups, fattore_uba, descrizione_breve, id_ref) AS (
         SELECT struttura_piani.id,
            struttura_piani.id_gisa,
            struttura_piani.cod_raggruppamento,
            struttura_piani.anno,
            struttura_piani.descrizione,
            struttura_piani.ordinamento,
            struttura_piani.data_scadenza,
            struttura_piani.stato,
            struttura_piani.codice_interno,
            struttura_piani.color,
            struttura_piani.livello,
            struttura_piani.p_id AS parent,
            struttura_piani.alias,
            pp.id_formula_ups,
            pp.id_formula_uba,
            fu.fattore_fin AS fattore_ups,
            fb.fattore_fin AS fattore_uba,
            pp.descrizione_breve,
            struttura_piani.id AS id_ref
           FROM (((matrix.vw_tree_nodes_piani_descr struttura_piani
             JOIN matrix.struttura_piani pp ON ((pp.id = struttura_piani.id)))
             LEFT JOIN matrix.formule fu ON ((fu.id = pp.id_formula_ups)))
             LEFT JOIN matrix.formule fb ON (((fb.id = pp.id_formula_uba) AND (struttura_piani.cod_raggruppamento IN ( SELECT r.cod_raggruppamento
                   FROM ra.config_adhoc r)))))
        UNION ALL
         SELECT p_r_1.id,
            p_r_1.id_gisa,
            p2.cod_raggruppamento,
            p2.anno,
            p2.descrizione,
            p2.ordinamento,
            p2.data_scadenza,
            p2.stato,
            p2.codice_interno,
            p2.color,
            p2.livello,
            p.p_id AS parent,
            p2.alias,
            pp2.id_formula_ups,
            pp2.id_formula_uba,
            p_r_1.fattore_ups,
            p_r_1.fattore_uba,
            pp2.descrizione_breve,
            p.p_id AS parent
           FROM (((matrix.vw_tree_nodes_piani_descr p
             JOIN matrix.struttura_piani pp2 ON ((pp2.id = p.id)))
             JOIN p_r p_r_1 ON ((p_r_1.id_ref = p.id)))
             JOIN matrix.vw_tree_nodes_piani_descr p2 ON ((p.p_id = p2.id)))
          WHERE ((p.p_id IS NOT NULL) AND (p.cod_raggruppamento IN ( SELECT r.cod_raggruppamento
                   FROM ra.config_adhoc r)))
        )
 SELECT p_r.id,
    p_r.id_gisa,
    p_r.cod_raggruppamento,
    p_r.anno,
    p_r.descrizione,
    p_r.ordinamento,
    p_r.data_scadenza,
    p_r.stato,
    p_r.codice_interno,
    p_r.color,
    p_r.livello,
    p_r.parent,
    p_r.alias,
    p_r.id_formula_ups,
    p_r.id_formula_uba,
    p_r.fattore_ups,
    p_r.fattore_uba,
    p_r.descrizione_breve,
    p_r.id_ref
   FROM p_r;


ALTER TABLE ra.vw_struttura_piani_ref_adhoc OWNER TO postgres;

--
-- Name: vw_struttura_piani_ref_iuv; Type: VIEW; Schema: ra; Owner: postgres
--

CREATE VIEW ra.vw_struttura_piani_ref_iuv AS
 WITH RECURSIVE p_r(id, id_gisa, cod_raggruppamento, anno, descrizione, ordinamento, data_scadenza, stato, codice_interno, color, livello, parent, alias, id_formula_ups, id_formula_uba, fattore_ups, fattore_uba, descrizione_breve, id_ref) AS (
         SELECT struttura_piani.id,
            struttura_piani.id_gisa,
            struttura_piani.cod_raggruppamento,
            struttura_piani.anno,
            struttura_piani.descrizione,
            struttura_piani.ordinamento,
            struttura_piani.data_scadenza,
            struttura_piani.stato,
            struttura_piani.codice_interno,
            struttura_piani.color,
            struttura_piani.livello,
            struttura_piani.p_id AS parent,
            struttura_piani.alias,
            pp.id_formula_ups,
            pp.id_formula_uba,
            fu.fattore_fin AS fattore_ups,
            fb.fattore_fin AS fattore_uba,
            pp.descrizione_breve,
            struttura_piani.id AS id_ref
           FROM (((matrix.vw_tree_nodes_piani_descr struttura_piani
             JOIN matrix.struttura_piani pp ON ((pp.id = struttura_piani.id)))
             LEFT JOIN matrix.formule fu ON ((fu.id = pp.id_formula_ups)))
             LEFT JOIN matrix.formule fb ON (((fb.id = pp.id_formula_uba) AND (struttura_piani.cod_raggruppamento IN ( SELECT r.cod_raggruppamento
                   FROM ra.config_iuv r)))))
        UNION ALL
         SELECT p_r_1.id,
            p_r_1.id_gisa,
            p2.cod_raggruppamento,
            p2.anno,
            p2.descrizione,
            p2.ordinamento,
            p2.data_scadenza,
            p2.stato,
            p2.codice_interno,
            p2.color,
            p2.livello,
            p.p_id AS parent,
            p2.alias,
            pp2.id_formula_ups,
            pp2.id_formula_uba,
            p_r_1.fattore_ups,
            p_r_1.fattore_uba,
            pp2.descrizione_breve,
            p.p_id AS parent
           FROM (((matrix.vw_tree_nodes_piani_descr p
             JOIN matrix.struttura_piani pp2 ON ((pp2.id = p.id)))
             JOIN p_r p_r_1 ON ((p_r_1.id_ref = p.id)))
             JOIN matrix.vw_tree_nodes_piani_descr p2 ON ((p.p_id = p2.id)))
          WHERE ((p.p_id IS NOT NULL) AND (p.cod_raggruppamento IN ( SELECT r.cod_raggruppamento
                   FROM ra.config_iuv r)))
        )
 SELECT p_r.id,
    p_r.id_gisa,
    p_r.cod_raggruppamento,
    p_r.anno,
    p_r.descrizione,
    p_r.ordinamento,
    p_r.data_scadenza,
    p_r.stato,
    p_r.codice_interno,
    p_r.color,
    p_r.livello,
    p_r.parent,
    p_r.alias,
    p_r.id_formula_ups,
    p_r.id_formula_uba,
    p_r.fattore_ups,
    p_r.fattore_uba,
    p_r.descrizione_breve,
    p_r.id_ref
   FROM p_r;


ALTER TABLE ra.vw_struttura_piani_ref_iuv OWNER TO postgres;

--
-- Name: permessi; Type: TABLE; Schema: rbac; Owner: postgres
--

CREATE TABLE rbac.permessi (
    id bigint NOT NULL,
    id_sezione bigint NOT NULL,
    id_modalita bigint NOT NULL
);


ALTER TABLE rbac.permessi OWNER TO postgres;

--
-- Name: permessi_id_seq; Type: SEQUENCE; Schema: rbac; Owner: postgres
--

CREATE SEQUENCE rbac.permessi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac.permessi_id_seq OWNER TO postgres;

--
-- Name: permessi_id_seq; Type: SEQUENCE OWNED BY; Schema: rbac; Owner: postgres
--

ALTER SEQUENCE rbac.permessi_id_seq OWNED BY rbac.permessi.id;


--
-- Name: permessi_id_seq1; Type: SEQUENCE; Schema: rbac; Owner: postgres
--

CREATE SEQUENCE rbac.permessi_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac.permessi_id_seq1 OWNER TO postgres;

--
-- Name: permessi_id_seq1; Type: SEQUENCE OWNED BY; Schema: rbac; Owner: postgres
--

ALTER SEQUENCE rbac.permessi_id_seq1 OWNED BY rbac.permessi.id;


--
-- Name: rbac_id_seq; Type: SEQUENCE; Schema: rbac; Owner: postgres
--

CREATE SEQUENCE rbac.rbac_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac.rbac_id_seq OWNER TO postgres;

--
-- Name: ruolo_id_seq; Type: SEQUENCE; Schema: rbac; Owner: postgres
--

CREATE SEQUENCE rbac.ruolo_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac.ruolo_id_seq OWNER TO postgres;

--
-- Name: ruolo_id_seq; Type: SEQUENCE OWNED BY; Schema: rbac; Owner: postgres
--

ALTER SEQUENCE rbac.ruolo_id_seq OWNED BY rbac.ruoli.id;


--
-- Name: ruolo_permessi; Type: TABLE; Schema: rbac; Owner: postgres
--

CREATE TABLE rbac.ruolo_permessi (
    id bigint NOT NULL,
    id_ruolo bigint NOT NULL,
    id_permesso bigint NOT NULL
);


ALTER TABLE rbac.ruolo_permessi OWNER TO postgres;

--
-- Name: ruolo_permessi_id_seq; Type: SEQUENCE; Schema: rbac; Owner: postgres
--

CREATE SEQUENCE rbac.ruolo_permessi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac.ruolo_permessi_id_seq OWNER TO postgres;

--
-- Name: ruolo_permessi_id_seq; Type: SEQUENCE OWNED BY; Schema: rbac; Owner: postgres
--

ALTER SEQUENCE rbac.ruolo_permessi_id_seq OWNED BY rbac.ruolo_permessi.id;


--
-- Name: ruolo_permessi_id_seq1; Type: SEQUENCE; Schema: rbac; Owner: postgres
--

CREATE SEQUENCE rbac.ruolo_permessi_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac.ruolo_permessi_id_seq1 OWNER TO postgres;

--
-- Name: ruolo_permessi_id_seq1; Type: SEQUENCE OWNED BY; Schema: rbac; Owner: postgres
--

ALTER SEQUENCE rbac.ruolo_permessi_id_seq1 OWNED BY rbac.ruolo_permessi.id;


--
-- Name: ruolo_ruoli; Type: TABLE; Schema: rbac; Owner: postgres
--

CREATE TABLE rbac.ruolo_ruoli (
    id bigint NOT NULL,
    id_ruolo_cte bigint NOT NULL,
    id_ruolo_cto bigint NOT NULL
);


ALTER TABLE rbac.ruolo_ruoli OWNER TO postgres;

--
-- Name: ruoloruoli_id_seq; Type: SEQUENCE; Schema: rbac; Owner: postgres
--

CREATE SEQUENCE rbac.ruoloruoli_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac.ruoloruoli_id_seq OWNER TO postgres;

--
-- Name: ruoloruoli_id_seq; Type: SEQUENCE OWNED BY; Schema: rbac; Owner: postgres
--

ALTER SEQUENCE rbac.ruoloruoli_id_seq OWNED BY rbac.ruolo_ruoli.id;


--
-- Name: utente_strutture_id_seq; Type: SEQUENCE; Schema: rbac; Owner: postgres
--

CREATE SEQUENCE rbac.utente_strutture_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac.utente_strutture_id_seq OWNER TO postgres;

--
-- Name: utente_strutture_id_seq; Type: SEQUENCE OWNED BY; Schema: rbac; Owner: postgres
--

ALTER SEQUENCE rbac.utente_strutture_id_seq OWNED BY rbac.utente_strutture.id;


--
-- Name: utente_strutture_ruoli_id_seq; Type: SEQUENCE; Schema: rbac; Owner: postgres
--

CREATE SEQUENCE rbac.utente_strutture_ruoli_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac.utente_strutture_ruoli_id_seq OWNER TO postgres;

--
-- Name: utente_strutture_ruoli_id_seq; Type: SEQUENCE OWNED BY; Schema: rbac; Owner: postgres
--

ALTER SEQUENCE rbac.utente_strutture_ruoli_id_seq OWNED BY rbac.utente_strutture_ruoli.id;


--
-- Name: utenti_id_seq; Type: SEQUENCE; Schema: rbac; Owner: postgres
--

CREATE SEQUENCE rbac.utenti_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac.utenti_id_seq OWNER TO postgres;

--
-- Name: utenti_id_seq; Type: SEQUENCE OWNED BY; Schema: rbac; Owner: postgres
--

ALTER SEQUENCE rbac.utenti_id_seq OWNED BY rbac.utenti.id;


--
-- Name: modalita; Type: TABLE; Schema: rbac_types; Owner: postgres
--

CREATE TABLE rbac_types.modalita (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    sigla character varying NOT NULL,
    descr character varying NOT NULL,
    peso integer NOT NULL
);


ALTER TABLE rbac_types.modalita OWNER TO postgres;

--
-- Name: vw_modalita; Type: VIEW; Schema: rbac_types; Owner: postgres
--

CREATE VIEW rbac_types.vw_modalita AS
 SELECT m.id AS id_modalita,
    m.id,
    m.cod,
    m.sigla,
    m.descr,
    m.peso
   FROM rbac_types.modalita m;


ALTER TABLE rbac_types.vw_modalita OWNER TO postgres;

--
-- Name: portali; Type: TABLE; Schema: rbac_ui; Owner: postgres
--

CREATE TABLE rbac_ui.portali (
    id integer NOT NULL,
    descr character varying,
    cod character varying,
    sigla character varying,
    tipo_chiamata character varying,
    parametro character varying,
    img character varying,
    tipo_portale boolean
);


ALTER TABLE rbac_ui.portali OWNER TO postgres;

--
-- Name: sezioni; Type: TABLE; Schema: rbac_ui; Owner: postgres
--

CREATE TABLE rbac_ui.sezioni (
    id integer NOT NULL,
    id_portale integer,
    descr character varying,
    cod character varying,
    sigla character varying,
    ord integer,
    visibile boolean,
    icon character varying
);


ALTER TABLE rbac_ui.sezioni OWNER TO postgres;

--
-- Name: vw_portali; Type: VIEW; Schema: rbac_ui; Owner: postgres
--

CREATE VIEW rbac_ui.vw_portali AS
 SELECT portali.id AS id_portale,
    portali.id,
    portali.descr,
    portali.cod,
    portali.sigla,
    portali.tipo_chiamata,
    portali.parametro,
    portali.img,
    portali.tipo_portale
   FROM rbac_ui.portali;


ALTER TABLE rbac_ui.vw_portali OWNER TO postgres;

--
-- Name: vw_sezioni; Type: VIEW; Schema: rbac_ui; Owner: postgres
--

CREATE VIEW rbac_ui.vw_sezioni AS
 SELECT s.id,
    s.id AS id_sezione,
    s.id_portale,
    s.descr,
    s.cod,
    s.sigla,
    s.ord,
    s.visibile,
    s.icon,
    p.cod AS cod_portale,
    p.descr AS descr_portale
   FROM (rbac_ui.sezioni s
     JOIN rbac_ui.vw_portali p ON ((s.id_portale = p.id_portale)));


ALTER TABLE rbac_ui.vw_sezioni OWNER TO postgres;

--
-- Name: vw_permessi; Type: VIEW; Schema: rbac; Owner: postgres
--

CREATE VIEW rbac.vw_permessi AS
 SELECT p.id AS id_permesso,
    p.id,
    p.id_sezione,
    p.id_modalita,
    s.cod AS cod_sezione,
    m.descr AS descr_modalita,
    m.peso,
    s.descr AS descr_sezione,
    s.descr_portale,
    s.cod_portale
   FROM ((rbac.permessi p
     JOIN rbac_ui.vw_sezioni s ON ((p.id_sezione = s.id_sezione)))
     JOIN rbac_types.vw_modalita m ON ((m.id_modalita = p.id_modalita)));


ALTER TABLE rbac.vw_permessi OWNER TO postgres;

--
-- Name: vw_ruoli_inclusi_down_tree; Type: VIEW; Schema: rbac; Owner: postgres
--

CREATE VIEW rbac.vw_ruoli_inclusi_down_tree AS
 WITH RECURSIVE ruoli_inclusi(id_ruolo, id_ruolo_cte, id_ruolo_cto) AS (
         SELECT r.id AS id_ruolo,
            r.id AS id_ruolo_cte,
            r.id AS id_ruolo_cto
           FROM rbac.ruoli r
        UNION ALL
         SELECT ri.id_ruolo,
            ri.id_ruolo_cto,
            rr.id_ruolo_cte
           FROM (ruoli_inclusi ri
             JOIN rbac.ruolo_ruoli rr ON ((ri.id_ruolo_cto = rr.id_ruolo_cto)))
        )
 SELECT ruoli_inclusi.id_ruolo,
    ruoli_inclusi.id_ruolo_cto
   FROM ruoli_inclusi;


ALTER TABLE rbac.vw_ruoli_inclusi_down_tree OWNER TO postgres;

--
-- Name: vw_ruoli_inclusi_up_tree; Type: VIEW; Schema: rbac; Owner: postgres
--

CREATE VIEW rbac.vw_ruoli_inclusi_up_tree AS
 WITH RECURSIVE ruoli_inclusi(id_ruolo, id_ruolo_cte, id_ruolo_cto) AS (
         SELECT r.id AS id_ruolo,
            r.id AS id_ruolo_cte,
            r.id AS id_ruolo_cto
           FROM rbac.ruoli r
        UNION ALL
         SELECT ri.id_ruolo,
            ri.id_ruolo_cto,
            rr.id_ruolo_cto
           FROM (ruoli_inclusi ri
             JOIN rbac.ruolo_ruoli rr ON ((ri.id_ruolo_cto = rr.id_ruolo_cte)))
        )
 SELECT ruoli_inclusi.id_ruolo,
    ruoli_inclusi.id_ruolo_cto
   FROM ruoli_inclusi;


ALTER TABLE rbac.vw_ruoli_inclusi_up_tree OWNER TO postgres;

--
-- Name: vw_ruolo_permessi; Type: VIEW; Schema: rbac; Owner: postgres
--

CREATE VIEW rbac.vw_ruolo_permessi AS
 SELECT rp.id AS id_ruolo_permesso,
    rp.id,
    rp.id_ruolo,
    rp.id_permesso,
    r.descr AS descr_ruolo,
    p.cod_sezione,
    p.descr_modalita,
    p.id_sezione,
    p.id_modalita,
    p.peso,
    p.descr_sezione,
    p.descr_portale,
    p.cod_portale
   FROM ((rbac.ruolo_permessi rp
     JOIN rbac.vw_ruoli r ON ((r.id_ruolo = rp.id_ruolo)))
     JOIN rbac.vw_permessi p ON ((p.id_permesso = rp.id_permesso)));


ALTER TABLE rbac.vw_ruolo_permessi OWNER TO postgres;

--
-- Name: vw_ruolo_ruoli; Type: VIEW; Schema: rbac; Owner: postgres
--

CREATE VIEW rbac.vw_ruolo_ruoli AS
 SELECT rr.id AS id_ruolo_ruoli,
    rr.id,
    rr.id_ruolo_cte,
    rr.id_ruolo_cto,
    r_cte.descr AS descr_cte,
    r_cto.descr AS descr_cto
   FROM ((rbac.ruolo_ruoli rr
     JOIN rbac.vw_ruoli r_cte ON ((rr.id_ruolo_cte = r_cte.id_ruolo)))
     JOIN rbac.vw_ruoli r_cto ON ((rr.id_ruolo_cto = r_cto.id_ruolo)));


ALTER TABLE rbac.vw_ruolo_ruoli OWNER TO postgres;

--
-- Name: risorse; Type: TABLE; Schema: rbac_conf; Owner: postgres
--

CREATE TABLE rbac_conf.risorse (
    id bigint NOT NULL,
    cod character varying NOT NULL,
    sigla character varying,
    descr character varying
);


ALTER TABLE rbac_conf.risorse OWNER TO postgres;

--
-- Name: risorse_id_seq; Type: SEQUENCE; Schema: rbac_conf; Owner: postgres
--

CREATE SEQUENCE rbac_conf.risorse_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac_conf.risorse_id_seq OWNER TO postgres;

--
-- Name: risorse_id_seq; Type: SEQUENCE OWNED BY; Schema: rbac_conf; Owner: postgres
--

ALTER SEQUENCE rbac_conf.risorse_id_seq OWNED BY rbac_conf.risorse.id;


--
-- Name: titoli_id_seq; Type: SEQUENCE; Schema: rbac_conf; Owner: postgres
--

CREATE SEQUENCE rbac_conf.titoli_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac_conf.titoli_id_seq OWNER TO postgres;

--
-- Name: titoli_id_seq; Type: SEQUENCE OWNED BY; Schema: rbac_conf; Owner: postgres
--

ALTER SEQUENCE rbac_conf.titoli_id_seq OWNED BY rbac_conf.qualifiche.id;


--
-- Name: vw_risorse; Type: VIEW; Schema: rbac_conf; Owner: postgres
--

CREATE VIEW rbac_conf.vw_risorse AS
 SELECT risorse.id AS id_risorsa,
    risorse.id,
    risorse.cod,
    risorse.sigla,
    risorse.descr
   FROM rbac_conf.risorse;


ALTER TABLE rbac_conf.vw_risorse OWNER TO postgres;

--
-- Name: call_logs; Type: TABLE; Schema: rbac_log; Owner: postgres
--

CREATE TABLE rbac_log.call_logs (
    id bigint NOT NULL,
    id_transazione bigint,
    procedura character varying,
    fase character varying,
    ts timestamp without time zone,
    val character varying
);


ALTER TABLE rbac_log.call_logs OWNER TO postgres;

--
-- Name: call_logs_id_seq; Type: SEQUENCE; Schema: rbac_log; Owner: postgres
--

CREATE SEQUENCE rbac_log.call_logs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac_log.call_logs_id_seq OWNER TO postgres;

--
-- Name: call_logs_id_seq; Type: SEQUENCE OWNED BY; Schema: rbac_log; Owner: postgres
--

ALTER SEQUENCE rbac_log.call_logs_id_seq OWNED BY rbac_log.call_logs.id;


--
-- Name: call_logs_id_seq1; Type: SEQUENCE; Schema: rbac_log; Owner: postgres
--

CREATE SEQUENCE rbac_log.call_logs_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac_log.call_logs_id_seq1 OWNER TO postgres;

--
-- Name: call_logs_id_seq1; Type: SEQUENCE OWNED BY; Schema: rbac_log; Owner: postgres
--

ALTER SEQUENCE rbac_log.call_logs_id_seq1 OWNED BY rbac_log.call_logs.id;


--
-- Name: operazioni_id_seq; Type: SEQUENCE; Schema: rbac_log; Owner: postgres
--

CREATE SEQUENCE rbac_log.operazioni_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac_log.operazioni_id_seq OWNER TO postgres;

--
-- Name: operazioni_id_seq; Type: SEQUENCE OWNED BY; Schema: rbac_log; Owner: postgres
--

ALTER SEQUENCE rbac_log.operazioni_id_seq OWNED BY rbac_log.operazioni.id;


--
-- Name: operazioni_id_seq1; Type: SEQUENCE; Schema: rbac_log; Owner: postgres
--

CREATE SEQUENCE rbac_log.operazioni_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac_log.operazioni_id_seq1 OWNER TO postgres;

--
-- Name: operazioni_id_seq1; Type: SEQUENCE OWNED BY; Schema: rbac_log; Owner: postgres
--

ALTER SEQUENCE rbac_log.operazioni_id_seq1 OWNED BY rbac_log.operazioni.id;


--
-- Name: transazioni_id_seq; Type: SEQUENCE; Schema: rbac_log; Owner: postgres
--

CREATE SEQUENCE rbac_log.transazioni_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac_log.transazioni_id_seq OWNER TO postgres;

--
-- Name: transazioni_id_seq; Type: SEQUENCE OWNED BY; Schema: rbac_log; Owner: postgres
--

ALTER SEQUENCE rbac_log.transazioni_id_seq OWNED BY rbac_log.transazioni.id;


--
-- Name: transazioni_id_seq1; Type: SEQUENCE; Schema: rbac_log; Owner: postgres
--

CREATE SEQUENCE rbac_log.transazioni_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac_log.transazioni_id_seq1 OWNER TO postgres;

--
-- Name: transazioni_id_seq1; Type: SEQUENCE OWNED BY; Schema: rbac_log; Owner: postgres
--

ALTER SEQUENCE rbac_log.transazioni_id_seq1 OWNED BY rbac_log.transazioni.id;


--
-- Name: modalita_id_seq; Type: SEQUENCE; Schema: rbac_types; Owner: postgres
--

CREATE SEQUENCE rbac_types.modalita_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac_types.modalita_id_seq OWNER TO postgres;

--
-- Name: modalita_id_seq; Type: SEQUENCE OWNED BY; Schema: rbac_types; Owner: postgres
--

ALTER SEQUENCE rbac_types.modalita_id_seq OWNED BY rbac_types.modalita.id;


--
-- Name: grid_definition; Type: TABLE; Schema: rbac_ui; Owner: postgres
--

CREATE TABLE rbac_ui.grid_definition (
    id bigint NOT NULL,
    funct character varying,
    id_user bigint,
    type_user character varying,
    str_conf character varying,
    note character varying
);


ALTER TABLE rbac_ui.grid_definition OWNER TO postgres;

--
-- Name: grid_definition_id_seq; Type: SEQUENCE; Schema: rbac_ui; Owner: postgres
--

CREATE SEQUENCE rbac_ui.grid_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rbac_ui.grid_definition_id_seq OWNER TO postgres;

--
-- Name: grid_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: rbac_ui; Owner: postgres
--

ALTER SEQUENCE rbac_ui.grid_definition_id_seq OWNED BY rbac_ui.grid_definition.id;


--
-- Name: accent; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.accent (
    a character varying
);


ALTER TABLE tmp.accent OWNER TO postgres;

--
-- Name: ag_log_operazioni; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.ag_log_operazioni (
    id bigint,
    id_transazione bigint,
    procedura character varying,
    fase character varying,
    ts_start timestamp without time zone,
    ts_transazione timestamp without time zone,
    val character varying,
    ts_end timestamp without time zone,
    ret character varying,
    id_trattato bigint
);


ALTER TABLE tmp.ag_log_operazioni OWNER TO postgres;

--
-- Name: ag_stato_eventi; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.ag_stato_eventi (
    id bigint,
    descr character varying,
    colore character varying,
    id_tipo_evento bigint,
    effettuata boolean,
    scaduta boolean
);


ALTER TABLE tmp.ag_stato_eventi OWNER TO postgres;

--
-- Name: ag_stato_eventi_20230714; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.ag_stato_eventi_20230714 (
    id bigint,
    descr character varying,
    colore character varying,
    id_tipo_evento bigint,
    effettuata boolean,
    scaduta boolean
);


ALTER TABLE tmp.ag_stato_eventi_20230714 OWNER TO postgres;

--
-- Name: ag_tipo_eventi; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.ag_tipo_eventi (
    id bigint,
    descr character varying,
    modifica_inizio boolean,
    modifica_durata boolean,
    elimina boolean,
    inserisci boolean,
    sigla character varying
);


ALTER TABLE tmp.ag_tipo_eventi OWNER TO postgres;

--
-- Name: ag_tipo_eventi_20230714; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.ag_tipo_eventi_20230714 (
    id bigint,
    descr character varying,
    modifica_inizio boolean,
    modifica_durata boolean,
    elimina boolean,
    inserisci boolean,
    sigla character varying
);


ALTER TABLE tmp.ag_tipo_eventi_20230714 OWNER TO postgres;

--
-- Name: ag_tree_nodes_20230214; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.ag_tree_nodes_20230214 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE tmp.ag_tree_nodes_20230214 OWNER TO postgres;

--
-- Name: agenda_eventi_20230126; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.agenda_eventi_20230126 (
    id bigint,
    id_nominativo bigint,
    id_tipo_evento bigint,
    inizio timestamp without time zone,
    fine timestamp without time zone,
    id_linea bigint,
    id_attivita bigint,
    id_piano bigint,
    effettuata boolean,
    id_partner bigint,
    valido_da timestamp without time zone,
    valido_a timestamp without time zone,
    per_conto bigint
);


ALTER TABLE tmp.agenda_eventi_20230126 OWNER TO postgres;

--
-- Name: asl_piani_20230117; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.asl_piani_20230117 (
    id bigint,
    id_struttura bigint,
    id_piano bigint
);


ALTER TABLE tmp.asl_piani_20230117 OWNER TO postgres;

--
-- Name: asl_piani_20230118; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.asl_piani_20230118 (
    id bigint,
    id_struttura bigint,
    id_piano bigint
);


ALTER TABLE tmp.asl_piani_20230118 OWNER TO postgres;

--
-- Name: asl_piani_20230904; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.asl_piani_20230904 (
    id bigint,
    id_struttura bigint,
    id_piano bigint
);


ALTER TABLE tmp.asl_piani_20230904 OWNER TO postgres;

--
-- Name: asl_piani_20230904_2; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.asl_piani_20230904_2 (
    id bigint,
    id_struttura bigint,
    id_piano bigint
);


ALTER TABLE tmp.asl_piani_20230904_2 OWNER TO postgres;

--
-- Name: asl_pinai_20230119; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.asl_pinai_20230119 (
    id bigint,
    id_struttura bigint,
    id_piano bigint
);


ALTER TABLE tmp.asl_pinai_20230119 OWNER TO postgres;

--
-- Name: asl_remap; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.asl_remap (
    idold bigint,
    idnew bigint
);


ALTER TABLE tmp.asl_remap OWNER TO postgres;

--
-- Name: az_lookup_comuni; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.az_lookup_comuni (
    id integer,
    com_id integer,
    istat integer,
    descrizione character varying,
    cap integer,
    id_fiscale character varying,
    superficie real,
    id_provincia integer,
    ref_id integer,
    utente_id integer,
    latitudine_min real,
    latitudine_max real,
    longitudine_min real,
    longitudine_max real,
    id_comune integer,
    dt_timerange character varying
);


ALTER TABLE tmp.az_lookup_comuni OWNER TO postgres;

--
-- Name: az_lookup_comuni_20230714; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.az_lookup_comuni_20230714 (
    id integer,
    com_id integer,
    istat integer,
    descrizione character varying,
    cap integer,
    id_fiscale character varying,
    superficie real,
    id_provincia integer,
    ref_id integer,
    utente_id integer,
    latitudine_min real,
    latitudine_max real,
    longitudine_min real,
    longitudine_max real,
    id_comune integer,
    dt_timerange character varying
);


ALTER TABLE tmp.az_lookup_comuni_20230714 OWNER TO postgres;

--
-- Name: c; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.c (
    comune character varying(32)
);


ALTER TABLE tmp.c OWNER TO postgres;

--
-- Name: clienti_2024_06_11; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.clienti_2024_06_11 (
    id bigint,
    descr character varying,
    id_ref bigint,
    type character varying,
    piva character varying
);


ALTER TABLE tmp.clienti_2024_06_11 OWNER TO postgres;

--
-- Name: clienti_2024_06_12; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.clienti_2024_06_12 (
    id bigint,
    descr character varying,
    id_ref bigint,
    type character varying,
    piva character varying
);


ALTER TABLE tmp.clienti_2024_06_12 OWNER TO postgres;

--
-- Name: comuni_20230130; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.comuni_20230130 (
    id bigint,
    comune character varying(32),
    id_asl bigint
);


ALTER TABLE tmp.comuni_20230130 OWNER TO postgres;

--
-- Name: cu_2024_06_12; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.cu_2024_06_12 (
    id bigint,
    codice character varying,
    dt timestamp without time zone,
    id_tecnica bigint,
    preavviso boolean,
    rilievi boolean,
    id_evento bigint,
    id_az_sede bigint,
    id_responsabile bigint,
    chiuso boolean,
    dt_chiusura timestamp without time zone,
    pec character varying,
    note_verbale character varying,
    note_generali character varying,
    dt_preavviso timestamp without time zone,
    mezzo_preavviso character varying,
    km_az numeric,
    km_pr numeric,
    id_stato_cu bigint
);


ALTER TABLE tmp.cu_2024_06_12 OWNER TO postgres;

--
-- Name: cu_linee_2024_06_11; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.cu_linee_2024_06_11 (
    id bigint,
    id_cu bigint,
    id_linea bigint,
    ord integer,
    linea_originaria boolean
);


ALTER TABLE tmp.cu_linee_2024_06_11 OWNER TO postgres;

--
-- Name: cu_linee_2024_06_12; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.cu_linee_2024_06_12 (
    id bigint,
    id_cu bigint,
    id_linea bigint,
    ord integer,
    linea_originaria boolean
);


ALTER TABLE tmp.cu_linee_2024_06_12 OWNER TO postgres;

--
-- Name: cu_norme_new; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.cu_norme_new (
    id bigint,
    norma character varying,
    regolamento character varying
);


ALTER TABLE tmp.cu_norme_new OWNER TO postgres;

--
-- Name: cu_requisiti_new; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.cu_requisiti_new (
    id integer,
    id_tipo_oggetto integer,
    ord integer,
    norma character varying,
    descr character varying,
    cl character varying,
    validita character varying,
    id_norma character varying
);


ALTER TABLE tmp.cu_requisiti_new OWNER TO postgres;

--
-- Name: cu_tipo_oggetti_new; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.cu_tipo_oggetti_new (
    id integer,
    sigla character varying,
    descr character varying,
    cod integer,
    validita character varying,
    ord integer
);


ALTER TABLE tmp.cu_tipo_oggetti_new OWNER TO postgres;

--
-- Name: cu_tipo_oggetto_piani_da_passare_2024-07-02; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp."cu_tipo_oggetto_piani_da_passare_2024-07-02" (
    id bigint NOT NULL,
    id_tipo_oggetto bigint NOT NULL,
    id_piano bigint NOT NULL
);


ALTER TABLE tmp."cu_tipo_oggetto_piani_da_passare_2024-07-02" OWNER TO postgres;

--
-- Name: cu_tipo_oggetto_piani_2024-07-02_id_seq; Type: SEQUENCE; Schema: tmp; Owner: postgres
--

CREATE SEQUENCE tmp."cu_tipo_oggetto_piani_2024-07-02_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tmp."cu_tipo_oggetto_piani_2024-07-02_id_seq" OWNER TO postgres;

--
-- Name: cu_tipo_oggetto_piani_2024-07-02_id_seq; Type: SEQUENCE OWNED BY; Schema: tmp; Owner: postgres
--

ALTER SEQUENCE tmp."cu_tipo_oggetto_piani_2024-07-02_id_seq" OWNED BY tmp."cu_tipo_oggetto_piani_da_passare_2024-07-02".id;


--
-- Name: cu_tipo_oggetto_piani_2024_07_02; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.cu_tipo_oggetto_piani_2024_07_02 (
    id bigint,
    id_tipo_oggetto bigint,
    id_piano bigint
);


ALTER TABLE tmp.cu_tipo_oggetto_piani_2024_07_02 OWNER TO postgres;

--
-- Name: denominazione_app; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.denominazione_app (
    denom character varying
);


ALTER TABLE tmp.denominazione_app OWNER TO postgres;

--
-- Name: eventi_20240417; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.eventi_20240417 (
    id bigint,
    id_nominativo bigint,
    id_tipo_evento bigint,
    inizio timestamp without time zone,
    fine timestamp without time zone,
    id_linea bigint,
    id_attivita bigint,
    id_piano bigint,
    effettuata boolean,
    id_partner bigint,
    valido_da timestamp without time zone,
    valido_a timestamp without time zone,
    per_conto bigint,
    id_elab_cal bigint,
    id_cu bigint,
    partner_per_conto bigint,
    validita_interna boolean,
    quantita numeric,
    id_user_create bigint,
    ts_create timestamp without time zone
);


ALTER TABLE tmp.eventi_20240417 OWNER TO postgres;

--
-- Name: eventi_2024_06_12; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.eventi_2024_06_12 (
    id bigint,
    id_nominativo bigint,
    id_tipo_evento bigint,
    inizio timestamp without time zone,
    fine timestamp without time zone,
    id_linea bigint,
    id_attivita bigint,
    id_piano bigint,
    effettuata boolean,
    id_partner bigint,
    valido_da timestamp without time zone,
    valido_a timestamp without time zone,
    per_conto bigint,
    id_elab_cal bigint,
    id_cu bigint,
    partner_per_conto bigint,
    validita_interna boolean,
    quantita numeric,
    id_user_create bigint,
    ts_create timestamp without time zone
);


ALTER TABLE tmp.eventi_2024_06_12 OWNER TO postgres;

--
-- Name: fvg_norme_benessere_animale_2024_08_13; Type: TABLE; Schema: tmp; Owner: gisa_fvg
--

CREATE TABLE tmp.fvg_norme_benessere_animale_2024_08_13 (
    id bigint,
    norma character varying,
    regolamento character varying
);


ALTER TABLE tmp.fvg_norme_benessere_animale_2024_08_13 OWNER TO gisa_fvg;

--
-- Name: fvg_oggetti_benessere_animale_2024_08_13; Type: TABLE; Schema: tmp; Owner: gisa_fvg
--

CREATE TABLE tmp.fvg_oggetti_benessere_animale_2024_08_13 (
    id bigint,
    id_tipo_oggetto bigint,
    ord integer,
    norma character varying,
    descr character varying,
    cl character varying,
    validita tsrange,
    id_norma bigint
);


ALTER TABLE tmp.fvg_oggetti_benessere_animale_2024_08_13 OWNER TO gisa_fvg;

--
-- Name: get_info_masterlist_210623; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.get_info_masterlist_210623 (
    codice_univoco text,
    id_norma integer,
    codice_norma text,
    id_macroarea integer,
    macroarea text,
    codice_macroarea text,
    id_aggregazione integer,
    aggregazione text,
    codice_aggregazione text,
    id_linea integer,
    attivita text,
    codice_attivita text,
    mobile boolean,
    fisso boolean,
    apicoltura boolean,
    registrabili boolean,
    riconoscibili boolean,
    sintesis boolean,
    bdu boolean,
    vam boolean,
    no_scia boolean,
    categorizzabili boolean,
    rev integer,
    categoria_rischio_default integer
);


ALTER TABLE tmp.get_info_masterlist_210623 OWNER TO postgres;

--
-- Name: gruppispecie; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.gruppispecie (
    id integer,
    grspe_id integer,
    istat integer,
    codice integer,
    descrizione character varying,
    codice_transponder integer
);


ALTER TABLE tmp.gruppispecie OWNER TO postgres;

--
-- Name: gruppispecie_20230714; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.gruppispecie_20230714 (
    id integer,
    grspe_id integer,
    istat integer,
    codice integer,
    descrizione character varying,
    codice_transponder integer
);


ALTER TABLE tmp.gruppispecie_20230714 OWNER TO postgres;

--
-- Name: impresa_figure_20240308; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.impresa_figure_20240308 (
    id bigint,
    id_impresa bigint,
    id_tipo_figura bigint,
    id_indirizzo bigint,
    old_id bigint,
    fonte text,
    descr character varying,
    validita tsrange,
    id_soggetto bigint
);


ALTER TABLE tmp.impresa_figure_20240308 OWNER TO postgres;

--
-- Name: imprese_20240306; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.imprese_20240306 (
    id bigint,
    nome character varying,
    cf character varying,
    piva character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    az_id bigint,
    az_cod_aziendale character varying,
    az_cod_regionale character varying,
    sd_id bigint,
    verificato boolean,
    fonte character varying,
    validita tsrange,
    tipo_soggetto character varying
);


ALTER TABLE tmp.imprese_20240306 OWNER TO postgres;

--
-- Name: imprese_20240309; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.imprese_20240309 (
    id bigint,
    nome character varying,
    cf character varying,
    piva character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    az_id bigint,
    az_cod_aziendale character varying,
    az_cod_regionale character varying,
    sd_id bigint,
    verificato boolean,
    fonte character varying,
    validita tsrange,
    tipo_soggetto character varying
);


ALTER TABLE tmp.imprese_20240309 OWNER TO postgres;

--
-- Name: imprese_2024_02_13; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.imprese_2024_02_13 (
    id bigint,
    nome character varying,
    cf character varying,
    piva character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    az_id bigint,
    az_cod_aziendale character varying,
    az_cod_regionale character varying,
    sd_id bigint,
    verificato boolean,
    fonte character varying,
    validita tsrange
);


ALTER TABLE tmp.imprese_2024_02_13 OWNER TO postgres;

--
-- Name: imprese_210623; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.imprese_210623 (
    id bigint,
    riferimento_id_impresa integer,
    riferimento_nome_tab_impresa text
);


ALTER TABLE tmp.imprese_210623 OWNER TO postgres;

--
-- Name: indirizzi_20240306; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.indirizzi_20240306 (
    id bigint,
    toponimo character varying,
    indirizzo character varying,
    cap text,
    stato_prov character varying,
    nazione text,
    istat_comune character varying,
    comune character varying,
    localita text,
    civico character varying,
    latitudine character varying,
    longitudine character varying,
    verificato boolean,
    fonte text
);


ALTER TABLE tmp.indirizzi_20240306 OWNER TO postgres;

--
-- Name: indirizzi_20240712; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.indirizzi_20240712 (
    id bigint,
    toponimo character varying,
    indirizzo character varying,
    cap text,
    stato_prov character varying,
    nazione text,
    istat_comune character varying,
    comune character varying,
    localita text,
    civico character varying,
    latitudine character varying,
    longitudine character varying,
    verificato boolean,
    fonte text
);


ALTER TABLE tmp.indirizzi_20240712 OWNER TO postgres;

--
-- Name: linea_piani_20230119; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.linea_piani_20230119 (
    id bigint,
    id_linea bigint,
    id_piano bigint
);


ALTER TABLE tmp.linea_piani_20230119 OWNER TO postgres;

--
-- Name: linee; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.linee (
    id bigint,
    id_stabilimento bigint,
    id_attivita integer,
    id_linea integer,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    num_riconoscimento text,
    n_linea text,
    data_inizio_attivita timestamp without time zone,
    data_fine_attivita timestamp without time zone,
    macroarea text,
    aggregazione text,
    attivita text,
    path_attivita_completo text,
    norma text,
    id_norma integer,
    codice_macroarea text,
    codice_aggregazione text,
    codice_attivita text,
    stato text,
    id_stato integer,
    miscela boolean,
    tipo_attivita_descrizione text,
    tipo_attivita integer,
    sintesis boolean
);


ALTER TABLE tmp.linee OWNER TO postgres;

--
-- Name: linee_2024_06_11; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.linee_2024_06_11 (
    id bigint,
    id_stabilimento bigint,
    id_tipo_linea integer,
    validita tsrange,
    attivita_fissa boolean,
    linea_principale boolean,
    verificato boolean,
    fonte text,
    data_ultima_visita timestamp without time zone,
    id_esterno character varying
);


ALTER TABLE tmp.linee_2024_06_11 OWNER TO postgres;

--
-- Name: linee_852_da_cancellare_2024_06_11; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.linee_852_da_cancellare_2024_06_11 (
    id bigint,
    id_stabilimento bigint,
    id_tipo_linea integer,
    validita tsrange,
    attivita_fissa boolean,
    linea_principale boolean,
    verificato boolean,
    fonte text,
    data_ultima_visita timestamp without time zone,
    id_esterno character varying
);


ALTER TABLE tmp.linee_852_da_cancellare_2024_06_11 OWNER TO postgres;

--
-- Name: linee_852_legame_2024_06_11; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.linee_852_legame_2024_06_11 (
    id_old bigint,
    id_new bigint,
    id bigint,
    id_stabilimento bigint,
    id_tipo_linea integer,
    validita tsrange,
    attivita_fissa boolean,
    linea_principale boolean,
    verificato boolean,
    fonte text,
    data_ultima_visita timestamp without time zone,
    id_esterno character varying
);


ALTER TABLE tmp.linee_852_legame_2024_06_11 OWNER TO postgres;

--
-- Name: linee_af_20240613; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.linee_af_20240613 (
    id bigint,
    id_stabilimento bigint,
    id_tipo_linea integer,
    validita tsrange,
    attivita_fissa boolean,
    linea_principale boolean,
    verificato boolean,
    fonte text,
    data_ultima_visita timestamp without time zone,
    id_esterno character varying
);


ALTER TABLE tmp.linee_af_20240613 OWNER TO postgres;

--
-- Name: linee_selezionate_20230119; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.linee_selezionate_20230119 (
    id bigint,
    id_elab_cal bigint,
    id_linea bigint,
    id_piano bigint,
    ordine integer
);


ALTER TABLE tmp.linee_selezionate_20230119 OWNER TO postgres;

--
-- Name: mappatura_852_cancellazione_2024_06_12; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.mappatura_852_cancellazione_2024_06_12 (
    nome character varying,
    stab_old bigint,
    stab_new bigint,
    imp_old bigint,
    imp_new bigint,
    linea_old bigint,
    linea_new bigint,
    tipo_linea_old integer,
    tipo_linea_new integer
);


ALTER TABLE tmp.mappatura_852_cancellazione_2024_06_12 OWNER TO postgres;

--
-- Name: mappatura_clienti_az_sede_2024_07_08; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.mappatura_clienti_az_sede_2024_07_08 (
    id_cliente_old bigint,
    id_cliente_new bigint,
    type text
);


ALTER TABLE tmp.mappatura_clienti_az_sede_2024_07_08 OWNER TO postgres;

--
-- Name: mappatura_clienti_linea_2024_07_08; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.mappatura_clienti_linea_2024_07_08 (
    id_cliente_old bigint,
    id_cliente_new bigint,
    type text
);


ALTER TABLE tmp.mappatura_clienti_linea_2024_07_08 OWNER TO postgres;

--
-- Name: mappatura_stabilimenti_cancellazione_2024_07_08; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.mappatura_stabilimenti_cancellazione_2024_07_08 (
    id_old bigint,
    id_new bigint,
    id bigint,
    id_impresa bigint,
    nome character varying,
    sd_id numeric(12,0),
    id_indirizzo bigint,
    cod_regionale character varying,
    verificato boolean,
    fonte character varying,
    categoria_rischio numeric,
    validita tsrange,
    cod_nazionale character varying,
    id_tipologia_struttura bigint,
    pec character varying,
    telefono character varying,
    sdi character varying
);


ALTER TABLE tmp.mappatura_stabilimenti_cancellazione_2024_07_08 OWNER TO postgres;

--
-- Name: mappatura_stabilimenti_linee_cancellazione_2024_07_08; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.mappatura_stabilimenti_linee_cancellazione_2024_07_08 (
    id_stab_old bigint,
    id_stab_new bigint,
    id_linea_old bigint,
    id_linea_new bigint,
    id_tipo_linea_old integer,
    id_tipo_linea_new integer
);


ALTER TABLE tmp.mappatura_stabilimenti_linee_cancellazione_2024_07_08 OWNER TO postgres;

--
-- Name: mappatura_totale_stabilimenti_linee_cancellazione_2024_07_08; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.mappatura_totale_stabilimenti_linee_cancellazione_2024_07_08 (
    id_stab_old bigint,
    id_stab_new bigint,
    id_linea_old bigint,
    id_linea_new bigint,
    id_tipo_linea_old integer,
    id_tipo_linea_new integer
);


ALTER TABLE tmp.mappatura_totale_stabilimenti_linee_cancellazione_2024_07_08 OWNER TO postgres;

--
-- Name: matrix_nominativi_300523; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.matrix_nominativi_300523 (
    id integer,
    id_nominativo_gisa bigint,
    id_anagrafica bigint,
    nominativo text,
    codice_fiscale text,
    qualifica text
);


ALTER TABLE tmp.matrix_nominativi_300523 OWNER TO postgres;

--
-- Name: matrix_nominativi_struttura_300523; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.matrix_nominativi_struttura_300523 (
    id integer,
    id_nominativo bigint,
    id_struttura bigint
);


ALTER TABLE tmp.matrix_nominativi_struttura_300523 OWNER TO postgres;

--
-- Name: matrix_struttura_asl_2023_04_17; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.matrix_struttura_asl_2023_04_17 (
    id bigint,
    id_gisa bigint,
    id_asl bigint,
    codice_interno_fk bigint,
    descrizione text,
    n_livello integer,
    anno integer,
    descrizione_breve text,
    ups double precision,
    uba double precision,
    codice_interno_univoco bigint
);


ALTER TABLE tmp.matrix_struttura_asl_2023_04_17 OWNER TO postgres;

--
-- Name: matrix_struttura_piani_16022023; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.matrix_struttura_piani_16022023 (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying,
    ha_campioni boolean,
    id_tipo_tecnica bigint
);


ALTER TABLE tmp.matrix_struttura_piani_16022023 OWNER TO postgres;

--
-- Name: matrix_struttura_piani_20230504; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.matrix_struttura_piani_20230504 (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying,
    ha_campioni boolean,
    id_tipo_tecnica bigint
);


ALTER TABLE tmp.matrix_struttura_piani_20230504 OWNER TO postgres;

--
-- Name: matrix_struttura_piani_20230505; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.matrix_struttura_piani_20230505 (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying,
    ha_campioni boolean,
    id_tipo_tecnica bigint
);


ALTER TABLE tmp.matrix_struttura_piani_20230505 OWNER TO postgres;

--
-- Name: matrix_struttura_piani_29062023; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.matrix_struttura_piani_29062023 (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying,
    ha_campioni boolean,
    id_tipo_tecnica bigint
);


ALTER TABLE tmp.matrix_struttura_piani_29062023 OWNER TO postgres;

--
-- Name: matrix_tree_nodes_20221128; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.matrix_tree_nodes_20221128 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE tmp.matrix_tree_nodes_20221128 OWNER TO postgres;

--
-- Name: matrix_tree_nodes_2023_04_17; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.matrix_tree_nodes_2023_04_17 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE tmp.matrix_tree_nodes_2023_04_17 OWNER TO postgres;

--
-- Name: mod4_nominativi_20230120; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.mod4_nominativi_20230120 (
    id bigint,
    id_nominativo_struttura bigint,
    livello_formativo integer,
    carico_annuale integer,
    perc_sottr numeric,
    perc_sottr2 integer,
    fattore1 boolean,
    fattore2 boolean,
    fattore3 boolean,
    uba_ora real,
    fattori_text character varying,
    ups smallint,
    uba smallint,
    entered timestamp without time zone,
    perc_dest_uba numeric
);


ALTER TABLE tmp.mod4_nominativi_20230120 OWNER TO postgres;

--
-- Name: mod4_nominativi_20230306; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.mod4_nominativi_20230306 (
    id bigint,
    id_nominativo_struttura bigint,
    livello_formativo integer,
    carico_annuale integer,
    perc_sottr numeric,
    perc_sottr2 integer,
    fattore1 boolean,
    fattore2 boolean,
    fattore3 boolean,
    uba_ora real,
    fattori_text character varying,
    ups smallint,
    uba smallint,
    entered timestamp without time zone,
    perc_dest_uba numeric
);


ALTER TABLE tmp.mod4_nominativi_20230306 OWNER TO postgres;

--
-- Name: mod4_nominativi_fattori_20230120; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.mod4_nominativi_fattori_20230120 (
    id integer,
    id_nominativo_struttura bigint,
    id_fattore bigint,
    valore double precision
);


ALTER TABLE tmp.mod4_nominativi_fattori_20230120 OWNER TO postgres;

--
-- Name: mod4_strutture_20230120; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.mod4_strutture_20230120 (
    id integer,
    id_struttura bigint,
    sottr integer,
    fattore1 boolean,
    fattore2 boolean,
    ups integer,
    uba integer
);


ALTER TABLE tmp.mod4_strutture_20230120 OWNER TO postgres;

--
-- Name: mod4_strutture_20230306; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.mod4_strutture_20230306 (
    id integer,
    id_struttura bigint,
    sottr integer,
    fattore1 boolean,
    fattore2 boolean,
    ups integer,
    uba integer
);


ALTER TABLE tmp.mod4_strutture_20230306 OWNER TO postgres;

--
-- Name: nominativi_20230117; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.nominativi_20230117 (
    id integer,
    id_nominativo_gisa bigint,
    id_anagrafica bigint,
    nominativo text,
    codice_fiscale text,
    qualifica text
);


ALTER TABLE tmp.nominativi_20230117 OWNER TO postgres;

--
-- Name: nominativi_20230228; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.nominativi_20230228 (
    id integer,
    id_nominativo_gisa bigint,
    id_anagrafica bigint,
    nominativo text,
    codice_fiscale text,
    qualifica text
);


ALTER TABLE tmp.nominativi_20230228 OWNER TO postgres;

--
-- Name: nominativi_20230228_post_allineamento; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.nominativi_20230228_post_allineamento (
    id integer,
    id_nominativo_gisa bigint,
    id_anagrafica bigint,
    nominativo text,
    codice_fiscale text,
    qualifica text
);


ALTER TABLE tmp.nominativi_20230228_post_allineamento OWNER TO postgres;

--
-- Name: nominativi_linee_20240327; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.nominativi_linee_20240327 (
    id bigint,
    id_nominativo_struttura bigint,
    id_linea bigint
);


ALTER TABLE tmp.nominativi_linee_20240327 OWNER TO postgres;

--
-- Name: nominativi_struttra_20230117; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.nominativi_struttra_20230117 (
    id integer,
    id_nominativo bigint,
    id_struttura bigint
);


ALTER TABLE tmp.nominativi_struttra_20230117 OWNER TO postgres;

--
-- Name: nominativi_struttra_20230228; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.nominativi_struttra_20230228 (
    id integer,
    id_nominativo bigint,
    id_struttura bigint
);


ALTER TABLE tmp.nominativi_struttra_20230228 OWNER TO postgres;

--
-- Name: nominativi_struttra_20230306; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.nominativi_struttra_20230306 (
    id integer,
    id_nominativo bigint,
    id_struttura bigint
);


ALTER TABLE tmp.nominativi_struttra_20230306 OWNER TO postgres;

--
-- Name: nominativi_struttura_20230117; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.nominativi_struttura_20230117 (
    id integer,
    id_nominativo bigint,
    id_struttura bigint
);


ALTER TABLE tmp.nominativi_struttura_20230117 OWNER TO postgres;

--
-- Name: nominativi_struttura_20230119; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.nominativi_struttura_20230119 (
    id integer,
    id_nominativo bigint,
    id_struttura bigint
);


ALTER TABLE tmp.nominativi_struttura_20230119 OWNER TO postgres;

--
-- Name: nominativo_comuni_20221229; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.nominativo_comuni_20221229 (
    id bigint,
    id_nominativo_struttura bigint,
    id_struttura_comune bigint
);


ALTER TABLE tmp.nominativo_comuni_20221229 OWNER TO postgres;

--
-- Name: nominativo_comuni_20230117; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.nominativo_comuni_20230117 (
    id bigint,
    id_nominativo_struttura bigint,
    id_struttura_comune bigint
);


ALTER TABLE tmp.nominativo_comuni_20230117 OWNER TO postgres;

--
-- Name: nominativo_piani_20230119; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.nominativo_piani_20230119 (
    id bigint,
    id_nominativo_struttura bigint,
    id_piano bigint
);


ALTER TABLE tmp.nominativo_piani_20230119 OWNER TO postgres;

--
-- Name: nominativo_piani_20230208; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.nominativo_piani_20230208 (
    id bigint,
    id_nominativo_struttura bigint,
    id_piano bigint
);


ALTER TABLE tmp.nominativo_piani_20230208 OWNER TO postgres;

--
-- Name: ns_remap; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.ns_remap (
    idold integer,
    idnew integer
);


ALTER TABLE tmp.ns_remap OWNER TO postgres;

--
-- Name: piani_remap; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.piani_remap (
    idold bigint,
    idnew bigint
);


ALTER TABLE tmp.piani_remap OWNER TO postgres;

--
-- Name: prezzo; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.prezzo (
    sum numeric
);


ALTER TABLE tmp.prezzo OWNER TO postgres;

--
-- Name: prova_scarti_fvg; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.prova_scarti_fvg (
    sd_id integer,
    nome character varying,
    cod_reg character varying,
    comune character varying,
    att character varying
);


ALTER TABLE tmp.prova_scarti_fvg OWNER TO postgres;

--
-- Name: prova_scarti_fvg_26_02; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.prova_scarti_fvg_26_02 (
    sd_id integer,
    nome character varying,
    codice_regionale character varying,
    comune character varying,
    attivita_controllate character varying
);


ALTER TABLE tmp.prova_scarti_fvg_26_02 OWNER TO postgres;

--
-- Name: provincie; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.provincie (
    idprovinciaistat integer,
    siglaprovincia character varying(50)
);


ALTER TABLE tmp.provincie OWNER TO postgres;

--
-- Name: provincie_20230714; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.provincie_20230714 (
    idprovinciaistat integer,
    siglaprovincia character varying(50)
);


ALTER TABLE tmp.provincie_20230714 OWNER TO postgres;

--
-- Name: provincie_20230914; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.provincie_20230914 (
    idprovinciaistat integer,
    siglaprovincia character varying(50)
);


ALTER TABLE tmp.provincie_20230914 OWNER TO postgres;

--
-- Name: provincie_20231120; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.provincie_20231120 (
    idprovinciaistat integer,
    siglaprovincia character varying(50)
);


ALTER TABLE tmp.provincie_20231120 OWNER TO postgres;

--
-- Name: sa; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.sa (
    id bigint,
    id_gisa bigint,
    id_asl bigint,
    codice_interno_fk bigint,
    descrizione text,
    n_livello integer,
    anno integer,
    descrizione_breve text,
    ups double precision,
    uba double precision
);


ALTER TABLE tmp.sa OWNER TO postgres;

--
-- Name: sheet_codici_cu_2024; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.sheet_codici_cu_2024 (
    codici_azienda character varying(512)
);


ALTER TABLE tmp.sheet_codici_cu_2024 OWNER TO postgres;

--
-- Name: sheet_prog_def_cu_2024; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.sheet_prog_def_cu_2024 (
    azienda_codice character varying(512),
    allev_id_fiscale character varying(512),
    spe_descrizione character varying(512),
    tipologia_struttura character varying(512),
    orientamento_produttivo character varying(512)
);


ALTER TABLE tmp.sheet_prog_def_cu_2024 OWNER TO postgres;

--
-- Name: soggetti_fisici_20240712; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.soggetti_fisici_20240712 (
    id bigint,
    titolo character varying,
    cognome character varying,
    nome character varying,
    comune_nascita character varying,
    codice_fiscale character varying,
    sesso character varying,
    telefono character varying,
    email character varying,
    pec character varying,
    telefono2 character varying,
    data_nascita date,
    documento_identita character varying,
    indirizzo_id bigint,
    verificato boolean,
    fonte character varying
);


ALTER TABLE tmp.soggetti_fisici_20240712 OWNER TO postgres;

--
-- Name: soggetti_fisici_non_validi_2024_10_11; Type: TABLE; Schema: tmp; Owner: gisa_fvg
--

CREATE TABLE tmp.soggetti_fisici_non_validi_2024_10_11 (
    split_check_cf character varying,
    id bigint,
    titolo character varying,
    cognome character varying,
    nome character varying,
    comune_nascita character varying,
    codice_fiscale character varying,
    sesso character varying,
    telefono character varying,
    email character varying,
    pec character varying,
    telefono2 character varying,
    data_nascita date,
    documento_identita character varying,
    indirizzo_id bigint,
    verificato boolean,
    fonte character varying
);


ALTER TABLE tmp.soggetti_fisici_non_validi_2024_10_11 OWNER TO gisa_fvg;

--
-- Name: stab_sto; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.stab_sto (
    id_stabilimento bigint,
    id_impresa bigint,
    validita tsrange,
    "?column?" text
);


ALTER TABLE tmp.stab_sto OWNER TO postgres;

--
-- Name: stabilimenti_2024_02_13; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.stabilimenti_2024_02_13 (
    id bigint,
    id_impresa bigint,
    nome character varying,
    sd_id numeric(12,0),
    id_indirizzo bigint,
    sd_cod_regionale character varying,
    cod_tipologia_struttura character varying,
    verificato boolean,
    fonte character varying,
    cod_registrazione character varying,
    categoria_rischio numeric,
    validita tsrange,
    cod_nazionale character varying,
    id_tipologia_struttura bigint
);


ALTER TABLE tmp.stabilimenti_2024_02_13 OWNER TO postgres;

--
-- Name: stabilimenti_210623; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.stabilimenti_210623 (
    id bigint,
    id_impresa bigint,
    riferimento_id integer,
    riferimento_id_nome_tab text
);


ALTER TABLE tmp.stabilimenti_210623 OWNER TO postgres;

--
-- Name: stabilimenti_852_da_cancellare_2024_06_11; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.stabilimenti_852_da_cancellare_2024_06_11 (
    id bigint,
    id_impresa bigint,
    nome character varying,
    sd_id numeric(12,0),
    id_indirizzo bigint,
    cod_regionale character varying,
    verificato boolean,
    fonte character varying,
    categoria_rischio numeric,
    validita tsrange,
    cod_nazionale character varying,
    id_tipologia_struttura bigint,
    pec character varying,
    telefono character varying,
    sdi character varying
);


ALTER TABLE tmp.stabilimenti_852_da_cancellare_2024_06_11 OWNER TO postgres;

--
-- Name: stabilimenti_852_legame_2024_06_11; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.stabilimenti_852_legame_2024_06_11 (
    id_old bigint,
    id_new bigint,
    id bigint,
    id_impresa bigint,
    nome character varying,
    sd_id numeric(12,0),
    id_indirizzo bigint,
    cod_regionale character varying,
    verificato boolean,
    fonte character varying,
    categoria_rischio numeric,
    validita tsrange,
    cod_nazionale character varying,
    id_tipologia_struttura bigint,
    pec character varying,
    telefono character varying,
    sdi character varying
);


ALTER TABLE tmp.stabilimenti_852_legame_2024_06_11 OWNER TO postgres;

--
-- Name: stabilimenti_linee_210623; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.stabilimenti_linee_210623 (
    id bigint,
    id_stabilimento bigint,
    id_linea_gisa integer
);


ALTER TABLE tmp.stabilimenti_linee_210623 OWNER TO postgres;

--
-- Name: stabilimenti_linee_26_09; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.stabilimenti_linee_26_09 (
    id bigint,
    id_stabilimento bigint,
    id_attivita integer,
    id_linea integer,
    riferimento_id integer,
    riferimento_id_nome_tab text,
    num_riconoscimento text,
    n_linea text,
    data_inizio_attivita timestamp without time zone,
    data_fine_attivita timestamp without time zone,
    macroarea text,
    aggregazione text,
    attivita text,
    path_attivita_completo text,
    norma text,
    id_norma integer,
    codice_macroarea text,
    codice_aggregazione text,
    codice_attivita text,
    stato text,
    id_stato integer,
    miscela boolean,
    tipo_attivita_descrizione text,
    tipo_attivita integer,
    sintesis boolean
);


ALTER TABLE tmp.stabilimenti_linee_26_09 OWNER TO postgres;

--
-- Name: stabilimenti_storico_20240411; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.stabilimenti_storico_20240411 (
    id integer,
    id_stabilimento bigint,
    id_impresa bigint,
    validita tsrange,
    note text
);


ALTER TABLE tmp.stabilimenti_storico_20240411 OWNER TO postgres;

--
-- Name: stabilimenti_upd_indirizzi_2024_07_08; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.stabilimenti_upd_indirizzi_2024_07_08 (
    cod_reg text,
    app_num text,
    id_ind_stab bigint,
    id_ind bigint,
    indirizzo_gisa character varying,
    indirizzo_file_new character varying,
    comune_old character varying,
    comune_file_new character varying,
    comune_gisa character varying(32),
    istat_comune_old character varying,
    istat_gisa_new character varying,
    cap_gisa_old text,
    cap_gisa_new_inutile character varying,
    cap_gisa_new integer
);


ALTER TABLE tmp.stabilimenti_upd_indirizzi_2024_07_08 OWNER TO postgres;

--
-- Name: stabilimenti_upd_indirizzi_2024_07_12; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.stabilimenti_upd_indirizzi_2024_07_12 (
    cod_reg text,
    app_num text,
    id_ind_stab bigint,
    id_ind bigint,
    indirizzo_gisa character varying,
    indirizzo_file_new character varying,
    comune_old character varying,
    comune_file_new character varying,
    comune_gisa character varying(32),
    istat_comune_old character varying,
    istat_gisa_new character varying,
    cap_gisa_old text,
    cap_gisa_new_inutile character varying,
    cap_gisa_new integer
);


ALTER TABLE tmp.stabilimenti_upd_indirizzi_2024_07_12 OWNER TO postgres;

--
-- Name: stabilimento_figure_20240308; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.stabilimento_figure_20240308 (
    id bigint,
    id_stabilimento bigint,
    id_soggetto bigint,
    id_tipo_figura bigint,
    id_indirizzo bigint,
    old_id bigint,
    fonte text,
    descr character varying,
    validita tsrange
);


ALTER TABLE tmp.stabilimento_figure_20240308 OWNER TO postgres;

--
-- Name: struttura_asl; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.struttura_asl (
    id bigint,
    id_gisa bigint,
    id_asl bigint,
    codice_interno_fk bigint,
    descrizione text,
    n_livello integer,
    anno integer,
    descrizione_breve text,
    ups double precision,
    uba double precision
);


ALTER TABLE tmp.struttura_asl OWNER TO postgres;

--
-- Name: struttura_asl_20230301; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.struttura_asl_20230301 (
    id bigint,
    id_gisa bigint,
    id_asl bigint,
    codice_interno_fk bigint,
    descrizione text,
    n_livello integer,
    anno integer,
    descrizione_breve text,
    ups double precision,
    uba double precision,
    codice_interno_univoco bigint
);


ALTER TABLE tmp.struttura_asl_20230301 OWNER TO postgres;

--
-- Name: struttura_asl_2024; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.struttura_asl_2024 (
    id bigint,
    id_gisa bigint,
    id_asl bigint,
    codice_interno_fk bigint,
    descrizione text,
    n_livello integer,
    anno integer,
    descrizione_breve text,
    ups double precision,
    uba double precision,
    codice_interno_univoco bigint
);


ALTER TABLE tmp.struttura_asl_2024 OWNER TO postgres;

--
-- Name: struttura_comuni_20230117; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.struttura_comuni_20230117 (
    id bigint,
    id_comune bigint,
    id_struttura bigint
);


ALTER TABLE tmp.struttura_comuni_20230117 OWNER TO postgres;

--
-- Name: struttura_comuni_28122022; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.struttura_comuni_28122022 (
    id bigint,
    id_comune bigint,
    id_struttura bigint
);


ALTER TABLE tmp.struttura_comuni_28122022 OWNER TO postgres;

--
-- Name: struttura_piani_14062023; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.struttura_piani_14062023 (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying,
    ha_campioni boolean,
    id_tipo_tecnica bigint
);


ALTER TABLE tmp.struttura_piani_14062023 OWNER TO postgres;

--
-- Name: struttura_piani_20230118; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.struttura_piani_20230118 (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying,
    ha_campioni boolean,
    id_tipo_tecnica bigint
);


ALTER TABLE tmp.struttura_piani_20230118 OWNER TO postgres;

--
-- Name: struttura_piani_2024; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.struttura_piani_2024 (
    id bigint,
    id_gisa bigint,
    id_asl bigint,
    codice_interno_fk bigint,
    descrizione text,
    n_livello integer,
    anno integer,
    descrizione_breve text,
    ups double precision,
    uba double precision,
    codice_interno_univoco bigint
);


ALTER TABLE tmp.struttura_piani_2024 OWNER TO postgres;

--
-- Name: struttura_piani_target_20240322; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.struttura_piani_target_20240322 (
    id integer,
    id_struttura integer,
    id_piano integer,
    target double precision
);


ALTER TABLE tmp.struttura_piani_target_20240322 OWNER TO postgres;

--
-- Name: struttura_piano_20220929; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.struttura_piano_20220929 (
    id bigint,
    id_gisa bigint,
    cod_raggruppamento bigint,
    anno integer,
    descrizione text,
    ordinamento integer,
    data_scadenza timestamp without time zone,
    stato integer,
    codice_interno integer,
    color character varying(100),
    path text,
    livello bigint,
    alias text,
    id_formula_ups bigint,
    id_formula_uba bigint,
    descrizione_breve text,
    codice_interno_univoco character varying,
    ha_campioni boolean,
    id_tipo_tecnica bigint
);


ALTER TABLE tmp.struttura_piano_20220929 OWNER TO postgres;

--
-- Name: struttura_piano_target_20221216; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.struttura_piano_target_20221216 (
    id integer,
    id_struttura integer,
    id_piano integer,
    target double precision
);


ALTER TABLE tmp.struttura_piano_target_20221216 OWNER TO postgres;

--
-- Name: struttura_piano_target_20230120; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.struttura_piano_target_20230120 (
    id integer,
    id_struttura integer,
    id_piano integer,
    target double precision
);


ALTER TABLE tmp.struttura_piano_target_20230120 OWNER TO postgres;

--
-- Name: tariffa_strutture; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tariffa_strutture (
    id bigint,
    id_tariffa bigint,
    id_asl bigint,
    validita tsrange
);


ALTER TABLE tmp.tariffa_strutture OWNER TO postgres;

--
-- Name: tariffa_strutture_20231025; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tariffa_strutture_20231025 (
    id bigint,
    id_tariffa bigint,
    id_asl bigint,
    validita tsrange
);


ALTER TABLE tmp.tariffa_strutture_20231025 OWNER TO postgres;

--
-- Name: tariffa_strutture_20231118; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tariffa_strutture_20231118 (
    id bigint,
    id_tariffa bigint,
    id_asl bigint,
    validita tsrange
);


ALTER TABLE tmp.tariffa_strutture_20231118 OWNER TO postgres;

--
-- Name: tariffa_strutture_20231121; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tariffa_strutture_20231121 (
    id bigint,
    id_tariffa bigint,
    id_asl bigint,
    validita tsrange
);


ALTER TABLE tmp.tariffa_strutture_20231121 OWNER TO postgres;

--
-- Name: tariffa_voci; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tariffa_voci (
    id bigint,
    id_tariffa_struttura bigint,
    scaglione numrange,
    ordine integer
);


ALTER TABLE tmp.tariffa_voci OWNER TO postgres;

--
-- Name: tariffa_voci_20230830; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tariffa_voci_20230830 (
    id bigint,
    id_tariffa_struttura bigint,
    scaglione numrange,
    ordine integer
);


ALTER TABLE tmp.tariffa_voci_20230830 OWNER TO postgres;

--
-- Name: tariffa_voci_20231118; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tariffa_voci_20231118 (
    id bigint,
    id_tariffa_struttura bigint,
    scaglione numrange,
    ordine integer
);


ALTER TABLE tmp.tariffa_voci_20231118 OWNER TO postgres;

--
-- Name: tariffa_voci_calcolo; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tariffa_voci_calcolo (
    id_tariffa_voce bigint,
    valore numeric,
    tipo integer
);


ALTER TABLE tmp.tariffa_voci_calcolo OWNER TO postgres;

--
-- Name: tariffa_voci_id_seq; Type: SEQUENCE; Schema: tmp; Owner: postgres
--

CREATE SEQUENCE tmp.tariffa_voci_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tmp.tariffa_voci_id_seq OWNER TO postgres;

--
-- Name: tariffe_20230831; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tariffe_20230831 (
    id bigint,
    id_tariffario bigint,
    sigla character varying,
    descr character varying,
    cod_iva character varying,
    nota character varying,
    visibile_trf boolean,
    visibile_fatt boolean,
    id_u_mis bigint,
    visibile_piani boolean,
    visibile_contabilita boolean,
    pdc character varying,
    ordine_tariffa integer,
    validita tsrange,
    livello_asl boolean,
    cod_conto_iva character varying
);


ALTER TABLE tmp.tariffe_20230831 OWNER TO postgres;

--
-- Name: tipo_linee_020223; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tipo_linee_020223 (
    id bigint,
    cod text,
    descr text
);


ALTER TABLE tmp.tipo_linee_020223 OWNER TO postgres;

--
-- Name: tipo_linee_20230206; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tipo_linee_20230206 (
    id bigint,
    cod text,
    descr text
);


ALTER TABLE tmp.tipo_linee_20230206 OWNER TO postgres;

--
-- Name: tn; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tn (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE tmp.tn OWNER TO postgres;

--
-- Name: tree_anno_20221209; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tree_anno_20221209 (
    anno integer,
    id_tree bigint,
    id_root bigint
);


ALTER TABLE tmp.tree_anno_20221209 OWNER TO postgres;

--
-- Name: tree_anno_2024; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tree_anno_2024 (
    anno integer,
    id_tree bigint,
    id_root bigint
);


ALTER TABLE tmp.tree_anno_2024 OWNER TO postgres;

--
-- Name: tree_nodes_14062023; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tree_nodes_14062023 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE tmp.tree_nodes_14062023 OWNER TO postgres;

--
-- Name: tree_nodes_20220929; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tree_nodes_20220929 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE tmp.tree_nodes_20220929 OWNER TO postgres;

--
-- Name: tree_nodes_20221209; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tree_nodes_20221209 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE tmp.tree_nodes_20221209 OWNER TO postgres;

--
-- Name: tree_nodes_20230118; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tree_nodes_20230118 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE tmp.tree_nodes_20230118 OWNER TO postgres;

--
-- Name: tree_nodes_20230301; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tree_nodes_20230301 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE tmp.tree_nodes_20230301 OWNER TO postgres;

--
-- Name: tree_nodes_20230504; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tree_nodes_20230504 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE tmp.tree_nodes_20230504 OWNER TO postgres;

--
-- Name: tree_nodes_20230505; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tree_nodes_20230505 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE tmp.tree_nodes_20230505 OWNER TO postgres;

--
-- Name: tree_nodes_20230505_; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tree_nodes_20230505_ (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE tmp.tree_nodes_20230505_ OWNER TO postgres;

--
-- Name: tree_nodes_20230522; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tree_nodes_20230522 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE tmp.tree_nodes_20230522 OWNER TO postgres;

--
-- Name: tree_nodes_20231025; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.tree_nodes_20231025 (
    id bigint,
    id_tree bigint,
    id_parent bigint,
    ordinamento character varying,
    node_descr character varying
);


ALTER TABLE tmp.tree_nodes_20231025 OWNER TO postgres;

--
-- Name: trf_att_inviate_20231102; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.trf_att_inviate_20231102 (
    id bigint,
    id_trf_attivita bigint,
    tm_invio timestamp without time zone,
    str_j json
);


ALTER TABLE tmp.trf_att_inviate_20231102 OWNER TO postgres;

--
-- Name: trf_attivita_dettagli_20230522; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.trf_attivita_dettagli_20230522 (
    id bigint,
    id_trf_attivita bigint,
    id_tariffa bigint,
    valore character varying,
    costo numeric
);


ALTER TABLE tmp.trf_attivita_dettagli_20230522 OWNER TO postgres;

--
-- Name: trf_fattura_stati; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.trf_fattura_stati (
    id bigint,
    descr character varying,
    ord integer,
    cod character varying,
    act_required character varying
);


ALTER TABLE tmp.trf_fattura_stati OWNER TO postgres;

--
-- Name: trf_fattura_stati_20230714; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.trf_fattura_stati_20230714 (
    id bigint,
    descr character varying,
    ord integer,
    cod character varying,
    act_required character varying
);


ALTER TABLE tmp.trf_fattura_stati_20230714 OWNER TO postgres;

--
-- Name: trf_regole_fatt_230526; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.trf_regole_fatt_230526 (
    id bigint,
    op character varying,
    val numeric,
    id_tariffa bigint,
    ord_exec integer
);


ALTER TABLE tmp.trf_regole_fatt_230526 OWNER TO postgres;

--
-- Name: trf_regole_fatt_dett230526; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.trf_regole_fatt_dett230526 (
    id bigint,
    id_regola_fatt bigint,
    id_tariffa bigint
);


ALTER TABLE tmp.trf_regole_fatt_dett230526 OWNER TO postgres;

--
-- Name: trf_ui_24102023; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.trf_ui_24102023 (
    id_tariffa bigint,
    ui_info character varying,
    ui_info_fatt character varying
);


ALTER TABLE tmp.trf_ui_24102023 OWNER TO postgres;

--
-- Name: upd_descr_breve; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.upd_descr_breve (
    id integer NOT NULL,
    tipo character varying,
    to_be_rep character varying,
    rep character varying,
    condition character varying,
    ordine integer,
    tabella character varying,
    metodo character varying
);


ALTER TABLE tmp.upd_descr_breve OWNER TO postgres;

--
-- Name: upd_descr_breve_id_seq; Type: SEQUENCE; Schema: tmp; Owner: postgres
--

CREATE SEQUENCE tmp.upd_descr_breve_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tmp.upd_descr_breve_id_seq OWNER TO postgres;

--
-- Name: upd_descr_breve_id_seq; Type: SEQUENCE OWNED BY; Schema: tmp; Owner: postgres
--

ALTER SEQUENCE tmp.upd_descr_breve_id_seq OWNED BY tmp.upd_descr_breve.id;


--
-- Name: utenti_fvg; Type: TABLE; Schema: tmp; Owner: postgres
--

CREATE TABLE tmp.utenti_fvg (
    "#" integer,
    "Username" character varying,
    "Cognome" character varying,
    "Nome" character varying,
    "Codice Fiscale" character varying,
    "ASL" character varying,
    "Struttura" character varying,
    "Column8" integer,
    "Ruolo" character varying,
    id_anagrafica integer
);


ALTER TABLE tmp.utenti_fvg OWNER TO postgres;

--
-- Name: utenti_select_prod; Type: TABLE; Schema: tmp; Owner: gisa_fvg
--

CREATE TABLE tmp.utenti_select_prod (
    id_anagrafica bigint,
    codice_fiscale character varying,
    id_qualifica bigint,
    id_asl bigint,
    mail character varying,
    tel character varying,
    dpat boolean,
    tsrange tsrange
);


ALTER TABLE tmp.utenti_select_prod OWNER TO gisa_fvg;

--
-- Name: utenti_strutture_select_prod; Type: TABLE; Schema: tmp; Owner: gisa_fvg
--

CREATE TABLE tmp.utenti_strutture_select_prod (
    id integer,
    id_anagrafica bigint,
    id_struttura bigint,
    tsrange tsrange,
    id_nominativo bigint
);


ALTER TABLE tmp.utenti_strutture_select_prod OWNER TO gisa_fvg;

--
-- Name: _tariffe_voci; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf._tariffe_voci (
    id bigint NOT NULL,
    id_tariffa bigint,
    id_u_mis bigint
);


ALTER TABLE trf._tariffe_voci OWNER TO postgres;

--
-- Name: cliente_sicer; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.cliente_sicer (
    id bigint,
    n bigint
);


ALTER TABLE trf.cliente_sicer OWNER TO postgres;

--
-- Name: clienti_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.clienti_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.clienti_id_seq OWNER TO postgres;

--
-- Name: clienti_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.clienti_id_seq OWNED BY trf.clienti.id;


--
-- Name: clienti_per_sicer; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.clienti_per_sicer (
    id bigint,
    descr character varying,
    id_cliente bigint,
    descr_cliente character varying,
    indirizzo character varying,
    comune character varying(32),
    rag_soc character varying,
    piva character varying,
    codfis character varying,
    indirizzo_fatturazione character varying,
    comune_fatturazione character varying,
    cap_fatturazione character varying,
    sdi character varying,
    inviaresdi boolean,
    is_split boolean,
    nazione character varying,
    comune_istat text,
    provincia_istat text,
    nome character varying,
    cognome character varying,
    comune_istat_fatturazione text,
    provincia_istat_fatturazione text
);


ALTER TABLE trf.clienti_per_sicer OWNER TO postgres;

--
-- Name: imprese_2; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.imprese_2 (
    id bigint,
    nome character varying,
    cf character varying,
    piva character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    az_id bigint,
    az_cod_aziendale character varying,
    az_cod_regionale character varying
);


ALTER TABLE trf.imprese_2 OWNER TO postgres;

--
-- Name: imprese_sicer; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.imprese_sicer (
    id bigint,
    nome character varying,
    cf character varying,
    piva character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    az_id bigint,
    az_cod_aziendale character varying,
    az_cod_regionale character varying
);


ALTER TABLE trf.imprese_sicer OWNER TO postgres;

--
-- Name: indirizzi_2; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.indirizzi_2 (
    id bigint NOT NULL,
    toponimo character varying,
    indirizzo character varying,
    cap character varying,
    stato_prov character varying,
    nazione character varying,
    comune character varying,
    localita character varying,
    civico character varying
);


ALTER TABLE trf.indirizzi_2 OWNER TO postgres;

--
-- Name: indirizzi_2_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.indirizzi_2_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.indirizzi_2_id_seq OWNER TO postgres;

--
-- Name: indirizzi_2_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.indirizzi_2_id_seq OWNED BY trf.indirizzi_2.id;


--
-- Name: indirizzi_sicer; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.indirizzi_sicer (
    id bigint NOT NULL,
    toponimo character varying,
    indirizzo character varying,
    cap character varying,
    stato_prov character varying,
    nazione character varying,
    comune character varying,
    localita character varying,
    civico character varying
);


ALTER TABLE trf.indirizzi_sicer OWNER TO postgres;

--
-- Name: indirizzi_sicer_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.indirizzi_sicer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.indirizzi_sicer_id_seq OWNER TO postgres;

--
-- Name: indirizzi_sicer_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.indirizzi_sicer_id_seq OWNED BY trf.indirizzi_sicer.id;


--
-- Name: j_tree; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.j_tree (
    json_tree json
);


ALTER TABLE trf.j_tree OWNER TO postgres;

--
-- Name: old_template_fatturazione; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.old_template_fatturazione (
    id integer NOT NULL,
    descr character varying,
    testo character varying
);


ALTER TABLE trf.old_template_fatturazione OWNER TO postgres;

--
-- Name: old_trf_ui; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.old_trf_ui (
    id_tariffa bigint,
    ui_info character varying,
    ui_info_fatt character varying
);


ALTER TABLE trf.old_trf_ui OWNER TO postgres;

--
-- Name: old_trf_ui_righe_fatt; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.old_trf_ui_righe_fatt (
    id_tariffa bigint,
    descr_in_fatt character varying
);


ALTER TABLE trf.old_trf_ui_righe_fatt OWNER TO postgres;

--
-- Name: prezzo; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.prezzo (
    sum numeric
);


ALTER TABLE trf.prezzo OWNER TO postgres;

--
-- Name: servizi_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.servizi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.servizi_id_seq OWNER TO postgres;

--
-- Name: servizi_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.servizi_id_seq OWNED BY trf.servizi.id;


--
-- Name: stabilimenti_sicer; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.stabilimenti_sicer (
    id bigint,
    id_impresa bigint,
    sd_id numeric(12,0),
    nome character varying,
    prov character varying,
    istat character varying,
    comune character varying,
    toponimo character varying,
    indirizzo character varying,
    civico character varying,
    cf character varying,
    piva character varying,
    sd_cod_tipologia_struttura character varying
);


ALTER TABLE trf.stabilimenti_sicer OWNER TO postgres;

--
-- Name: stabilimenti_sicer_2; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.stabilimenti_sicer_2 (
    id bigint,
    id_impresa bigint,
    sd_id numeric(12,0),
    nome character varying,
    prov character varying,
    istat character varying,
    comune character varying,
    toponimo character varying,
    indirizzo character varying,
    civico character varying,
    cf character varying,
    piva character varying,
    sd_cod_tipologia_struttura character varying
);


ALTER TABLE trf.stabilimenti_sicer_2 OWNER TO postgres;

--
-- Name: stabilimento_sedi_2; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.stabilimento_sedi_2 (
    id bigint NOT NULL,
    id_stabilimento bigint NOT NULL,
    id_tipo_sede bigint NOT NULL,
    id_indirizzo bigint NOT NULL,
    cf character varying,
    piva character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    old_id bigint
);


ALTER TABLE trf.stabilimento_sedi_2 OWNER TO postgres;

--
-- Name: stabilimento_sedi_2_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.stabilimento_sedi_2_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.stabilimento_sedi_2_id_seq OWNER TO postgres;

--
-- Name: stabilimento_sedi_2_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.stabilimento_sedi_2_id_seq OWNED BY trf.stabilimento_sedi_2.id;


--
-- Name: stabilimento_sedi_sicer; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.stabilimento_sedi_sicer (
    id bigint NOT NULL,
    id_stabilimento bigint NOT NULL,
    id_tipo_sede bigint NOT NULL,
    id_indirizzo bigint NOT NULL,
    cf character varying,
    piva character varying,
    pec character varying,
    email character varying,
    sdi character varying,
    split_payement character varying,
    cod_tipo_impresa character varying,
    old_id bigint
);


ALTER TABLE trf.stabilimento_sedi_sicer OWNER TO postgres;

--
-- Name: stabilimento_sedi_sicer_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.stabilimento_sedi_sicer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.stabilimento_sedi_sicer_id_seq OWNER TO postgres;

--
-- Name: stabilimento_sedi_sicer_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.stabilimento_sedi_sicer_id_seq OWNED BY trf.stabilimento_sedi_sicer.id;


--
-- Name: tariffa_ml; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.tariffa_ml (
    id bigint NOT NULL,
    id_linea_attivita bigint NOT NULL,
    validita tsrange NOT NULL
);


ALTER TABLE trf.tariffa_ml OWNER TO postgres;

--
-- Name: tariffa_ml_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.tariffa_ml_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.tariffa_ml_id_seq OWNER TO postgres;

--
-- Name: tariffa_ml_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.tariffa_ml_id_seq OWNED BY trf.tariffa_ml.id;


--
-- Name: tariffa_ml_livello; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.tariffa_ml_livello (
    id bigint NOT NULL,
    id_tariffa_ml bigint NOT NULL,
    livello integer NOT NULL,
    valore numeric NOT NULL
);


ALTER TABLE trf.tariffa_ml_livello OWNER TO postgres;

--
-- Name: tariffa_ml_livello_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.tariffa_ml_livello_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.tariffa_ml_livello_id_seq OWNER TO postgres;

--
-- Name: tariffa_ml_livello_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.tariffa_ml_livello_id_seq OWNED BY trf.tariffa_ml_livello.id;


--
-- Name: tariffa_strutture; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.tariffa_strutture (
    id bigint NOT NULL,
    id_tariffa bigint NOT NULL,
    id_asl bigint,
    validita tsrange NOT NULL
);


ALTER TABLE trf.tariffa_strutture OWNER TO postgres;

--
-- Name: tariffa_strutture_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.tariffa_strutture_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.tariffa_strutture_id_seq OWNER TO postgres;

--
-- Name: tariffa_strutture_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.tariffa_strutture_id_seq OWNED BY trf.tariffa_strutture.id;


--
-- Name: tariffa_voci_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.tariffa_voci_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.tariffa_voci_id_seq OWNER TO postgres;

--
-- Name: tariffa_voci_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.tariffa_voci_id_seq OWNED BY trf._tariffe_voci.id;


--
-- Name: tariffa_voci; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.tariffa_voci (
    id bigint DEFAULT nextval('trf.tariffa_voci_id_seq'::regclass) NOT NULL,
    id_tariffa_struttura bigint NOT NULL,
    scaglione numrange,
    ordine integer
);


ALTER TABLE trf.tariffa_voci OWNER TO postgres;

--
-- Name: tariffa_voci_calcolo; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.tariffa_voci_calcolo (
    id_tariffa_voce bigint,
    valore numeric,
    tipo integer
);


ALTER TABLE trf.tariffa_voci_calcolo OWNER TO postgres;

--
-- Name: tariffario_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.tariffario_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.tariffario_id_seq OWNER TO postgres;

--
-- Name: tariffario_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.tariffario_id_seq OWNED BY trf.tariffari.id;


--
-- Name: tariffe_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.tariffe_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.tariffe_id_seq OWNER TO postgres;

--
-- Name: tariffe_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.tariffe_id_seq OWNED BY trf.tariffe.id;


--
-- Name: tariffe_u_mis_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.tariffe_u_mis_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.tariffe_u_mis_id_seq OWNER TO postgres;

--
-- Name: tariffe_u_mis_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.tariffe_u_mis_id_seq OWNED BY trf.tariffe_u_mis.id;


--
-- Name: template_fatturazione_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.template_fatturazione_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.template_fatturazione_id_seq OWNER TO postgres;

--
-- Name: template_fatturazione_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.template_fatturazione_id_seq OWNED BY trf.old_template_fatturazione.id;


--
-- Name: trf_att_inviate_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_att_inviate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_att_inviate_id_seq OWNER TO postgres;

--
-- Name: trf_att_inviate_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_att_inviate_id_seq OWNED BY trf.trf_att_inviate.id;


--
-- Name: trf_att_inviate_stati_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_att_inviate_stati_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_att_inviate_stati_id_seq OWNER TO postgres;

--
-- Name: trf_att_inviate_stati_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_att_inviate_stati_id_seq OWNED BY trf.trf_att_inviate_stati.id;


--
-- Name: trf_attivita_dettagli_forfet; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_attivita_dettagli_forfet (
    id bigint,
    id_trf_attivita bigint,
    id_tariffa bigint,
    valore character varying,
    costo numeric
);


ALTER TABLE trf.trf_attivita_dettagli_forfet OWNER TO postgres;

--
-- Name: trf_attivita_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_attivita_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_attivita_id_seq OWNER TO postgres;

--
-- Name: trf_attivita_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_attivita_id_seq OWNED BY trf.trf_attivita.id;


--
-- Name: trf_cod_iva; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_cod_iva (
    id bigint NOT NULL,
    cod_iva character varying,
    descr_iva character varying,
    perc numeric
);


ALTER TABLE trf.trf_cod_iva OWNER TO postgres;

--
-- Name: trf_cod_iva_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_cod_iva_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_cod_iva_id_seq OWNER TO postgres;

--
-- Name: trf_cod_iva_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_cod_iva_id_seq OWNED BY trf.trf_cod_iva.id;


--
-- Name: trf_fattura_dettagli_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_fattura_dettagli_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_fattura_dettagli_id_seq OWNER TO postgres;

--
-- Name: trf_fattura_dettagli_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_fattura_dettagli_id_seq OWNED BY trf.trf_fattura_dettagli.id;


--
-- Name: trf_fattura_stati; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_fattura_stati (
    id bigint NOT NULL,
    id_trf_fattura bigint,
    ret character varying,
    id_trf_stato bigint,
    ts timestamp without time zone
);


ALTER TABLE trf.trf_fattura_stati OWNER TO postgres;

--
-- Name: trf_fattura_stati_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_fattura_stati_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_fattura_stati_id_seq OWNER TO postgres;

--
-- Name: trf_fattura_stati_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_fattura_stati_id_seq OWNED BY trf.trf_fattura_stati.id;


--
-- Name: trf_fatture_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_fatture_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_fatture_id_seq OWNER TO postgres;

--
-- Name: trf_fatture_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_fatture_id_seq OWNED BY trf.trf_fatture.id;


--
-- Name: trf_ft_periodiche; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_ft_periodiche (
    id bigint NOT NULL,
    id_cliente bigint NOT NULL,
    data_creazione timestamp without time zone NOT NULL,
    id_asl bigint NOT NULL,
    n_ft_periodica bigint,
    open_amt double precision,
    dt date
);


ALTER TABLE trf.trf_ft_periodiche OWNER TO postgres;

--
-- Name: trf_ft_periodiche_dett; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_ft_periodiche_dett (
    id bigint NOT NULL,
    id_trf_ft_periodica bigint NOT NULL,
    dt date NOT NULL,
    descr_tariffa character varying NOT NULL,
    costo numeric NOT NULL,
    ordine integer,
    stringa_xml character varying,
    id_trf_fattura bigint
);


ALTER TABLE trf.trf_ft_periodiche_dett OWNER TO postgres;

--
-- Name: trf_ft_periodiche_dettagli_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_ft_periodiche_dettagli_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_ft_periodiche_dettagli_id_seq OWNER TO postgres;

--
-- Name: trf_ft_periodiche_dettagli_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_ft_periodiche_dettagli_id_seq OWNED BY trf.trf_ft_periodiche_dett.id;


--
-- Name: trf_ft_periodiche_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_ft_periodiche_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_ft_periodiche_id_seq OWNER TO postgres;

--
-- Name: trf_ft_periodiche_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_ft_periodiche_id_seq OWNED BY trf.trf_ft_periodiche.id;


--
-- Name: trf_ft_periodiche_stati; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_ft_periodiche_stati (
    id bigint NOT NULL,
    id_trf_ft_periodica bigint,
    ret character varying,
    id_trf_stato bigint,
    ts timestamp without time zone
);


ALTER TABLE trf.trf_ft_periodiche_stati OWNER TO postgres;

--
-- Name: trf_ft_periodiche_stati_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_ft_periodiche_stati_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_ft_periodiche_stati_id_seq OWNER TO postgres;

--
-- Name: trf_ft_periodiche_stati_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_ft_periodiche_stati_id_seq OWNED BY trf.trf_ft_periodiche_stati.id;


--
-- Name: trf_piano_tariffa; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_piano_tariffa (
    id bigint NOT NULL,
    id_tariffa bigint NOT NULL,
    id_piano bigint NOT NULL
);


ALTER TABLE trf.trf_piano_tariffa OWNER TO postgres;

--
-- Name: trf_piano_tariffa_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_piano_tariffa_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_piano_tariffa_id_seq OWNER TO postgres;

--
-- Name: trf_piano_tariffa_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_piano_tariffa_id_seq OWNED BY trf.trf_piano_tariffa.id;


--
-- Name: trf_regole_fatt; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_regole_fatt (
    id bigint NOT NULL,
    op character varying NOT NULL,
    val numeric,
    id_tariffa bigint,
    ord_exec integer
);


ALTER TABLE trf.trf_regole_fatt OWNER TO postgres;

--
-- Name: trf_regole_fatt_dett; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_regole_fatt_dett (
    id bigint NOT NULL,
    id_regola_fatt bigint NOT NULL,
    id_tariffa bigint NOT NULL
);


ALTER TABLE trf.trf_regole_fatt_dett OWNER TO postgres;

--
-- Name: trf_regole_fatt_dett_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_regole_fatt_dett_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_regole_fatt_dett_id_seq OWNER TO postgres;

--
-- Name: trf_regole_fatt_dett_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_regole_fatt_dett_id_seq OWNED BY trf.trf_regole_fatt_dett.id;


--
-- Name: trf_regole_fatt_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_regole_fatt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_regole_fatt_id_seq OWNER TO postgres;

--
-- Name: trf_regole_fatt_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_regole_fatt_id_seq OWNED BY trf.trf_regole_fatt.id;


--
-- Name: trf_scontrino_pdf; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_scontrino_pdf (
    id integer NOT NULL,
    id_trf_fattura bigint,
    base64_pdf bytea,
    filename character varying
);


ALTER TABLE trf.trf_scontrino_pdf OWNER TO postgres;

--
-- Name: trf_sscontrino_pdf_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_sscontrino_pdf_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_sscontrino_pdf_id_seq OWNER TO postgres;

--
-- Name: trf_sscontrino_pdf_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_sscontrino_pdf_id_seq OWNED BY trf.trf_scontrino_pdf.id;


--
-- Name: trf_ws_calls; Type: TABLE; Schema: trf; Owner: postgres
--

CREATE TABLE trf.trf_ws_calls (
    id bigint NOT NULL,
    inp character varying,
    id_fattura bigint,
    "out" character varying,
    in_ts timestamp without time zone,
    out_ts timestamp without time zone
);


ALTER TABLE trf.trf_ws_calls OWNER TO postgres;

--
-- Name: trf_ws_calls_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.trf_ws_calls_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.trf_ws_calls_id_seq OWNER TO postgres;

--
-- Name: trf_ws_calls_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.trf_ws_calls_id_seq OWNED BY trf.trf_ws_calls.id;


--
-- Name: voci_tariffa_id_seq; Type: SEQUENCE; Schema: trf; Owner: postgres
--

CREATE SEQUENCE trf.voci_tariffa_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf.voci_tariffa_id_seq OWNER TO postgres;

--
-- Name: voci_tariffa_id_seq; Type: SEQUENCE OWNED BY; Schema: trf; Owner: postgres
--

ALTER SEQUENCE trf.voci_tariffa_id_seq OWNED BY trf.tariffa_voci.id;


--
-- Name: vw_dati_per_contabilita; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_dati_per_contabilita AS
 SELECT r.id,
    r.id AS id_fattura_dettaglio,
    r.id_trf_fattura,
        CASE
            WHEN (((f.piva IS NULL) OR ((f.piva)::text = ''::text)) AND (((f.nome IS NOT NULL) AND ((f.nome)::text <> ''::text)) OR ((f.cognome IS NOT NULL) AND ((f.cognome)::text <> ''::text)))) THEN ''::character varying
            ELSE f.rag_soc
        END AS ragione_sociale,
    f.codfis AS fiscal_code,
    (replace((f.piva)::text, 'IT'::text, ''::text))::character varying AS tax_id,
    f.indirizzo_fatturazione AS indirizzo,
    f.provincia_istat AS regionname,
    (f.comune_istat)::character varying AS city,
    f.cap_fatturazione AS cap,
    f.data_creazione AS data_fattura,
    f.numero_fattura AS doc_no,
    f.sdi,
        CASE
            WHEN f.is_split THEN 'Y'::text
            ELSE 'N'::text
        END AS issplit,
        CASE
            WHEN f.inviaresdi THEN 'Y'::text
            ELSE 'N'::text
        END AS inviare_sdi,
    r.ordine AS numero_linea,
    t.descr AS descrizione_linea,
    t.cod_conto_iva AS charge_account_code,
    r.valore AS quantita,
    r.costo AS prezzo,
    t.cod_iva,
    t.pdc AS activity_value,
    (f.nome)::text AS nome,
    (f.cognome)::text AS cognome,
    'Amministrativo'::text AS tipo_indirizzo
   FROM ((trf.vw_trf_fatture f
     JOIN trf.vw_trf_fattura_dettagli r ON ((r.id_trf_fattura = f.id_trf_fattura)))
     JOIN trf.vw_tariffe t ON (((t.id_tariffa = r.id_tariffa) AND t.visibile_contabilita)));


ALTER TABLE trf.vw_dati_per_contabilita OWNER TO postgres;

--
-- Name: vw_dati_per_contabilita_sicer; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_dati_per_contabilita_sicer AS
 SELECT r.id,
    r.id AS id_fattura_dettaglio,
    r.id_trf_fattura,
        CASE
            WHEN (((f.piva IS NULL) OR ((f.piva)::text = ''::text)) AND (((f.nome IS NOT NULL) AND ((f.nome)::text <> ''::text)) OR ((f.cognome IS NOT NULL) AND ((f.cognome)::text <> ''::text)))) THEN ''::character varying
            ELSE f.rag_soc
        END AS ragione_sociale,
    f.codfis AS fiscal_code,
    (replace((f.piva)::text, 'IT'::text, ''::text))::character varying AS tax_id,
    f.indirizzo_fatturazione AS indirizzo,
    f.provincia_istat AS regionname,
    (f.comune_istat)::character varying AS city,
    f.cap_fatturazione AS cap,
    f.data_creazione AS data_fattura,
    f.numero_fattura AS doc_no,
    f.sdi,
        CASE
            WHEN f.is_split THEN 'Y'::text
            ELSE 'N'::text
        END AS issplit,
        CASE
            WHEN f.inviaresdi THEN 'Y'::text
            ELSE 'N'::text
        END AS inviare_sdi,
    r.ordine AS numero_linea,
    t.descr AS descrizione_linea,
    t.cod_conto_iva AS charge_account_code,
    r.valore AS quantita,
    r.costo AS prezzo,
    t.cod_iva,
    t.pdc AS activity_value,
    (f.nome)::text AS nome,
    (f.cognome)::text AS cognome,
    'Amministrativo'::text AS tipo_indirizzo,
    t.sigla
   FROM ((trf.vw_trf_fatture f
     JOIN trf.vw_trf_fattura_dettagli r ON ((r.id_trf_fattura = f.id_trf_fattura)))
     JOIN trf.vw_tariffe t ON (((t.id_tariffa = r.id_tariffa) AND t.visibile_trf)))
  WHERE (NOT (t.id IN ( SELECT tree_nodes.id_parent
           FROM matrix.tree_nodes
          WHERE (tree_nodes.id_parent IS NOT NULL))));


ALTER TABLE trf.vw_dati_per_contabilita_sicer OWNER TO postgres;

--
-- Name: vw_dati_per_query_contabilita; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_dati_per_query_contabilita AS
 SELECT vw_trf_fatture.id,
    vw_trf_fatture.id AS id_fattura,
    vw_trf_fatture.numero_fattura,
    vw_trf_fatture.id AS id_trf_fattura,
    vw_trf_fatture.numero_fattura AS doc_no
   FROM trf.vw_trf_fatture;


ALTER TABLE trf.vw_dati_per_query_contabilita OWNER TO postgres;

--
-- Name: vw_regole_trf_dett; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_regole_trf_dett AS
 SELECT tl.sigla AS sigla_l,
    tr.sigla AS sigla_r,
    r.id_tariffa AS id_tariffa_l,
    d.id_tariffa AS id_tariffa_r,
    r.op,
    r.val,
    r.id,
    r.ord_exec,
    tl.descr AS descr_l,
    tr.descr AS descr_r
   FROM (((trf.trf_regole_fatt r
     JOIN trf.trf_regole_fatt_dett d ON ((d.id_regola_fatt = r.id)))
     JOIN trf.tariffe tl ON ((tl.id = r.id_tariffa)))
     JOIN trf.tariffe tr ON ((tr.id = d.id_tariffa)));


ALTER TABLE trf.vw_regole_trf_dett OWNER TO postgres;

--
-- Name: vw_tariffa_ml; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_tariffa_ml AS
 SELECT tariffa_ml.id,
    tariffa_ml.id AS id_tariffa_ml,
    tariffa_ml.id_linea_attivita,
    tariffa_ml.validita,
    lower(tariffa_ml.validita) AS valida_da,
    upper(tariffa_ml.validita) AS valida_a,
    upper_inf(tariffa_ml.validita) AS aperta
   FROM trf.tariffa_ml;


ALTER TABLE trf.vw_tariffa_ml OWNER TO postgres;

--
-- Name: vw_tariffa_ml_livello; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_tariffa_ml_livello AS
 SELECT l.id,
    l.id AS id_tariffa_ml_livello,
    l.id_tariffa_ml,
    t.id_linea_attivita,
    t.validita,
    t.valida_da,
    t.valida_a,
    t.aperta,
    l.livello,
    (COALESCE(r.descr_livello_rischio, ''::character varying))::text AS liv,
    l.valore,
    tl.cod,
    tl.descr
   FROM (((trf.tariffa_ml_livello l
     JOIN trf.vw_tariffa_ml t ON ((l.id_tariffa_ml = t.id_tariffa_ml)))
     JOIN public.vw_livelli_rischio r ON ((l.livello = r.id_livello_rischio)))
     LEFT JOIN agenda.vw_tipo_linee tl ON ((tl.id_tipo_linea = t.id_linea_attivita)));


ALTER TABLE trf.vw_tariffa_ml_livello OWNER TO postgres;

--
-- Name: vw_tariffa_voci; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_tariffa_voci AS
 SELECT tariffa_voci.id AS id_tariffa_voci,
    tariffa_voci.id,
    tariffa_voci.id_tariffa_struttura,
    tariffa_voci.scaglione,
    tariffa_voci.ordine
   FROM trf.tariffa_voci;


ALTER TABLE trf.vw_tariffa_voci OWNER TO postgres;

--
-- Name: trf_tipi_calcolo; Type: TABLE; Schema: trf_types; Owner: postgres
--

CREATE TABLE trf_types.trf_tipi_calcolo (
    n integer,
    descr character varying
);


ALTER TABLE trf_types.trf_tipi_calcolo OWNER TO postgres;

--
-- Name: vw_tariffe_export; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_tariffe_export AS
 SELECT
        CASE
            WHEN ((a.sigla_tariffa)::text = (a.l)::text) THEN ''::character varying
            ELSE a.sigla_tariffa
        END AS sigla,
        CASE
            WHEN ((a.sigla_tariffa)::text = (a.l)::text) THEN ''::character varying
            ELSE a.descr_tariffa
        END AS descr,
    a.da,
    a.a,
    a.v0 AS minimo,
    a.v1 AS base,
    a.v2 AS scaglione,
    a.v3 AS cumulativo
   FROM ( SELECT t.sigla_tariffa,
            t.descr_tariffa,
            lead(t.sigla_tariffa) OVER (ORDER BY t.sigla_tariffa) AS l,
            lower(v.scaglione) AS da,
            upper(v.scaglione) AS a,
            tc0.descr AS d0,
            vc0.valore AS v0,
            tc1.descr AS d1,
            vc1.valore AS v1,
            tc2.descr AS d2,
            vc2.valore AS v2,
            tc3.descr AS d3,
            vc3.valore AS v3
           FROM ((((((((((matrix.vw_tree_nodes_up_tariffario t
             LEFT JOIN trf.tariffa_strutture s ON ((s.id_tariffa = t.id_node)))
             LEFT JOIN trf.tariffa_voci v ON ((s.id = v.id_tariffa_struttura)))
             LEFT JOIN trf.tariffa_voci_calcolo vc0 ON (((vc0.id_tariffa_voce = v.id) AND (vc0.tipo = 0))))
             LEFT JOIN trf_types.trf_tipi_calcolo tc0 ON ((tc0.n = vc0.tipo)))
             LEFT JOIN trf.tariffa_voci_calcolo vc1 ON (((vc1.id_tariffa_voce = v.id) AND (vc1.tipo = 1))))
             LEFT JOIN trf_types.trf_tipi_calcolo tc1 ON ((tc1.n = vc1.tipo)))
             LEFT JOIN trf.tariffa_voci_calcolo vc2 ON (((vc2.id_tariffa_voce = v.id) AND (vc2.tipo = 2))))
             LEFT JOIN trf_types.trf_tipi_calcolo tc2 ON ((tc2.n = vc2.tipo)))
             LEFT JOIN trf.tariffa_voci_calcolo vc3 ON (((vc3.id_tariffa_voce = v.id) AND (vc3.tipo = 3))))
             LEFT JOIN trf_types.trf_tipi_calcolo tc3 ON ((tc3.n = vc3.tipo)))
          ORDER BY t.path_ord) a;


ALTER TABLE trf.vw_tariffe_export OWNER TO postgres;

--
-- Name: vw_tariffe_u_mis; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_tariffe_u_mis AS
 SELECT tum.id AS id_u_mis,
    tum.id,
    tum.descr
   FROM trf.tariffe_u_mis tum;


ALTER TABLE trf.vw_tariffe_u_mis OWNER TO postgres;

--
-- Name: vw_trf_att_forf_riep; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_att_forf_riep AS
 SELECT to_char(date_trunc('year'::text, vtf.data_da), 'yyyy'::text) AS anno,
    count(*) AS n_attivita,
    sum(COALESCE((vtf.imponibile)::numeric, (0)::numeric)) AS tot_attivita
   FROM trf.vw_trf_attivita_forfet vtf
  GROUP BY (to_char(date_trunc('year'::text, vtf.data_da), 'yyyy'::text));


ALTER TABLE trf.vw_trf_att_forf_riep OWNER TO postgres;

--
-- Name: vw_trf_cod_iva; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_cod_iva AS
 SELECT tum.id AS id_cod_iva,
    tum.id,
    tum.cod_iva,
    tum.descr_iva
   FROM trf.trf_cod_iva tum;


ALTER TABLE trf.vw_trf_cod_iva OWNER TO postgres;

--
-- Name: vw_trf_fatt_forf_riep; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_fatt_forf_riep AS
 SELECT to_char(date_trunc('year'::text, vtf.data_creazione), 'yyyy'::text) AS anno,
    count(*) AS n_fatture,
    sum(COALESCE(vtf.costo, (0)::numeric)) AS tot_fatture
   FROM trf.vw_trf_fatture vtf
  WHERE ((vtf.descr_tariffa)::text = 'Tariffa forfettaria annuale'::text)
  GROUP BY (to_char(date_trunc('year'::text, vtf.data_creazione), 'yyyy'::text));


ALTER TABLE trf.vw_trf_fatt_forf_riep OWNER TO postgres;

--
-- Name: trf_fattura_stati; Type: TABLE; Schema: trf_types; Owner: postgres
--

CREATE TABLE trf_types.trf_fattura_stati (
    id bigint NOT NULL,
    descr character varying,
    ord integer,
    cod character varying,
    act_required character varying,
    second_wait double precision
);


ALTER TABLE trf_types.trf_fattura_stati OWNER TO postgres;

--
-- Name: vw_trf_fatture_ultimo_stato; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_fatture_ultimo_stato AS
 SELECT f.id,
    f.id_cliente,
    f.data_creazione,
    f.descr,
    f.id_trf_fattura,
    f.descr_tariffa,
    f.rag_soc,
    f.piva,
    f.codfis,
    f.indirizzo_fatturazione,
    f.comune_fatturazione,
    f.cap_fatturazione,
    f.inviaresdi,
    f.sdi,
    f.is_split,
    f.nazione,
    f.numero_fattura,
    f.provincia_istat,
    f.nome,
    f.cognome,
    f.id_asl,
    f.costo,
    f.comune_istat,
    s.ts,
    s.id_trf_stato,
    s.descr AS descr_stato,
    s.ord,
    s.cod,
    s.act_required,
    s.second_wait,
    (s.ts + ('00:00:01'::interval * s.second_wait)) AS dt_new_invio
   FROM (trf.vw_trf_fatture f
     LEFT JOIN ( SELECT DISTINCT ON (s_1.id_trf_fattura) s_1.id_trf_fattura,
            s_1.ts,
            s_1.id_trf_stato,
            ts.descr,
            ts.ord,
            ts.cod,
            ts.act_required,
            ts.second_wait
           FROM (trf.trf_fattura_stati s_1
             JOIN trf_types.trf_fattura_stati ts ON ((ts.id = s_1.id_trf_stato)))
          ORDER BY s_1.id_trf_fattura, s_1.ts DESC) s ON ((f.id_trf_fattura = s.id_trf_fattura)));


ALTER TABLE trf.vw_trf_fatture_ultimo_stato OWNER TO postgres;

--
-- Name: vw_trf_forfettarie; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_forfettarie AS
 SELECT (((((tt.descr)::text || ' - '::text) || l.desc_tipo_linea) || ' - '::text) || tml.liv) AS descr,
    tml.id AS id_tml,
    tt.descr AS t_descr,
    l.desc_tipo_linea,
    l.livello_di_rischio,
    l.id_linea,
    tt.id AS id_tariffa,
    l.id,
    l.id_struttura,
    l.id_struttura AS id_asl,
    tml.valore
   FROM (((trf.vw_tariffa_ml_livello tml
     JOIN agenda.vw_linee l ON (((tml.id_linea_attivita = l.id_attivita) AND (l.livello_di_rischio = tml.livello))))
     JOIN trf.tariffari t ON (((t.codice)::text = 'forfettario'::text)))
     JOIN trf.tariffe tt ON ((t.id = tt.id_tariffario)));


ALTER TABLE trf.vw_trf_forfettarie OWNER TO postgres;

--
-- Name: vw_trf_ft_periodiche; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_ft_periodiche AS
 SELECT f.id AS id_trf_ft_periodica,
    f.id,
    f.id_cliente,
    f.data_creazione,
    f.id_asl,
    f.n_ft_periodica,
    f.open_amt
   FROM trf.trf_ft_periodiche f;


ALTER TABLE trf.vw_trf_ft_periodiche OWNER TO postgres;

--
-- Name: vw_trf_ft_periodiche_dett; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_ft_periodiche_dett AS
 SELECT d.id AS id_trf_ft_periodiche_dett,
    d.id,
    d.id_trf_ft_periodica,
    d.dt,
    d.descr_tariffa,
    d.costo,
    d.ordine,
    d.id_trf_fattura,
    f.id_cliente,
    f.id_asl,
    f.n_ft_periodica
   FROM (trf.trf_ft_periodiche_dett d
     JOIN trf.vw_trf_ft_periodiche f ON ((f.id_trf_ft_periodica = d.id_trf_ft_periodica)));


ALTER TABLE trf.vw_trf_ft_periodiche_dett OWNER TO postgres;

--
-- Name: vw_trf_per_regole; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_per_regole AS
 SELECT d.id_node_ref AS id,
    d.id_node AS id_child,
    t.sigla,
    t.descr,
    (NOT t.visibile_trf) AS calcolabile
   FROM (((matrix.vw_tree_nodes_down d
     JOIN trf.tariffe t ON ((t.id = d.id_node)))
     JOIN trf.tariffe p ON ((p.id = d.id_node_ref)))
     LEFT JOIN ( SELECT DISTINCT tn.id_parent AS id
           FROM matrix.tree_nodes tn) f ON ((f.id = d.id_node)))
  WHERE (t.visibile_fatt AND (f.id IS NULL));


ALTER TABLE trf.vw_trf_per_regole OWNER TO postgres;

--
-- Name: vw_trf_piano_tariffa; Type: VIEW; Schema: trf; Owner: postgres
--

CREATE VIEW trf.vw_trf_piano_tariffa AS
 SELECT pt.id,
    pt.id_tariffa,
    pt.id_piano,
    pt.id AS id_piano_tariffa,
    sp.descrizione AS descrizione_piano,
    sp.descrizione_breve AS descrizione_breve_piano,
    t.descr AS descrizione_tariffa,
    t.sigla AS descrizione_breve_tariffa,
    t.sigla AS sigla_tariffa,
    sp.alias AS alias_piano
   FROM ((trf.trf_piano_tariffa pt
     JOIN matrix.struttura_piani sp ON ((sp.id = pt.id_piano)))
     JOIN trf.tariffe t ON ((t.id = pt.id_tariffa)));


ALTER TABLE trf.vw_trf_piano_tariffa OWNER TO postgres;

--
-- Name: idtrffattura; Type: TABLE; Schema: trf_conf; Owner: postgres
--

CREATE TABLE trf_conf.idtrffattura (
    id_trf_fattura bigint
);


ALTER TABLE trf_conf.idtrffattura OWNER TO postgres;

--
-- Name: template_fatturazione; Type: TABLE; Schema: trf_conf; Owner: postgres
--

CREATE TABLE trf_conf.template_fatturazione (
    id integer,
    descr character varying,
    testo character varying
);


ALTER TABLE trf_conf.template_fatturazione OWNER TO postgres;

--
-- Name: template_fatturazione_id_seq; Type: SEQUENCE; Schema: trf_conf; Owner: postgres
--

CREATE SEQUENCE trf_conf.template_fatturazione_id_seq
    START WITH 4
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf_conf.template_fatturazione_id_seq OWNER TO postgres;

--
-- Name: ws_parameters; Type: TABLE; Schema: trf_conf; Owner: postgres
--

CREATE TABLE trf_conf.ws_parameters (
    id bigint NOT NULL,
    application character varying,
    key character varying,
    val character varying
);


ALTER TABLE trf_conf.ws_parameters OWNER TO postgres;

--
-- Name: vw_ws_parameters; Type: VIEW; Schema: trf_conf; Owner: postgres
--

CREATE VIEW trf_conf.vw_ws_parameters AS
 SELECT ws_parameters.id AS id_ws_parameters,
    ws_parameters.id,
    ws_parameters.application,
    ws_parameters.key,
    ws_parameters.val
   FROM trf_conf.ws_parameters;


ALTER TABLE trf_conf.vw_ws_parameters OWNER TO postgres;

--
-- Name: ws_parameters_id_seq; Type: SEQUENCE; Schema: trf_conf; Owner: postgres
--

CREATE SEQUENCE trf_conf.ws_parameters_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf_conf.ws_parameters_id_seq OWNER TO postgres;

--
-- Name: ws_parameters_id_seq; Type: SEQUENCE OWNED BY; Schema: trf_conf; Owner: postgres
--

ALTER SEQUENCE trf_conf.ws_parameters_id_seq OWNED BY trf_conf.ws_parameters.id;


--
-- Name: tariffa_strutture_id_seq; Type: SEQUENCE; Schema: trf_his; Owner: postgres
--

CREATE SEQUENCE trf_his.tariffa_strutture_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf_his.tariffa_strutture_id_seq OWNER TO postgres;

--
-- Name: tariffa_strutture_id_seq; Type: SEQUENCE OWNED BY; Schema: trf_his; Owner: postgres
--

ALTER SEQUENCE trf_his.tariffa_strutture_id_seq OWNED BY trf_his.tariffa_strutture.id;


--
-- Name: trf_att_inviate_stati_id_seq; Type: SEQUENCE; Schema: trf_his; Owner: postgres
--

CREATE SEQUENCE trf_his.trf_att_inviate_stati_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf_his.trf_att_inviate_stati_id_seq OWNER TO postgres;

--
-- Name: trf_att_inviate_stati_id_seq; Type: SEQUENCE OWNED BY; Schema: trf_his; Owner: postgres
--

ALTER SEQUENCE trf_his.trf_att_inviate_stati_id_seq OWNED BY trf_his.trf_att_inviate_stati.id;


--
-- Name: trf_attivita_forfet_id_seq; Type: SEQUENCE; Schema: trf_his; Owner: postgres
--

CREATE SEQUENCE trf_his.trf_attivita_forfet_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf_his.trf_attivita_forfet_id_seq OWNER TO postgres;

--
-- Name: vw_clienti; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_clienti AS
 SELECT c.id_his,
    c.his_validita AS validita,
    c.his_id_transazione,
    c.ts,
    c.ts_transazione,
    c.id,
    c.descr,
    c.id_ref,
    c.type,
    c.piva,
    lower(c.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(c.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log
   FROM (trf_his.clienti c
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = c.his_id_transazione)));


ALTER TABLE trf_his.vw_clienti OWNER TO postgres;

--
-- Name: vw_ref_soggetti_fisici; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_soggetti_fisici AS
 SELECT sf.his_id_transazione,
    sf.id,
    sf.codice_fiscale AS descr_oggetto,
    'soggetti_fisici'::text AS tabella,
    t.id_user,
    t.nominativo,
    sf.his_validita
   FROM (cu_his.soggetti_fisici sf
     LEFT JOIN cu_log.vw_transazioni t ON ((sf.his_id_transazione = t.id_transazione)));


ALTER TABLE trf_his.vw_ref_soggetti_fisici OWNER TO postgres;

--
-- Name: vw_ref_soggetti_fisici_fast; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_ref_soggetti_fisici_fast AS
 SELECT sf.his_id_transazione,
    sf.id,
    sf.codice_fiscale AS descr_oggetto,
    'soggetti_fisici'::text AS tabella,
    sf.his_validita
   FROM cu_his.soggetti_fisici sf;


ALTER TABLE trf_his.vw_ref_soggetti_fisici_fast OWNER TO postgres;

--
-- Name: vw_tariffa_strutture; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_tariffa_strutture AS
 SELECT ts.id_his,
    ts.his_validita,
    ts.his_id_transazione,
    ts.ts,
    ts.ts_transazione,
    ts.id,
    ts.id_tariffa,
    ts.id_asl,
    ts.validita,
    lower(ts.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(ts.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log
   FROM (trf_his.tariffa_strutture ts
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = ts.his_id_transazione)));


ALTER TABLE trf_his.vw_tariffa_strutture OWNER TO postgres;

--
-- Name: vw_tariffa_voci; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_tariffa_voci AS
 SELECT tv.id_his,
    tv.his_validita AS validita,
    tv.his_id_transazione,
    tv.ts,
    tv.ts_transazione,
    tv.id,
    tv.id_tariffa_struttura,
    tv.scaglione,
    tv.ordine,
    lower(tv.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(tv.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log
   FROM (trf_his.tariffa_voci tv
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = tv.his_id_transazione)));


ALTER TABLE trf_his.vw_tariffa_voci OWNER TO postgres;

--
-- Name: vw_tariffa_voci_calcolo; Type: VIEW; Schema: trf_his; Owner: postgres
--

CREATE VIEW trf_his.vw_tariffa_voci_calcolo AS
 SELECT tvc.id_his,
    tvc.his_validita AS validita,
    tvc.his_id_transazione,
    tvc.ts,
    tvc.ts_transazione,
    tvc.id_tariffa_voce,
    tvc.valore,
    tvc.tipo,
    lower(tvc.his_validita) AS inizio_validita_log,
    vt.nominativo,
    (to_char(lower(tvc.his_validita), 'HH24:MI:SS'::text))::time without time zone AS ora_inizio_validita_log
   FROM (trf_his.tariffa_voci_calcolo tvc
     JOIN ag_log.vw_transazioni vt ON ((vt.id_transazione = tvc.his_id_transazione)));


ALTER TABLE trf_his.vw_tariffa_voci_calcolo OWNER TO postgres;

--
-- Name: trf_att_sicer_stati_id_seq; Type: SEQUENCE; Schema: trf_types; Owner: postgres
--

CREATE SEQUENCE trf_types.trf_att_sicer_stati_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf_types.trf_att_sicer_stati_id_seq OWNER TO postgres;

--
-- Name: trf_att_sicer_stati_id_seq; Type: SEQUENCE OWNED BY; Schema: trf_types; Owner: postgres
--

ALTER SEQUENCE trf_types.trf_att_sicer_stati_id_seq OWNED BY trf_types.trf_att_inviate_tipo_stati.id;


--
-- Name: trf_attivita_forfet_stato_id_seq; Type: SEQUENCE; Schema: trf_types; Owner: postgres
--

CREATE SEQUENCE trf_types.trf_attivita_forfet_stato_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf_types.trf_attivita_forfet_stato_id_seq OWNER TO postgres;

--
-- Name: trf_attivita_forfet_stato_id_seq; Type: SEQUENCE OWNED BY; Schema: trf_types; Owner: postgres
--

ALTER SEQUENCE trf_types.trf_attivita_forfet_stato_id_seq OWNED BY trf_types.trf_attivita_forfet_stati.id;


--
-- Name: trf_fattura_stati_id_seq; Type: SEQUENCE; Schema: trf_types; Owner: postgres
--

CREATE SEQUENCE trf_types.trf_fattura_stati_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf_types.trf_fattura_stati_id_seq OWNER TO postgres;

--
-- Name: trf_fattura_stati_id_seq; Type: SEQUENCE OWNED BY; Schema: trf_types; Owner: postgres
--

ALTER SEQUENCE trf_types.trf_fattura_stati_id_seq OWNED BY trf_types.trf_fattura_stati.id;


--
-- Name: trf_tipi_regole; Type: TABLE; Schema: trf_types; Owner: postgres
--

CREATE TABLE trf_types.trf_tipi_regole (
    codice character varying,
    descrizione character varying
);


ALTER TABLE trf_types.trf_tipi_regole OWNER TO postgres;

--
-- Name: vw_trf_fattura_stati; Type: VIEW; Schema: trf_types; Owner: postgres
--

CREATE VIEW trf_types.vw_trf_fattura_stati AS
 SELECT trf_fattura_stati.id AS id_fattura_stato,
    trf_fattura_stati.id,
    trf_fattura_stati.descr,
    trf_fattura_stati.ord,
    trf_fattura_stati.act_required,
    trf_fattura_stati.second_wait
   FROM trf_types.trf_fattura_stati;


ALTER TABLE trf_types.vw_trf_fattura_stati OWNER TO postgres;

--
-- Name: trf_intestazioni; Type: TABLE; Schema: trf_ui; Owner: postgres
--

CREATE TABLE trf_ui.trf_intestazioni (
    id integer NOT NULL,
    cod character varying NOT NULL,
    descr character varying NOT NULL,
    val character varying NOT NULL
);


ALTER TABLE trf_ui.trf_intestazioni OWNER TO postgres;

--
-- Name: newtable_id_seq; Type: SEQUENCE; Schema: trf_ui; Owner: postgres
--

CREATE SEQUENCE trf_ui.newtable_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trf_ui.newtable_id_seq OWNER TO postgres;

--
-- Name: newtable_id_seq; Type: SEQUENCE OWNED BY; Schema: trf_ui; Owner: postgres
--

ALTER SEQUENCE trf_ui.newtable_id_seq OWNED BY trf_ui.trf_intestazioni.id;


--
-- Name: trf_ui; Type: TABLE; Schema: trf_ui; Owner: postgres
--

CREATE TABLE trf_ui.trf_ui (
    id_tariffa bigint,
    ui_info character varying,
    ui_info_fatt character varying
);


ALTER TABLE trf_ui.trf_ui OWNER TO postgres;

--
-- Name: vw_trf_intestazioni; Type: VIEW; Schema: trf_ui; Owner: postgres
--

CREATE VIEW trf_ui.vw_trf_intestazioni AS
 SELECT trf_intestazioni.id AS id_trf_intestazioni,
    trf_intestazioni.id,
    trf_intestazioni.cod,
    trf_intestazioni.descr,
    trf_intestazioni.val
   FROM trf_ui.trf_intestazioni;


ALTER TABLE trf_ui.vw_trf_intestazioni OWNER TO postgres;

--
-- Name: dizionario_nomi id; Type: DEFAULT; Schema: Analisi_dev; Owner: postgres
--

ALTER TABLE ONLY "Analisi_dev".dizionario_nomi ALTER COLUMN id SET DEFAULT nextval('"Analisi_dev".dizionario_nomi_id_seq'::regclass);


--
-- Name: lookup_asl code; Type: DEFAULT; Schema: Analisi_dev; Owner: postgres
--

ALTER TABLE ONLY "Analisi_dev".lookup_asl ALTER COLUMN code SET DEFAULT nextval('"Analisi_dev".lookup_asl_code_seq'::regclass);


--
-- Name: lookup_tipo_controllo code; Type: DEFAULT; Schema: Analisi_dev; Owner: postgres
--

ALTER TABLE ONLY "Analisi_dev".lookup_tipo_controllo ALTER COLUMN code SET DEFAULT nextval('"Analisi_dev".lookup_tipo_controllo_code_seq'::regclass);


--
-- Name: ag_conf id; Type: DEFAULT; Schema: ag_conf; Owner: postgres
--

ALTER TABLE ONLY ag_conf.ag_conf ALTER COLUMN id SET DEFAULT nextval('ag_conf.ag_conf_id_seq'::regclass);


--
-- Name: manuali id; Type: DEFAULT; Schema: ag_conf; Owner: postgres
--

ALTER TABLE ONLY ag_conf.manuali ALTER COLUMN id SET DEFAULT nextval('ag_conf.manuali_id_seq'::regclass);


--
-- Name: cf_liste id; Type: DEFAULT; Schema: ag_his; Owner: postgres
--

ALTER TABLE ONLY ag_his.cf_liste ALTER COLUMN id SET DEFAULT nextval('ag_his.cf_liste_id_seq'::regclass);


--
-- Name: lista_import id; Type: DEFAULT; Schema: ag_his; Owner: postgres
--

ALTER TABLE ONLY ag_his.lista_import ALTER COLUMN id SET DEFAULT nextval('ag_his.lista_import_id_seq'::regclass);


--
-- Name: call_logs id; Type: DEFAULT; Schema: ag_log; Owner: postgres
--

ALTER TABLE ONLY ag_log.call_logs ALTER COLUMN id SET DEFAULT nextval('ag_log.call_logs_id_seq'::regclass);


--
-- Name: operazioni id; Type: DEFAULT; Schema: ag_log; Owner: postgres
--

ALTER TABLE ONLY ag_log.operazioni ALTER COLUMN id SET DEFAULT nextval('ag_log.operazioni_id_seq'::regclass);


--
-- Name: transazioni id; Type: DEFAULT; Schema: ag_log; Owner: postgres
--

ALTER TABLE ONLY ag_log.transazioni ALTER COLUMN id SET DEFAULT nextval('ag_log.transazioni_id_seq'::regclass);


--
-- Name: ag_livelli_avviso id; Type: DEFAULT; Schema: ag_types; Owner: postgres
--

ALTER TABLE ONLY ag_types.ag_livelli_avviso ALTER COLUMN id SET DEFAULT nextval('ag_types.ag_livelli_avviso_id_seq'::regclass);


--
-- Name: ag_stato_eventi id; Type: DEFAULT; Schema: ag_types; Owner: postgres
--

ALTER TABLE ONLY ag_types.ag_stato_eventi ALTER COLUMN id SET DEFAULT nextval('ag_types.ag_stato_eventi_id_seq'::regclass);


--
-- Name: ag_tipo_avvisi id; Type: DEFAULT; Schema: ag_types; Owner: postgres
--

ALTER TABLE ONLY ag_types.ag_tipo_avvisi ALTER COLUMN id SET DEFAULT nextval('ag_types.ag_tipo_avvisi_id_seq'::regclass);


--
-- Name: ag_tipo_eventi id; Type: DEFAULT; Schema: ag_types; Owner: postgres
--

ALTER TABLE ONLY ag_types.ag_tipo_eventi ALTER COLUMN id SET DEFAULT nextval('ag_types.ag_tipo_eventi_id_seq'::regclass);


--
-- Name: tipi_indirizzo id; Type: DEFAULT; Schema: ag_types; Owner: postgres
--

ALTER TABLE ONLY ag_types.tipi_indirizzo ALTER COLUMN id SET DEFAULT nextval('ag_types.tipi_indirizzo_id_seq'::regclass);


--
-- Name: tipi_persona id; Type: DEFAULT; Schema: ag_types; Owner: postgres
--

ALTER TABLE ONLY ag_types.tipi_persona ALTER COLUMN id SET DEFAULT nextval('ag_types.tipi_persona_id_seq'::regclass);


--
-- Name: grid_definition id; Type: DEFAULT; Schema: ag_ui; Owner: postgres
--

ALTER TABLE ONLY ag_ui.grid_definition ALTER COLUMN id SET DEFAULT nextval('ag_ui.grid_definition_id_seq'::regclass);


--
-- Name: asl_piani id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.asl_piani ALTER COLUMN id SET DEFAULT nextval('agenda.asl_piani_id_seq'::regclass);


--
-- Name: attivita id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.attivita ALTER COLUMN id SET DEFAULT nextval('agenda.attivita_id_seq'::regclass);


--
-- Name: avvisi id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.avvisi ALTER COLUMN id SET DEFAULT nextval('agenda.avvisi_id_seq'::regclass);


--
-- Name: avviso_risorse id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.avviso_risorse ALTER COLUMN id SET DEFAULT nextval('agenda.avviso_risorse_id_seq'::regclass);


--
-- Name: az_sedi_selezionate id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.az_sedi_selezionate ALTER COLUMN id SET DEFAULT nextval('agenda.az_sedi_selezionate_id_seq'::regclass);


--
-- Name: azienda_indirizzi id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.azienda_indirizzi ALTER COLUMN id SET DEFAULT nextval('agenda.azienda_indirizzi_id_seq'::regclass);


--
-- Name: azienda_persone id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.azienda_persone ALTER COLUMN id SET DEFAULT nextval('agenda.azienda_persone_id_seq'::regclass);


--
-- Name: cf_allevamenti id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.cf_allevamenti ALTER COLUMN id SET DEFAULT nextval('agenda.lista_cf_id_seq'::regclass);


--
-- Name: cf_liste id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.cf_liste ALTER COLUMN id SET DEFAULT nextval('agenda.cf_liste_id_seq'::regclass);


--
-- Name: cf_tipo_liste id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.cf_tipo_liste ALTER COLUMN id SET DEFAULT nextval('agenda.cf_tipo_lista_id_seq'::regclass);


--
-- Name: config_exp_imp id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.config_exp_imp ALTER COLUMN id SET DEFAULT nextval('agenda.config_exp_imp_id_seq'::regclass);


--
-- Name: elab_cal_param_asl id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_asl ALTER COLUMN id SET DEFAULT nextval('agenda.elab_cal_param_asl_id_seq'::regclass);


--
-- Name: elab_cal_param_ns id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_ns ALTER COLUMN id SET DEFAULT nextval('agenda.elab_cal_param_ns_id_seq'::regclass);


--
-- Name: elab_cal_param_piani id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_piani ALTER COLUMN id SET DEFAULT nextval('agenda.elab_cal_param_piani_id_seq'::regclass);


--
-- Name: indirizzi id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.indirizzi ALTER COLUMN id SET DEFAULT nextval('agenda.indirizzi_id_seq'::regclass);


--
-- Name: linea_piani id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.linea_piani ALTER COLUMN id SET DEFAULT nextval('agenda.linea_piani_id_seq'::regclass);


--
-- Name: linee_selezionate id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.linee_selezionate ALTER COLUMN id SET DEFAULT nextval('agenda.linee_selezionate_id_seq'::regclass);


--
-- Name: lista_import id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.lista_import ALTER COLUMN id SET DEFAULT nextval('agenda.lista_import_id_seq'::regclass);


--
-- Name: nominativo_az_sedi id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_az_sedi ALTER COLUMN id SET DEFAULT nextval('agenda.nominativo_az_sedi_id_seq'::regclass);


--
-- Name: nominativo_comuni id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_comuni ALTER COLUMN id SET DEFAULT nextval('agenda.nominativo_comuni_id_seq'::regclass);


--
-- Name: nominativo_linee id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_linee ALTER COLUMN id SET DEFAULT nextval('agenda.nominativo_linee_id_seq'::regclass);


--
-- Name: nominativo_piani id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_piani ALTER COLUMN id SET DEFAULT nextval('agenda.nominativo_piani_id_seq'::regclass);


--
-- Name: persone id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.persone ALTER COLUMN id SET DEFAULT nextval('agenda.persone_id_seq'::regclass);


--
-- Name: piano_periodo id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.piano_periodo ALTER COLUMN id SET DEFAULT nextval('agenda.piano_periodo_id_seq'::regclass);


--
-- Name: tipologia_controllo_piani id; Type: DEFAULT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.tipologia_controllo_piani ALTER COLUMN id SET DEFAULT nextval('agenda.tipologia_controllo_piani_id_seq'::regclass);


--
-- Name: bonifica_soggetti_fisici id; Type: DEFAULT; Schema: conf_ext; Owner: postgres
--

ALTER TABLE ONLY conf_ext.bonifica_soggetti_fisici ALTER COLUMN id SET DEFAULT nextval('conf_ext.bonifica_soggetti_fisici_id_seq'::regclass);


--
-- Name: log_bonifica_imprese id; Type: DEFAULT; Schema: conf_ext; Owner: postgres
--

ALTER TABLE ONLY conf_ext.log_bonifica_imprese ALTER COLUMN id SET DEFAULT nextval('conf_ext.log_bonifica_imprese_id_seq'::regclass);


--
-- Name: utenti_fvg_bonifica_soggetti_fisici id; Type: DEFAULT; Schema: conf_ext; Owner: postgres
--

ALTER TABLE ONLY conf_ext.utenti_fvg_bonifica_soggetti_fisici ALTER COLUMN id SET DEFAULT nextval('conf_ext.utenti_fvg_bonifica_soggetti_fisici_id_seq'::regclass);


--
-- Name: festivita id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY config.festivita ALTER COLUMN id SET DEFAULT nextval('config.festivita_id_seq'::regclass);


--
-- Name: categorizzazione_rischio_tipo_stabilimento id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.categorizzazione_rischio_tipo_stabilimento ALTER COLUMN id SET DEFAULT nextval('cu.categorizzazione_rischio_tipo_stabilimento_id_seq'::regclass);


--
-- Name: cu id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu ALTER COLUMN id SET DEFAULT nextval('cu.cu_id_seq'::regclass);


--
-- Name: cu_altri id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_altri ALTER COLUMN id SET DEFAULT nextval('cu.cu_altri_id_seq'::regclass);


--
-- Name: cu_categ_evals id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_categ_evals ALTER COLUMN id SET DEFAULT nextval('cu.cu_categ_eval_id_seq'::regclass);


--
-- Name: cu_categ_evals_storico id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_categ_evals_storico ALTER COLUMN id SET DEFAULT nextval('cu.cu_categ_evals_storico_id_seq'::regclass);


--
-- Name: cu_dichiarazioni id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_dichiarazioni ALTER COLUMN id SET DEFAULT nextval('cu.cu_dichiarazioni_id_seq'::regclass);


--
-- Name: cu_evidenza_linee id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_evidenza_linee ALTER COLUMN id SET DEFAULT nextval('cu.cu_evidenza_linee_id_seq'::regclass);


--
-- Name: cu_evidenze id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_evidenze ALTER COLUMN id SET DEFAULT nextval('cu.cu_evidenze_id_seq'::regclass);


--
-- Name: cu_evidenze_sp id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_evidenze_sp ALTER COLUMN id SET DEFAULT nextval('cu.cu_evidenze_sosp_id_seq'::regclass);


--
-- Name: cu_indirizzi id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_indirizzi ALTER COLUMN id SET DEFAULT nextval('cu.cu_indirizzi_id_seq'::regclass);


--
-- Name: cu_linee id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_linee ALTER COLUMN id SET DEFAULT nextval('cu.cu_linee_id_seq'::regclass);


--
-- Name: cu_nominativo_provv id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_nominativo_provv ALTER COLUMN id SET DEFAULT nextval('cu.cu_nominativo_provv_id_seq'::regclass);


--
-- Name: cu_norme_violate id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_norme_violate ALTER COLUMN id SET DEFAULT nextval('cu.cu_norme_violate_id_seq'::regclass);


--
-- Name: cu_nucleo id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_nucleo ALTER COLUMN id SET DEFAULT nextval('cu.cu_nucleo_id_seq'::regclass);


--
-- Name: cu_nucleo_periodi id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_nucleo_periodi ALTER COLUMN id SET DEFAULT nextval('cu.cu_nucleo_periodi_id_seq'::regclass);


--
-- Name: cu_oggetti id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_oggetti ALTER COLUMN id SET DEFAULT nextval('cu.cu_oggetti_id_seq'::regclass);


--
-- Name: cu_oggetti_cl id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_oggetti_cl ALTER COLUMN id SET DEFAULT nextval('cu.cu_oggetti_cl_id_seq'::regclass);


--
-- Name: cu_piani id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_piani ALTER COLUMN id SET DEFAULT nextval('cu.cu_piani_id_seq'::regclass);


--
-- Name: cu_provv id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv ALTER COLUMN id SET DEFAULT nextval('cu.cu_provv_id_seq'::regclass);


--
-- Name: cu_provv_fu id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv_fu ALTER COLUMN id SET DEFAULT nextval('cu.cu_provv_fu_id_seq'::regclass);


--
-- Name: cu_provv_sopralluogo id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv_sopralluogo ALTER COLUMN id SET DEFAULT nextval('cu.cu_provv_sopralluogo_id_seq'::regclass);


--
-- Name: cu_provv_sopralluogo_fu id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv_sopralluogo_fu ALTER COLUMN id SET DEFAULT nextval('cu.cu_provv_sopralluogo_fu_id_seq'::regclass);


--
-- Name: nomi_file_pdf_controlli id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.nomi_file_pdf_controlli ALTER COLUMN id SET DEFAULT nextval('cu.nomi_file_pdf_controlli_id_seq'::regclass);


--
-- Name: nomi_file_pdf_evidenze id; Type: DEFAULT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.nomi_file_pdf_evidenze ALTER COLUMN id SET DEFAULT nextval('cu.nomi_file_pdf_evidenze_id_seq'::regclass);


--
-- Name: codici id; Type: DEFAULT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.codici ALTER COLUMN id SET DEFAULT nextval('cu_anag.codici_id_seq'::regclass);


--
-- Name: import_anagrafica id; Type: DEFAULT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.import_anagrafica ALTER COLUMN id SET DEFAULT nextval('cu_anag.import_anagrafica_id_seq'::regclass);


--
-- Name: impresa_figure id; Type: DEFAULT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.impresa_figure ALTER COLUMN id SET DEFAULT nextval('cu_anag.impresa_figure_id_seq'::regclass);


--
-- Name: impresa_sedi id; Type: DEFAULT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.impresa_sedi ALTER COLUMN id SET DEFAULT nextval('cu_anag.impresa_sedi_id_seq'::regclass);


--
-- Name: indirizzi_all id; Type: DEFAULT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.indirizzi_all ALTER COLUMN id SET DEFAULT nextval('cu_anag.opu_indirizzo_id_seq'::regclass);


--
-- Name: pratiche id; Type: DEFAULT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.pratiche ALTER COLUMN id SET DEFAULT nextval('cu_anag.pratiche_id_seq'::regclass);


--
-- Name: stabilimenti_storico id; Type: DEFAULT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimenti_storico ALTER COLUMN id SET DEFAULT nextval('cu_anag.stabilimenti_storico_id_seq'::regclass);


--
-- Name: stabilimento_categorizzazioni id; Type: DEFAULT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimento_categorizzazioni ALTER COLUMN id SET DEFAULT nextval('cu_anag.stabilimento_catgorizzazioni_id_seq'::regclass);


--
-- Name: storico_pratiche id; Type: DEFAULT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.storico_pratiche ALTER COLUMN id SET DEFAULT nextval('cu_anag.storico_pratiche_id_seq'::regclass);


--
-- Name: tipo_import_anagrafica id; Type: DEFAULT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.tipo_import_anagrafica ALTER COLUMN id SET DEFAULT nextval('cu_anag.tipo_import_anagrafica_id_seq'::regclass);


--
-- Name: cu_categ_esiti id; Type: DEFAULT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_categ_esiti ALTER COLUMN id SET DEFAULT nextval('cu_conf.cu_categ_esiti_id_seq'::regclass);


--
-- Name: cu_conf id; Type: DEFAULT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_conf ALTER COLUMN id SET DEFAULT nextval('cu_conf.cu_conf_id_seq'::regclass);


--
-- Name: cu_piani_speciali id; Type: DEFAULT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_piani_speciali ALTER COLUMN id SET DEFAULT nextval('cu_conf.cu_piani_speciali_id_seq'::regclass);


--
-- Name: cu_requisiti id; Type: DEFAULT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_requisiti ALTER COLUMN id SET DEFAULT nextval('cu_conf.cu_requisiti_id_seq'::regclass);


--
-- Name: cu_tecniche id; Type: DEFAULT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tecniche ALTER COLUMN id SET DEFAULT nextval('cu_conf.cu_tecnica_id_seq'::regclass);


--
-- Name: cu_tipo_isp id; Type: DEFAULT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tipo_isp ALTER COLUMN id SET DEFAULT nextval('cu_conf.cu_tipo_isp_id_seq'::regclass);


--
-- Name: cu_tipo_oggetti id; Type: DEFAULT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tipo_oggetti ALTER COLUMN id SET DEFAULT nextval('cu_conf.cu_oggetti_id_seq'::regclass);


--
-- Name: cu_tipo_oggetto_piani id; Type: DEFAULT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tipo_oggetto_piani ALTER COLUMN id SET DEFAULT nextval('cu_conf.cu_tipo_oggetto_piani_id_seq'::regclass);


--
-- Name: cu_tipo_per id; Type: DEFAULT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tipo_per ALTER COLUMN id SET DEFAULT nextval('cu_conf.cu_tipo_per_id_seq'::regclass);


--
-- Name: call_logs id; Type: DEFAULT; Schema: cu_log; Owner: postgres
--

ALTER TABLE ONLY cu_log.call_logs ALTER COLUMN id SET DEFAULT nextval('cu_log.call_logs_id_seq'::regclass);


--
-- Name: operazioni id; Type: DEFAULT; Schema: cu_log; Owner: postgres
--

ALTER TABLE ONLY cu_log.operazioni ALTER COLUMN id SET DEFAULT nextval('cu_log.operazioni_id_seq'::regclass);


--
-- Name: transazioni id; Type: DEFAULT; Schema: cu_log; Owner: postgres
--

ALTER TABLE ONLY cu_log.transazioni ALTER COLUMN id SET DEFAULT nextval('cu_log.transazioni_id_seq'::regclass);


--
-- Name: cu_classe_evidenze id; Type: DEFAULT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_classe_evidenze ALTER COLUMN id SET DEFAULT nextval('cu_types.cu_classe_evidenze_id_seq'::regclass);


--
-- Name: cu_grado_evidenze id; Type: DEFAULT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_grado_evidenze ALTER COLUMN id SET DEFAULT nextval('cu_types.cu_grado_evidenze_id_seq'::regclass);


--
-- Name: cu_stati_cl id; Type: DEFAULT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_stati_cl ALTER COLUMN id SET DEFAULT nextval('cu_types.cu_stati_cl_id_seq'::regclass);


--
-- Name: cu_stati_cu id; Type: DEFAULT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_stati_cu ALTER COLUMN id SET DEFAULT nextval('cu_types.cu_stati_cu_id_seq'::regclass);


--
-- Name: cu_stati_oggetto id; Type: DEFAULT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_stati_oggetto ALTER COLUMN id SET DEFAULT nextval('cu_types.cu_stati_oggetto_id_seq'::regclass);


--
-- Name: cu_tipi_provv id; Type: DEFAULT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_tipi_provv ALTER COLUMN id SET DEFAULT nextval('cu_types.cu_tipi_provv_id_seq'::regclass);


--
-- Name: cu_tipo_nucleo id; Type: DEFAULT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_tipo_nucleo ALTER COLUMN id SET DEFAULT nextval('cu_types.cu_tipo_nucleo_id_seq'::regclass);


--
-- Name: stati_pratiche id; Type: DEFAULT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.stati_pratiche ALTER COLUMN id SET DEFAULT nextval('cu_types.stati_pratiche_id_seq'::regclass);


--
-- Name: tipi_figura id; Type: DEFAULT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.tipi_figura ALTER COLUMN id SET DEFAULT nextval('cu_types.tipi_figura_id_seq'::regclass);


--
-- Name: tipi_pratiche id; Type: DEFAULT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.tipi_pratiche ALTER COLUMN id SET DEFAULT nextval('cu_types.tipi_pratiche_id_seq'::regclass);


--
-- Name: tipi_sede id; Type: DEFAULT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.tipi_sede ALTER COLUMN id SET DEFAULT nextval('cu_types.tipi_sede_id_seq'::regclass);


--
-- Name: tipo_import_anagrafica id; Type: DEFAULT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.tipo_import_anagrafica ALTER COLUMN id SET DEFAULT nextval('cu_types.tipo_import_anagrafica_id_seq'::regclass);


--
-- Name: form_definition id; Type: DEFAULT; Schema: cu_ui; Owner: postgres
--

ALTER TABLE ONLY cu_ui.form_definition ALTER COLUMN id SET DEFAULT nextval('cu_ui.form_definition_id_seq'::regclass);


--
-- Name: form_definition_detail id; Type: DEFAULT; Schema: cu_ui; Owner: postgres
--

ALTER TABLE ONLY cu_ui.form_definition_detail ALTER COLUMN id SET DEFAULT nextval('cu_ui.form_defintion_detail_id_seq'::regclass);


--
-- Name: grid_definition id; Type: DEFAULT; Schema: cu_ui; Owner: postgres
--

ALTER TABLE ONLY cu_ui.grid_definition ALTER COLUMN id SET DEFAULT nextval('cu_ui.grid_definition_id_seq'::regclass);


--
-- Name: menu id; Type: DEFAULT; Schema: cu_ui; Owner: postgres
--

ALTER TABLE ONLY cu_ui.menu ALTER COLUMN id SET DEFAULT nextval('cu_ui.menu_id_seq'::regclass);


--
-- Name: menu_item_modes id; Type: DEFAULT; Schema: cu_ui; Owner: postgres
--

ALTER TABLE ONLY cu_ui.menu_item_modes ALTER COLUMN id SET DEFAULT nextval('cu_ui.menu_item_modes_id_seq'::regclass);


--
-- Name: menu_items id; Type: DEFAULT; Schema: cu_ui; Owner: postgres
--

ALTER TABLE ONLY cu_ui.menu_items ALTER COLUMN id SET DEFAULT nextval('cu_ui.menu_items_id_seq'::regclass);


--
-- Name: pdf id; Type: DEFAULT; Schema: documenti; Owner: postgres
--

ALTER TABLE ONLY documenti.pdf ALTER COLUMN id SET DEFAULT nextval('documenti.pdf_id_seq'::regclass);


--
-- Name: aree id; Type: DEFAULT; Schema: log; Owner: postgres
--

ALTER TABLE ONLY log.aree ALTER COLUMN id SET DEFAULT nextval('log.area_id_seq'::regclass);


--
-- Name: funzioni id; Type: DEFAULT; Schema: log; Owner: postgres
--

ALTER TABLE ONLY log.funzioni ALTER COLUMN id SET DEFAULT nextval('log.funzioni_id_seq'::regclass);


--
-- Name: mod4_fattori id; Type: DEFAULT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.mod4_fattori ALTER COLUMN id SET DEFAULT nextval('matrix.mod4_fattori_id_seq'::regclass);


--
-- Name: mod4_nominativi id; Type: DEFAULT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.mod4_nominativi ALTER COLUMN id SET DEFAULT nextval('matrix.mod4_nominativi_id_seq'::regclass);


--
-- Name: mod4_nominativi_fattori id; Type: DEFAULT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.mod4_nominativi_fattori ALTER COLUMN id SET DEFAULT nextval('matrix.mod4_nominativi_fattori_id_seq'::regclass);


--
-- Name: mod4_strutture id; Type: DEFAULT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.mod4_strutture ALTER COLUMN id SET DEFAULT nextval('matrix.mod4_strutture_id_seq'::regclass);


--
-- Name: tables_history id; Type: DEFAULT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.tables_history ALTER COLUMN id SET DEFAULT nextval('matrix.tables_history_id_seq'::regclass);


--
-- Name: upd_descr_breve id; Type: DEFAULT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.upd_descr_breve ALTER COLUMN id SET DEFAULT nextval('matrix.upd_descr_breve_id_seq'::regclass);


--
-- Name: livelli_rischio id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.livelli_rischio ALTER COLUMN id SET DEFAULT nextval('public.livelli_rishio_id_seq'::regclass);


--
-- Name: permessi id; Type: DEFAULT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.permessi ALTER COLUMN id SET DEFAULT nextval('rbac.permessi_id_seq'::regclass);


--
-- Name: ruoli id; Type: DEFAULT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.ruoli ALTER COLUMN id SET DEFAULT nextval('rbac.ruolo_id_seq'::regclass);


--
-- Name: ruolo_permessi id; Type: DEFAULT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.ruolo_permessi ALTER COLUMN id SET DEFAULT nextval('rbac.ruolo_permessi_id_seq'::regclass);


--
-- Name: ruolo_ruoli id; Type: DEFAULT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.ruolo_ruoli ALTER COLUMN id SET DEFAULT nextval('rbac.ruoloruoli_id_seq'::regclass);


--
-- Name: utente_strutture id; Type: DEFAULT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.utente_strutture ALTER COLUMN id SET DEFAULT nextval('rbac.utente_strutture_id_seq'::regclass);


--
-- Name: utente_strutture_ruoli id; Type: DEFAULT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.utente_strutture_ruoli ALTER COLUMN id SET DEFAULT nextval('rbac.utente_strutture_ruoli_id_seq'::regclass);


--
-- Name: utenti id; Type: DEFAULT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.utenti ALTER COLUMN id SET DEFAULT nextval('rbac.utenti_id_seq'::regclass);


--
-- Name: qualifiche id; Type: DEFAULT; Schema: rbac_conf; Owner: postgres
--

ALTER TABLE ONLY rbac_conf.qualifiche ALTER COLUMN id SET DEFAULT nextval('rbac_conf.titoli_id_seq'::regclass);


--
-- Name: risorse id; Type: DEFAULT; Schema: rbac_conf; Owner: postgres
--

ALTER TABLE ONLY rbac_conf.risorse ALTER COLUMN id SET DEFAULT nextval('rbac_conf.risorse_id_seq'::regclass);


--
-- Name: call_logs id; Type: DEFAULT; Schema: rbac_log; Owner: postgres
--

ALTER TABLE ONLY rbac_log.call_logs ALTER COLUMN id SET DEFAULT nextval('rbac_log.call_logs_id_seq'::regclass);


--
-- Name: operazioni id; Type: DEFAULT; Schema: rbac_log; Owner: postgres
--

ALTER TABLE ONLY rbac_log.operazioni ALTER COLUMN id SET DEFAULT nextval('rbac_log.operazioni_id_seq'::regclass);


--
-- Name: transazioni id; Type: DEFAULT; Schema: rbac_log; Owner: postgres
--

ALTER TABLE ONLY rbac_log.transazioni ALTER COLUMN id SET DEFAULT nextval('rbac_log.transazioni_id_seq'::regclass);


--
-- Name: modalita id; Type: DEFAULT; Schema: rbac_types; Owner: postgres
--

ALTER TABLE ONLY rbac_types.modalita ALTER COLUMN id SET DEFAULT nextval('rbac_types.modalita_id_seq'::regclass);


--
-- Name: grid_definition id; Type: DEFAULT; Schema: rbac_ui; Owner: postgres
--

ALTER TABLE ONLY rbac_ui.grid_definition ALTER COLUMN id SET DEFAULT nextval('rbac_ui.grid_definition_id_seq'::regclass);


--
-- Name: cu_tipo_oggetto_piani_da_passare_2024-07-02 id; Type: DEFAULT; Schema: tmp; Owner: postgres
--

ALTER TABLE ONLY tmp."cu_tipo_oggetto_piani_da_passare_2024-07-02" ALTER COLUMN id SET DEFAULT nextval('tmp."cu_tipo_oggetto_piani_2024-07-02_id_seq"'::regclass);


--
-- Name: upd_descr_breve id; Type: DEFAULT; Schema: tmp; Owner: postgres
--

ALTER TABLE ONLY tmp.upd_descr_breve ALTER COLUMN id SET DEFAULT nextval('tmp.upd_descr_breve_id_seq'::regclass);


--
-- Name: _tariffe_voci id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf._tariffe_voci ALTER COLUMN id SET DEFAULT nextval('trf.tariffa_voci_id_seq'::regclass);


--
-- Name: clienti id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.clienti ALTER COLUMN id SET DEFAULT nextval('trf.clienti_id_seq'::regclass);


--
-- Name: indirizzi_2 id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.indirizzi_2 ALTER COLUMN id SET DEFAULT nextval('trf.indirizzi_2_id_seq'::regclass);


--
-- Name: indirizzi_sicer id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.indirizzi_sicer ALTER COLUMN id SET DEFAULT nextval('trf.indirizzi_sicer_id_seq'::regclass);


--
-- Name: old_template_fatturazione id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.old_template_fatturazione ALTER COLUMN id SET DEFAULT nextval('trf.template_fatturazione_id_seq'::regclass);


--
-- Name: servizi id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.servizi ALTER COLUMN id SET DEFAULT nextval('trf.servizi_id_seq'::regclass);


--
-- Name: stabilimento_sedi_2 id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.stabilimento_sedi_2 ALTER COLUMN id SET DEFAULT nextval('trf.stabilimento_sedi_2_id_seq'::regclass);


--
-- Name: stabilimento_sedi_sicer id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.stabilimento_sedi_sicer ALTER COLUMN id SET DEFAULT nextval('trf.stabilimento_sedi_sicer_id_seq'::regclass);


--
-- Name: tariffa_ml id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.tariffa_ml ALTER COLUMN id SET DEFAULT nextval('trf.tariffa_ml_id_seq'::regclass);


--
-- Name: tariffa_ml_livello id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.tariffa_ml_livello ALTER COLUMN id SET DEFAULT nextval('trf.tariffa_ml_livello_id_seq'::regclass);


--
-- Name: tariffa_strutture id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.tariffa_strutture ALTER COLUMN id SET DEFAULT nextval('trf.tariffa_strutture_id_seq'::regclass);


--
-- Name: tariffari id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.tariffari ALTER COLUMN id SET DEFAULT nextval('trf.tariffario_id_seq'::regclass);


--
-- Name: tariffe id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.tariffe ALTER COLUMN id SET DEFAULT nextval('trf.tariffe_id_seq'::regclass);


--
-- Name: tariffe_u_mis id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.tariffe_u_mis ALTER COLUMN id SET DEFAULT nextval('trf.tariffe_u_mis_id_seq'::regclass);


--
-- Name: trf_att_inviate id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_att_inviate ALTER COLUMN id SET DEFAULT nextval('trf.trf_att_inviate_id_seq'::regclass);


--
-- Name: trf_att_inviate_stati id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_att_inviate_stati ALTER COLUMN id SET DEFAULT nextval('trf.trf_att_inviate_stati_id_seq'::regclass);


--
-- Name: trf_attivita id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_attivita ALTER COLUMN id SET DEFAULT nextval('trf.trf_attivita_id_seq'::regclass);


--
-- Name: trf_cod_iva id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_cod_iva ALTER COLUMN id SET DEFAULT nextval('trf.trf_cod_iva_id_seq'::regclass);


--
-- Name: trf_fattura_dettagli id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_fattura_dettagli ALTER COLUMN id SET DEFAULT nextval('trf.trf_fattura_dettagli_id_seq'::regclass);


--
-- Name: trf_fattura_stati id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_fattura_stati ALTER COLUMN id SET DEFAULT nextval('trf.trf_fattura_stati_id_seq'::regclass);


--
-- Name: trf_fatture id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_fatture ALTER COLUMN id SET DEFAULT nextval('trf.trf_fatture_id_seq'::regclass);


--
-- Name: trf_fatture numero_fattura; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_fatture ALTER COLUMN numero_fattura SET DEFAULT nextval('trf.trf_fatture_id_seq'::regclass);


--
-- Name: trf_ft_periodiche id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_ft_periodiche ALTER COLUMN id SET DEFAULT nextval('trf.trf_ft_periodiche_id_seq'::regclass);


--
-- Name: trf_ft_periodiche_dett id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_ft_periodiche_dett ALTER COLUMN id SET DEFAULT nextval('trf.trf_ft_periodiche_dettagli_id_seq'::regclass);


--
-- Name: trf_ft_periodiche_stati id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_ft_periodiche_stati ALTER COLUMN id SET DEFAULT nextval('trf.trf_ft_periodiche_stati_id_seq'::regclass);


--
-- Name: trf_piano_tariffa id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_piano_tariffa ALTER COLUMN id SET DEFAULT nextval('trf.trf_piano_tariffa_id_seq'::regclass);


--
-- Name: trf_regole_fatt id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_regole_fatt ALTER COLUMN id SET DEFAULT nextval('trf.trf_regole_fatt_id_seq'::regclass);


--
-- Name: trf_regole_fatt_dett id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_regole_fatt_dett ALTER COLUMN id SET DEFAULT nextval('trf.trf_regole_fatt_dett_id_seq'::regclass);


--
-- Name: trf_scontrino_pdf id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_scontrino_pdf ALTER COLUMN id SET DEFAULT nextval('trf.trf_sscontrino_pdf_id_seq'::regclass);


--
-- Name: trf_ws_calls id; Type: DEFAULT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_ws_calls ALTER COLUMN id SET DEFAULT nextval('trf.trf_ws_calls_id_seq'::regclass);


--
-- Name: ws_parameters id; Type: DEFAULT; Schema: trf_conf; Owner: postgres
--

ALTER TABLE ONLY trf_conf.ws_parameters ALTER COLUMN id SET DEFAULT nextval('trf_conf.ws_parameters_id_seq'::regclass);


--
-- Name: tariffa_strutture id; Type: DEFAULT; Schema: trf_his; Owner: postgres
--

ALTER TABLE ONLY trf_his.tariffa_strutture ALTER COLUMN id SET DEFAULT nextval('trf_his.tariffa_strutture_id_seq'::regclass);


--
-- Name: trf_att_inviate_stati id; Type: DEFAULT; Schema: trf_his; Owner: postgres
--

ALTER TABLE ONLY trf_his.trf_att_inviate_stati ALTER COLUMN id SET DEFAULT nextval('trf_his.trf_att_inviate_stati_id_seq'::regclass);


--
-- Name: trf_att_inviate_tipo_stati id; Type: DEFAULT; Schema: trf_types; Owner: postgres
--

ALTER TABLE ONLY trf_types.trf_att_inviate_tipo_stati ALTER COLUMN id SET DEFAULT nextval('trf_types.trf_att_sicer_stati_id_seq'::regclass);


--
-- Name: trf_attivita_forfet_stati id; Type: DEFAULT; Schema: trf_types; Owner: postgres
--

ALTER TABLE ONLY trf_types.trf_attivita_forfet_stati ALTER COLUMN id SET DEFAULT nextval('trf_types.trf_attivita_forfet_stato_id_seq'::regclass);


--
-- Name: trf_fattura_stati id; Type: DEFAULT; Schema: trf_types; Owner: postgres
--

ALTER TABLE ONLY trf_types.trf_fattura_stati ALTER COLUMN id SET DEFAULT nextval('trf_types.trf_fattura_stati_id_seq'::regclass);


--
-- Name: trf_intestazioni id; Type: DEFAULT; Schema: trf_ui; Owner: postgres
--

ALTER TABLE ONLY trf_ui.trf_intestazioni ALTER COLUMN id SET DEFAULT nextval('trf_ui.newtable_id_seq'::regclass);


--
-- Name: config_iuv config_iuv_un; Type: CONSTRAINT; Schema: Analisi_dev; Owner: postgres
--

ALTER TABLE ONLY "Analisi_dev".config_iuv
    ADD CONSTRAINT config_iuv_un UNIQUE (cod_raggruppamento);


--
-- Name: config config_pk; Type: CONSTRAINT; Schema: Analisi_dev; Owner: postgres
--

ALTER TABLE ONLY "Analisi_dev".config
    ADD CONSTRAINT config_pk PRIMARY KEY (id);


--
-- Name: config config_un; Type: CONSTRAINT; Schema: Analisi_dev; Owner: postgres
--

ALTER TABLE ONLY "Analisi_dev".config
    ADD CONSTRAINT config_un UNIQUE (descr);


--
-- Name: gisadbi_coll gisadbi_coll_pkey; Type: CONSTRAINT; Schema: Analisi_dev; Owner: postgres
--

ALTER TABLE ONLY "Analisi_dev".gisadbi_coll
    ADD CONSTRAINT gisadbi_coll_pkey PRIMARY KEY (tname);


--
-- Name: gisadbi gisadbi_pk; Type: CONSTRAINT; Schema: Analisi_dev; Owner: postgres
--

ALTER TABLE ONLY "Analisi_dev".gisadbi
    ADD CONSTRAINT gisadbi_pk PRIMARY KEY (id);


--
-- Name: gisadbi gisadbi_un; Type: CONSTRAINT; Schema: Analisi_dev; Owner: postgres
--

ALTER TABLE ONLY "Analisi_dev".gisadbi
    ADD CONSTRAINT gisadbi_un UNIQUE (tname);


--
-- Name: lookup_asl lookup_asl_pkey; Type: CONSTRAINT; Schema: Analisi_dev; Owner: postgres
--

ALTER TABLE ONLY "Analisi_dev".lookup_asl
    ADD CONSTRAINT lookup_asl_pkey PRIMARY KEY (code);


--
-- Name: lookup_tipo_controllo lookup_tipo_controllo_pkey; Type: CONSTRAINT; Schema: Analisi_dev; Owner: postgres
--

ALTER TABLE ONLY "Analisi_dev".lookup_tipo_controllo
    ADD CONSTRAINT lookup_tipo_controllo_pkey PRIMARY KEY (code);


--
-- Name: versioni vers_pk; Type: CONSTRAINT; Schema: Analisi_dev; Owner: postgres
--

ALTER TABLE ONLY "Analisi_dev".versioni
    ADD CONSTRAINT vers_pk PRIMARY KEY (id);


--
-- Name: call_logs call_logs_pk; Type: CONSTRAINT; Schema: ag_log; Owner: postgres
--

ALTER TABLE ONLY ag_log.call_logs
    ADD CONSTRAINT call_logs_pk PRIMARY KEY (id);


--
-- Name: operazioni operazioni_pk; Type: CONSTRAINT; Schema: ag_log; Owner: postgres
--

ALTER TABLE ONLY ag_log.operazioni
    ADD CONSTRAINT operazioni_pk PRIMARY KEY (id);


--
-- Name: ag_livelli_avviso ag_livelli_avviso_pk; Type: CONSTRAINT; Schema: ag_types; Owner: postgres
--

ALTER TABLE ONLY ag_types.ag_livelli_avviso
    ADD CONSTRAINT ag_livelli_avviso_pk PRIMARY KEY (id);


--
-- Name: ag_tipo_avvisi ag_tipo_avvisi_pk; Type: CONSTRAINT; Schema: ag_types; Owner: postgres
--

ALTER TABLE ONLY ag_types.ag_tipo_avvisi
    ADD CONSTRAINT ag_tipo_avvisi_pk PRIMARY KEY (id);


--
-- Name: messaggi_ui messaggi_ui_pk; Type: CONSTRAINT; Schema: ag_ui; Owner: postgres
--

ALTER TABLE ONLY ag_ui.messaggi_ui
    ADD CONSTRAINT messaggi_ui_pk PRIMARY KEY (id);


--
-- Name: ag_tree_nodes ag_tree_nodes_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.ag_tree_nodes
    ADD CONSTRAINT ag_tree_nodes_pk PRIMARY KEY (id);


--
-- Name: ag_trees ag_trees_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.ag_trees
    ADD CONSTRAINT ag_trees_pk PRIMARY KEY (id);


--
-- Name: asl_piani asl_piani_piani_id_unique; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.asl_piani
    ADD CONSTRAINT asl_piani_piani_id_unique UNIQUE (id_struttura, id_piano);


--
-- Name: asl_piani asl_piani_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.asl_piani
    ADD CONSTRAINT asl_piani_pk PRIMARY KEY (id);


--
-- Name: attivita attivita_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.attivita
    ADD CONSTRAINT attivita_id_pk UNIQUE (id);


--
-- Name: avvisi avvisi_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.avvisi
    ADD CONSTRAINT avvisi_pk PRIMARY KEY (id);


--
-- Name: az_sedi az_sedi_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.az_sedi
    ADD CONSTRAINT az_sedi_id_pk UNIQUE (id);


--
-- Name: az_sedi_selezionate az_sedi_selezionate_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.az_sedi_selezionate
    ADD CONSTRAINT az_sedi_selezionate_id_pk UNIQUE (id);


--
-- Name: az_sedi_selezionate az_sedi_selezionate_un; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.az_sedi_selezionate
    ADD CONSTRAINT az_sedi_selezionate_un UNIQUE (id_elab_cal, id_az_sede, id_piano);


--
-- Name: aziende aziende_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.aziende
    ADD CONSTRAINT aziende_id_pk UNIQUE (id);


--
-- Name: calendari calendari_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.calendari
    ADD CONSTRAINT calendari_id_pk UNIQUE (id);


--
-- Name: cf_allevamenti cf_allevamenti_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.cf_allevamenti
    ADD CONSTRAINT cf_allevamenti_pk PRIMARY KEY (id);


--
-- Name: comuni comuni_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.comuni
    ADD CONSTRAINT comuni_id_pk UNIQUE (id);


--
-- Name: elab_cal_logs elab_cal_logs_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_logs
    ADD CONSTRAINT elab_cal_logs_id_pk UNIQUE (id);


--
-- Name: elab_cal_param_asl elab_cal_param_asl_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_asl
    ADD CONSTRAINT elab_cal_param_asl_pk PRIMARY KEY (id);


--
-- Name: elab_cal_param_asl elab_cal_param_asl_un; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_asl
    ADD CONSTRAINT elab_cal_param_asl_un UNIQUE (id_elab_cal, id_asl);


--
-- Name: elab_cal_param_ns elab_cal_param_ns_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_ns
    ADD CONSTRAINT elab_cal_param_ns_pk PRIMARY KEY (id);


--
-- Name: elab_cal_param_ns elab_cal_param_ns_un; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_ns
    ADD CONSTRAINT elab_cal_param_ns_un UNIQUE (id_elab_cal, id_ns);


--
-- Name: elab_cal_param_piani elab_cal_param_piani_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_piani
    ADD CONSTRAINT elab_cal_param_piani_pk PRIMARY KEY (id);


--
-- Name: elab_cal_param_piani elab_cal_param_piani_un; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_piani
    ADD CONSTRAINT elab_cal_param_piani_un UNIQUE (id_elab_cal, id_piano);


--
-- Name: elab_cal_params elab_cal_params_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_params
    ADD CONSTRAINT elab_cal_params_id_pk UNIQUE (id);


--
-- Name: elab_cals elab_cals_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cals
    ADD CONSTRAINT elab_cals_id_pk UNIQUE (id);


--
-- Name: eventi eventi_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.eventi
    ADD CONSTRAINT eventi_id_pk UNIQUE (id);


--
-- Name: file_xls_cf file_xls_cf_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.file_xls_cf
    ADD CONSTRAINT file_xls_cf_pk PRIMARY KEY (id);


--
-- Name: file_xls_linea file_xls_linea_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.file_xls_linea
    ADD CONSTRAINT file_xls_linea_pk PRIMARY KEY (id);


--
-- Name: file_xls_profilassi file_xls_profilassi_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.file_xls_profilassi
    ADD CONSTRAINT file_xls_profilassi_pk PRIMARY KEY (id);


--
-- Name: file_xls_sicer file_xls_sicer_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.file_xls_sicer
    ADD CONSTRAINT file_xls_sicer_pk PRIMARY KEY (id);


--
-- Name: formato_import formato_import_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.formato_import
    ADD CONSTRAINT formato_import_pk PRIMARY KEY (id);


--
-- Name: formato_import formato_import_unique; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.formato_import
    ADD CONSTRAINT formato_import_unique UNIQUE (id);


--
-- Name: import_linea import_linea_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.import_linea
    ADD CONSTRAINT import_linea_pk PRIMARY KEY (id);


--
-- Name: linea_piani linea_piani_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.linea_piani
    ADD CONSTRAINT linea_piani_pk PRIMARY KEY (id);


--
-- Name: linea_piani linea_piano_id_unique; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.linea_piani
    ADD CONSTRAINT linea_piano_id_unique UNIQUE (id_linea, id_piano);


--
-- Name: linee linee_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.linee
    ADD CONSTRAINT linee_id_pk UNIQUE (id);


--
-- Name: linee_selezionate linee_selezionate_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.linee_selezionate
    ADD CONSTRAINT linee_selezionate_id_pk UNIQUE (id);


--
-- Name: linee_selezionate linee_selezionate_un; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.linee_selezionate
    ADD CONSTRAINT linee_selezionate_un UNIQUE (id_elab_cal, id_linea, id_piano);


--
-- Name: lista_import lista_import_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.lista_import
    ADD CONSTRAINT lista_import_pk PRIMARY KEY (id);


--
-- Name: nominativo_az_sedi nominativo_az_sedi_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_az_sedi
    ADD CONSTRAINT nominativo_az_sedi_id_pk UNIQUE (id);


--
-- Name: nominativo_az_sedi nominativo_az_sedi_id_unique; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_az_sedi
    ADD CONSTRAINT nominativo_az_sedi_id_unique UNIQUE (id_nominativo_struttura, id_az_sede);


--
-- Name: nominativo_comuni nominativo_comune_id_unique; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_comuni
    ADD CONSTRAINT nominativo_comune_id_unique UNIQUE (id_nominativo_struttura, id_struttura_comune);


--
-- Name: nominativo_comuni nominativo_comuni_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_comuni
    ADD CONSTRAINT nominativo_comuni_id_pk UNIQUE (id);


--
-- Name: nominativo_linee nominativo_linee_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_linee
    ADD CONSTRAINT nominativo_linee_id_pk UNIQUE (id);


--
-- Name: nominativo_linee nominativo_linee_id_unique; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_linee
    ADD CONSTRAINT nominativo_linee_id_unique UNIQUE (id_nominativo_struttura, id_linea);


--
-- Name: nominativo_piani nominativo_piani_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_piani
    ADD CONSTRAINT nominativo_piani_id_pk UNIQUE (id);


--
-- Name: nominativo_piani nominativo_piano_id_unique; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_piani
    ADD CONSTRAINT nominativo_piano_id_unique UNIQUE (id_nominativo_struttura, id_piano);


--
-- Name: piano_freq piano_freq_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.piano_freq
    ADD CONSTRAINT piano_freq_pk PRIMARY KEY (id);


--
-- Name: piano_tipo_linea piano_tipo_linea_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.piano_tipo_linea
    ADD CONSTRAINT piano_tipo_linea_pk PRIMARY KEY (id);


--
-- Name: piano_tipo_linea piano_tipo_linea_un; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.piano_tipo_linea
    ADD CONSTRAINT piano_tipo_linea_un UNIQUE (id_piano, id_tipo_linea);


--
-- Name: struttura_comuni struttura_comune_id_unique; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.struttura_comuni
    ADD CONSTRAINT struttura_comune_id_unique UNIQUE (id_comune, id_struttura);


--
-- Name: struttura_comuni struttura_comuni_id_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.struttura_comuni
    ADD CONSTRAINT struttura_comuni_id_pk UNIQUE (id);


--
-- Name: tipo_linee tipo_linee_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.tipo_linee
    ADD CONSTRAINT tipo_linee_pk PRIMARY KEY (id);


--
-- Name: tipo_lista_piano tipo_lista_piano_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.tipo_lista_piano
    ADD CONSTRAINT tipo_lista_piano_pk PRIMARY KEY (id);


--
-- Name: tipo_lista_piano tipo_lista_piano_un; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.tipo_lista_piano
    ADD CONSTRAINT tipo_lista_piano_un UNIQUE (id_piano, id_tipo_lista);


--
-- Name: tipo_liste tipo_liste_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.tipo_liste
    ADD CONSTRAINT tipo_liste_pk PRIMARY KEY (id);


--
-- Name: tipologia_controllo_piani tipologia_controllo_piani_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.tipologia_controllo_piani
    ADD CONSTRAINT tipologia_controllo_piani_pk UNIQUE (id);


--
-- Name: unita_di_crisi_as_fo unita_di_crisi_as_fo_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.unita_di_crisi_as_fo
    ADD CONSTRAINT unita_di_crisi_as_fo_pk PRIMARY KEY (id);


--
-- Name: unita_di_crisi_asu_fc unita_di_crisi_asu_fc_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.unita_di_crisi_asu_fc
    ADD CONSTRAINT unita_di_crisi_asu_fc_pk PRIMARY KEY (id);


--
-- Name: unita_di_crisi_asu_gi unita_di_crisi_asu_gi_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.unita_di_crisi_asu_gi
    ADD CONSTRAINT unita_di_crisi_asu_gi_pk PRIMARY KEY (id);


--
-- Name: unita_di_crisi_fvg unita_di_crisi_fvg_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.unita_di_crisi_fvg
    ADD CONSTRAINT unita_di_crisi_fvg_pk PRIMARY KEY (id);


--
-- Name: unita_di_crisi unita_di_crisi_pk; Type: CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.unita_di_crisi
    ADD CONSTRAINT unita_di_crisi_pk PRIMARY KEY (id);


--
-- Name: categorizzazione_rischio_tipo_stabilimento categorizzazione_rischio_tipo_stabilimento_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.categorizzazione_rischio_tipo_stabilimento
    ADD CONSTRAINT categorizzazione_rischio_tipo_stabilimento_pk UNIQUE (id);


--
-- Name: cu_altri cu_altri_unique; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_altri
    ADD CONSTRAINT cu_altri_unique UNIQUE (id);


--
-- Name: cu_dichiarazioni cu_dichiarazioni_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_dichiarazioni
    ADD CONSTRAINT cu_dichiarazioni_pk PRIMARY KEY (id);


--
-- Name: cu_dichiarazioni cu_dichiarazioni_un; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_dichiarazioni
    ADD CONSTRAINT cu_dichiarazioni_un UNIQUE (id_cu_nucleo);


--
-- Name: cu_evidenza_linee cu_evidenza_linee_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_evidenza_linee
    ADD CONSTRAINT cu_evidenza_linee_pk PRIMARY KEY (id);


--
-- Name: cu_evidenza_linee cu_evidenza_linee_un; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_evidenza_linee
    ADD CONSTRAINT cu_evidenza_linee_un UNIQUE (id_evidenza, id_cu_linea);


--
-- Name: cu_evidenze cu_evidenze_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_evidenze
    ADD CONSTRAINT cu_evidenze_pk PRIMARY KEY (id);


--
-- Name: cu_evidenze_sp cu_evidenze_sosp_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_evidenze_sp
    ADD CONSTRAINT cu_evidenze_sosp_pk PRIMARY KEY (id);


--
-- Name: cu_evidenze cu_evidenze_un; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_evidenze
    ADD CONSTRAINT cu_evidenze_un UNIQUE (id_cu_oggetto_cl, ord);


--
-- Name: cu_linee cu_linee_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_linee
    ADD CONSTRAINT cu_linee_pk PRIMARY KEY (id);


--
-- Name: cu_linee cu_linee_un; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_linee
    ADD CONSTRAINT cu_linee_un UNIQUE (id_cu, id_linea);


--
-- Name: cu_nominativo_provv cu_nominativo_provv_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_nominativo_provv
    ADD CONSTRAINT cu_nominativo_provv_pk PRIMARY KEY (id);


--
-- Name: cu_nominativo_provv cu_nominativo_provv_unique; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_nominativo_provv
    ADD CONSTRAINT cu_nominativo_provv_unique UNIQUE (id_cu);


--
-- Name: cu_norme_violate cu_norme_violate_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_norme_violate
    ADD CONSTRAINT cu_norme_violate_pk PRIMARY KEY (id);


--
-- Name: cu_norme_violate cu_norme_violate_un; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_norme_violate
    ADD CONSTRAINT cu_norme_violate_un UNIQUE (id_cu, id_norma);


--
-- Name: cu_nucleo_periodi cu_nucleo_periodi_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_nucleo_periodi
    ADD CONSTRAINT cu_nucleo_periodi_pk PRIMARY KEY (id);


--
-- Name: cu_nucleo_periodi cu_nucleo_periodi_un; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_nucleo_periodi
    ADD CONSTRAINT cu_nucleo_periodi_un UNIQUE (id_cu_nucleo, periodo);


--
-- Name: cu_nucleo cu_nucleo_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_nucleo
    ADD CONSTRAINT cu_nucleo_pk PRIMARY KEY (id);


--
-- Name: cu_nucleo cu_nucleo_un; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_nucleo
    ADD CONSTRAINT cu_nucleo_un UNIQUE (id_cu, id_nominativo);


--
-- Name: cu_oggetti_cl cu_oggetti_cl_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_oggetti_cl
    ADD CONSTRAINT cu_oggetti_cl_pk PRIMARY KEY (id);


--
-- Name: cu_oggetti_cl cu_oggetti_cl_un; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_oggetti_cl
    ADD CONSTRAINT cu_oggetti_cl_un UNIQUE (id_cu_oggetto, id_requisito);


--
-- Name: cu_oggetti cu_oggetti_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_oggetti
    ADD CONSTRAINT cu_oggetti_pk PRIMARY KEY (id);


--
-- Name: cu_oggetti cu_oggetti_un; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_oggetti
    ADD CONSTRAINT cu_oggetti_un UNIQUE (id_cu, id_tipo_oggetto);


--
-- Name: cu_piani cu_piani_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_piani
    ADD CONSTRAINT cu_piani_pk PRIMARY KEY (id);


--
-- Name: cu_piani cu_piani_un; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_piani
    ADD CONSTRAINT cu_piani_un UNIQUE (id_cu, id_piano);


--
-- Name: cu cu_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu
    ADD CONSTRAINT cu_pk PRIMARY KEY (id);


--
-- Name: cu_provv cu_provv_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv
    ADD CONSTRAINT cu_provv_pk PRIMARY KEY (id);


--
-- Name: cu_provv_sopralluogo cu_provv_sopralluogo_pk; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv_sopralluogo
    ADD CONSTRAINT cu_provv_sopralluogo_pk PRIMARY KEY (id);


--
-- Name: cu_provv cu_provv_un; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv
    ADD CONSTRAINT cu_provv_un UNIQUE (id_norma_violata, id_tipo_provv);


--
-- Name: cu_provv cu_provv_un_2; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv
    ADD CONSTRAINT cu_provv_un_2 UNIQUE (id_norma_violata, ord);


--
-- Name: nomi_file_pdf_controlli nomi_file_pdf_controlli_pkey; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.nomi_file_pdf_controlli
    ADD CONSTRAINT nomi_file_pdf_controlli_pkey PRIMARY KEY (id);


--
-- Name: nomi_file_pdf_evidenze nomi_file_pdf_evidenze_pkey; Type: CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.nomi_file_pdf_evidenze
    ADD CONSTRAINT nomi_file_pdf_evidenze_pkey PRIMARY KEY (id);


--
-- Name: automezzi automezzi_pk; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.automezzi
    ADD CONSTRAINT automezzi_pk PRIMARY KEY (id);


--
-- Name: automezzi automezzi_unique; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.automezzi
    ADD CONSTRAINT automezzi_unique UNIQUE (targa);


--
-- Name: file_xls_mangimifici file_xls_mangimifici_pk; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.file_xls_mangimifici
    ADD CONSTRAINT file_xls_mangimifici_pk PRIMARY KEY (id);


--
-- Name: file_xls_sintesis file_xls_sintesis_pk; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.file_xls_sintesis
    ADD CONSTRAINT file_xls_sintesis_pk PRIMARY KEY (id);


--
-- Name: import_anagrafica import_anagrafica_pk; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.import_anagrafica
    ADD CONSTRAINT import_anagrafica_pk PRIMARY KEY (id);


--
-- Name: imprese imprese_pk; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.imprese
    ADD CONSTRAINT imprese_pk PRIMARY KEY (id);


--
-- Name: linee linee_pk; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.linee
    ADD CONSTRAINT linee_pk PRIMARY KEY (id);


--
-- Name: indirizzi new_indirizzi_pk; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.indirizzi
    ADD CONSTRAINT new_indirizzi_pk PRIMARY KEY (id);


--
-- Name: stabilimenti_storico new_stabilimenti_storico_pk; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimenti_storico
    ADD CONSTRAINT new_stabilimenti_storico_pk PRIMARY KEY (id);


--
-- Name: stabilimento_sedi new_stabilimento_sedi_pk; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimento_sedi
    ADD CONSTRAINT new_stabilimento_sedi_pk PRIMARY KEY (id);


--
-- Name: pratiche pratiche_pk; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.pratiche
    ADD CONSTRAINT pratiche_pk PRIMARY KEY (id);


--
-- Name: pratiche pratiche_unique; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.pratiche
    ADD CONSTRAINT pratiche_unique UNIQUE (n_pratica);


--
-- Name: stabilimenti stabilimenti_pk; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimenti
    ADD CONSTRAINT stabilimenti_pk PRIMARY KEY (id);


--
-- Name: stabilimento_automezzi stabilimento_automezzi_unique; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimento_automezzi
    ADD CONSTRAINT stabilimento_automezzi_unique UNIQUE (id_automezzo, id_stabilimento, validita);


--
-- Name: stabilimento_figure stabilimento_figure_unique; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimento_figure
    ADD CONSTRAINT stabilimento_figure_unique UNIQUE (id_stabilimento, id_tipo_figura, validita);


--
-- Name: stabilimento_sedi stabilimento_sedi_unique; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimento_sedi
    ADD CONSTRAINT stabilimento_sedi_unique UNIQUE (id_stabilimento, id_tipo_sede, validita);


--
-- Name: stabilimento_automezzi stabilimento_unique_automezzi; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimento_automezzi
    ADD CONSTRAINT stabilimento_unique_automezzi EXCLUDE USING gist (id_automezzo WITH =, validita WITH &&);


--
-- Name: storico_pratiche storico_pratiche_pk; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.storico_pratiche
    ADD CONSTRAINT storico_pratiche_pk PRIMARY KEY (id);


--
-- Name: tipo_import_anagrafica tipo_import_anagrafica_pk; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.tipo_import_anagrafica
    ADD CONSTRAINT tipo_import_anagrafica_pk PRIMARY KEY (id);


--
-- Name: stabilimento_figure unique_stabilimento_tipo_figura; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimento_figure
    ADD CONSTRAINT unique_stabilimento_tipo_figura EXCLUDE USING gist (id_stabilimento WITH =, id_tipo_figura WITH =, validita WITH &&);


--
-- Name: stabilimento_sedi unique_stabilimento_tipo_sede; Type: CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimento_sedi
    ADD CONSTRAINT unique_stabilimento_tipo_sede EXCLUDE USING gist (id_stabilimento WITH =, id_tipo_sede WITH =, validita WITH &&);


--
-- Name: cu_categ_esiti cu_categ_esiti_pk; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_categ_esiti
    ADD CONSTRAINT cu_categ_esiti_pk PRIMARY KEY (id);


--
-- Name: cu_conf cu_conf_pk; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_conf
    ADD CONSTRAINT cu_conf_pk PRIMARY KEY (id);


--
-- Name: cu_conf cu_conf_un; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_conf
    ADD CONSTRAINT cu_conf_un UNIQUE (idx, cod);


--
-- Name: cu_norme cu_norme_pk; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_norme
    ADD CONSTRAINT cu_norme_pk PRIMARY KEY (id);


--
-- Name: cu_norme cu_norme_un; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_norme
    ADD CONSTRAINT cu_norme_un UNIQUE (norma);


--
-- Name: cu_piani_categ cu_piani_categ_pk; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_piani_categ
    ADD CONSTRAINT cu_piani_categ_pk PRIMARY KEY (id);


--
-- Name: cu_requisiti cu_requisiti_pk; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_requisiti
    ADD CONSTRAINT cu_requisiti_pk PRIMARY KEY (id);


--
-- Name: cu_requisiti cu_requisiti_un; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_requisiti
    ADD CONSTRAINT cu_requisiti_un UNIQUE (id_tipo_oggetto, ord);


--
-- Name: cu_tecniche cu_tecniche_descr_un; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tecniche
    ADD CONSTRAINT cu_tecniche_descr_un UNIQUE (descr);


--
-- Name: cu_tecniche cu_tecniche_pk; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tecniche
    ADD CONSTRAINT cu_tecniche_pk PRIMARY KEY (id);


--
-- Name: cu_tecniche cu_tecniche_sigla_un; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tecniche
    ADD CONSTRAINT cu_tecniche_sigla_un UNIQUE (sigla);


--
-- Name: cu_tipo_isp cu_tipo_isp_pk; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tipo_isp
    ADD CONSTRAINT cu_tipo_isp_pk PRIMARY KEY (id);


--
-- Name: cu_tipo_oggetti cu_tipo_oggetti_cod_un; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tipo_oggetti
    ADD CONSTRAINT cu_tipo_oggetti_cod_un UNIQUE (cod, validita);


--
-- Name: cu_tipo_oggetti cu_tipo_oggetti_descr_un; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tipo_oggetti
    ADD CONSTRAINT cu_tipo_oggetti_descr_un UNIQUE (descr, validita);


--
-- Name: cu_tipo_oggetti cu_tipo_oggetti_pk; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tipo_oggetti
    ADD CONSTRAINT cu_tipo_oggetti_pk PRIMARY KEY (id);


--
-- Name: cu_tipo_oggetti cu_tipo_oggetti_sigla_un; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tipo_oggetti
    ADD CONSTRAINT cu_tipo_oggetti_sigla_un UNIQUE (sigla, validita);


--
-- Name: cu_tipo_oggetto_piani cu_tipo_oggetto_piani_pk; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tipo_oggetto_piani
    ADD CONSTRAINT cu_tipo_oggetto_piani_pk PRIMARY KEY (id);


--
-- Name: cu_tipo_oggetto_piani cu_tipo_oggetto_piani_un; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tipo_oggetto_piani
    ADD CONSTRAINT cu_tipo_oggetto_piani_un UNIQUE (id_tipo_oggetto, id_piano);


--
-- Name: cu_tipo_per cu_tipo_per_pk; Type: CONSTRAINT; Schema: cu_conf; Owner: postgres
--

ALTER TABLE ONLY cu_conf.cu_tipo_per
    ADD CONSTRAINT cu_tipo_per_pk PRIMARY KEY (id);


--
-- Name: call_logs call_logs_pk; Type: CONSTRAINT; Schema: cu_log; Owner: postgres
--

ALTER TABLE ONLY cu_log.call_logs
    ADD CONSTRAINT call_logs_pk PRIMARY KEY (id);


--
-- Name: operazioni operazioni_pk; Type: CONSTRAINT; Schema: cu_log; Owner: postgres
--

ALTER TABLE ONLY cu_log.operazioni
    ADD CONSTRAINT operazioni_pk PRIMARY KEY (id);


--
-- Name: cu_stati_oggetto cu_stati_cod_oggetto_un; Type: CONSTRAINT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_stati_oggetto
    ADD CONSTRAINT cu_stati_cod_oggetto_un UNIQUE (cod);


--
-- Name: cu_stati_oggetto cu_stati_descr_oggetto_un; Type: CONSTRAINT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_stati_oggetto
    ADD CONSTRAINT cu_stati_descr_oggetto_un UNIQUE (descr);


--
-- Name: cu_stati_oggetto cu_stati_oggetto_pk; Type: CONSTRAINT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_stati_oggetto
    ADD CONSTRAINT cu_stati_oggetto_pk PRIMARY KEY (id);


--
-- Name: cu_stati_oggetto cu_stati_sigla_oggetto_un; Type: CONSTRAINT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_stati_oggetto
    ADD CONSTRAINT cu_stati_sigla_oggetto_un UNIQUE (sigla);


--
-- Name: cu_tipi_provv cu_tipi_provv_pk; Type: CONSTRAINT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_tipi_provv
    ADD CONSTRAINT cu_tipi_provv_pk PRIMARY KEY (id);


--
-- Name: cu_tipi_provv cu_tipi_provv_un_cod; Type: CONSTRAINT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_tipi_provv
    ADD CONSTRAINT cu_tipi_provv_un_cod UNIQUE (cod);


--
-- Name: cu_tipi_provv cu_tipi_provv_un_descr; Type: CONSTRAINT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_tipi_provv
    ADD CONSTRAINT cu_tipi_provv_un_descr UNIQUE (descr);


--
-- Name: cu_tipi_provv cu_tipi_provv_un_sigla; Type: CONSTRAINT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_tipi_provv
    ADD CONSTRAINT cu_tipi_provv_un_sigla UNIQUE (sigla);


--
-- Name: cu_tipo_nucleo cu_tipo_nucleo_descr_un; Type: CONSTRAINT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_tipo_nucleo
    ADD CONSTRAINT cu_tipo_nucleo_descr_un UNIQUE (descr_tipo_nucleo);


--
-- Name: cu_tipo_nucleo cu_tipo_nucleo_pk; Type: CONSTRAINT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_tipo_nucleo
    ADD CONSTRAINT cu_tipo_nucleo_pk PRIMARY KEY (id);


--
-- Name: cu_tipo_nucleo cu_tipo_nucleo_sigla_un; Type: CONSTRAINT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.cu_tipo_nucleo
    ADD CONSTRAINT cu_tipo_nucleo_sigla_un UNIQUE (sigla);


--
-- Name: tipo_import_anagrafica tipo_import_anagrafica_pk; Type: CONSTRAINT; Schema: cu_types; Owner: postgres
--

ALTER TABLE ONLY cu_types.tipo_import_anagrafica
    ADD CONSTRAINT tipo_import_anagrafica_pk PRIMARY KEY (id);


--
-- Name: form_definition form_definition_pk; Type: CONSTRAINT; Schema: cu_ui; Owner: postgres
--

ALTER TABLE ONLY cu_ui.form_definition
    ADD CONSTRAINT form_definition_pk PRIMARY KEY (id);


--
-- Name: menu_item_modes menu_item_modes_pk; Type: CONSTRAINT; Schema: cu_ui; Owner: postgres
--

ALTER TABLE ONLY cu_ui.menu_item_modes
    ADD CONSTRAINT menu_item_modes_pk PRIMARY KEY (id);


--
-- Name: menu_items menu_items_pk; Type: CONSTRAINT; Schema: cu_ui; Owner: postgres
--

ALTER TABLE ONLY cu_ui.menu_items
    ADD CONSTRAINT menu_items_pk PRIMARY KEY (id);


--
-- Name: menu menu_pk; Type: CONSTRAINT; Schema: cu_ui; Owner: postgres
--

ALTER TABLE ONLY cu_ui.menu
    ADD CONSTRAINT menu_pk PRIMARY KEY (id);


--
-- Name: messaggi_ui messaggi_ui_pk; Type: CONSTRAINT; Schema: cu_ui; Owner: postgres
--

ALTER TABLE ONLY cu_ui.messaggi_ui
    ADD CONSTRAINT messaggi_ui_pk PRIMARY KEY (id);


--
-- Name: pdf pdf_pk; Type: CONSTRAINT; Schema: documenti; Owner: postgres
--

ALTER TABLE ONLY documenti.pdf
    ADD CONSTRAINT pdf_pk PRIMARY KEY (id);


--
-- Name: pdf pdf_un; Type: CONSTRAINT; Schema: documenti; Owner: postgres
--

ALTER TABLE ONLY documenti.pdf
    ADD CONSTRAINT pdf_un UNIQUE (id_modulo, descr_modulo, filename);


--
-- Name: aree area_pk; Type: CONSTRAINT; Schema: log; Owner: postgres
--

ALTER TABLE ONLY log.aree
    ADD CONSTRAINT area_pk PRIMARY KEY (id);


--
-- Name: aree area_unique; Type: CONSTRAINT; Schema: log; Owner: postgres
--

ALTER TABLE ONLY log.aree
    ADD CONSTRAINT area_unique UNIQUE (cod);


--
-- Name: aree area_unique_1; Type: CONSTRAINT; Schema: log; Owner: postgres
--

ALTER TABLE ONLY log.aree
    ADD CONSTRAINT area_unique_1 UNIQUE (sigla);


--
-- Name: aree area_unique_2; Type: CONSTRAINT; Schema: log; Owner: postgres
--

ALTER TABLE ONLY log.aree
    ADD CONSTRAINT area_unique_2 UNIQUE (descr);


--
-- Name: funzioni funzioni_pk; Type: CONSTRAINT; Schema: log; Owner: postgres
--

ALTER TABLE ONLY log.funzioni
    ADD CONSTRAINT funzioni_pk PRIMARY KEY (id);


--
-- Name: mod4_nominativi_fattori mod4_nominativi_fattori_un; Type: CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.mod4_nominativi_fattori
    ADD CONSTRAINT mod4_nominativi_fattori_un UNIQUE (id_nominativo_struttura, id_fattore);


--
-- Name: mod4_nominativi mod4_nominativi_un; Type: CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.mod4_nominativi
    ADD CONSTRAINT mod4_nominativi_un UNIQUE (id_nominativo_struttura);


--
-- Name: mod4_strutture mod4_strutture_un; Type: CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.mod4_strutture
    ADD CONSTRAINT mod4_strutture_un UNIQUE (id_struttura);


--
-- Name: struttura_asl struttura_asl_id_pk; Type: CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.struttura_asl
    ADD CONSTRAINT struttura_asl_id_pk UNIQUE (id);


--
-- Name: struttura_asl struttura_asl_id_un; Type: CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.struttura_asl
    ADD CONSTRAINT struttura_asl_id_un UNIQUE (id_gisa, anno);


--
-- Name: struttura_piani struttura_piani_id_pk; Type: CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.struttura_piani
    ADD CONSTRAINT struttura_piani_id_pk UNIQUE (id);


--
-- Name: struttura_piani struttura_piani_test_un; Type: CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.struttura_piani
    ADD CONSTRAINT struttura_piani_test_un UNIQUE (cod_raggruppamento, anno, livello);


--
-- Name: struttura_piano_target_2019 struttura_piano_target_un; Type: CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.struttura_piano_target_2019
    ADD CONSTRAINT struttura_piano_target_un UNIQUE (id_struttura, id_piano);


--
-- Name: struttura_piano_target struttura_piano_target_un2; Type: CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.struttura_piano_target
    ADD CONSTRAINT struttura_piano_target_un2 UNIQUE (id_struttura, id_piano);


--
-- Name: tree_nodes_2019 tree_nodes_pk; Type: CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.tree_nodes_2019
    ADD CONSTRAINT tree_nodes_pk PRIMARY KEY (id);


--
-- Name: tree_nodes tree_nodes_pk_; Type: CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.tree_nodes
    ADD CONSTRAINT tree_nodes_pk_ PRIMARY KEY (id);


--
-- Name: trees trees_pk; Type: CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.trees
    ADD CONSTRAINT trees_pk PRIMARY KEY (id);


--
-- Name: trees trees_un; Type: CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.trees
    ADD CONSTRAINT trees_un UNIQUE (name);


--
-- Name: session_log session_log_un; Type: CONSTRAINT; Schema: ra; Owner: postgres
--

ALTER TABLE ONLY ra.session_log
    ADD CONSTRAINT session_log_un UNIQUE (id);


--
-- Name: permessi permessi_pk; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.permessi
    ADD CONSTRAINT permessi_pk PRIMARY KEY (id);


--
-- Name: permessi permessi_unique; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.permessi
    ADD CONSTRAINT permessi_unique UNIQUE (id_modalita, id_sezione);


--
-- Name: ruolo_permessi ruolo_permessi_pk; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.ruolo_permessi
    ADD CONSTRAINT ruolo_permessi_pk PRIMARY KEY (id);


--
-- Name: ruolo_permessi ruolo_permessi_unique; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.ruolo_permessi
    ADD CONSTRAINT ruolo_permessi_unique UNIQUE (id_ruolo, id_permesso);


--
-- Name: ruoli ruolo_pk; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.ruoli
    ADD CONSTRAINT ruolo_pk PRIMARY KEY (id);


--
-- Name: ruoli ruolo_unique; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.ruoli
    ADD CONSTRAINT ruolo_unique UNIQUE (cod);


--
-- Name: ruoli ruolo_unique_1; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.ruoli
    ADD CONSTRAINT ruolo_unique_1 UNIQUE (sigla);


--
-- Name: ruoli ruolo_unique_2; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.ruoli
    ADD CONSTRAINT ruolo_unique_2 UNIQUE (descr);


--
-- Name: ruolo_ruoli ruoloruoli_pk; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.ruolo_ruoli
    ADD CONSTRAINT ruoloruoli_pk PRIMARY KEY (id);


--
-- Name: ruolo_ruoli ruoloruoli_unique; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.ruolo_ruoli
    ADD CONSTRAINT ruoloruoli_unique UNIQUE (id_ruolo_cte, id_ruolo_cto);


--
-- Name: utente_strutture_ruoli utente_ruoli_pk; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.utente_strutture_ruoli
    ADD CONSTRAINT utente_ruoli_pk PRIMARY KEY (id);


--
-- Name: utente_strutture utente_strutture_pk; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.utente_strutture
    ADD CONSTRAINT utente_strutture_pk PRIMARY KEY (id);


--
-- Name: utente_strutture_ruoli utente_strutture_ruoli_unique; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.utente_strutture_ruoli
    ADD CONSTRAINT utente_strutture_ruoli_unique UNIQUE (id_utente_struttura);


--
-- Name: utenti utenti_pk; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.utenti
    ADD CONSTRAINT utenti_pk PRIMARY KEY (id);


--
-- Name: utenti utenti_unique; Type: CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.utenti
    ADD CONSTRAINT utenti_unique UNIQUE (cf, id_asl, validita);


--
-- Name: risorse risorse_pk; Type: CONSTRAINT; Schema: rbac_conf; Owner: postgres
--

ALTER TABLE ONLY rbac_conf.risorse
    ADD CONSTRAINT risorse_pk PRIMARY KEY (id);


--
-- Name: risorse risorse_unique; Type: CONSTRAINT; Schema: rbac_conf; Owner: postgres
--

ALTER TABLE ONLY rbac_conf.risorse
    ADD CONSTRAINT risorse_unique UNIQUE (cod);


--
-- Name: call_logs call_logs_pk; Type: CONSTRAINT; Schema: rbac_log; Owner: postgres
--

ALTER TABLE ONLY rbac_log.call_logs
    ADD CONSTRAINT call_logs_pk PRIMARY KEY (id);


--
-- Name: operazioni operazioni_pk; Type: CONSTRAINT; Schema: rbac_log; Owner: postgres
--

ALTER TABLE ONLY rbac_log.operazioni
    ADD CONSTRAINT operazioni_pk PRIMARY KEY (id);


--
-- Name: portali portali_pk; Type: CONSTRAINT; Schema: rbac_ui; Owner: postgres
--

ALTER TABLE ONLY rbac_ui.portali
    ADD CONSTRAINT portali_pk PRIMARY KEY (id);


--
-- Name: sezioni sezioni_pk; Type: CONSTRAINT; Schema: rbac_ui; Owner: postgres
--

ALTER TABLE ONLY rbac_ui.sezioni
    ADD CONSTRAINT sezioni_pk PRIMARY KEY (id);


--
-- Name: clienti _id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.clienti
    ADD CONSTRAINT _id_pk UNIQUE (id);


--
-- Name: clienti clienti_unique; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.clienti
    ADD CONSTRAINT clienti_unique UNIQUE (id_ref, type);


--
-- Name: servizi servizi_id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.servizi
    ADD CONSTRAINT servizi_id_pk UNIQUE (id);


--
-- Name: tariffa_strutture tariffa_strutture_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.tariffa_strutture
    ADD CONSTRAINT tariffa_strutture_pk PRIMARY KEY (id);


--
-- Name: tariffa_voci tariffa_voci_id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.tariffa_voci
    ADD CONSTRAINT tariffa_voci_id_pk UNIQUE (id);


--
-- Name: tariffari tariffari_id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.tariffari
    ADD CONSTRAINT tariffari_id_pk UNIQUE (id);


--
-- Name: tariffe tariffe_id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.tariffe
    ADD CONSTRAINT tariffe_id_pk UNIQUE (id);


--
-- Name: tariffe_u_mis tariffe_u_mis_id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.tariffe_u_mis
    ADD CONSTRAINT tariffe_u_mis_id_pk UNIQUE (id);


--
-- Name: trf_att_inviate trf_att_inviate_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_att_inviate
    ADD CONSTRAINT trf_att_inviate_pk PRIMARY KEY (id);


--
-- Name: trf_att_inviate_stati trf_att_inviate_stati_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_att_inviate_stati
    ADD CONSTRAINT trf_att_inviate_stati_pk PRIMARY KEY (id);


--
-- Name: trf_att_inviate trf_att_inviate_un; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_att_inviate
    ADD CONSTRAINT trf_att_inviate_un UNIQUE (id_trf_attivita);


--
-- Name: trf_attivita_dettagli trf_attivita_dettagli_id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_attivita_dettagli
    ADD CONSTRAINT trf_attivita_dettagli_id_pk UNIQUE (id);


--
-- Name: trf_attivita trf_attivita_id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_attivita
    ADD CONSTRAINT trf_attivita_id_pk UNIQUE (id);


--
-- Name: trf_fattura_dettagli trf_fattura_dettagli_id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_fattura_dettagli
    ADD CONSTRAINT trf_fattura_dettagli_id_pk UNIQUE (id);


--
-- Name: trf_fatture trf_fatture_id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_fatture
    ADD CONSTRAINT trf_fatture_id_pk UNIQUE (id);


--
-- Name: trf_piano_tariffa trf_piano_tariffa_id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_piano_tariffa
    ADD CONSTRAINT trf_piano_tariffa_id_pk UNIQUE (id);


--
-- Name: trf_regole_fatt_dett trf_regole_fatt_dett_id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_regole_fatt_dett
    ADD CONSTRAINT trf_regole_fatt_dett_id_pk UNIQUE (id);


--
-- Name: trf_regole_fatt trf_regole_fatt_id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_regole_fatt
    ADD CONSTRAINT trf_regole_fatt_id_pk UNIQUE (id);


--
-- Name: trf_scontrino_pdf trf_scontrino_pdf_un; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_scontrino_pdf
    ADD CONSTRAINT trf_scontrino_pdf_un UNIQUE (id_trf_fattura);


--
-- Name: old_trf_ui trf_ui_id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.old_trf_ui
    ADD CONSTRAINT trf_ui_id_pk UNIQUE (id_tariffa);


--
-- Name: old_trf_ui_righe_fatt trf_ui_righe_fatt_id_pk; Type: CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.old_trf_ui_righe_fatt
    ADD CONSTRAINT trf_ui_righe_fatt_id_pk UNIQUE (id_tariffa);


--
-- Name: diz_nomi_ix; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX diz_nomi_ix ON "Analisi_dev".dizionario_nomi_random USING btree (id_originale);


--
-- Name: idx_bdu_animali_id_animale; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX idx_bdu_animali_id_animale ON "Analisi_dev".h_dbi_bdu_animali USING btree (id_animale);


--
-- Name: idx_bdu_registrazioni_data_evento_id_animale; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX idx_bdu_registrazioni_data_evento_id_animale ON "Analisi_dev".h_dbi_bdu_registrazioni_data_evento USING btree (id_animale);


--
-- Name: macroarea_codice_idx; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX macroarea_codice_idx ON "Analisi_dev".macroarea USING btree (codice);


--
-- Name: macroarea_id_idx; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX macroarea_id_idx ON "Analisi_dev".macroarea USING btree (id);


--
-- Name: macroarea_parent_idx; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX macroarea_parent_idx ON "Analisi_dev".macroarea USING btree (parent);


--
-- Name: matrix_codice_norma; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX matrix_codice_norma ON "Analisi_dev".macroarea USING btree (codice);


--
-- Name: matrix_id_norma; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX matrix_id_norma ON "Analisi_dev".macroarea USING btree (id_gisa);


--
-- Name: matrix_id_parent; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX matrix_id_parent ON "Analisi_dev".macroarea USING btree (parent);


--
-- Name: matrix_norma; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX matrix_norma ON "Analisi_dev".macroarea USING btree (id);


--
-- Name: mvw_macroarea; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX mvw_macroarea ON "Analisi_dev".mvw_macroarea_ref USING btree (id);


--
-- Name: mvw_macroarea_codice; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX mvw_macroarea_codice ON "Analisi_dev".mvw_macroarea_ref USING btree (codice);


--
-- Name: mvw_macroarea_gisa; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX mvw_macroarea_gisa ON "Analisi_dev".mvw_macroarea_ref USING btree (id_gisa);


--
-- Name: mvw_macroarea_ref_idx; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX mvw_macroarea_ref_idx ON "Analisi_dev".mvw_macroarea_ref USING btree (id_ref);


--
-- Name: ocse_nomi_ix; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX ocse_nomi_ix ON "Analisi_dev".ocse_235 USING btree (componentenucleoid_uno);


--
-- Name: piani_no_rend_idx; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX piani_no_rend_idx ON "Analisi_dev".piani_no_rend USING btree (id_piano);


--
-- Name: rng_bdu_anim_idx; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX rng_bdu_anim_idx ON "Analisi_dev".h_dbi_bdu_animali USING btree (rng);


--
-- Name: rng_isp_idx; Type: INDEX; Schema: Analisi_dev; Owner: postgres
--

CREATE INDEX rng_isp_idx ON "Analisi_dev".h_get_controlli_ispezioni_semplici USING btree (rng);


--
-- Name: attivita_id_elab_cal_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX attivita_id_elab_cal_idx ON agenda.attivita USING btree (id_elab_cal);


--
-- Name: comuni_id_asl_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX comuni_id_asl_idx ON agenda.comuni USING btree (id_asl);


--
-- Name: config_exp_imp_id_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX config_exp_imp_id_idx ON agenda.config_exp_imp USING btree (id);


--
-- Name: elab_cal_param_ns_id_elab_cal_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX elab_cal_param_ns_id_elab_cal_idx ON agenda.elab_cal_param_ns USING btree (id_elab_cal);


--
-- Name: elab_cals_id_calendario_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX elab_cals_id_calendario_idx ON agenda.elab_cals USING btree (id_calendario);


--
-- Name: eventi_id_attivita_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX eventi_id_attivita_idx ON agenda.eventi USING btree (id_attivita);


--
-- Name: eventi_id_linea_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX eventi_id_linea_idx ON agenda.eventi USING btree (id_linea);


--
-- Name: eventi_id_nominativo_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX eventi_id_nominativo_idx ON agenda.eventi USING btree (id_nominativo);


--
-- Name: linea_piani_id_linea_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX linea_piani_id_linea_idx ON agenda.linea_piani USING btree (id_linea);


--
-- Name: linea_piani_id_piano_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX linea_piani_id_piano_idx ON agenda.linea_piani USING btree (id_piano);


--
-- Name: linee_id_tipo_linea_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX linee_id_tipo_linea_idx ON agenda.linee USING btree (id_tipo_linea);


--
-- Name: linee_selezionate_id_elab_cal_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX linee_selezionate_id_elab_cal_idx ON agenda.linee_selezionate USING btree (id_elab_cal);


--
-- Name: linee_selezionate_id_piano_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX linee_selezionate_id_piano_idx ON agenda.linee_selezionate USING btree (id_piano, id_linea);


--
-- Name: nominativo_linee_id_linea_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE UNIQUE INDEX nominativo_linee_id_linea_idx ON agenda.nominativo_linee USING btree (id_linea);


--
-- Name: piano_tipo_linea_id_piano_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX piano_tipo_linea_id_piano_idx ON agenda.piano_tipo_linea USING btree (id_piano);


--
-- Name: piano_tipo_linea_id_tipo_linea_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX piano_tipo_linea_id_tipo_linea_idx ON agenda.piano_tipo_linea USING btree (id_tipo_linea);


--
-- Name: struttura_comuni_id_comune_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX struttura_comuni_id_comune_idx ON agenda.struttura_comuni USING btree (id_comune);


--
-- Name: struttura_comuni_id_struttura_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX struttura_comuni_id_struttura_idx ON agenda.struttura_comuni USING btree (id_struttura);


--
-- Name: tipo_lista_piano_id_piano_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE INDEX tipo_lista_piano_id_piano_idx ON agenda.tipo_lista_piano USING btree (id_piano);


--
-- Name: tipologia_controllo_piani_id_tipologia_controllo_idx; Type: INDEX; Schema: agenda; Owner: postgres
--

CREATE UNIQUE INDEX tipologia_controllo_piani_id_tipologia_controllo_idx ON agenda.tipologia_controllo_piani USING btree (id_tipologia_controllo, id_piano);


--
-- Name: anpr_archivio_comuni_codcatastale_idx; Type: INDEX; Schema: conf_ext; Owner: postgres
--

CREATE INDEX anpr_archivio_comuni_codcatastale_idx ON conf_ext.anpr_archivio_comuni USING btree (codcatastale);


--
-- Name: anpr_archivio_comuni_codice_istat_idx; Type: INDEX; Schema: conf_ext; Owner: postgres
--

CREATE INDEX anpr_archivio_comuni_codice_istat_idx ON conf_ext.anpr_archivio_comuni USING btree (codice_istat);


--
-- Name: bonifica_soggetti_fisici_idx; Type: INDEX; Schema: conf_ext; Owner: postgres
--

CREATE UNIQUE INDEX bonifica_soggetti_fisici_idx ON conf_ext.bonifica_soggetti_fisici USING btree (codice_fiscale, fonte);


--
-- Name: utenti_fvg_bonifica_soggetti_fisici_idx; Type: INDEX; Schema: conf_ext; Owner: postgres
--

CREATE UNIQUE INDEX utenti_fvg_bonifica_soggetti_fisici_idx ON conf_ext.utenti_fvg_bonifica_soggetti_fisici USING btree (codice_fiscale);


--
-- Name: vwm_comuni_vigenti_catastali_codcatastale_idx; Type: INDEX; Schema: conf_ext; Owner: postgres
--

CREATE INDEX vwm_comuni_vigenti_catastali_codcatastale_idx ON conf_ext.vwm_comuni_vigenti_catastali USING btree (codcatastale);


--
-- Name: vwm_comuni_vigenti_catastali_codice_istat_idx; Type: INDEX; Schema: conf_ext; Owner: postgres
--

CREATE INDEX vwm_comuni_vigenti_catastali_codice_istat_idx ON conf_ext.vwm_comuni_vigenti_catastali USING btree (codice_istat);


--
-- Name: vwm_comuni_vigenti_codcatastale_idx; Type: INDEX; Schema: conf_ext; Owner: postgres
--

CREATE INDEX vwm_comuni_vigenti_codcatastale_idx ON conf_ext.vwm_comuni_vigenti USING btree (codcatastale);


--
-- Name: vwm_comuni_vigenti_codice_istat_idx; Type: INDEX; Schema: conf_ext; Owner: postgres
--

CREATE INDEX vwm_comuni_vigenti_codice_istat_idx ON conf_ext.vwm_comuni_vigenti USING btree (codice_istat);


--
-- Name: categorizzazione_rischio_tipo_stabilimento_id_categorizzazione_; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE UNIQUE INDEX categorizzazione_rischio_tipo_stabilimento_id_categorizzazione_ ON cu.categorizzazione_rischio_tipo_stabilimento USING btree (id_categorizzazione_rischio, id_tipo_stabilimento);


--
-- Name: cu_automezzi_id_cu_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE INDEX cu_automezzi_id_cu_idx ON cu.cu_automezzi USING btree (id_cu);


--
-- Name: cu_automezzi_id_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE UNIQUE INDEX cu_automezzi_id_idx ON cu.cu_automezzi USING btree (id);


--
-- Name: cu_categ_evals_id_cu_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE INDEX cu_categ_evals_id_cu_idx ON cu.cu_categ_evals USING btree (id_cu);


--
-- Name: cu_categ_evals_id_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE UNIQUE INDEX cu_categ_evals_id_idx ON cu.cu_categ_evals USING btree (id);


--
-- Name: cu_categ_evals_storico_id_cu_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE INDEX cu_categ_evals_storico_id_cu_idx ON cu.cu_categ_evals_storico USING btree (id_cu);


--
-- Name: cu_categ_evals_storico_id_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE UNIQUE INDEX cu_categ_evals_storico_id_idx ON cu.cu_categ_evals_storico USING btree (id);


--
-- Name: cu_evidenze_sp_id_cu_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE INDEX cu_evidenze_sp_id_cu_idx ON cu.cu_evidenze_sp USING btree (id_cu);


--
-- Name: cu_id_az_sede_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE INDEX cu_id_az_sede_idx ON cu.cu USING btree (id_az_sede);


--
-- Name: cu_indirizzi_id_cu_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE INDEX cu_indirizzi_id_cu_idx ON cu.cu_indirizzi USING btree (id_cu);


--
-- Name: cu_indirizzi_id_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE UNIQUE INDEX cu_indirizzi_id_idx ON cu.cu_indirizzi USING btree (id);


--
-- Name: cu_linee_id_cu_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE INDEX cu_linee_id_cu_idx ON cu.cu_linee USING btree (id_cu);


--
-- Name: cu_provv_fu_id_cu_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE INDEX cu_provv_fu_id_cu_idx ON cu.cu_provv_fu USING btree (id_cu);


--
-- Name: cu_provv_fu_id_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE UNIQUE INDEX cu_provv_fu_id_idx ON cu.cu_provv_fu USING btree (id);


--
-- Name: cu_provv_sopralluogo_fu_id_cu_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE INDEX cu_provv_sopralluogo_fu_id_cu_idx ON cu.cu_provv_sopralluogo_fu USING btree (id_cu);


--
-- Name: cu_provv_sopralluogo_fu_id_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE UNIQUE INDEX cu_provv_sopralluogo_fu_id_idx ON cu.cu_provv_sopralluogo_fu USING btree (id);


--
-- Name: cu_provv_sopralluogo_id_cu_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE INDEX cu_provv_sopralluogo_id_cu_idx ON cu.cu_provv_sopralluogo USING btree (id_cu);


--
-- Name: cu_provv_sopralluogo_id_idx; Type: INDEX; Schema: cu; Owner: postgres
--

CREATE UNIQUE INDEX cu_provv_sopralluogo_id_idx ON cu.cu_provv_sopralluogo USING btree (id);


--
-- Name: linee_id_tipo_linea_idx; Type: INDEX; Schema: cu_anag; Owner: postgres
--

CREATE INDEX linee_id_tipo_linea_idx ON cu_anag.linee USING btree (id_tipo_linea);


--
-- Name: soggetti_fisici_codice_fiscale_idx; Type: INDEX; Schema: cu_anag; Owner: postgres
--

CREATE UNIQUE INDEX soggetti_fisici_codice_fiscale_idx ON cu_anag.soggetti_fisici USING btree (codice_fiscale);


--
-- Name: stabilimenti_id_impresa_idx; Type: INDEX; Schema: cu_anag; Owner: postgres
--

CREATE INDEX stabilimenti_id_impresa_idx ON cu_anag.stabilimenti USING btree (id_impresa);


--
-- Name: cu_altri_cf_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_altri_cf_idx ON cu_his.cu_altri USING btree (cf);


--
-- Name: cu_altri_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_altri_his_id_transazione_idx ON cu_his.cu_altri USING btree (his_id_transazione);


--
-- Name: cu_automezzi_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_automezzi_his_id_transazione_idx ON cu_his.cu_automezzi USING btree (his_id_transazione);


--
-- Name: cu_automezzi_id_cu_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_automezzi_id_cu_idx ON cu_his.cu_automezzi USING btree (id_cu);


--
-- Name: cu_dichiarazioni_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_dichiarazioni_his_id_transazione_idx ON cu_his.cu_dichiarazioni USING btree (his_id_transazione);


--
-- Name: cu_dichiarazioni_id_cu_nucleo_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_dichiarazioni_id_cu_nucleo_idx ON cu_his.cu_dichiarazioni USING btree (id_cu_nucleo);


--
-- Name: cu_evidenza_linee_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_evidenza_linee_his_id_transazione_idx ON cu_his.cu_evidenza_linee USING btree (his_id_transazione);


--
-- Name: cu_evidenza_linee_id_cu_linea_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_evidenza_linee_id_cu_linea_idx ON cu_his.cu_evidenza_linee USING btree (id_cu_linea);


--
-- Name: cu_evidenze_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_evidenze_his_id_transazione_idx ON cu_his.cu_evidenze USING btree (his_id_transazione);


--
-- Name: cu_evidenze_id_cu_oggetto_cl_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_evidenze_id_cu_oggetto_cl_idx ON cu_his.cu_evidenze USING btree (id_cu_oggetto_cl);


--
-- Name: cu_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_his_id_transazione_idx ON cu_his.cu USING btree (his_id_transazione);


--
-- Name: cu_id_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_id_idx ON cu_his.cu USING btree (id);


--
-- Name: cu_indirizzi_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_indirizzi_his_id_transazione_idx ON cu_his.cu_indirizzi USING btree (his_id_transazione);


--
-- Name: cu_indirizzi_id_cu_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_indirizzi_id_cu_idx ON cu_his.cu_indirizzi USING btree (id_cu);


--
-- Name: cu_linee_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_linee_his_id_transazione_idx ON cu_his.cu_linee USING btree (his_id_transazione);


--
-- Name: cu_linee_id_cu_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_linee_id_cu_idx ON cu_his.cu_linee USING btree (id_cu);


--
-- Name: cu_linee_id_linea_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_linee_id_linea_idx ON cu_his.cu_linee USING btree (id_linea);


--
-- Name: cu_norme_violate_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_norme_violate_his_id_transazione_idx ON cu_his.cu_norme_violate USING btree (his_id_transazione);


--
-- Name: cu_norme_violate_id_cu_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_norme_violate_id_cu_idx ON cu_his.cu_norme_violate USING btree (id_cu);


--
-- Name: cu_norme_violate_id_norma_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_norme_violate_id_norma_idx ON cu_his.cu_norme_violate USING btree (id_norma);


--
-- Name: cu_nucleo_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_nucleo_his_id_transazione_idx ON cu_his.cu_nucleo USING btree (his_id_transazione);


--
-- Name: cu_nucleo_id_cu_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_nucleo_id_cu_idx ON cu_his.cu_nucleo USING btree (id_cu);


--
-- Name: cu_nucleo_periodi_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_nucleo_periodi_his_id_transazione_idx ON cu_his.cu_nucleo_periodi USING btree (his_id_transazione);


--
-- Name: cu_nucleo_periodi_id_cu_nucleo_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_nucleo_periodi_id_cu_nucleo_idx ON cu_his.cu_nucleo_periodi USING btree (id_cu_nucleo);


--
-- Name: cu_oggetti_cl_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_oggetti_cl_his_id_transazione_idx ON cu_his.cu_oggetti_cl USING btree (his_id_transazione);


--
-- Name: cu_oggetti_cl_id_cu_oggetto_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_oggetti_cl_id_cu_oggetto_idx ON cu_his.cu_oggetti_cl USING btree (id_cu_oggetto);


--
-- Name: cu_oggetti_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_oggetti_his_id_transazione_idx ON cu_his.cu_oggetti USING btree (his_id_transazione);


--
-- Name: cu_oggetti_id_cu_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_oggetti_id_cu_idx ON cu_his.cu_oggetti USING btree (id_cu);


--
-- Name: cu_piani_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_piani_his_id_transazione_idx ON cu_his.cu_piani USING btree (his_id_transazione);


--
-- Name: cu_piani_id_cu_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_piani_id_cu_idx ON cu_his.cu_piani USING btree (id_cu);


--
-- Name: cu_provv_fu_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_provv_fu_his_id_transazione_idx ON cu_his.cu_provv_fu USING btree (his_id_transazione);


--
-- Name: cu_provv_fu_id_cu_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_provv_fu_id_cu_idx ON cu_his.cu_provv_fu USING btree (id_cu);


--
-- Name: cu_provv_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_provv_his_id_transazione_idx ON cu_his.cu_provv USING btree (his_id_transazione);


--
-- Name: cu_provv_id_norma_violata_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_provv_id_norma_violata_idx ON cu_his.cu_provv USING btree (id_norma_violata);


--
-- Name: cu_provv_sopralluogo_fu_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_provv_sopralluogo_fu_his_id_transazione_idx ON cu_his.cu_provv_sopralluogo_fu USING btree (his_id_transazione);


--
-- Name: cu_provv_sopralluogo_fu_id_cu_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_provv_sopralluogo_fu_id_cu_idx ON cu_his.cu_provv_sopralluogo_fu USING btree (id_cu);


--
-- Name: cu_provv_sopralluogo_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_provv_sopralluogo_his_id_transazione_idx ON cu_his.cu_provv_sopralluogo USING btree (his_id_transazione);


--
-- Name: cu_provv_sopralluogo_id_cu_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX cu_provv_sopralluogo_id_cu_idx ON cu_his.cu_provv_sopralluogo USING btree (id_cu);


--
-- Name: impresa_figure_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX impresa_figure_his_id_transazione_idx ON cu_his.impresa_figure USING btree (his_id_transazione);


--
-- Name: impresa_figure_id_impresa_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX impresa_figure_id_impresa_idx ON cu_his.impresa_figure USING btree (id_impresa);


--
-- Name: impresa_sedi_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX impresa_sedi_his_id_transazione_idx ON cu_his.impresa_sedi USING btree (his_id_transazione);


--
-- Name: impresa_sedi_id_impresa_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX impresa_sedi_id_impresa_idx ON cu_his.impresa_sedi USING btree (id_impresa);


--
-- Name: imprese_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX imprese_his_id_transazione_idx ON cu_his.imprese USING btree (his_id_transazione);


--
-- Name: imprese_id_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX imprese_id_idx ON cu_his.imprese USING btree (id);


--
-- Name: indirizzi_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX indirizzi_his_id_transazione_idx ON cu_his.indirizzi USING btree (his_id_transazione);


--
-- Name: indirizzi_id_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX indirizzi_id_idx ON cu_his.indirizzi USING btree (id);


--
-- Name: linee_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX linee_his_id_transazione_idx ON cu_his.linee USING btree (his_id_transazione);


--
-- Name: linee_id_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX linee_id_idx ON cu_his.linee USING btree (id);


--
-- Name: linee_id_stabilimento_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX linee_id_stabilimento_idx ON cu_his.linee USING btree (id_stabilimento);


--
-- Name: pratiche_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX pratiche_his_id_transazione_idx ON cu_his.pratiche USING btree (his_id_transazione);


--
-- Name: pratiche_id_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX pratiche_id_idx ON cu_his.pratiche USING btree (id);


--
-- Name: soggetti_fisici_codice_fiscale_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX soggetti_fisici_codice_fiscale_idx ON cu_his.soggetti_fisici USING btree (codice_fiscale);


--
-- Name: soggetti_fisici_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX soggetti_fisici_his_id_transazione_idx ON cu_his.soggetti_fisici USING btree (his_id_transazione);


--
-- Name: soggetti_fisici_id_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX soggetti_fisici_id_idx ON cu_his.soggetti_fisici USING btree (id);


--
-- Name: stabilimenti_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX stabilimenti_his_id_transazione_idx ON cu_his.stabilimenti USING btree (his_id_transazione);


--
-- Name: stabilimenti_id_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX stabilimenti_id_idx ON cu_his.stabilimenti USING btree (id);


--
-- Name: stabilimenti_id_impresa_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX stabilimenti_id_impresa_idx ON cu_his.stabilimenti USING btree (id_impresa);


--
-- Name: stabilimento_figure_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX stabilimento_figure_his_id_transazione_idx ON cu_his.stabilimento_figure USING btree (his_id_transazione);


--
-- Name: stabilimento_figure_id_stabilimento_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX stabilimento_figure_id_stabilimento_idx ON cu_his.stabilimento_figure USING btree (id_stabilimento);


--
-- Name: stabilimento_sedi_his_id_transazione_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX stabilimento_sedi_his_id_transazione_idx ON cu_his.stabilimento_sedi USING btree (his_id_transazione);


--
-- Name: stabilimento_sedi_id_stabilimento_idx; Type: INDEX; Schema: cu_his; Owner: postgres
--

CREATE INDEX stabilimento_sedi_id_stabilimento_idx ON cu_his.stabilimento_sedi USING btree (id_stabilimento);


--
-- Name: matrix_formule_idx; Type: INDEX; Schema: matrix; Owner: postgres
--

CREATE INDEX matrix_formule_idx ON matrix.formule USING btree (id);


--
-- Name: matrix_id_asl; Type: INDEX; Schema: matrix; Owner: postgres
--

CREATE INDEX matrix_id_asl ON matrix.struttura_asl USING btree (id);


--
-- Name: matrix_id_asl_gisa; Type: INDEX; Schema: matrix; Owner: postgres
--

CREATE INDEX matrix_id_asl_gisa ON matrix.struttura_asl USING btree (id_gisa);


--
-- Name: matrix_id_piano; Type: INDEX; Schema: matrix; Owner: postgres
--

CREATE INDEX matrix_id_piano ON matrix.struttura_piani USING btree (id);


--
-- Name: matrix_id_piano_gisa; Type: INDEX; Schema: matrix; Owner: postgres
--

CREATE INDEX matrix_id_piano_gisa ON matrix.struttura_piani USING btree (id_gisa);


--
-- Name: mvw_struttura_asl_ref_new_id_gisa_idx; Type: INDEX; Schema: matrix; Owner: postgres
--

CREATE INDEX mvw_struttura_asl_ref_new_id_gisa_idx ON matrix.mvw_struttura_asl_ref_new USING btree (id_gisa, id_ref);


--
-- Name: stabilimenti_linee_id_idx; Type: INDEX; Schema: matrix; Owner: postgres
--

CREATE INDEX stabilimenti_linee_id_idx ON matrix.stabilimenti_linee USING btree (id);


--
-- Name: struttura_asl_asl_livello_idx; Type: INDEX; Schema: matrix; Owner: postgres
--

CREATE INDEX struttura_asl_asl_livello_idx ON matrix.struttura_asl USING btree (id_asl, n_livello);


--
-- Name: tree_nodes_id; Type: INDEX; Schema: matrix; Owner: postgres
--

CREATE INDEX tree_nodes_id ON matrix.tree_nodes USING btree (id);


--
-- Name: tree_nodes_id_parent; Type: INDEX; Schema: matrix; Owner: postgres
--

CREATE INDEX tree_nodes_id_parent ON matrix.tree_nodes USING btree (id_parent);


--
-- Name: campioni_id_cu_motivo; Type: INDEX; Schema: ra; Owner: postgres
--

CREATE INDEX campioni_id_cu_motivo ON ra.mvw_get_campioni_validi USING btree (id_controllo, id_motivo);


--
-- Name: iuv_idx; Type: INDEX; Schema: ra; Owner: postgres
--

CREATE INDEX iuv_idx ON ra.mvw_iuv USING btree (id_asl, data, cod_raggruppamento);


--
-- Name: ra_data; Type: INDEX; Schema: ra; Owner: postgres
--

CREATE INDEX ra_data ON ra.vw_gisa_controlli_ufficiali USING btree (data_inizio_controllo);


--
-- Name: ra_linea; Type: INDEX; Schema: ra; Owner: postgres
--

CREATE INDEX ra_linea ON ra.vw_gisa_controlli_ufficiali USING btree (codice_linea);


--
-- Name: ra_motivo; Type: INDEX; Schema: ra; Owner: postgres
--

CREATE INDEX ra_motivo ON ra.vw_gisa_controlli_ufficiali USING btree (id_motivo);


--
-- Name: ra_norma; Type: INDEX; Schema: ra; Owner: postgres
--

CREATE INDEX ra_norma ON ra.vw_gisa_controlli_ufficiali USING btree (id_norma);


--
-- Name: ra_unita; Type: INDEX; Schema: ra; Owner: postgres
--

CREATE INDEX ra_unita ON ra.vw_gisa_controlli_ufficiali USING btree (id_unita_operativa);


--
-- Name: vw_gisa_controlli_ufficiali_data_idx; Type: INDEX; Schema: ra; Owner: postgres
--

CREATE INDEX vw_gisa_controlli_ufficiali_data_idx ON ra.vw_gisa_controlli_ufficiali USING btree (data_inizio_controllo);


--
-- Name: vw_gisa_controlli_ufficiali_motivo_idx; Type: INDEX; Schema: ra; Owner: postgres
--

CREATE INDEX vw_gisa_controlli_ufficiali_motivo_idx ON ra.vw_gisa_controlli_ufficiali USING btree (id_motivo);


--
-- Name: clienti_type_ref_idx; Type: INDEX; Schema: trf; Owner: postgres
--

CREATE INDEX clienti_type_ref_idx ON trf.clienti USING btree (type, id_ref);


--
-- Name: servizi_type_idx; Type: INDEX; Schema: trf; Owner: postgres
--

CREATE INDEX servizi_type_idx ON trf.servizi USING btree (type);


--
-- Name: tariffa_voci_id_idx; Type: INDEX; Schema: trf; Owner: postgres
--

CREATE UNIQUE INDEX tariffa_voci_id_idx ON trf.tariffa_voci USING btree (id);


--
-- Name: trf_attivita_dettagli_id_trf_attivita_idx; Type: INDEX; Schema: trf; Owner: postgres
--

CREATE INDEX trf_attivita_dettagli_id_trf_attivita_idx ON trf.trf_attivita_dettagli USING btree (id_trf_attivita);


--
-- Name: trf_attivita_id_cliente_idx; Type: INDEX; Schema: trf; Owner: postgres
--

CREATE INDEX trf_attivita_id_cliente_idx ON trf.trf_attivita USING btree (id_cliente);


--
-- Name: trf_attivita_id_trf_operatore_idx; Type: INDEX; Schema: trf; Owner: postgres
--

CREATE INDEX trf_attivita_id_trf_operatore_idx ON trf.trf_attivita USING btree (id_trf_operatore);


--
-- Name: ag_tree_nodes ag_tree_nodes_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.ag_tree_nodes
    ADD CONSTRAINT ag_tree_nodes_fk FOREIGN KEY (id_tree) REFERENCES agenda.ag_trees(id);


--
-- Name: asl_piani asl_piani_piani_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.asl_piani
    ADD CONSTRAINT asl_piani_piani_fk FOREIGN KEY (id_piano) REFERENCES matrix.struttura_piani(id) ON DELETE CASCADE;


--
-- Name: asl_piani asl_piani_struttura_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.asl_piani
    ADD CONSTRAINT asl_piani_struttura_fk FOREIGN KEY (id_struttura) REFERENCES matrix.struttura_asl(id) ON DELETE CASCADE;


--
-- Name: attivita attivita_attivita_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.attivita
    ADD CONSTRAINT attivita_attivita_fk FOREIGN KEY (id_struttura) REFERENCES matrix.struttura_asl(id);


--
-- Name: attivita attivita_elab_cal_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.attivita
    ADD CONSTRAINT attivita_elab_cal_fk FOREIGN KEY (id_elab_cal) REFERENCES agenda.elab_cals(id);


--
-- Name: avvisi avvisi_ag_livelli_avviso_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.avvisi
    ADD CONSTRAINT avvisi_ag_livelli_avviso_fk FOREIGN KEY (id_livello_avviso) REFERENCES ag_types.ag_livelli_avviso(id);


--
-- Name: avvisi avvisi_ag_tipo_avvisi_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.avvisi
    ADD CONSTRAINT avvisi_ag_tipo_avvisi_fk FOREIGN KEY (id_tipo_avviso) REFERENCES ag_types.ag_tipo_avvisi(id);


--
-- Name: avviso_risorse avviso_risorse_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.avviso_risorse
    ADD CONSTRAINT avviso_risorse_fk FOREIGN KEY (id_avviso) REFERENCES agenda.avvisi(id);


--
-- Name: avviso_risorse avviso_risorse_fk_1; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.avviso_risorse
    ADD CONSTRAINT avviso_risorse_fk_1 FOREIGN KEY (id_risorsa) REFERENCES rbac.utente_strutture(id);


--
-- Name: az_sedi az_sedi_azienda_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.az_sedi
    ADD CONSTRAINT az_sedi_azienda_fk FOREIGN KEY (id_azienda) REFERENCES agenda.aziende(id);


--
-- Name: az_sedi az_sedi_comuni_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.az_sedi
    ADD CONSTRAINT az_sedi_comuni_fk FOREIGN KEY (id_comune) REFERENCES agenda.comuni(id);


--
-- Name: az_sedi_selezionate az_sedi_selezionate_elab_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.az_sedi_selezionate
    ADD CONSTRAINT az_sedi_selezionate_elab_fk FOREIGN KEY (id_elab_cal) REFERENCES agenda.elab_cals(id);


--
-- Name: az_sedi_selezionate az_sedi_selezionate_piano_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.az_sedi_selezionate
    ADD CONSTRAINT az_sedi_selezionate_piano_fk FOREIGN KEY (id_piano) REFERENCES matrix.struttura_piani(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: cf_allevamenti cf_allevamenti_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.cf_allevamenti
    ADD CONSTRAINT cf_allevamenti_fk FOREIGN KEY (id_lista) REFERENCES agenda.lista_import(id);


--
-- Name: elab_cal_logs elab_cal_logs_elab_cals_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_logs
    ADD CONSTRAINT elab_cal_logs_elab_cals_fk FOREIGN KEY (id_elab_cal) REFERENCES agenda.elab_cals(id);


--
-- Name: elab_cal_logs elab_cal_logs_logs_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_logs
    ADD CONSTRAINT elab_cal_logs_logs_fk FOREIGN KEY (id_elab_cal) REFERENCES agenda.elab_cals(id);


--
-- Name: elab_cal_param_asl elab_cal_param_asl_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_asl
    ADD CONSTRAINT elab_cal_param_asl_fk FOREIGN KEY (id_asl) REFERENCES matrix.struttura_asl(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: elab_cal_param_asl elab_cal_param_asl_fk_1; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_asl
    ADD CONSTRAINT elab_cal_param_asl_fk_1 FOREIGN KEY (id_elab_cal) REFERENCES agenda.elab_cals(id) ON DELETE CASCADE;


--
-- Name: elab_cal_param_ns elab_cal_param_ns_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_ns
    ADD CONSTRAINT elab_cal_param_ns_fk FOREIGN KEY (id_ns) REFERENCES rbac.utente_strutture(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: elab_cal_param_ns elab_cal_param_ns_fk_1; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_ns
    ADD CONSTRAINT elab_cal_param_ns_fk_1 FOREIGN KEY (id_elab_cal) REFERENCES agenda.elab_cals(id);


--
-- Name: elab_cal_param_piani elab_cal_param_piani_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_piani
    ADD CONSTRAINT elab_cal_param_piani_fk FOREIGN KEY (id_elab_cal) REFERENCES agenda.elab_cals(id);


--
-- Name: elab_cal_param_piani elab_cal_param_piani_fk_1; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_param_piani
    ADD CONSTRAINT elab_cal_param_piani_fk_1 FOREIGN KEY (id_piano) REFERENCES matrix.struttura_piani(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: elab_cal_params elab_cal_params_params_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.elab_cal_params
    ADD CONSTRAINT elab_cal_params_params_fk FOREIGN KEY (id_elab_cal) REFERENCES agenda.elab_cals(id);


--
-- Name: file_xls_cf file_xls_cf_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.file_xls_cf
    ADD CONSTRAINT file_xls_cf_fk FOREIGN KEY (idlista) REFERENCES agenda.lista_import(id);


--
-- Name: file_xls_linea file_xls_linea_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.file_xls_linea
    ADD CONSTRAINT file_xls_linea_fk FOREIGN KEY (idlista) REFERENCES agenda.lista_import(id);


--
-- Name: file_xls_sicer file_xls_sicer_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.file_xls_sicer
    ADD CONSTRAINT file_xls_sicer_fk FOREIGN KEY (idlista) REFERENCES agenda.lista_import(id);


--
-- Name: file_xls_profilassi file_xls_sicer_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.file_xls_profilassi
    ADD CONSTRAINT file_xls_sicer_fk FOREIGN KEY (idlista) REFERENCES agenda.lista_import(id);


--
-- Name: import_linea import_linea_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.import_linea
    ADD CONSTRAINT import_linea_fk FOREIGN KEY (id_lista) REFERENCES agenda.lista_import(id);


--
-- Name: linea_piani linea_piani_linea_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.linea_piani
    ADD CONSTRAINT linea_piani_linea_fk FOREIGN KEY (id_linea) REFERENCES agenda.linee(id);


--
-- Name: linea_piani linea_piani_piano_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.linea_piani
    ADD CONSTRAINT linea_piani_piano_fk FOREIGN KEY (id_piano) REFERENCES matrix.struttura_piani(id);


--
-- Name: linee_selezionate linee_selezionate_elab_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.linee_selezionate
    ADD CONSTRAINT linee_selezionate_elab_fk FOREIGN KEY (id_elab_cal) REFERENCES agenda.elab_cals(id);


--
-- Name: linee_selezionate linee_selezionate_piano_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.linee_selezionate
    ADD CONSTRAINT linee_selezionate_piano_fk FOREIGN KEY (id_piano) REFERENCES matrix.struttura_piani(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: lista_import lista_import_fk_1; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.lista_import
    ADD CONSTRAINT lista_import_fk_1 FOREIGN KEY (id_tipo_lista) REFERENCES agenda.tipo_liste(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: nominativo_az_sedi nominativo_az_sedi_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_az_sedi
    ADD CONSTRAINT nominativo_az_sedi_fk FOREIGN KEY (id_nominativo_struttura) REFERENCES rbac.utente_strutture(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: nominativo_comuni nominativo_comuni_comuni_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_comuni
    ADD CONSTRAINT nominativo_comuni_comuni_fk FOREIGN KEY (id_struttura_comune) REFERENCES agenda.struttura_comuni(id) ON DELETE CASCADE;


--
-- Name: nominativo_comuni nominativo_comuni_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_comuni
    ADD CONSTRAINT nominativo_comuni_fk FOREIGN KEY (id_nominativo_struttura) REFERENCES rbac.utente_strutture(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: nominativo_linee nominativo_linee_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_linee
    ADD CONSTRAINT nominativo_linee_fk FOREIGN KEY (id_nominativo_struttura) REFERENCES rbac.utente_strutture(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: nominativo_piani nominativo_piani_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_piani
    ADD CONSTRAINT nominativo_piani_fk FOREIGN KEY (id_nominativo_struttura) REFERENCES rbac.utente_strutture(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: nominativo_piani nominativo_piani_piano_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.nominativo_piani
    ADD CONSTRAINT nominativo_piani_piano_fk FOREIGN KEY (id_piano) REFERENCES matrix.struttura_piani(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: piano_freq piano_freq_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.piano_freq
    ADD CONSTRAINT piano_freq_fk FOREIGN KEY (id_piano) REFERENCES matrix.struttura_piani(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: piano_periodo piano_periodo_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.piano_periodo
    ADD CONSTRAINT piano_periodo_fk FOREIGN KEY (id_piano) REFERENCES matrix.struttura_piani(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: struttura_comuni struttura_comuni_comuni_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.struttura_comuni
    ADD CONSTRAINT struttura_comuni_comuni_fk FOREIGN KEY (id_comune) REFERENCES agenda.comuni(id) ON DELETE CASCADE;


--
-- Name: struttura_comuni struttura_comuni_struttura_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.struttura_comuni
    ADD CONSTRAINT struttura_comuni_struttura_fk FOREIGN KEY (id_struttura) REFERENCES matrix.struttura_asl(id) ON DELETE CASCADE;


--
-- Name: tipo_lista_piano tipo_lista_piano_struttura_piani_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.tipo_lista_piano
    ADD CONSTRAINT tipo_lista_piano_struttura_piani_fk FOREIGN KEY (id_piano) REFERENCES matrix.struttura_piani(id);


--
-- Name: tipo_lista_piano tipo_lista_piano_tipo_liste_fk; Type: FK CONSTRAINT; Schema: agenda; Owner: postgres
--

ALTER TABLE ONLY agenda.tipo_lista_piano
    ADD CONSTRAINT tipo_lista_piano_tipo_liste_fk FOREIGN KEY (id_tipo_lista) REFERENCES agenda.tipo_liste(id);


--
-- Name: cu_automezzi cu_automezzi_automezzi_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_automezzi
    ADD CONSTRAINT cu_automezzi_automezzi_fk FOREIGN KEY (id_automezzo) REFERENCES cu_anag.automezzi(id);


--
-- Name: cu_automezzi cu_automezzi_cu_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_automezzi
    ADD CONSTRAINT cu_automezzi_cu_fk FOREIGN KEY (id_cu) REFERENCES cu.cu(id);


--
-- Name: cu_categ_evals cu_categ_evals_cu_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_categ_evals
    ADD CONSTRAINT cu_categ_evals_cu_fk FOREIGN KEY (id_cu) REFERENCES cu.cu(id);


--
-- Name: cu_categ_evals_storico cu_categ_evals_cu_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_categ_evals_storico
    ADD CONSTRAINT cu_categ_evals_cu_fk FOREIGN KEY (id_cu) REFERENCES cu.cu(id);


--
-- Name: cu_categ_evals_storico cu_categ_evals_stab_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_categ_evals_storico
    ADD CONSTRAINT cu_categ_evals_stab_fk FOREIGN KEY (id_stabilimento) REFERENCES cu_anag.stabilimenti(id);


--
-- Name: cu_dichiarazioni cu_dichiarazioni_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_dichiarazioni
    ADD CONSTRAINT cu_dichiarazioni_fk FOREIGN KEY (id_cu_nucleo) REFERENCES cu.cu_nucleo(id);


--
-- Name: cu_evidenza_linee cu_evidenza_linee_evidenze_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_evidenza_linee
    ADD CONSTRAINT cu_evidenza_linee_evidenze_fk FOREIGN KEY (id_evidenza) REFERENCES cu.cu_evidenze(id) ON DELETE CASCADE;


--
-- Name: cu_evidenza_linee cu_evidenza_linee_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_evidenza_linee
    ADD CONSTRAINT cu_evidenza_linee_fk FOREIGN KEY (id_cu_linea) REFERENCES cu.cu_linee(id);


--
-- Name: cu_evidenze cu_evidenze_cu_oggetti_cl_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_evidenze
    ADD CONSTRAINT cu_evidenze_cu_oggetti_cl_fk FOREIGN KEY (id_cu_oggetto_cl) REFERENCES cu.cu_oggetti_cl(id);


--
-- Name: cu_evidenze_sp cu_evidenze_sosp_cu_evidenze_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_evidenze_sp
    ADD CONSTRAINT cu_evidenze_sosp_cu_evidenze_fk FOREIGN KEY (id_cu_evidenza) REFERENCES cu.cu_evidenze(id);


--
-- Name: cu_evidenze_sp cu_evidenze_sosp_cu_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_evidenze_sp
    ADD CONSTRAINT cu_evidenze_sosp_cu_fk FOREIGN KEY (id_cu) REFERENCES cu.cu(id);


--
-- Name: cu_linee cu_linee_cu_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_linee
    ADD CONSTRAINT cu_linee_cu_fk FOREIGN KEY (id_cu) REFERENCES cu.cu(id);


--
-- Name: cu_linee cu_linee_linee_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_linee
    ADD CONSTRAINT cu_linee_linee_fk FOREIGN KEY (id_linea) REFERENCES cu_anag.linee(id);


--
-- Name: cu_nominativo_provv cu_nominativo_provv_cu_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_nominativo_provv
    ADD CONSTRAINT cu_nominativo_provv_cu_fk FOREIGN KEY (id_cu) REFERENCES cu.cu(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: cu_norme_violate cu_norme_violate_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_norme_violate
    ADD CONSTRAINT cu_norme_violate_fk FOREIGN KEY (id_cu) REFERENCES cu.cu(id);


--
-- Name: cu_norme_violate cu_norme_violate_norme_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_norme_violate
    ADD CONSTRAINT cu_norme_violate_norme_fk FOREIGN KEY (id_norma) REFERENCES cu_conf.cu_norme(id);


--
-- Name: cu_nucleo cu_nucleo_cu_tipo_nucleo_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_nucleo
    ADD CONSTRAINT cu_nucleo_cu_tipo_nucleo_fk FOREIGN KEY (id_tipo_nucleo) REFERENCES cu_types.cu_tipo_nucleo(id);


--
-- Name: cu_nucleo cu_nucleo_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_nucleo
    ADD CONSTRAINT cu_nucleo_fk FOREIGN KEY (id_cu) REFERENCES cu.cu(id);


--
-- Name: cu_nucleo_periodi cu_nucleo_periodi_cu_nucleo_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_nucleo_periodi
    ADD CONSTRAINT cu_nucleo_periodi_cu_nucleo_fk FOREIGN KEY (id_cu_nucleo) REFERENCES cu.cu_nucleo(id);


--
-- Name: cu_oggetti_cl cu_oggetti_cl_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_oggetti_cl
    ADD CONSTRAINT cu_oggetti_cl_fk FOREIGN KEY (id_cu_oggetto) REFERENCES cu.cu_oggetti(id);


--
-- Name: cu_oggetti cu_oggetti_cu_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_oggetti
    ADD CONSTRAINT cu_oggetti_cu_fk FOREIGN KEY (id_cu) REFERENCES cu.cu(id);


--
-- Name: cu_oggetti cu_oggetti_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_oggetti
    ADD CONSTRAINT cu_oggetti_fk FOREIGN KEY (id_tipo_oggetto) REFERENCES cu_conf.cu_tipo_oggetti(id);


--
-- Name: cu_oggetti cu_oggetti_stato_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_oggetti
    ADD CONSTRAINT cu_oggetti_stato_fk FOREIGN KEY (id_stato_oggetto) REFERENCES cu_types.cu_stati_oggetto(id);


--
-- Name: cu_piani cu_piani_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_piani
    ADD CONSTRAINT cu_piani_fk FOREIGN KEY (id_cu) REFERENCES cu.cu(id);


--
-- Name: cu_piani cu_piani_struttura_piani_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_piani
    ADD CONSTRAINT cu_piani_struttura_piani_fk FOREIGN KEY (id_piano) REFERENCES matrix.struttura_piani(id);


--
-- Name: cu_provv cu_provv_cu_norme_violate_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv
    ADD CONSTRAINT cu_provv_cu_norme_violate_fk FOREIGN KEY (id_norma_violata) REFERENCES cu.cu_norme_violate(id);


--
-- Name: cu_provv cu_provv_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv
    ADD CONSTRAINT cu_provv_fk FOREIGN KEY (id_tipo_provv) REFERENCES cu_types.cu_tipi_provv(id);


--
-- Name: cu_provv_fu cu_provv_fu_cu_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv_fu
    ADD CONSTRAINT cu_provv_fu_cu_fk FOREIGN KEY (id_cu) REFERENCES cu.cu(id);


--
-- Name: cu_provv_fu cu_provv_fu_cu_provv_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv_fu
    ADD CONSTRAINT cu_provv_fu_cu_provv_fk FOREIGN KEY (id_provv) REFERENCES cu.cu_provv(id);


--
-- Name: cu_provv_sopralluogo_fu cu_provv_fu_cu_provv_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv_sopralluogo_fu
    ADD CONSTRAINT cu_provv_fu_cu_provv_fk FOREIGN KEY (id_provv) REFERENCES cu.cu_provv_sopralluogo(id);


--
-- Name: cu_provv_sopralluogo cu_provv_sopralluogo_cu_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv_sopralluogo
    ADD CONSTRAINT cu_provv_sopralluogo_cu_fk FOREIGN KEY (id_cu) REFERENCES cu.cu(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: cu_provv_sopralluogo cu_provv_sopralluogo_linee_linee_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu_provv_sopralluogo
    ADD CONSTRAINT cu_provv_sopralluogo_linee_linee_fk FOREIGN KEY (id_cu_linea) REFERENCES cu.cu_linee(id);


--
-- Name: cu cu_stabilimenti_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.cu
    ADD CONSTRAINT cu_stabilimenti_fk FOREIGN KEY (id_az_sede) REFERENCES cu_anag.stabilimenti(id);


--
-- Name: nomi_file_pdf_controlli nomi_file_pdf_controlli_cu_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.nomi_file_pdf_controlli
    ADD CONSTRAINT nomi_file_pdf_controlli_cu_fk FOREIGN KEY (id_cu) REFERENCES cu.cu(id);


--
-- Name: nomi_file_pdf_evidenze nomi_file_pdf_evidenze_cu_evidenze_fk; Type: FK CONSTRAINT; Schema: cu; Owner: postgres
--

ALTER TABLE ONLY cu.nomi_file_pdf_evidenze
    ADD CONSTRAINT nomi_file_pdf_evidenze_cu_evidenze_fk FOREIGN KEY (id_evidenza) REFERENCES cu.cu_evidenze(id);


--
-- Name: file_xls_mangimifici file_xls_mangimifici_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.file_xls_mangimifici
    ADD CONSTRAINT file_xls_mangimifici_fk FOREIGN KEY (idimport) REFERENCES cu_anag.import_anagrafica(id);


--
-- Name: file_xls_sintesis file_xls_sintesis_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.file_xls_sintesis
    ADD CONSTRAINT file_xls_sintesis_fk FOREIGN KEY (idimport) REFERENCES cu_anag.import_anagrafica(id);


--
-- Name: impresa_figure impresa_figure_imprese_2_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.impresa_figure
    ADD CONSTRAINT impresa_figure_imprese_2_fk FOREIGN KEY (id_impresa) REFERENCES cu_anag.imprese(id);


--
-- Name: impresa_figure impresa_figure_imprese_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.impresa_figure
    ADD CONSTRAINT impresa_figure_imprese_fk FOREIGN KEY (id_soggetto) REFERENCES cu_anag.imprese(id);


--
-- Name: impresa_sedi impresa_sedi_imprese_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.impresa_sedi
    ADD CONSTRAINT impresa_sedi_imprese_fk FOREIGN KEY (id_impresa) REFERENCES cu_anag.imprese(id);


--
-- Name: impresa_sedi impresa_sedi_indirizzi_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.impresa_sedi
    ADD CONSTRAINT impresa_sedi_indirizzi_fk FOREIGN KEY (id_indirizzo) REFERENCES cu_anag.indirizzi(id);


--
-- Name: linee linee_stabilimenti_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.linee
    ADD CONSTRAINT linee_stabilimenti_fk FOREIGN KEY (id_stabilimento) REFERENCES cu_anag.stabilimenti(id);


--
-- Name: stabilimenti stabilimenti_imprese_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimenti
    ADD CONSTRAINT stabilimenti_imprese_fk FOREIGN KEY (id_impresa) REFERENCES cu_anag.imprese(id);


--
-- Name: stabilimenti_storico stabilimenti_storico_imprese_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimenti_storico
    ADD CONSTRAINT stabilimenti_storico_imprese_fk FOREIGN KEY (id_impresa) REFERENCES cu_anag.imprese(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: stabilimenti_storico stabilimenti_storico_stabilimenti_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimenti_storico
    ADD CONSTRAINT stabilimenti_storico_stabilimenti_fk FOREIGN KEY (id_stabilimento) REFERENCES cu_anag.stabilimenti(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: stabilimento_automezzi stabilimento_automezzi_automezzi_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimento_automezzi
    ADD CONSTRAINT stabilimento_automezzi_automezzi_fk FOREIGN KEY (id_automezzo) REFERENCES cu_anag.automezzi(id);


--
-- Name: stabilimento_automezzi stabilimento_automezzi_stabilimenti_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimento_automezzi
    ADD CONSTRAINT stabilimento_automezzi_stabilimenti_fk FOREIGN KEY (id_stabilimento) REFERENCES cu_anag.stabilimenti(id);


--
-- Name: stabilimento_figure stabilimento_figure_stabilimenti_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimento_figure
    ADD CONSTRAINT stabilimento_figure_stabilimenti_fk FOREIGN KEY (id_stabilimento) REFERENCES cu_anag.stabilimenti(id) ON UPDATE SET NULL ON DELETE SET NULL;


--
-- Name: stabilimento_figure stabilimento_figure_stabilimento_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimento_figure
    ADD CONSTRAINT stabilimento_figure_stabilimento_fk FOREIGN KEY (id_soggetto) REFERENCES cu_anag.imprese(id);


--
-- Name: stabilimento_sedi stabilimento_sedi_indirizzi_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimento_sedi
    ADD CONSTRAINT stabilimento_sedi_indirizzi_fk FOREIGN KEY (id_indirizzo) REFERENCES cu_anag.indirizzi(id);


--
-- Name: stabilimento_sedi stabilimento_sedi_stabilimenti_fk; Type: FK CONSTRAINT; Schema: cu_anag; Owner: postgres
--

ALTER TABLE ONLY cu_anag.stabilimento_sedi
    ADD CONSTRAINT stabilimento_sedi_stabilimenti_fk FOREIGN KEY (id_stabilimento) REFERENCES cu_anag.stabilimenti(id) ON UPDATE SET NULL ON DELETE SET NULL;


--
-- Name: menu_item_modes menu_item_modes_fk; Type: FK CONSTRAINT; Schema: cu_ui; Owner: postgres
--

ALTER TABLE ONLY cu_ui.menu_item_modes
    ADD CONSTRAINT menu_item_modes_fk FOREIGN KEY (id_menu_item) REFERENCES cu_ui.menu_items(id);


--
-- Name: menu_items menu_items_fk; Type: FK CONSTRAINT; Schema: cu_ui; Owner: postgres
--

ALTER TABLE ONLY cu_ui.menu_items
    ADD CONSTRAINT menu_items_fk FOREIGN KEY (id_menu) REFERENCES cu_ui.menu(id);


--
-- Name: tree_nodes_2019 tree_nodes_fk; Type: FK CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.tree_nodes_2019
    ADD CONSTRAINT tree_nodes_fk FOREIGN KEY (id_tree) REFERENCES matrix.trees(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tree_nodes tree_nodes_fk_; Type: FK CONSTRAINT; Schema: matrix; Owner: postgres
--

ALTER TABLE ONLY matrix.tree_nodes
    ADD CONSTRAINT tree_nodes_fk_ FOREIGN KEY (id_tree) REFERENCES matrix.trees(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ruolo_ruoli ruolo_ruoli_ruoli_fk; Type: FK CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.ruolo_ruoli
    ADD CONSTRAINT ruolo_ruoli_ruoli_fk FOREIGN KEY (id_ruolo_cte) REFERENCES rbac.ruoli(id);


--
-- Name: ruolo_ruoli ruolo_ruoli_ruoli_fk_1; Type: FK CONSTRAINT; Schema: rbac; Owner: postgres
--

ALTER TABLE ONLY rbac.ruolo_ruoli
    ADD CONSTRAINT ruolo_ruoli_ruoli_fk_1 FOREIGN KEY (id_ruolo_cto) REFERENCES rbac.ruoli(id);


--
-- Name: sezioni sezioni_portali_fk; Type: FK CONSTRAINT; Schema: rbac_ui; Owner: postgres
--

ALTER TABLE ONLY rbac_ui.sezioni
    ADD CONSTRAINT sezioni_portali_fk FOREIGN KEY (id_portale) REFERENCES rbac_ui.portali(id);


--
-- Name: tariffa_voci_calcolo fk_tariffa_voci_calcolo; Type: FK CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.tariffa_voci_calcolo
    ADD CONSTRAINT fk_tariffa_voci_calcolo FOREIGN KEY (id_tariffa_voce) REFERENCES trf.tariffa_voci(id) ON DELETE CASCADE;


--
-- Name: tariffa_strutture tariffa_strutture_fk; Type: FK CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.tariffa_strutture
    ADD CONSTRAINT tariffa_strutture_fk FOREIGN KEY (id_tariffa) REFERENCES trf.tariffe(id);


--
-- Name: tariffa_voci tariffa_voci_fk; Type: FK CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.tariffa_voci
    ADD CONSTRAINT tariffa_voci_fk FOREIGN KEY (id_tariffa_struttura) REFERENCES trf.tariffa_strutture(id) ON DELETE CASCADE;


--
-- Name: trf_att_inviate_stati trf_att_inviate_stati_fk; Type: FK CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_att_inviate_stati
    ADD CONSTRAINT trf_att_inviate_stati_fk FOREIGN KEY (id_att_inviata) REFERENCES trf.trf_att_inviate(id) ON DELETE CASCADE;


--
-- Name: trf_attivita trf_attivita_clienti_fk; Type: FK CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_attivita
    ADD CONSTRAINT trf_attivita_clienti_fk FOREIGN KEY (id_cliente) REFERENCES trf.clienti(id);


--
-- Name: trf_fattura_dettagli trf_fattura_dettagli_fk; Type: FK CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_fattura_dettagli
    ADD CONSTRAINT trf_fattura_dettagli_fk FOREIGN KEY (id_trf_fattura) REFERENCES trf.trf_fatture(id);


--
-- Name: trf_fatture trf_fatture_fatture_fk; Type: FK CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_fatture
    ADD CONSTRAINT trf_fatture_fatture_fk FOREIGN KEY (id_tariffa) REFERENCES trf.tariffe(id);


--
-- Name: trf_regole_fatt_dett trf_regole_fatt_dett_dett_fk; Type: FK CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_regole_fatt_dett
    ADD CONSTRAINT trf_regole_fatt_dett_dett_fk FOREIGN KEY (id_tariffa) REFERENCES trf.tariffe(id) ON DELETE CASCADE;


--
-- Name: trf_regole_fatt trf_regole_fatt_fk; Type: FK CONSTRAINT; Schema: trf; Owner: postgres
--

ALTER TABLE ONLY trf.trf_regole_fatt
    ADD CONSTRAINT trf_regole_fatt_fk FOREIGN KEY (id_tariffa) REFERENCES trf.tariffe(id);


--
-- Name: SCHEMA public; Type: ACL; Schema: -; Owner: pg_database_owner
--

REVOKE USAGE ON SCHEMA public FROM PUBLIC;


--
-- PostgreSQL database dump complete
--

